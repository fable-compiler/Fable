# fable_library/core/options.pyi
from __future__ import annotations

from collections.abc import Callable
from typing import Generic, TypeAlias, TypeVar

T = TypeVar("T")
U = TypeVar("U")
V = TypeVar("V")
W = TypeVar("W")  # For map3 result

class SomeWrapper(Generic[T]):
    value: T
    def __init__(self, value: T) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __eq__(self, other: object) -> bool: ...

# Type alias for Option based on SomeWrapper or None
Option: TypeAlias = SomeWrapper[T] | None

def default_arg(opt: Option[T], default_value: T) -> T: ...
def default_arg_with(opt: Option[T], def_thunk: Callable[[], T]) -> T: ...
def filter(predicate: Callable[[T], bool], opt: Option[T]) -> Option[T]: ...
def map(mapping: Callable[[T], U], opt: Option[T]) -> Option[U]: ...
def map2(mapping: Callable[[T, U], V], opt1: Option[T], opt2: Option[U]) -> Option[V]: ...
def map3(mapping: Callable[[T, U, V], W], opt1: Option[T], opt2: Option[U], opt3: Option[V]) -> Option[W]: ...

# Based on Rust implementation's behavior with SomeWrapper
def some(x: T) -> SomeWrapper[T]: ...
def value(x: Option[T]) -> T: ...  # Raises ValueError if None

# Converts Python Optional[T] (T | None) to F# Option[T] (Some T | None)
def of_nullable(x: T | None) -> Option[T]: ...

# Converts F# Option<T> to Python Optional[T] (Some T -> T, None -> None)
def to_nullable(x: Option[T]) -> T | None: ...
def flatten(x: Option[Option[T]]) -> Option[T]: ...
def to_array(opt: Option[T]) -> list[T]: ...
def bind(binder: Callable[[T], Option[U]], opt: Option[T]) -> Option[U]: ...
def or_else(opt: Option[T], if_none: Option[T]) -> Option[T]: ...
def or_else_with(opt: Option[T], if_none_thunk: Callable[[], Option[T]]) -> Option[T]: ...
