# Stub file for fable_library.core.option module
from collections.abc import Callable
from typing import overload

from .array import FSharpArray as Array

class SomeWrapper[T]:
    value: T
    def __init__(self, value: T) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __eq__(self, other: object) -> bool: ...

# Type alias for Option based on SomeWrapper or None
type Option[T] = SomeWrapper[T] | T | None

def default_arg[T](opt: Option[T], default_value: T) -> T: ...
def default_arg_with[T](opt: Option[T], def_thunk: Callable[[], T]) -> T: ...
@overload
def filter[T](predicate: Callable[[T], bool], opt: T | None) -> T | None: ...
@overload
def filter[T](predicate: Callable[[T], bool], opt: Option[T]) -> Option[T]: ...

# Overloads for non-wrapped (erased) options: T | None -> U | None
@overload
def map[T, U](mapping: Callable[[T], U], opt: T | None) -> U | None: ...
@overload
def map[T, U](mapping: Callable[[T], Option[U]], opt: T | None) -> Option[U]: ...
@overload
def map[T, U](mapping: Callable[[T], U], opt: Option[T]) -> Option[U]: ...
@overload
def map2[T, U, V](mapping: Callable[[T, U], V], opt1: T | None, opt2: U | None) -> V | None: ...
@overload
def map2[T, U, V](mapping: Callable[[T, U], V], opt1: Option[T], opt2: Option[U]) -> Option[V]: ...
@overload
def map3[T, U, V, W](mapping: Callable[[T, U, V], W], opt1: T | None, opt2: U | None, opt3: V | None) -> W | None: ...
@overload
def map3[T, U, V, W](
    mapping: Callable[[T, U, V], W], opt1: Option[T], opt2: Option[U], opt3: Option[V]
) -> Option[W]: ...

# Based on Rust implementation's behavior with SomeWrapper
def some[T](x: T) -> SomeWrapper[T]: ...
def value[T](x: Option[T] | T) -> T: ...  # Raises ValueError if None

# Converts Python Optional[T] (T | None) to F# Option[T] (Some T | None)
def of_nullable[T](x: T | None) -> T | None: ...

# Converts F# Option<T> to Python Optional[T] (Some T -> T, None -> None)
def to_nullable[T](x: Option[T]) -> T | None: ...
def flatten[T](x: Option[Option[T]]) -> Option[T]: ...
def to_array[T](opt: Option[T]) -> Array[T]: ...
@overload
def bind[T, U](binder: Callable[[T], U | None], opt: T | None) -> U | None: ...
@overload
def bind[T, U](binder: Callable[[T], Option[U]], opt: Option[T]) -> Option[U]: ...

# or_else: when first arg wraps None, allow second arg to be any type
@overload
def or_else[T](opt: SomeWrapper[None], if_none: Option[T]) -> Option[T]: ...
@overload
def or_else[T, U](opt: Option[T], if_none: Option[U]) -> Option[T | U]: ...
@overload
def or_else_with[T](opt: SomeWrapper[None], if_none_thunk: Callable[[], Option[T]]) -> Option[T]: ...
@overload
def or_else_with[T, U](opt: Option[T], if_none_thunk: Callable[[], Option[U]]) -> Option[T | U]: ...

# For nullable reference types - returns value if not None, raises ValueError if None
def non_null[T](x: T | None) -> T: ...
