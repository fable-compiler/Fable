"""Stub file for the array module.

This is only needed so that the static type checker can find the types for the extension
methods we have written in Rust. The file will never be used by Python at runtime.
"""

from __future__ import annotations

from collections.abc import Callable, Iterator, MutableSequence
from typing import Any, Literal, TypeVar, overload

from .floats import Float32, Float64
from .ints import Int8, Int16, Int32, Int64, UInt8, UInt16, UInt32, UInt64

_T = TypeVar("_T")
_U = TypeVar("_U")

ArrayType = Literal[
    "Int8",
    "UInt8",
    "Int16",
    "UInt16",
    "Int32",
    "UInt32",
    "Int64",
    "UInt64",
    "Float32",
    "Float64",
    "String",
    "Generic",
]

class FSharpArray(MutableSequence[_T]):
    @overload
    def __init__(self, array_type: Literal["UInt8"] | None = None, elements: list[UInt8] | None = None) -> None: ...
    @overload
    def __init__(self, array_type: Literal["Int8"] | None = None, elements: list[Int8] | None = None) -> None: ...
    @overload
    def __init__(self, array_type: Literal["UInt16"] | None = None, elements: list[UInt16] | None = None) -> None: ...
    @overload
    def __init__(self, array_type: Literal["Int16"] | None = None, elements: list[Int16] | None = None) -> None: ...
    @overload
    def __init__(self, array_type: Literal["UInt32"] | None = None, elements: list[UInt32] | None = None) -> None: ...
    @overload
    def __init__(self, array_type: Literal["Int32"] | None = None, elements: list[Int32] | None = None) -> None: ...
    @overload
    def __init__(self, array_type: Literal["UInt64"] | None = None, elements: list[UInt64] | None = None) -> None: ...
    @overload
    def __init__(self, array_type: Literal["Int64"] | None = None, elements: list[Int64] | None = None) -> None: ...
    @overload
    def __init__(self, array_type: Literal["Float32"] | None = None, elements: list[Float32] | None = None) -> None: ...
    @overload
    def __init__(self, array_type: Literal["Float64"] | None = None, elements: list[Float64] | None = None) -> None: ...
    @overload
    def __init__(self, array_type: Literal["String"] | None = None, elements: list[str] | None = None) -> None: ...
    @overload
    def __init__(self, array_type: Literal["Generic"] | None = None, elements: list[Any] | None = None) -> None: ...
    def __len__(self) -> int: ...
    @overload
    def __getitem__(self, idx: int) -> _T: ...
    @overload
    def __getitem__(self, idx: slice[Any, Any, Any]) -> FSharpArray[_T]: ...
    def __setitem__(self, idx: int | slice[Any, Any, Any], value: Any) -> None: ...
    def __delitem__(self, idx: int | slice[Any, Any, Any]) -> None: ...
    def __iter__(self) -> Iterator[_T]: ...
    def __bytes__(self) -> bytes: ...
    @staticmethod
    def create(count: int, value: _T) -> FSharpArray[_T]: ...
    def insert(self, index: int, value: Any) -> None: ...
    def map(self, f: Callable[[_T], _U], cons: Any | None = None) -> FSharpArray[_U]: ...
    def map_indexed(self, f: Callable[[int, Any], Any], cons: Any | None = None) -> FSharpArray: ...
    def map_indexed2(
        self,
        f: Callable[[int, Any, Any], Any],
        array1: FSharpArray,
        array2: FSharpArray,
        cons: Any | None = None,
    ) -> FSharpArray: ...
    def map2(
        self, f: Callable[[Any, Any], Any], array1: FSharpArray, array2: FSharpArray, cons: Any | None = None
    ) -> FSharpArray: ...
    def map3(
        self,
        f: Callable[[Any, Any, Any], Any],
        array1: FSharpArray[_T],
        array2: FSharpArray[_T],
        array3: FSharpArray[_T],
        cons: Any | None = None,
    ) -> FSharpArray[_T]: ...
    def map_indexed3(
        self,
        f: Callable[[int, Any, Any], Any],
        array1: FSharpArray[_T],
        array2: FSharpArray[_T],
        array3: FSharpArray[_T],
        cons: Any | None = None,
    ) -> FSharpArray[_T]: ...
    def filter(self, predicate: Callable[[Any], bool]) -> FSharpArray[_T]: ...
    def chunk_by_size(self, size: int) -> list[FSharpArray[_T]]: ...
    def fill(self, target_index: int, count: int, value: _T) -> FSharpArray[_T]: ...
    def sort_in_place(self, comparer: Callable[[Any, Any], int]) -> None: ...
    def sort_in_place_with(self, comparer: Callable[[Any, Any], int]) -> None: ...
    def fold(self, folder: Callable[[Any, Any], Any], state: Any) -> Any: ...
    def fold_indexed(
        self, folder: Callable[[int, Any, Any], Any], state: Any
    ) -> Any: ...  # Use Any for fold_indexed function types
    def fold_back(
        self, folder: Callable[[Any, Any], Any], state: Any
    ) -> Any: ...  # Use Any for fold_back function types
    def fold_back_indexed(
        self, folder: Callable[[int, Any, Any], Any], state: Any
    ) -> Any: ...  # Use Any for fold_back_indexed function types
    def fold_back2(
        self,
        folder: Callable[[int, Any, Any], Any],
        array1: FSharpArray[_T],
        array2: FSharpArray[_T],
        state: Any,
    ) -> Any: ...
    def fold_back_indexed2(
        self,
        folder: Callable[[int, Any, Any], Any],
        array1: FSharpArray[_T],
        array2: FSharpArray[_T],
        state: Any,
    ) -> Any: ...
    def equals_with(self, equals: Callable[[Any, Any], bool], other: FSharpArray[_T]) -> bool: ...
    def reduce(self, folder: Callable[[Any, Any], Any], state: Any) -> Any: ...
    def reduce_back(self, reduction: Callable[[Any, Any], Any], state: Any) -> Any: ...
    def iterate(self, action: Callable[[Any], None]) -> None: ...
    def iterate_indexed(self, action: Callable[[int, Any], None]) -> None: ...
    def sum(self, adder: Any) -> Any: ...
    def pairwise(self) -> Iterator[tuple[Any, Any]]: ...
    def permute(self, f: Callable[[int, Any], int]) -> FSharpArray: ...
    def scan(self, folder: Callable[[Any, Any], Any], state: Any) -> FSharpArray: ...
    def scan_back(self, folder: Callable[[Any, Any], Any], state: Any) -> FSharpArray: ...
    def split_into(self, chunks: int) -> FSharpArray: ...
    def transpose(self) -> FSharpArray: ...
    def try_find_back(self, predicate: Callable[[Any], bool]) -> Any: ...
    def try_find_index_back(self, predicate: Callable[[Any], bool]) -> int: ...
    def windowed(self, window_size: int) -> FSharpArray: ...
    def map_fold(
        self,
        mapping: Callable[[Any, Any], tuple[Any, Any]],
        state: Any,
        cons: Any | None = None,
    ) -> tuple[FSharpArray, Any]: ...
    def map_fold_back(
        self,
        mapping: Callable[[int, Any, Any], tuple[Any, Any]],
        state: Any,
        cons: Any | None = None,
    ) -> tuple[FSharpArray, Any]: ...
    def singleton(self, value: Any, cons: Any | None = None) -> FSharpArray: ...
    def head(self) -> _T: ...
    def try_head(self) -> _T | None: ...
    def tail(self) -> FSharpArray[_T]: ...
    def item(self, index: int) -> _T: ...
    def try_item(self, index: int) -> _T | None: ...
    def reverse(self) -> FSharpArray[_T]: ...  # type: ignore # Override returns new array instead of None
    @staticmethod
    def initialize(count: int, initializer: Callable[[int], Any], cons: Any | None = None) -> FSharpArray[_T]: ...
    def compare_with(self, comparer: Callable[[Any, Any], bool], other: FSharpArray[_T]) -> bool: ...
    def exists_offset(self, predicate: Callable[[Any], bool], index: int) -> bool: ...
    def exists(self, predicate: Callable[[Any], bool]) -> bool: ...
    def update_at(self, index: int, value: _T, cons: Any | None = None) -> FSharpArray[_T]: ...
    def set_slice(self, target: FSharpArray[_T], lower: int | None, upper: int | None) -> None: ...
    def insert_at(self, index: int, value: _T, cons: Any | None = None) -> None: ...
    def remove_at(self, index: int, cons: Any | None = None) -> FSharpArray[_T]: ...
    def insert_many_at(self, index: int, values: FSharpArray[_T], cons: Any | None = None) -> FSharpArray[_T]: ...

# Loose functions that delegate to member functions
def append(array1: FSharpArray[_T], array2: FSharpArray[_T], cons: Any | None = None) -> FSharpArray[_T]: ...
def chunk_by_size(chunk_size: int, array: FSharpArray) -> FSharpArray: ...
def compare_with(comparer: Callable[[Any, Any], int], array1: FSharpArray, array2: FSharpArray) -> bool: ...
def create(count: int, value: _T) -> FSharpArray[_T]: ...
def empty(cons: Any | None = None) -> FSharpArray: ...
def equals_with(equals_func: Callable[[Any, Any], bool], array1: FSharpArray, array2: FSharpArray) -> bool: ...
def exists(predicate: Callable[[Any], bool], array: FSharpArray) -> bool: ...
def exists_offset(predicate: Callable[[Any], bool], array: FSharpArray, index: int) -> bool: ...
def fill(array: FSharpArray, target_index: int, count: int, value: Any) -> FSharpArray: ...
def filter(predicate: Callable[[Any], bool], array: FSharpArray) -> FSharpArray: ...
def fold(folder: Callable[[Any, Any], Any], state: Any, array: FSharpArray) -> Any: ...
def fold_back(folder: Callable[[Any, Any], Any], array: FSharpArray, state: Any) -> Any: ...
def fold_back2(f: Callable[[Any, Any, Any], Any], array1: FSharpArray, array2: FSharpArray, state: Any) -> Any: ...
def fold_back_indexed(folder: Callable[[int, Any, Any], Any], array: FSharpArray, state: Any) -> Any: ...
def fold_back_indexed2(
    folder: Callable[[int, Any, Any, Any], Any], array1: FSharpArray, array2: FSharpArray, state: Any
) -> Any: ...
def fold_indexed(folder: Callable[[int, Any, Any], Any], state: Any, array: FSharpArray) -> Any: ...
def head(array: FSharpArray[_T]) -> _T: ...
def initialize(count: int, initializer: Callable[[int], Any], cons: Any | None = None) -> FSharpArray: ...
def insert_at(index: int, value: Any, array: FSharpArray, cons: Any | None = None) -> None: ...
def insert_many_at(
    index: int, values: FSharpArray[_T], array: FSharpArray[_T], cons: Any | None = None
) -> FSharpArray[_T]: ...
def item(index: int, array: FSharpArray) -> Any: ...
def iterate(action: Callable[[Any], None], array: FSharpArray) -> None: ...
def iterate_indexed(action: Callable[[int, Any], None], array: FSharpArray) -> None: ...
def map(f: Callable[[Any], Any], array: FSharpArray, cons: Any | None = None) -> FSharpArray: ...
def map2(
    f: Callable[[Any, Any], Any], array1: FSharpArray, array2: FSharpArray, cons: Any | None = None
) -> FSharpArray: ...
def map3(
    f: Callable[[Any, Any, Any], Any],
    array1: FSharpArray,
    array2: FSharpArray,
    array3: FSharpArray,
    cons: Any | None = None,
) -> FSharpArray: ...
def map_fold(
    mapping: Callable[[Any, Any], tuple[Any, Any]], state: Any, array: FSharpArray, cons: Any | None = None
) -> tuple[FSharpArray, Any]: ...
def map_fold_back(
    mapping: Callable[[Any, Any], tuple[Any, Any]], array: FSharpArray, state: Any, cons: Any | None = None
) -> tuple[FSharpArray, Any]: ...
def map_indexed(f: Callable[[int, Any], Any], array: FSharpArray, cons: Any | None = None) -> FSharpArray: ...
def map_indexed2(
    f: Callable[[int, Any, Any], Any],
    array1: FSharpArray,
    array2: FSharpArray,
    cons: Any | None = None,
) -> FSharpArray: ...
def map_indexed3(
    f: Callable[[int, Any, Any], Any],
    array1: FSharpArray,
    array2: FSharpArray,
    array3: FSharpArray,
    cons: Any | None = None,
) -> FSharpArray: ...
def pairwise(array: FSharpArray) -> FSharpArray: ...
def permute(f: Callable[[Any], int], array: FSharpArray) -> FSharpArray: ...
def reduce(reduction: Callable[[Any, Any], Any], array: FSharpArray) -> Any: ...
def reduce_back(reduction: Callable[[Any, Any], Any], array: FSharpArray) -> Any: ...
def remove_at(index: int, array: FSharpArray[_T], cons: Any | None = None) -> FSharpArray[_T]: ...
def remove_many_at(index: int, count: int, array: FSharpArray[_T], cons: Any | None = None) -> FSharpArray[_T]: ...
def reverse(array: FSharpArray) -> FSharpArray: ...
def scan(folder: Callable[[Any, Any], Any], state: Any, array: FSharpArray, cons: Any | None = None) -> FSharpArray: ...
def scan_back(
    folder: Callable[[Any, Any], Any], state: Any, array: FSharpArray, cons: Any | None = None
) -> FSharpArray: ...
def set_slice(target: FSharpArray, lower: int | None, upper: int | None, array: FSharpArray) -> None: ...
def singleton(value: _T, cons: Any | None = None) -> FSharpArray[_T]: ...
def skip(count: int, array: FSharpArray, cons: Any | None = None) -> FSharpArray: ...
def sort_in_place(array: FSharpArray) -> None: ...
def sort_in_place_with(compare_func: Callable[[Any, Any], int], array: FSharpArray) -> None: ...
def split_into(chunks: int, array: FSharpArray) -> FSharpArray: ...
def sum(array: FSharpArray, adder: Any) -> Any: ...
def tail(array: FSharpArray, cons: Any | None = None) -> FSharpArray: ...
def transpose(array: FSharpArray, cons: Any | None = None) -> FSharpArray: ...
def try_find_back(predicate: Callable[[Any], bool], array: FSharpArray) -> Any: ...
def try_find_index_back(predicate: Callable[[Any], bool], array: FSharpArray) -> int | None: ...
def try_head(array: FSharpArray[_T]) -> _T | None: ...
def try_item(index: int, array: FSharpArray[_T]) -> _T | None: ...
def update_at(index: int, value: Any, array: FSharpArray, cons: Any | None = None) -> FSharpArray: ...
def windowed(window_size: int, array: FSharpArray) -> FSharpArray: ...

class FSharpCons:
    array_type: str
    def __init__(self, array_type: ArrayType) -> None: ...
    # Allocate should probably return FSharpArray[Any] or a specific type based on cons?
    # For now, let's keep it simple, but this might need refinement.
    def allocate(self, length: int) -> FSharpArray: ...
    def __call__(self, length: int) -> FSharpArray: ...

# Similar consideration for allocate_array_from_cons
def allocate_array_from_cons(cons: Any | None, length: int) -> FSharpArray: ...
