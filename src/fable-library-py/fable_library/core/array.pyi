"""Stub file for the array module.

This is only needed so that the static type checker can find the types for the extension
methods we have written in Rust. The file will never be used by Python at runtime.
"""

from __future__ import annotations

from collections.abc import Callable, Iterator, MutableSequence
from typing import Any, Literal, overload

from .floats import Float32, Float64
from .ints import Int8, Int16, Int32, Int64, UInt8, UInt16, UInt32, UInt64

ArrayType = Literal[
    "Int8",
    "UInt8",
    "Int16",
    "UInt16",
    "Int32",
    "UInt32",
    "Int64",
    "UInt64",
    "Float32",
    "Float64",
    "String",
    "Generic",
]

class FSharpArray(MutableSequence[Any]):
    @overload
    def __init__(self, elements: list[UInt8] | None = None, array_type: Literal["UInt8"] | None = None) -> None: ...
    @overload
    def __init__(self, elements: list[Int8] | None = None, array_type: Literal["Int8"] | None = None) -> None: ...
    @overload
    def __init__(self, elements: list[UInt16] | None = None, array_type: Literal["UInt16"] | None = None) -> None: ...
    @overload
    def __init__(self, elements: list[Int16] | None = None, array_type: Literal["Int16"] | None = None) -> None: ...
    @overload
    def __init__(self, elements: list[UInt32] | None = None, array_type: Literal["UInt32"] | None = None) -> None: ...
    @overload
    def __init__(self, elements: list[Int32] | None = None, array_type: Literal["Int32"] | None = None) -> None: ...
    @overload
    def __init__(self, elements: list[UInt64] | None = None, array_type: Literal["UInt64"] | None = None) -> None: ...
    @overload
    def __init__(self, elements: list[Int64] | None = None, array_type: Literal["Int64"] | None = None) -> None: ...
    @overload
    def __init__(self, elements: list[Float32] | None = None, array_type: Literal["Float32"] | None = None) -> None: ...
    @overload
    def __init__(self, elements: list[Float64] | None = None, array_type: Literal["Float64"] | None = None) -> None: ...
    @overload
    def __init__(self, elements: list[str] | None = None, array_type: Literal["String"] | None = None) -> None: ...
    @overload
    def __init__(self, elements: list[object] | None = None, array_type: Literal["Generic"] | None = None) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, idx: int | slice[Any, Any, Any]) -> Any: ...
    def __setitem__(self, idx: int | slice[Any, Any, Any], value: Any) -> None: ...
    def __delitem__(self, idx: int | slice[Any, Any, Any]) -> None: ...
    def __iter__(self) -> Iterator[Any]: ...
    def insert(self, index: int, value: Any) -> None: ...
    def map(self, f: Callable[[Any], Any], cons: Any | None = None) -> FSharpArray: ...
    def filter(self, predicate: Callable[[Any], bool]) -> FSharpArray: ...
    def chunk_by_size(self, size: int) -> list[FSharpArray]: ...
    def fill(self, target_index: int, count: int, value: Any) -> FSharpArray: ...
    def sort_in_place(self, comparer: Callable[[Any, Any], int]) -> None: ...
    def sort_in_place_with(self, comparer: Callable[[Any, Any], int]) -> None: ...
    def fold_back(
        self, folder: Callable[[Any, Any], Any], state: Any
    ) -> Any: ...  # Use Any for fold_back function types
    def fold_back_indexed(
        self, folder: Callable[[int, Any, Any], Any], state: Any
    ) -> Any: ...  # Use Any for fold_back_indexed function types
    def fold_back2(
        self,
        folder: Callable[[int, Any, Any], Any],
        array1: FSharpArray,
        array2: FSharpArray,
        state: Any,
    ) -> Any: ...
    def fold_back_indexed2(
        self,
        folder: Callable[[int, Any, Any], Any],
        array1: FSharpArray,
        array2: FSharpArray,
        state: Any,
    ) -> Any: ...
    def equals_with(self, equals: Callable[[Any, Any], bool], other: FSharpArray) -> bool: ...
    def reduce(self, folder: Callable[[Any, Any], Any], state: Any) -> Any: ...
    def iterate(self, action: Callable[[Any], None]) -> None: ...
    def iterate_indexed(self, action: Callable[[int, Any], None]) -> None: ...
    def sum(self, adder: Any) -> Any: ...
    def pairwise(self) -> Iterator[tuple[Any, Any]]: ...
    def permute(self, f: Callable[[int, Any], int]) -> FSharpArray: ...
    def scan(self, folder: Callable[[Any, Any], Any], state: Any) -> FSharpArray: ...
    def scan_back(self, folder: Callable[[Any, Any], Any], state: Any) -> FSharpArray: ...
    def split_into(self, chunks: int) -> FSharpArray: ...
    def transpose(self) -> FSharpArray: ...
    def try_find_back(self, predicate: Callable[[Any], bool]) -> Any: ...
    def try_find_index_back(self, predicate: Callable[[Any], bool]) -> int: ...
    def windowed(self, window_size: int) -> FSharpArray: ...
    def map_fold(
        self,
        mapping: Callable[[Any, Any], tuple[Any, Any]],
        state: Any,
        cons: Any | None = None,
    ) -> tuple[FSharpArray, Any]: ...
    def map_fold_back(
        self,
        mapping: Callable[[int, Any, Any], tuple[Any, Any]],
        state: Any,
        cons: Any | None = None,
    ) -> tuple[FSharpArray, Any]: ...
    def singleton(self, value: Any, cons: Any | None = None) -> FSharpArray: ...
    def head(self) -> Any: ...
    def try_head(self) -> Any: ...
    def tail(self) -> FSharpArray: ...
    def item(self, index: int) -> Any: ...
    def try_item(self, index: int) -> Any: ...

class FSharpCons:
    array_type: str
    def __init__(self, array_type: ArrayType) -> None: ...
    # Allocate should probably return FSharpArray[Any] or a specific type based on cons?
    # For now, let's keep it simple, but this might need refinement.
    def allocate(self, length: int) -> FSharpArray: ...
    def __call__(self, length: int) -> FSharpArray: ...

# Similar consideration for allocate_array_from_cons
def allocate_array_from_cons(cons: Any | None, length: int) -> FSharpArray: ...
