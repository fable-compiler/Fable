"""Stub file for the array module.

This is only needed so that the static type checker can find the types for the extension
methods we have written in Rust. The file will never be used by Python at runtime.
"""

from __future__ import annotations

from collections.abc import Callable, Iterable, Iterator, MutableSequence
from typing import Any, ClassVar, Generic, Literal, Protocol, TypeVar, overload

from .floats import Float32, Float64
from .ints import Int8, Int16, Int32, Int64, UInt8, UInt16, UInt32, UInt64
from .types import FSharpRef

_T = TypeVar("_T")
_T_co = TypeVar("_T_co", covariant=True)
_T1 = TypeVar("_T1")
_T2 = TypeVar("_T2")
_T3 = TypeVar("_T3")
_U = TypeVar("_U")
_S = TypeVar("_S")
_R = TypeVar("_R")

ArrayType = Literal[
    "Int8",
    "UInt8",
    "Int16",
    "UInt16",
    "Int32",
    "UInt32",
    "Int64",
    "UInt64",
    "Float32",
    "Float64",
    "String",
    "Generic",
]

class FSharpArray(MutableSequence[_T]):
    @overload
    def __init__(self, elements: Iterable[UInt8] | None = None, array_type: Literal["UInt8"] | None = None) -> None: ...
    @overload
    def __init__(self, elements: Iterable[Int8] | None = None, array_type: Literal["Int8"] | None = None) -> None: ...
    @overload
    def __init__(
        self, elements: Iterable[UInt16] | None = None, array_type: Literal["UInt16"] | None = None
    ) -> None: ...
    @overload
    def __init__(self, elements: Iterable[Int16] | None = None, array_type: Literal["Int16"] | None = None) -> None: ...
    @overload
    def __init__(
        self, elements: Iterable[UInt32] | None = None, array_type: Literal["UInt32"] | None = None
    ) -> None: ...
    @overload
    def __init__(self, elements: Iterable[Int32] | None = None, array_type: Literal["Int32"] | None = None) -> None: ...
    @overload
    def __init__(
        self, elements: Iterable[UInt64] | None = None, array_type: Literal["UInt64"] | None = None
    ) -> None: ...
    @overload
    def __init__(self, elements: Iterable[Int64] | None = None, array_type: Literal["Int64"] | None = None) -> None: ...
    @overload
    def __init__(
        self, elements: Iterable[Float32] | None = None, array_type: Literal["Float32"] | None = None
    ) -> None: ...
    @overload
    def __init__(
        self, elements: Iterable[Float64] | None = None, array_type: Literal["Float64"] | None = None
    ) -> None: ...
    @overload
    def __init__(self, elements: Iterable[str] | None = None, array_type: Literal["String"] | None = None) -> None: ...
    @overload
    def __init__(
        self, elements: Iterable[object] | None = None, array_type: Literal["Generic"] | None = None
    ) -> None: ...
    @overload
    def __init__(self, elements: Iterable[Any] | None = None, array_type: Literal["Generic"] | None = None) -> None: ...
    def __len__(self) -> int: ...
    @overload
    def __getitem__(self, idx: int) -> _T: ...
    @overload
    def __getitem__(self, idx: slice) -> FSharpArray[_T]: ...
    def __setitem__(self, idx: int | slice, value: Any) -> None: ...
    def __delitem__(self, idx: int | slice) -> None: ...
    def __iter__(self) -> Iterator[_T]: ...
    def __bytes__(self) -> bytes: ...
    @staticmethod
    def create(count: int, value: _T) -> FSharpArray[_T]: ...
    @staticmethod
    def initialize(count: int, initializer: Callable[[int], _T], cons: Any | None = None) -> FSharpArray[_T]: ...
    def insert(self, index: int, value: Any) -> None: ...
    def map(self, f: Callable[[_T], _U], cons: Any | None = None) -> FSharpArray[_U]: ...
    def map_indexed(self, f: Callable[[int, _T], _U], cons: Any | None = None) -> FSharpArray[_U]: ...
    def map_indexed2(
        self,
        f: Callable[[int, _T1, _T2], _U],
        array1: FSharpArray[_T2],
        array2: FSharpArray[_T2],
        cons: Any | None = None,
    ) -> FSharpArray[_U]: ...
    def map2(
        self, f: Callable[[_T1, _T2], _U], array1: FSharpArray[_T1], array2: FSharpArray[_T2], cons: Any | None = None
    ) -> FSharpArray[_U]: ...
    def map3(
        self,
        f: Callable[[_T1, _T2, _T3], _U],
        array1: FSharpArray[_T1],
        array2: FSharpArray[_T2],
        array3: FSharpArray[_T3],
        cons: Any | None = None,
    ) -> FSharpArray[_U]: ...
    def map_indexed3(
        self,
        f: Callable[[int, _T1, _T2, _T3], _U],
        array1: FSharpArray[_T1],
        array2: FSharpArray[_T2],
        array3: FSharpArray[_T3],
        cons: Any | None = None,
    ) -> FSharpArray[_U]: ...
    def filter(self, predicate: Callable[[_T], bool]) -> FSharpArray[_T]: ...
    def chunk_by_size(self, size: int) -> list[FSharpArray[_T]]: ...
    def fill(self, target_index: int, count: int, value: _T) -> FSharpArray[_T]: ...
    def sort_in_place(self, comparer: Callable[[Any, Any], int]) -> None: ...
    def sort_in_place_with(self, comparer: Callable[[Any, Any], int]) -> None: ...
    def sort(self, comparer: IComparer[_T]) -> FSharpArray[_T]: ...
    def sort_by(self, projection: Callable[[_T], Any], comparer: IComparer[_T] | None = None) -> FSharpArray[_T]: ...
    def sort_with(self, comparer: Callable[[_T, _T], int]) -> FSharpArray[_T]: ...
    def fold(self, folder: Callable[[_S, _T], _S], state: _S) -> _S: ...
    def fold_indexed(
        self, folder: Callable[[int, Any, Any], Any], state: Any
    ) -> Any: ...  # Use Any for fold_indexed function types
    def fold_back(self, folder: Callable[[_T, _S], _S], state: _S) -> _S: ...
    def fold_back_indexed(self, folder: Callable[[int, _T, _S], _S], state: _S) -> _S: ...
    def fold_back2(self, folder: Callable[[_T1, _T2, _S], _S], array2: FSharpArray[_T2], state: _S) -> _S: ...
    def compare_with(self, comparer: Callable[[_T, _T], int], other: FSharpArray[_T]) -> int: ...
    def reduce(self, folder: Callable[[Any, Any], Any], state: Any) -> Any: ...
    def reduce_back(self, reduction: Callable[[Any, Any], Any], state: Any) -> Any: ...
    def iterate(self, action: Callable[[Any], None]) -> None: ...
    def iterate_indexed(self, action: Callable[[int, Any], None]) -> None: ...
    def sum(self, adder: Any) -> Any: ...
    def sum_by(self, projection: Callable[[_T], _U], adder: Any) -> _U: ...
    def pairwise(self) -> Iterator[tuple[Any, Any]]: ...
    def permute(self, f: Callable[[int], int], array: FSharpArray[_T]) -> FSharpArray[_T]: ...
    def scan(self, folder: Callable[[_S, _T], _S], state: _S, cons: Any | None = None) -> FSharpArray[_S]: ...
    def scan_back(self, folder: Callable[[_T, _S], _S], state: _S, cons: Any | None = None) -> FSharpArray[_S]: ...
    def split_into(self, chunks: int) -> FSharpArray[FSharpArray[_T]]: ...
    def transpose(self) -> FSharpArray[FSharpArray[_T]]: ...
    def try_find_back(self, predicate: Callable[[Any], bool]) -> Any: ...
    def try_find_index_back(self, predicate: Callable[[Any], bool]) -> int: ...
    def try_find_index(self, predicate: Callable[[Any], bool]) -> int | None: ...
    def windowed(self, window_size: int) -> FSharpArray[FSharpArray[_T]]: ...
    def map_fold(
        self,
        mapping: Callable[[_S, _T], tuple[_R, _S]],
        state: _S,
        cons: Any | None = None,
    ) -> tuple[FSharpArray[_R], _S]: ...
    def map_fold_back(
        self,
        mapping: Callable[[_T, _S], tuple[_R, _S]],
        state: _S,
        cons: Any | None = None,
    ) -> tuple[FSharpArray[_R], _S]: ...
    def singleton(self, value: _T, cons: Any | None = None) -> FSharpArray[_T]: ...
    def head(self) -> _T: ...
    def try_head(self) -> _T | None: ...
    def tail(self) -> FSharpArray[_T]: ...
    def item(self, index: int) -> _T: ...
    def try_item(self, index: int) -> _T | None: ...
    def reverse(self) -> FSharpArray[_T]: ...  # type: ignore # Override returns new array instead of None
    def exists_offset(self, predicate: Callable[[Any], bool], index: int) -> bool: ...
    def exists(self, predicate: Callable[[Any], bool]) -> bool: ...
    def for_all(self, predicate: Callable[[_T], bool]) -> bool: ...
    def find(self, predicate: Callable[[_T], bool]) -> _T: ...
    def find_index(self, predicate: Callable[[_T], bool]) -> int: ...
    def try_find(self, predicate: Callable[[_T], bool]) -> _T | None: ...
    def find_last_index(self, predicate: Callable[[_T], bool]) -> int: ...
    def find_index_back(self, predicate: Callable[[_T], bool]) -> int: ...
    def find_back(self, predicate: Callable[[_T], bool]) -> _T: ...
    def update_at(self, index: int, value: _T, cons: Any | None = None) -> FSharpArray[_T]: ...
    def set_slice(self, target: FSharpArray[_T], lower: int | None, upper: int | None) -> None: ...
    def insert_at(self, index: int, value: _T, cons: Any | None = None) -> None: ...
    def remove_at(self, index: int, cons: Any | None = None) -> FSharpArray[_T]: ...
    def insert_many_at(self, index: int, values: FSharpArray[_T], cons: Any | None = None) -> FSharpArray[_T]: ...
    def equals_with(self, equals: Callable[[_T, _T], bool], other: FSharpArray[_T]) -> bool: ...
    def remove_in_place(self, item: _T) -> bool: ...
    def index_of(
        self, item: _T, start: int | None = None, count: int | None = None, eq: IEqualityComparer[_T] | None = None
    ) -> int: ...
    def copy_to(self, source_index: int, target: FSharpArray[_T], target_index: int, count: int) -> None: ...
    def zip(self, array2: FSharpArray[_U]) -> FSharpArray[tuple[_T, _U]]: ...
    def add_in_place(self, value: _T) -> None: ...
    def add_range_in_place(self, values: Iterable[_T]) -> None: ...
    def insert_range_in_place(self, index: int, values: Iterable[_T]) -> None: ...
    def get_sub_array(self, start_index: int, count: int, cons: FSharpCons[_T] | None = None) -> FSharpArray[_T]: ...
    def contains(self, value: _T) -> bool: ...
    def max(self, comparer: IComparer[_T]) -> _T: ...
    def min(self, comparer: IComparer[_T]) -> _T: ...
    def max_by(self, projection: Callable[[_T], _U], comparer: IComparer[_U]) -> _T: ...
    def min_by(self, projection: Callable[[_T], _U], comparer: IComparer[_U]) -> _T: ...
    def average(self, averager: IGenericAverager[_T]) -> _T: ...
    def average_by(self, projection: Callable[[_T], _U], averager: IGenericAverager[_U]) -> _U: ...
    def pick(self, chooser: Callable[[_T], _U | None]) -> _U: ...
    def try_pick(self, chooser: Callable[[_T], _U | None]) -> _U | None: ...
    def remove_all_in_place(self, predicate: Callable[[_T], bool]) -> int: ...
    def indexed(self) -> FSharpArray[tuple[int, _T]]: ...
    def last(self) -> _T: ...
    def try_last(self) -> _T | None: ...
    def truncate(self, count: int) -> FSharpArray[_T]: ...
    def partition(
        self, f: Callable[[_T], bool], cons: FSharpCons[_T] | None = None
    ) -> tuple[FSharpArray[_T], FSharpArray[_T]]: ...
    def resize(self, new_size: int, zero: _T | None = None, cons: FSharpCons[_T] | None = None) -> FSharpArray[_T]: ...

# Loose functions that delegate to member functions
def append(array1: FSharpArray[_T], array2: FSharpArray[_T], cons: FSharpCons[_T] | None = None) -> FSharpArray[_T]: ...
def chunk_by_size(chunk_size: int, array: FSharpArray[_T]) -> FSharpArray[FSharpArray[_T]]: ...
def compare_with(comparer: Callable[[_T, _T], int], array1: FSharpArray[_T], array2: FSharpArray[_T]) -> int: ...
def create(count: int, value: _T) -> FSharpArray[_T]: ...
def empty(cons: FSharpCons[_T] | None = None) -> FSharpArray[_T]: ...
def equals_with(equals_func: Callable[[_T, _T], bool], array1: FSharpArray[_T], array2: FSharpArray[_T]) -> bool: ...
def exists(predicate: Callable[[_T], bool], array: FSharpArray[_T]) -> bool: ...
def exists_offset(predicate: Callable[[Any], bool], array: FSharpArray[_T], index: int) -> bool: ...
def for_all(predicate: Callable[[_T], bool], array: FSharpArray[_T]) -> bool: ...
def find(predicate: Callable[[_T], bool], array: FSharpArray[_T]) -> _T: ...
def find_index(predicate: Callable[[_T], bool], array: FSharpArray[_T]) -> int: ...
def find_index_back(predicate: Callable[[_T], bool], array: FSharpArray[_T]) -> int: ...
def try_find(predicate: Callable[[_T], bool], array: FSharpArray[_T]) -> _T | None: ...
def find_last_index(predicate: Callable[[_T], bool], array: FSharpArray[_T]) -> int: ...
def fill(array: FSharpArray[_T], target_index: int, count: int, value: _T) -> FSharpArray[_T]: ...
def filter(predicate: Callable[[_T], bool], array: FSharpArray[_T]) -> FSharpArray[_T]: ...
def fold(folder: Callable[[_S, _T], _S], state: _S, array: FSharpArray[_T]) -> _S: ...
def fold_back(folder: Callable[[_T, _S], _S], array: FSharpArray[_T], state: _S) -> _S: ...
def fold_back2(
    folder: Callable[[_T1, _T2, _S], _S], array1: FSharpArray[_T1], array2: FSharpArray[_T2], state: _S
) -> _S: ...
def fold_back_indexed(folder: Callable[[int, _T, _S], _S], array: FSharpArray[_T], state: _S) -> _S: ...
def fold_back_indexed2(folder: Callable[[int, _T1, _T2, _S], _S], array2: FSharpArray[_T2], state: _S) -> _S: ...
def fold_indexed(folder: Callable[[int, Any, Any], Any], state: Any, array: FSharpArray[_T]) -> Any: ...
def head(array: FSharpArray[_T]) -> _T: ...
def initialize(count: int, initializer: Callable[[int], _T], cons: FSharpCons[_T] | None = None) -> FSharpArray[_T]: ...
def insert_at(index: int, value: _T, array: FSharpArray[_T], cons: FSharpCons[_T] | None = None) -> None: ...
def insert_many_at(
    index: int, values: FSharpArray[_T], array: FSharpArray[_T], cons: FSharpCons[_T] | None = None
) -> FSharpArray[_T]: ...
def item(index: int, array: FSharpArray[_T]) -> _T: ...
def iterate(action: Callable[[_T], None], array: FSharpArray[_T]) -> None: ...
def iterate_indexed(action: Callable[[int, _T], None], array: FSharpArray[_T]) -> None: ...
def map(f: Callable[[_T], _U], array: FSharpArray[_T], cons: FSharpCons[_U] | None = None) -> FSharpArray[_U]: ...
def map2(
    f: Callable[[_T1, _T2], _U], array1: FSharpArray[_T1], array2: FSharpArray[_T2], cons: FSharpCons[_U] | None = None
) -> FSharpArray[_U]: ...
def map3(
    f: Callable[[_T1, _T2, _T3], _U],
    array1: FSharpArray[_T1],
    array2: FSharpArray[_T2],
    array3: FSharpArray[_T3],
    cons: FSharpCons[_U] | None = None,
) -> FSharpArray[_U]: ...
def map_fold(
    mapping: Callable[[_S, _T], tuple[_R, _S]], state: _S, array: FSharpArray[_T], cons: FSharpCons[_R] | None = None
) -> tuple[FSharpArray[_R], _S]: ...
def map_fold_back(
    mapping: Callable[[_T, _S], tuple[_R, _S]], array: FSharpArray[_T], state: _S, cons: FSharpCons[_R] | None = None
) -> tuple[FSharpArray[_R], _S]: ...
def map_indexed(
    f: Callable[[int, _T], _U], array: FSharpArray[_T], cons: FSharpCons[_U] | None = None
) -> FSharpArray[_U]: ...
def map_indexed2(
    f: Callable[[int, _T1, _T2], _U],
    array1: FSharpArray[_T1],
    array2: FSharpArray[_T2],
    cons: FSharpCons[_U] | None = None,
) -> FSharpArray[_U]: ...
def map_indexed3(
    f: Callable[[int, _T1, _T2, _T3], _U],
    array1: FSharpArray[_T1],
    array2: FSharpArray[_T2],
    array3: FSharpArray[_T3],
    cons: FSharpCons[_U] | None = None,
) -> FSharpArray[_U]: ...
def pairwise(array: FSharpArray[_T]) -> FSharpArray[tuple[_T, _T]]: ...
def permute(f: Callable[[int], int], array: FSharpArray[_T]) -> FSharpArray[_T]: ...
def reduce(reduction: Callable[[_T, _T], _T], array: FSharpArray[_T]) -> _T: ...
def reduce_back(reduction: Callable[[_T, _T], _T], array: FSharpArray[_T]) -> _T: ...
def remove_at(index: int, array: FSharpArray[_T], cons: FSharpCons[_T] | None = None) -> FSharpArray[_T]: ...
def remove_many_at(index: int, count: int, array: FSharpArray[_T]) -> FSharpArray[_T]: ...
def remove_in_place(array: FSharpArray[_T], item: _T) -> bool: ...
def index_of(
    array: FSharpArray[_T],
    item: _T,
    start: int | None = None,
    count: int | None = None,
    eq: IEqualityComparer[_T] | None = None,
) -> int: ...
def reverse(array: FSharpArray[_T]) -> FSharpArray[_T]: ...
def scan(
    folder: Callable[[_S, _T], _S], state: _S, array: FSharpArray[_T], cons: FSharpCons[_S] | None = None
) -> FSharpArray[_S]: ...
def scan_back(
    folder: Callable[[_T, _S], _S], array: FSharpArray[_T], state: _S, cons: FSharpCons[_S] | None = None
) -> FSharpArray[_S]: ...
def set_slice(target: FSharpArray[_T], lower: int | None, upper: int | None, array: FSharpArray[_T]) -> None: ...
def singleton(value: _T, cons: FSharpCons[_T] | None = None) -> FSharpArray[_T]: ...
def skip(count: int, array: FSharpArray[_T], cons: FSharpCons[_T] | None = None) -> FSharpArray[_T]: ...
def sort_in_place(array: FSharpArray[_T]) -> None: ...
def sort_in_place_with(compare_func: Callable[[_T, _T], int], array: FSharpArray[_T]) -> None: ...
def sort(array: FSharpArray[_T], comparer: IComparer[_T]) -> FSharpArray[_T]: ...
def split_into(chunks: int, array: FSharpArray[_T]) -> FSharpArray[FSharpArray[_T]]: ...
def sum(array: FSharpArray[_T], adder: Callable[[_T, _T], _T]) -> _T: ...
def tail(array: FSharpArray[_T], cons: FSharpCons[_T] | None = None) -> FSharpArray[_T]: ...
def transpose(
    array: FSharpArray[FSharpArray[_T]], cons: FSharpCons[FSharpArray[_T]] | None = None
) -> FSharpArray[FSharpArray[_T]]: ...
def try_find_back(predicate: Callable[[_T], bool], array: FSharpArray[_T]) -> _T | None: ...
def try_find_index(predicate: Callable[[_T], bool], array: FSharpArray[_T]) -> int | None: ...
def try_find_index_back(predicate: Callable[[_T], bool], array: FSharpArray[_T]) -> int | None: ...
def try_head(array: FSharpArray[_T]) -> _T | None: ...
def try_item(index: int, array: FSharpArray[_T]) -> _T | None: ...
def update_at(index: int, value: _T, array: FSharpArray[_T], cons: FSharpCons[_T] | None = None) -> FSharpArray[_T]: ...
def windowed(window_size: int, array: FSharpArray[_T]) -> FSharpArray[FSharpArray[_T]]: ...
def copy_to(
    source: FSharpArray[_T], source_index: int, target: FSharpArray[_T], target_index: int, count: int
) -> None: ...
def zip(array1: FSharpArray[_T], array2: FSharpArray[_U]) -> FSharpArray[tuple[_T, _U]]: ...
def add_in_place(array: FSharpArray[_T], value: _T) -> None: ...
def add_range_in_place(array: FSharpArray[_T], values: Iterable[_T]) -> None: ...
def insert_range_in_place(array: FSharpArray[_T], index: int, values: Iterable[_T]) -> None: ...
def get_sub_array(
    array: FSharpArray[_T], start_index: int, count: int, cons: FSharpCons[_T] | None = None
) -> FSharpArray[_T]: ...
def contains(value: _T, array: FSharpArray[_T]) -> bool: ...
def max(array: FSharpArray[_T], comparer: IComparer[_T]) -> _T: ...
def min(array: FSharpArray[_T], comparer: IComparer[_T]) -> _T: ...
def max_by(projection: Callable[[_T], _U], array: FSharpArray[_T], comparer: IComparer[_U]) -> _T: ...
def min_by(projection: Callable[[_T], _U], array: FSharpArray[_T], comparer: IComparer[_U]) -> _T: ...
def remove_all_in_place(array: FSharpArray[_T], predicate: Callable[[_T], bool]) -> int: ...
def resize(
    array: FSharpRef[FSharpArray[_T]], new_size: int, zero: _T | None = None, cons: FSharpCons[_T] | None = None
) -> FSharpArray[_T]: ...
def find_back(predicate: Callable[[_T], bool], array: FSharpArray[_T]) -> _T: ...
def pick(chooser: Callable[[_T], _U | None], array: FSharpArray[_T]) -> _U: ...
def try_pick(chooser: Callable[[_T], _U | None], array: FSharpArray[_T]) -> _U | None: ...
def indexed(array: FSharpArray[_T]) -> FSharpArray[tuple[int, _T]]: ...
def last(array: FSharpArray[_T]) -> _T: ...
def try_last(array: FSharpArray[_T]) -> _T | None: ...
def average(array: FSharpArray[_T], averager: IGenericAverager[_T]) -> _T: ...
def average_by(projection: Callable[[_T], _U], array: FSharpArray[_T], averager: IGenericAverager[_U]) -> _U: ...
def truncate(array: FSharpArray[_T], count: int) -> FSharpArray[_T]: ...
def partition(
    f: Callable[[_T], bool], array: FSharpArray[_T], cons: FSharpCons[_T] | None = None
) -> tuple[FSharpArray[_T], FSharpArray[_T]]: ...
def concat(arrays: Iterable[FSharpArray[_T]], cons: FSharpCons[_T] | None = None) -> FSharpArray[_T]: ...
def sort_by(
    projection: Callable[[_T], Any], array: FSharpArray[_T], comparer: IComparer[_T] | None = None
) -> FSharpArray[_T]: ...
def sort_with(comparer: Callable[[_T, _T], int], array: FSharpArray[_T]) -> FSharpArray[_T]: ...
def sum_by(projection: Callable[[_T], _U], array: FSharpArray[_T], adder: Any) -> _U: ...

class FSharpCons(Generic[_T]):
    array_type: ClassVar[str]
    def __init__(self, array_type: ArrayType) -> None: ...
    def __call__(self, length: int) -> FSharpArray[_T]: ...
    def allocate(self, length: int) -> FSharpArray[_T]: ...

def allocate_array_from_cons(cons: FSharpCons[_T] | None, length: int) -> FSharpArray[_T]: ...

class IGenericAverager(Protocol[_T]):
    def GetZero(self) -> _T: ...
    def Add(self, a: _T, b: _T) -> _T: ...
    def DivideByInt(self, a: _T, n: Int32) -> _T: ...

class IEqualityComparer(Protocol[_T_co]):
    def Equals(self, x: _T, y: _T) -> bool: ...

class IComparer(Protocol[_T_co]):
    def Compare(self, x: _T, y: _T) -> int: ...
