"""Stub file for the array module.

This is only needed so that the static type checker can find the types for the extension
methods we have written in Rust. The file will never be used by Python at runtime.
"""

from __future__ import annotations

from collections.abc import Callable, Iterable, Iterator, MutableSequence
from typing import Any, ClassVar, Literal, SupportsInt, overload

from fable_library.protocols import (
    IComparer_1,
    IEnumerable_1,
    IEnumerator,
    IEqualityComparer_1,
    IGenericAdder,
    IGenericAverager,
)

from .ints import Int32
from .types import FSharpRef

# Type alias for inputs that can be iterated - supports both Python Iterable and F# IEnumerable
type Elements[T] = Iterable[T] | IEnumerable_1[T]

ArrayType = Literal[
    "Int8",
    "UInt8",
    "Int16",
    "UInt16",
    "Int32",
    "UInt32",
    "SupportsInt",
    "USupportsInt",
    "Int64",
    "UInt64",
    "Float32",
    "Float64",
    "String",
    "Bool",
    "Generic",
]

class FSharpArray[T](MutableSequence[T]):
    # Special methods - accepts both Python Iterable and F# IEnumerable
    def __init__(self, elements: Elements[T] | None = None) -> None: ...
    def __bytes__(self) -> bytes: ...
    def __delitem__(self, idx: int | slice) -> None: ...
    @overload
    def __getitem__(self, idx: int) -> T: ...
    @overload
    def __getitem__(self, idx: slice) -> FSharpArray[T]: ...
    def __iter__(self) -> Iterator[T]: ...
    def __len__(self) -> int: ...
    def __setitem__(self, idx: int | slice, value: Any) -> None: ...

    # F# interop property
    @property
    def length(self) -> Int32: ...

    # IEnumerable implementation (for .NET compatibility)
    def GetEnumerator(self, __unit: None = None) -> IEnumerator[T]: ...

    # Static methods
    @staticmethod
    def create(count: SupportsInt, value: T) -> FSharpArray[T]: ...
    @staticmethod
    def initialize(
        count: SupportsInt, initializer: Callable[[Int32], T], cons: Any | None = None
    ) -> FSharpArray[T]: ...

    # Instance methods (alphabetically sorted)
    def add_in_place(self, value: T) -> None: ...
    def add_range_in_place(self, values: Iterable[T]) -> None: ...
    def append(self, array2: FSharpArray[T], cons: FSharpCons[T] | None = None) -> FSharpArray[T]: ...  # type: ignore[override]
    def average(self, averager: IGenericAverager[T]) -> T: ...
    def average_by[U](self, projection: Callable[[T], U], averager: IGenericAverager[U]) -> U: ...
    def choose[U](self, chooser: Callable[[T], U | None], cons: FSharpCons[U] | None = None) -> FSharpArray[U]: ...
    def chunk_by_size(self, size: SupportsInt) -> list[FSharpArray[T]]: ...
    def collect[U](self, mapping: Callable[[T], FSharpArray[U]], cons: Any | None = None) -> FSharpArray[U]: ...
    def compare_to(self, comparer: Callable[[T, T], SupportsInt], other: FSharpArray[T]) -> Int32: ...
    def compare_with(self, comparer: Callable[[T, T], SupportsInt], other: FSharpArray[T]) -> Int32: ...
    def contains(self, value: T, eq: IEqualityComparer_1[T] | None = None) -> bool: ...
    def copy(self) -> FSharpArray[T]: ...
    def copy_to(
        self, source_index: SupportsInt, target: FSharpArray[T], target_index: SupportsInt, count: SupportsInt
    ) -> None: ...
    def equals_with(self, equals: Callable[[T, T], bool], other: FSharpArray[T] | None) -> bool: ...
    def exists(self, predicate: Callable[[T], bool]) -> bool: ...
    def exists_offset(self, predicate: Callable[[T], bool], index: SupportsInt) -> bool: ...
    def fill(self, target_index: SupportsInt, count: SupportsInt, value: T) -> FSharpArray[T]: ...
    def filter(self, predicate: Callable[[T], bool]) -> FSharpArray[T]: ...
    def find(self, predicate: Callable[[T], bool]) -> T: ...
    def find_back(self, predicate: Callable[[T], bool]) -> T: ...
    def find_index(self, predicate: Callable[[T], bool]) -> Int32: ...
    def find_index_back(self, predicate: Callable[[T], bool]) -> Int32: ...
    def find_last_index(self, predicate: Callable[[T], bool]) -> Int32: ...
    def fold[S](self, folder: Callable[[S, T], S], state: S) -> S: ...
    def fold_back[S](self, folder: Callable[[T, S], S], state: S) -> S: ...
    def fold_back2[T1, T2, S](self, folder: Callable[[T1, T2, S], S], array2: FSharpArray[T2], state: S) -> S: ...
    def fold_back_indexed[S](self, folder: Callable[[Int32, T, S], S], state: S) -> S: ...
    def fold_indexed(
        self, folder: Callable[[Int32, Any, Any], Any], state: Any
    ) -> Any: ...  # Use Any for fold_indexed function types
    def for_all(self, predicate: Callable[[T], bool]) -> bool: ...
    def get_sub_array(
        self, start_index: SupportsInt, count: SupportsInt, cons: FSharpCons[T] | None = None
    ) -> FSharpArray[T]: ...
    def head(self) -> T: ...
    def index_of(
        self,
        item: T,
        start: SupportsInt | None = None,
        count: SupportsInt | None = None,
        eq: IEqualityComparer_1[T] | None = None,
    ) -> SupportsInt: ...
    def indexed(self) -> FSharpArray[tuple[SupportsInt, T]]: ...
    def insert(self, index: SupportsInt, value: Any) -> None: ...
    def insert_at(self, index: SupportsInt, value: T, cons: Any | None = None) -> None: ...
    def insert_many_at(self, index: SupportsInt, values: FSharpArray[T], cons: Any | None = None) -> FSharpArray[T]: ...
    def insert_range_in_place(self, index: SupportsInt, values: Iterable[T]) -> None: ...
    def item(self, index: SupportsInt) -> T: ...
    def iterate(self, action: Callable[[Any], None]) -> None: ...
    def iterate_indexed(self, action: Callable[[Int32, Any], None]) -> None: ...
    def last(self) -> T: ...
    def map[U](self, f: Callable[[T], U], cons: Any | None = None) -> FSharpArray[U]: ...
    def map2[T1, T2, U](
        self, f: Callable[[T1, T2], U], array1: FSharpArray[T1], array2: FSharpArray[T2], cons: Any | None = None
    ) -> FSharpArray[U]: ...
    def map3[T1, T2, T3, U](
        self,
        f: Callable[[T1, T2, T3], U],
        array1: FSharpArray[T1],
        array2: FSharpArray[T2],
        array3: FSharpArray[T3],
        cons: Any | None = None,
    ) -> FSharpArray[U]: ...
    def map_fold[S, R](
        self,
        mapping: Callable[[S, T], tuple[R, S]],
        state: S,
        cons: Any | None = None,
    ) -> tuple[FSharpArray[R], S]: ...
    def map_fold_back[S, R](
        self,
        mapping: Callable[[T, S], tuple[R, S]],
        state: S,
        cons: Any | None = None,
    ) -> tuple[FSharpArray[R], S]: ...
    def map_indexed[U](self, f: Callable[[Int32, T], U], cons: Any | None = None) -> FSharpArray[U]: ...
    def map_indexed2[T1, T2, U](
        self,
        f: Callable[[Int32, T1, T2], U],
        array1: FSharpArray[T1],
        array2: FSharpArray[T2],
        cons: Any | None = None,
    ) -> FSharpArray[U]: ...
    def map_indexed3[T1, T2, T3, U](
        self,
        f: Callable[[Int32, T1, T2, T3], U],
        array1: FSharpArray[T1],
        array2: FSharpArray[T2],
        array3: FSharpArray[T3],
        cons: Any | None = None,
    ) -> FSharpArray[U]: ...
    def max(self, comparer: IComparer_1[T]) -> T: ...
    def max_by[U](self, projection: Callable[[T], U], comparer: IComparer_1[U]) -> T: ...
    def min(self, comparer: IComparer_1[T]) -> T: ...
    def min_by[U](self, projection: Callable[[T], U], comparer: IComparer_1[U]) -> T: ...
    def pairwise(self) -> FSharpArray[tuple[T, T]]: ...
    def partition(
        self, f: Callable[[T], bool], cons: FSharpCons[T] | None = None
    ) -> tuple[FSharpArray[T], FSharpArray[T]]: ...
    def permute(self, f: Callable[[Int32], SupportsInt], array: FSharpArray[T]) -> FSharpArray[T]: ...
    def pick[U](self, chooser: Callable[[T], U | None]) -> U: ...
    def reduce(self, folder: Callable[[Any, Any], Any], state: Any) -> Any: ...
    def reduce_back(self, reduction: Callable[[Any, Any], Any], state: Any) -> Any: ...
    def remove_all_in_place(self, predicate: Callable[[T], bool]) -> SupportsInt: ...
    def remove_at(self, index: SupportsInt, cons: Any | None = None) -> FSharpArray[T]: ...
    def remove_in_place(self, item: T) -> bool: ...
    def resize(
        self, new_size: SupportsInt, zero: T | None = None, cons: FSharpCons[T] | None = None
    ) -> FSharpArray[T]: ...
    def reverse(self) -> FSharpArray[T]: ...  # type: ignore # Override returns new array instead of None
    def scan[S](self, folder: Callable[[S, T], S], state: S, cons: Any | None = None) -> FSharpArray[S]: ...
    def scan_back[S](self, folder: Callable[[T, S], S], state: S, cons: Any | None = None) -> FSharpArray[S]: ...
    def set_slice(self, target: FSharpArray[T], lower: SupportsInt | None, upper: SupportsInt | None) -> None: ...
    def singleton(self, value: T, cons: Any | None = None) -> FSharpArray[T]: ...
    def skip(self, count: SupportsInt, cons: FSharpCons[T] | None = None) -> FSharpArray[T]: ...
    def skip_while(self, predicate: Callable[[T], bool], cons: FSharpCons[T] | None = None) -> FSharpArray[T]: ...
    def sort(self, comparer: IComparer_1[T]) -> FSharpArray[T]: ...
    def sort_by(self, projection: Callable[[T], Any], comparer: IComparer_1[T] | None = None) -> FSharpArray[T]: ...
    def sort_in_place(self, comparer: IComparer_1[T]) -> None: ...
    def sort_in_place_by[U](self, projection: Callable[[T], U], comparer: IComparer_1[U]) -> None: ...
    def sort_in_place_with(self, comparer: Callable[[Any, Any], SupportsInt]) -> None: ...
    def sort_with(self, comparer: Callable[[T, T], SupportsInt]) -> FSharpArray[T]: ...
    def split_into(self, chunks: int) -> FSharpArray[FSharpArray[T]]: ...
    def sum(self, adder: IGenericAdder[T]) -> T: ...
    def sum_by[U](self, projection: Callable[[T], U], adder: IGenericAdder[U]) -> U: ...
    def tail(self, cons: FSharpCons[T] | None = None) -> FSharpArray[T]: ...
    def take(self, count: SupportsInt, cons: FSharpCons[T] | None = None) -> FSharpArray[T]: ...
    def take_while(self, predicate: Callable[[T], bool], cons: FSharpCons[T] | None = None) -> FSharpArray[T]: ...
    def transpose(self, cons: FSharpCons[T] | None = None) -> FSharpArray[FSharpArray[T]]: ...
    def truncate(self, count: SupportsInt) -> FSharpArray[T]: ...
    def try_find(self, predicate: Callable[[T], bool]) -> T | None: ...
    def try_find_back(self, predicate: Callable[[Any], bool]) -> Any: ...
    def try_find_index(self, predicate: Callable[[Any], bool]) -> SupportsInt | None: ...
    def try_find_index_back(self, predicate: Callable[[Any], bool]) -> SupportsInt: ...
    def try_head(self) -> T | None: ...
    def try_item(self, index: SupportsInt) -> T | None: ...
    def try_last(self) -> T | None: ...
    def try_pick[U](self, chooser: Callable[[T], U | None]) -> U | None: ...
    def unzip[U](self: FSharpArray[tuple[T, U]]) -> tuple[FSharpArray[T], FSharpArray[U]]: ...
    def update_at(self, index: SupportsInt, value: T, cons: Any | None = None) -> FSharpArray[T]: ...
    def windowed(self, window_size: SupportsInt) -> FSharpArray[FSharpArray[T]]: ...
    def zip[U](self, array2: FSharpArray[U]) -> FSharpArray[tuple[T, U]]: ...

# Loose functions (alphabetically sorted)
# Note: Many functions accept Elements[T] (Iterable | IEnumerable) to support both Python and F# collections
def add_in_place[T](array: FSharpArray[T], value: T) -> None: ...
def add_range_in_place[T](array: FSharpArray[T], values: Elements[T]) -> None: ...
def allocate_array_from_cons[T](cons: FSharpCons[T] | None, length: SupportsInt) -> FSharpArray[T]: ...
def append[T](
    array1: Elements[T], array2: Elements[T], cons: FSharpCons[T] | None = None
) -> FSharpArray[T]: ...
def average[T](array: Elements[T], averager: IGenericAverager[T]) -> T: ...
def average_by[T, U](
    projection: Callable[[T], U], array: Elements[T], averager: IGenericAverager[U]
) -> U: ...
def choose[T, U](
    chooser: Callable[[T], U | None], array: Elements[T], cons: FSharpCons[U] | None = None
) -> FSharpArray[U]: ...
def chunk_by_size[T](chunk_size: SupportsInt, array: Elements[T]) -> FSharpArray[FSharpArray[T]]: ...
def collect[T, U](
    mapping: Callable[[T], FSharpArray[U]], array: Elements[T], cons: FSharpCons[U] | None = None
) -> FSharpArray[U]: ...
def compare_to[T](
    comparer: Callable[[T, T], SupportsInt],
    source1: Elements[T],
    source2: Elements[T],
) -> Int32: ...
def compare_with[T](
    comparer: Callable[[T, T], SupportsInt], array1: Elements[T], array2: Elements[T]
) -> Int32: ...
def concat[T](arrays: Elements[FSharpArray[T]], cons: FSharpCons[T] | None = None) -> FSharpArray[T]: ...
def contains[T](value: T, array: Elements[T], eq: IEqualityComparer_1[T] | None = None) -> bool: ...
def copy[T](array: Elements[T]) -> FSharpArray[T]: ...
def copy_to[T](
    source: FSharpArray[T],
    source_index: SupportsInt,
    target: FSharpArray[T],
    target_index: SupportsInt,
    count: SupportsInt,
) -> None: ...
def create[T](count: SupportsInt, value: T) -> FSharpArray[T]: ...

# NOTE: zero_value is typed as `object` instead of `T` intentionally. When the F# compiler
# generates code for generic types, it passes `None` as the zero value. If we used `T`,
# pyright would infer `T = None`, resulting in `FSharpArray[None]`.
def zero_create[T](count: SupportsInt, zero_value: object) -> FSharpArray[T]: ...  # pyright: ignore[reportInvalidTypeVarUse]
def empty[T](cons: FSharpCons[T] | None = None) -> FSharpArray[T]: ...
def equals_with[T](
    equals_func: Callable[[T, T], bool],
    array1: Elements[T] | None,
    array2: Elements[T] | None,
) -> bool: ...
def exists[T](predicate: Callable[[T], bool], array: Elements[T]) -> bool: ...
def exists_offset[T](predicate: Callable[[T], bool], array: Elements[T], index: int) -> bool: ...
def fill[T](array: FSharpArray[T], target_index: int, count: int, value: T) -> FSharpArray[T]: ...
def filter[T](predicate: Callable[[T], bool], array: Elements[T]) -> FSharpArray[T]: ...
def find[T](predicate: Callable[[T], bool], array: Elements[T]) -> T: ...
def find_back[T](predicate: Callable[[T], bool], array: Elements[T]) -> T: ...
def find_index[T](predicate: Callable[[T], bool], array: Elements[T]) -> int: ...
def find_index_back[T](predicate: Callable[[T], bool], array: Elements[T]) -> int: ...
def find_last_index[T](predicate: Callable[[T], bool], array: Elements[T]) -> int: ...
def fold[T, S](folder: Callable[[S, T], S], state: S, array: Elements[T]) -> S: ...
def fold_back[T, S](folder: Callable[[T, S], S], array: Elements[T], state: S) -> S: ...
def fold_back2[T1, T2, S](
    folder: Callable[[T1, T2, S], S],
    array1: Elements[T1],
    array2: Elements[T2],
    state: S,
) -> S: ...
def fold_back_indexed[T, S](folder: Callable[[Int32, T, S], S], array: Elements[T], state: S) -> S: ...
def fold_back_indexed2[T1, T2, S](
    folder: Callable[[Int32, T1, T2, S], S],
    array1: Elements[T1],
    array2: Elements[T2],
    state: S,
) -> S: ...
def fold_indexed[T, S](
    folder: Callable[[Int32, Any, Any], Any], state: Any, array: Elements[T]
) -> Any: ...
def for_all[T](predicate: Callable[[T], bool], array: Elements[T]) -> bool: ...
def get_sub_array[T](
    array: Elements[T], start_index: SupportsInt, count: SupportsInt, cons: FSharpCons[T] | None = None
) -> FSharpArray[T]: ...
def head[T](array: Elements[T]) -> T: ...
def index_of[T](
    array: Elements[T],
    item: T,
    start: SupportsInt | None = None,
    count: SupportsInt | None = None,
    eq: IEqualityComparer_1[T] | None = None,
) -> SupportsInt: ...
def indexed[T](array: Elements[T]) -> FSharpArray[tuple[SupportsInt, T]]: ...
def initialize[T](
    count: SupportsInt, initializer: Callable[[Int32], T], cons: FSharpCons[T] | None = None
) -> FSharpArray[T]: ...
def insert_at[T](
    index: SupportsInt, value: T, array: Elements[T], cons: FSharpCons[T] | None = None
) -> FSharpArray[T]: ...
def insert_many_at[T](
    index: SupportsInt,
    values: Elements[T],
    array: Elements[T],
    cons: FSharpCons[T] | None = None,
) -> FSharpArray[T]: ...
def insert_range_in_place[T](array: FSharpArray[T], index: SupportsInt, values: Elements[T]) -> None: ...
def item[T](index: SupportsInt, array: Elements[T]) -> T: ...
def iterate[T](action: Callable[[T], None], array: Elements[T]) -> None: ...
def iterate_indexed[T](action: Callable[[Int32, T], None], array: Elements[T]) -> None: ...
def last[T](array: Elements[T]) -> T: ...
def map[T, U](
    f: Callable[[T], U], array: Elements[T], cons: FSharpCons[U] | None = None
) -> FSharpArray[U]: ...
def map2[T1, T2, U](
    f: Callable[[T1, T2], U],
    array1: Elements[T1],
    array2: Elements[T2],
    cons: FSharpCons[U] | None = None,
) -> FSharpArray[U]: ...
def map3[T1, T2, T3, U](
    f: Callable[[T1, T2, T3], U],
    array1: Elements[T1],
    array2: Elements[T2],
    array3: Elements[T3],
    cons: FSharpCons[U] | None = None,
) -> FSharpArray[U]: ...
def map_fold[T, S, R](
    mapping: Callable[[S, T], tuple[R, S]],
    state: S,
    array: Elements[T],
    cons: FSharpCons[R] | None = None,
) -> tuple[FSharpArray[R], S]: ...
def map_fold_back[T, S, R](
    mapping: Callable[[T, S], tuple[R, S]],
    array: Elements[T],
    state: S,
    cons: FSharpCons[R] | None = None,
) -> tuple[FSharpArray[R], S]: ...
def map_indexed[T, U](
    f: Callable[[Int32, T], U], array: Elements[T], cons: FSharpCons[U] | None = None
) -> FSharpArray[U]: ...
def map_indexed2[T1, T2, U](
    f: Callable[[Int32, T1, T2], U],
    array1: Elements[T1],
    array2: Elements[T2],
    cons: FSharpCons[U] | None = None,
) -> FSharpArray[U]: ...
def map_indexed3[T1, T2, T3, U](
    f: Callable[[Int32, T1, T2, T3], U],
    array1: Elements[T1],
    array2: Elements[T2],
    array3: Elements[T3],
    cons: FSharpCons[U] | None = None,
) -> FSharpArray[U]: ...
def max[T](array: Elements[T], comparer: IComparer_1[T]) -> T: ...
def max_by[T, U](projection: Callable[[T], U], array: Elements[T], comparer: IComparer_1[U]) -> T: ...
def min[T](array: Elements[T], comparer: IComparer_1[T]) -> T: ...
def min_by[T, U](projection: Callable[[T], U], array: Elements[T], comparer: IComparer_1[U]) -> T: ...
def of_seq[T](seq: Elements[T], cons: FSharpCons[T] | None = None) -> FSharpArray[T]: ...
def pairwise[T](array: Elements[T]) -> FSharpArray[tuple[T, T]]: ...
def partition[T](
    f: Callable[[T], bool], array: Elements[T], cons: FSharpCons[T] | None = None
) -> tuple[FSharpArray[T], FSharpArray[T]]: ...
def permute[T](f: Callable[[Int32], SupportsInt], array: Elements[T]) -> FSharpArray[T]: ...
def pick[T, U](chooser: Callable[[T], U | None], array: Elements[T]) -> U: ...
def reduce[T](reduction: Callable[[T, T], T], array: Elements[T]) -> T: ...
def reduce_back[T](reduction: Callable[[T, T], T], array: Elements[T]) -> T: ...
def remove_all_in_place[T](array: FSharpArray[T], predicate: Callable[[T], bool]) -> SupportsInt: ...
def remove_at[T](index: SupportsInt, array: FSharpArray[T], cons: FSharpCons[T] | None = None) -> FSharpArray[T]: ...
def remove_in_place[T](array: FSharpArray[T], item: T) -> bool: ...
def remove_many_at[T](index: SupportsInt, count: SupportsInt, array: FSharpArray[T]) -> FSharpArray[T]: ...
def resize[T](
    array: FSharpRef[FSharpArray[T]], new_size: SupportsInt, zero: T | None = None, cons: FSharpCons[T] | None = None
) -> FSharpArray[T]: ...
def reverse[T](array: Elements[T]) -> FSharpArray[T]: ...
def scan[T, S](
    folder: Callable[[S, T], S], state: S, array: Elements[T], cons: FSharpCons[S] | None = None
) -> FSharpArray[S]: ...
def scan_back[T, S](
    folder: Callable[[T, S], S], array: Elements[T], state: S, cons: FSharpCons[S] | None = None
) -> FSharpArray[S]: ...
def set_slice[T](
    target: FSharpArray[T], lower: SupportsInt | None, upper: SupportsInt | None, array: FSharpArray[T]
) -> None: ...
def singleton[T](value: T, cons: FSharpCons[T] | None = None) -> FSharpArray[T]: ...
def skip[T](
    count: SupportsInt, array: Elements[T], cons: FSharpCons[T] | None = None
) -> FSharpArray[T]: ...
def skip_while[T](
    predicate: Callable[[T], bool], array: Elements[T], cons: FSharpCons[T] | None = None
) -> FSharpArray[T]: ...
def sort[T](array: Elements[T], comparer: IComparer_1[T]) -> FSharpArray[T]: ...
def sort_by[T](
    projection: Callable[[T], Any], array: Elements[T], comparer: IComparer_1[T] | None = None
) -> FSharpArray[T]: ...
def sort_in_place[T](array: FSharpArray[T], comparer: IComparer_1[T]) -> None: ...
def sort_in_place_by[T, U](projection: Callable[[T], U], array: FSharpArray[T], comparer: IComparer_1[U]) -> None: ...
def sort_in_place_with[T](compare_func: Callable[[T, T], SupportsInt], array: FSharpArray[T]) -> None: ...
def sort_with[T](comparer: Callable[[T, T], SupportsInt], array: Elements[T]) -> FSharpArray[T]: ...
def split_into[T](chunks: SupportsInt, array: Elements[T]) -> FSharpArray[FSharpArray[T]]: ...
def sum[T](array: Elements[T], adder: IGenericAdder[T]) -> T: ...
def sum_by[T, U](projection: Callable[[T], U], array: Elements[T], adder: IGenericAdder[U]) -> U: ...
def tail[T](array: Elements[T], cons: FSharpCons[T] | None = None) -> FSharpArray[T]: ...
def take[T](
    count: SupportsInt, array: Elements[T], cons: FSharpCons[T] | None = None
) -> FSharpArray[T]: ...
def take_while[T](
    predicate: Callable[[T], bool], array: Elements[T], cons: FSharpCons[T] | None = None
) -> FSharpArray[T]: ...
def transpose[T](
    array: Elements[FSharpArray[T]], cons: FSharpCons[T] | None = None
) -> FSharpArray[FSharpArray[T]]: ...
def truncate[T](count: SupportsInt, array: Elements[T]) -> FSharpArray[T]: ...
def try_find[T](predicate: Callable[[T], bool], array: Elements[T]) -> T | None: ...
def try_find_back[T](predicate: Callable[[T], bool], array: Elements[T]) -> T | None: ...
def try_find_index[T](predicate: Callable[[T], bool], array: Elements[T]) -> Int32 | None: ...
def try_find_index_back[T](predicate: Callable[[T], bool], array: Elements[T]) -> Int32 | None: ...
def try_head[T](array: Elements[T]) -> T | None: ...
def try_item[T](index: SupportsInt, array: Elements[T]) -> T | None: ...
def try_last[T](array: Elements[T]) -> T | None: ...
def try_pick[T, U](chooser: Callable[[T], U | None], array: Elements[T]) -> U | None: ...
def unzip[T, U](array: Elements[tuple[T, U]]) -> tuple[FSharpArray[T], FSharpArray[U]]: ...
def update_at[T](
    index: SupportsInt, value: T, array: Elements[T], cons: FSharpCons[T] | None = None
) -> FSharpArray[T]: ...
def windowed[T](window_size: SupportsInt, array: Elements[T]) -> FSharpArray[FSharpArray[T]]: ...
def zip[T, U](
    array1: Elements[T], array2: Elements[U]
) -> FSharpArray[tuple[T, U]]: ...

# Typed array subclasses (for isinstance checks and type annotations)
class Int8Array(FSharpArray[int]): ...
class UInt8Array(FSharpArray[int]): ...
class Int16Array(FSharpArray[int]): ...
class UInt16Array(FSharpArray[int]): ...
class Int32Array(FSharpArray[int]): ...
class UInt32Array(FSharpArray[int]): ...
class Int64Array(FSharpArray[int]): ...
class UInt64Array(FSharpArray[int]): ...
class Float32Array(FSharpArray[float]): ...
class Float64Array(FSharpArray[float]): ...
class BoolArray(FSharpArray[bool]): ...
class GenericArray[T](FSharpArray[T]): ...

class FSharpCons[T]:
    array_type: ClassVar[str]
    def __init__(self, array_type: ArrayType) -> None: ...
    def __call__(self, length: SupportsInt) -> FSharpArray[T]: ...
    def allocate(self, length: SupportsInt) -> FSharpArray[T]: ...
