"""Stub file for the array module.

This is only needed so that the static type checker can find the types for the extension
methods we have written in Rust. The file will never be used by Python at runtime.
"""

from __future__ import annotations

from collections.abc import Callable
from typing import Any, Generic, TypeVar

_T = TypeVar("_T")
_U = TypeVar("_U")

class FSharpArray(Generic[_T]):
    def __init__(self, elements: list[_T] | None = None, array_type: str | None = None) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, idx: int) -> _T: ...
    def __setitem__(self, idx: int, value: _T) -> None: ...
    def map(self, f: Callable[[_T], _U], cons: Any | None = None) -> FSharpArray[_U]: ...
    def filter(self, predicate: Callable[[_T], bool]) -> FSharpArray[_T]: ...

class FSharpCons:
    array_type: str
    def __init__(self, array_type: str) -> None: ...
    # Allocate should probably return FSharpArray[Any] or a specific type based on cons?
    # For now, let's keep it simple, but this might need refinement.
    def allocate(self, length: int) -> FSharpArray[Any]: ...
    def __call__(self, length: int) -> FSharpArray[Any]: ...

# Similar consideration for allocate_array_from_cons
def allocate_array_from_cons(cons: Any | None, length: int) -> FSharpArray[Any]: ...
