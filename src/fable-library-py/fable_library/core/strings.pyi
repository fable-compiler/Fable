# fable_library/core/string_.pyi
from __future__ import annotations

from collections.abc import Callable
from typing import Any, overload

from .core import Array, int32

class IPrintfFormat:
    """F# printf-style formatting class.

    Returns Any because the actual return type depends on the format string
    at runtime (could be a continuation or a final string).
    """
    def __init__(self, input: str) -> None: ...
    @property
    def input(self) -> str: ...
    def __call__(self, arg: Any) -> Any: ...
    def cont(self, continuation: Callable[[str], Any]) -> Any: ...

class ConsolePrinter:
    """Console printer wrapper that maintains F# currying semantics.

    Returns Any because the number of required arguments depends on the
    format string at runtime and cannot be statically typed.
    """
    def __call__(self, arg: Any) -> Any: ...

class StringComparison:
    """String comparison enumeration."""

    CURRENT_CULTURE: int = 0
    CURRENT_CULTURE_IGNORE_CASE: int = 1
    INVARIANT_CULTURE: int = 2
    INVARIANT_CULTURE_IGNORE_CASE: int = 3
    ORDINAL: int = 4
    ORDINAL_IGNORE_CASE: int = 5

# F# printf-style formatting functions. We use Any as return type since the
# number of arguments and actual types depend on the format string at runtime.
def printf(input: str) -> Any: ...
def continue_print(cont: Callable[..., Any], arg: Any) -> Any: ...
def to_console(arg: Any) -> Any: ...
def to_text(arg: Any) -> Any: ...

# String formatting functions
def format_replacement(
    rep: Any,
    flags: str | None = None,
    pad_length: int | None = None,
    precision: int | None = None,
    format: str | None = None,
) -> str: ...

# format() overloads - handles both with and without provider
@overload
def format(fmt: str) -> str: ...
@overload
def format(fmt: str, *args: Any) -> str: ...
@overload
def format(provider: Any, fmt: str) -> str: ...
@overload
def format(provider: Any, fmt: str, *args: Any) -> str: ...

# String manipulation functions
def initialize(n: int32, f: Callable[[int32], str]) -> str: ...
def insert(string: str, start_index: int32, value: str) -> str: ...
def is_null_or_empty(string: str | None) -> bool: ...
def is_null_or_white_space(string: str | None) -> bool: ...
def concat(*strings: str) -> str: ...
def join(delimiter: str, strings: Any) -> str: ...
def pad_left(string: str, length: int32, ch: str | None = None, is_right: bool = False) -> str: ...
def pad_right(string: str, length: int32, ch: str | None = None) -> str: ...
def remove(string: str, start_index: int32, count: int32 | None = None) -> str: ...
def replace(string: str, search: str, replace: str) -> str: ...
def replicate(n: int32, x: str) -> str: ...
def get_char_at_index(input: str, index: int32) -> str: ...
def split(
    string: str,
    splitters: Any,
    count: int | None = None,
    remove_empty: int = 0,
) -> Array[str]: ...
def trim(string: str, *chars: Any) -> str: ...
def trim_start(string: str, *chars: Any) -> str: ...
def trim_end(string: str, *chars: Any) -> str: ...
def filter(pred: Callable[[str], bool], x: str) -> str: ...
def map(mapping: Callable[[str], str], x: str) -> str: ...
def map_indexed(mapping: Callable[[int32, str], str], x: str) -> str: ...
def collect(mapping: Callable[[str], str], x: str) -> str: ...
def substring(string: str, start_index: int, length: int | None = None) -> str: ...
def to_char_array2(string: str, start_index: int, length: int) -> Array[str]: ...

# String comparison functions
def compare(*args: Any) -> int: ...
def starts_with(string: str, pattern: str, ic: int32 | bool | None = None) -> bool: ...
def ends_with(string: str, pattern: str, ic: int32 | bool | None = None) -> bool: ...
def index_of(string: str, pattern: str, start_index: int = 0) -> int: ...
def last_index_of(string: str, pattern: str, start_index: int | None = None) -> int: ...

# Additional compatibility functions
def compare_to(this: str, other: str) -> int: ...
def ends_with_exact(string: str, pattern: str) -> bool: ...
def starts_with_exact(string: str, pattern: str) -> bool: ...
def index_of_any(string: str, any_of: Any, *args: int) -> int: ...
def interpolate(string: str, values: Any) -> str: ...
