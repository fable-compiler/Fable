# Fable Library for Python

This module is used as the [Fable](https://fable.io/) library for Python.

This document outlines the distribution strategy for the Fable Python
target, which includes both Python code and Rust-based extensions for
features like unsigned integers that aren't natively supported in
Python.

The code should be annotated using [type
hints](https://docs.python.org/3/library/typing.html) and statically
type checked using
[pylance](https://marketplace.visualstudio.com/items?itemName=ms-python.vscode-pylance)
at `strict` setting.

The code should be formatted using the
[ruff](https://docs.astral.sh/ruff/) formatter with default settings.

## Fable Python Target Distribution Design

### Design Goals

- Provide proper type support for F# (including uint8, etc.) and
  performance using Rust extensions
- Support cross-platform usage of libraries compiled with Fable
- Maintain version compatibility while avoiding breaking changes and allowing evolution.
- Offer flexibility for library authors (bundled vs PyPI dependency)
- Minimize duplication while ensuring stability

### Architecture

The system uses a two-tier architecture:

1. **Python components** - The main Fable library functionality
2. **Rust extensions** - Native code for performance and proper type support

### Distribution Approach

The `fable-library` package will be available through two methods:

1. **Bundled** - Generated and included directly with compiled F# code
2. **PyPI** - Installable as a dependency with wheels for all major platforms

Library authors can choose which approach to use based on their distribution needs.

### Version Management

#### Major Versions

- Versions are aligned with main Fable releases (e.g., v4, v5)
- Each PyPI release contains only the two most recent major versions
- Older versions remain available through version pinning

#### Version Structure

```text
fable_library/
├── v4/           # Python components for Fable v4
│   ├── __init__.py
│   ├── date.py
│   └── ...
├── v5/           # Python components for Fable v5
│   ├── __init__.py
│   ├── date.py
│   ├── date.py  # New date for v5.1 with breaking changes
│   └── ...
└── core/         # Rust extensions
    ├── v4/       # Rust extensions for v4
    │   └── ...
    └── v5/       # Rust extensions for v5
        └── ...
```

#### PyPI Release Pattern

To avoid breaking changes, we use a versioning scheme that allows for
backward compatibility. The latest version of `fable-library` will
include different modules for each major version, thus using the latest
version of the library will not break existing code, even if they
upgrade to a new major version of the library.

Eventually, the `fable-library` package will need to retire the old
versions, but the latest versions will always be available. For
example:

```text
fable-library 6.x.y  # Contains v5 and v6 modules
fable-library 5.x.y  # Contains v4 and v5 modules
fable-library 4.x.y  # Contains v3 and v4 modules
```

#### Non-Breaking Fixes Within Versions

For backward compatibility with bug fixes, we use suffixed function
names:

```python
# Original function
def parse_date(date_string):
    # Original implementation

# Fixed version in same module
def parse_date_v51(date_string):
    # Fixed implementation

# Fable compiler will generate:
from fable.library.core.v5 import parse_date_v51 as parse_date
```

#### Code Sharing Between Versions

To minimize duplication, v5 imports unchanged functionality from v4:

```python
# In fable_library/v5/__init__.py
from fable_library.v4.unchanged_function import unchanged_function

# Only define new functions or ones that have changed
def changed_function():
    # New implementation
```

This approach:

- Reduces code duplication
- Makes it clear which functions have changed
- Simplifies backporting fixes to shared functionality
- Maintains logical separation between versions

### Developer Experience

Since all code using `fable-library` is generated by Fable itself:

- F# library authors only need to upgrade their Fable version
- No manual migration steps are required
- The correct version references are automatically generated

### Implementation Notes

1. All Rust extensions are compiled for multiple platforms during the PyPI package build
2. The version system is append-only within major versions to maintain compatibility
3. The Fable compiler automatically selects the appropriate module versions based on its own version
