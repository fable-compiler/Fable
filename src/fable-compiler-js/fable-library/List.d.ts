import { Option } from "./Option.js";
import { IComparer, IEqualityComparer, IDisposable, IEnumerator } from "./Util.js";
import { int32 } from "./Int32.js";
import { Record } from "./Types.js";
import { TypeInfo } from "./Reflection.js";
export declare class FSharpList<T> extends Record implements Iterable<T> {
    readonly head: T;
    tail: Option<FSharpList<T>>;
    constructor(head: T, tail: Option<FSharpList<T>>);
    toString(): string;
    Equals(other: any): boolean;
    GetHashCode(): int32;
    toJSON(): any;
    CompareTo(other: any): int32;
    GetEnumerator(): IEnumerator<T>;
    [Symbol.iterator](): Iterator<T>;
    "System.Collections.IEnumerable.GetEnumerator"(): IEnumerator<any>;
}
export declare function FSharpList_$reflection(gen0: TypeInfo): TypeInfo;
export declare class ListEnumerator$1<T> implements IEnumerator<T>, IDisposable {
    readonly xs: FSharpList<T>;
    it: FSharpList<T>;
    current: T;
    constructor(xs: FSharpList<T>);
    "System.Collections.Generic.IEnumerator`1.get_Current"(): T;
    "System.Collections.IEnumerator.get_Current"(): any;
    "System.Collections.IEnumerator.MoveNext"(): boolean;
    "System.Collections.IEnumerator.Reset"(): void;
    Dispose(): void;
}
export declare function ListEnumerator$1_$reflection(gen0: TypeInfo): TypeInfo;
export declare function ListEnumerator$1_$ctor_3002E699<T>(xs: FSharpList<T>): ListEnumerator$1<T>;
export declare function FSharpList_get_Empty<T>(): FSharpList<T>;
export declare function FSharpList_Cons_305B8EAC<T>(x: T, xs: FSharpList<T>): FSharpList<T>;
export declare function FSharpList__get_IsEmpty<T>(xs: FSharpList<T>): boolean;
export declare function FSharpList__get_Length<T>(xs: FSharpList<T>): int32;
export declare function FSharpList__get_Head<T>(xs: FSharpList<T>): T;
export declare function FSharpList__get_Tail<T>(xs: FSharpList<T>): FSharpList<T>;
export declare function FSharpList__get_Item_Z524259A4<T>(xs: FSharpList<T>, index: int32): T;
export declare function indexNotFound<$a>(): $a;
export declare function empty<$a>(): FSharpList<$a>;
export declare function cons<T>(x: T, xs: FSharpList<T>): FSharpList<T>;
export declare function singleton<$a>(x: $a): FSharpList<$a>;
export declare function isEmpty<T>(xs: FSharpList<T>): boolean;
export declare function length<T>(xs: FSharpList<T>): int32;
export declare function head<T>(xs: FSharpList<T>): T;
export declare function tryHead<T>(xs: FSharpList<T>): Option<T>;
export declare function tail<T>(xs: FSharpList<T>): FSharpList<T>;
export declare function tryLast<T>(xs_mut: FSharpList<T>): Option<T>;
export declare function last<T>(xs: FSharpList<T>): T;
export declare function compareWith<T>(comparer: ((arg0: T, arg1: T) => int32), xs: FSharpList<T>, ys: FSharpList<T>): int32;
export declare function toArray<T>(xs: FSharpList<T>): T[];
export declare function fold<T, State>(folder: ((arg0: State, arg1: T) => State), state: State, xs: FSharpList<T>): State;
export declare function reverse<T>(xs: FSharpList<T>): FSharpList<T>;
export declare function foldBack<T, State>(folder: ((arg0: T, arg1: State) => State), xs: FSharpList<T>, state: State): State;
export declare function foldIndexed<State, T>(folder: ((arg0: int32, arg1: State, arg2: T) => State), state: State, xs: FSharpList<T>): State;
export declare function fold2<T1, T2, State>(folder: ((arg0: State, arg1: T1, arg2: T2) => State), state: State, xs: FSharpList<T1>, ys: FSharpList<T2>): State;
export declare function foldBack2<T1, T2, State>(folder: ((arg0: T1, arg1: T2, arg2: State) => State), xs: FSharpList<T1>, ys: FSharpList<T2>, state: State): State;
export declare function unfold<State, T>(gen: ((arg0: State) => Option<[T, State]>), state: State): FSharpList<T>;
export declare function iterate<$a>(action: ((arg0: $a) => void), xs: FSharpList<$a>): void;
export declare function iterate2<$a, $b>(action: ((arg0: $a, arg1: $b) => void), xs: FSharpList<$a>, ys: FSharpList<$b>): void;
export declare function iterateIndexed<$a>(action: ((arg0: int32, arg1: $a) => void), xs: FSharpList<$a>): void;
export declare function iterateIndexed2<$a, $b>(action: ((arg0: int32, arg1: $a, arg2: $b) => void), xs: FSharpList<$a>, ys: FSharpList<$b>): void;
export declare function toSeq<T>(xs: FSharpList<T>): Iterable<T>;
export declare function ofArrayWithTail<T>(xs: T[], tail_1: FSharpList<T>): FSharpList<T>;
export declare function ofArray<T>(xs: T[]): FSharpList<T>;
export declare function ofSeq<T>(xs: Iterable<T>): FSharpList<T>;
export declare function concat<T>(lists: Iterable<FSharpList<T>>): FSharpList<T>;
export declare function scan<State, T>(folder: ((arg0: State, arg1: T) => State), state: State, xs: FSharpList<T>): FSharpList<State>;
export declare function scanBack<T, State>(folder: ((arg0: T, arg1: State) => State), xs: FSharpList<T>, state: State): FSharpList<State>;
export declare function append<T>(xs: FSharpList<T>, ys: FSharpList<T>): FSharpList<T>;
export declare function collect<T, U>(mapping: ((arg0: T) => FSharpList<U>), xs: FSharpList<T>): FSharpList<U>;
export declare function mapIndexed<T, U>(mapping: ((arg0: int32, arg1: T) => U), xs: FSharpList<T>): FSharpList<U>;
export declare function map<T, U>(mapping: ((arg0: T) => U), xs: FSharpList<T>): FSharpList<U>;
export declare function indexed<$a>(xs: FSharpList<$a>): FSharpList<[int32, $a]>;
export declare function map2<T1, T2, U>(mapping: ((arg0: T1, arg1: T2) => U), xs: FSharpList<T1>, ys: FSharpList<T2>): FSharpList<U>;
export declare function mapIndexed2<T1, T2, U>(mapping: ((arg0: int32, arg1: T1, arg2: T2) => U), xs: FSharpList<T1>, ys: FSharpList<T2>): FSharpList<U>;
export declare function map3<T1, T2, T3, U>(mapping: ((arg0: T1, arg1: T2, arg2: T3) => U), xs: FSharpList<T1>, ys: FSharpList<T2>, zs: FSharpList<T3>): FSharpList<U>;
export declare function mapFold<State, T, Result>(mapping: ((arg0: State, arg1: T) => [Result, State]), state: State, xs: FSharpList<T>): [FSharpList<Result>, State];
export declare function mapFoldBack<T, State, Result>(mapping: ((arg0: T, arg1: State) => [Result, State]), xs: FSharpList<T>, state: State): [FSharpList<Result>, State];
export declare function tryPick<T, $a>(f: ((arg0: T) => Option<$a>), xs: FSharpList<T>): Option<$a>;
export declare function pick<$a, $b>(f: ((arg0: $a) => Option<$b>), xs: FSharpList<$a>): $b;
export declare function tryFind<$a>(f: ((arg0: $a) => boolean), xs: FSharpList<$a>): Option<$a>;
export declare function find<$a>(f: ((arg0: $a) => boolean), xs: FSharpList<$a>): $a;
export declare function tryFindBack<$a>(f: ((arg0: $a) => boolean), xs: FSharpList<$a>): Option<$a>;
export declare function findBack<$a>(f: ((arg0: $a) => boolean), xs: FSharpList<$a>): $a;
export declare function tryFindIndex<T>(f: ((arg0: T) => boolean), xs: FSharpList<T>): Option<int32>;
export declare function findIndex<$a>(f: ((arg0: $a) => boolean), xs: FSharpList<$a>): int32;
export declare function tryFindIndexBack<$a>(f: ((arg0: $a) => boolean), xs: FSharpList<$a>): Option<int32>;
export declare function findIndexBack<$a>(f: ((arg0: $a) => boolean), xs: FSharpList<$a>): int32;
export declare function tryItem<T>(n: int32, xs: FSharpList<T>): Option<T>;
export declare function item<T>(n: int32, xs: FSharpList<T>): T;
export declare function filter<T>(f: ((arg0: T) => boolean), xs: FSharpList<T>): FSharpList<T>;
export declare function partition<T>(f: ((arg0: T) => boolean), xs: FSharpList<T>): [FSharpList<T>, FSharpList<T>];
export declare function choose<T, U>(f: ((arg0: T) => Option<U>), xs: FSharpList<T>): FSharpList<U>;
export declare function contains<T>(value: T, xs: FSharpList<T>, eq: IEqualityComparer<T>): boolean;
export declare function initialize<T>(n: int32, f: ((arg0: int32) => T)): FSharpList<T>;
export declare function replicate<$a>(n: int32, x: $a): FSharpList<$a>;
export declare function reduce<T>(f: ((arg0: T, arg1: T) => T), xs: FSharpList<T>): T;
export declare function reduceBack<T>(f: ((arg0: T, arg1: T) => T), xs: FSharpList<T>): T;
export declare function forAll<$a>(f: ((arg0: $a) => boolean), xs: FSharpList<$a>): boolean;
export declare function forAll2<$a, $b>(f: ((arg0: $a, arg1: $b) => boolean), xs: FSharpList<$a>, ys: FSharpList<$b>): boolean;
export declare function exists<$a>(f: ((arg0: $a) => boolean), xs: FSharpList<$a>): boolean;
export declare function exists2<T1, T2>(f_mut: ((arg0: T1, arg1: T2) => boolean), xs_mut: FSharpList<T1>, ys_mut: FSharpList<T2>): boolean;
export declare function unzip<$a, $b>(xs: FSharpList<[$a, $b]>): [FSharpList<$a>, FSharpList<$b>];
export declare function unzip3<$a, $b, $c>(xs: FSharpList<[$a, $b, $c]>): [FSharpList<$a>, FSharpList<$b>, FSharpList<$c>];
export declare function zip<$a, $b>(xs: FSharpList<$a>, ys: FSharpList<$b>): FSharpList<[$a, $b]>;
export declare function zip3<$a, $b, $c>(xs: FSharpList<$a>, ys: FSharpList<$b>, zs: FSharpList<$c>): FSharpList<[$a, $b, $c]>;
export declare function sortWith<T>(comparer: ((arg0: T, arg1: T) => int32), xs: FSharpList<T>): FSharpList<T>;
export declare function sort<T>(xs: FSharpList<T>, comparer: IComparer<T>): FSharpList<T>;
export declare function sortBy<T, U>(projection: ((arg0: T) => U), xs: FSharpList<T>, comparer: IComparer<U>): FSharpList<T>;
export declare function sortDescending<T>(xs: FSharpList<T>, comparer: IComparer<T>): FSharpList<T>;
export declare function sortByDescending<T, U>(projection: ((arg0: T) => U), xs: FSharpList<T>, comparer: IComparer<U>): FSharpList<T>;
export declare function sum<T>(xs: FSharpList<T>, adder: any): T;
export declare function sumBy<T, U>(f: ((arg0: T) => U), xs: FSharpList<T>, adder: any): U;
export declare function maxBy<T, U>(projection: ((arg0: T) => U), xs: FSharpList<T>, comparer: IComparer<U>): T;
export declare function max<T>(xs: FSharpList<T>, comparer: IComparer<T>): T;
export declare function minBy<T, U>(projection: ((arg0: T) => U), xs: FSharpList<T>, comparer: IComparer<U>): T;
export declare function min<T>(xs: FSharpList<T>, comparer: IComparer<T>): T;
export declare function average<T>(xs: FSharpList<T>, averager: any): T;
export declare function averageBy<T, U>(f: ((arg0: T) => U), xs: FSharpList<T>, averager: any): U;
export declare function permute<T>(f: ((arg0: int32) => int32), xs: FSharpList<T>): FSharpList<T>;
export declare function chunkBySize<T>(chunkSize: int32, xs: FSharpList<T>): FSharpList<FSharpList<T>>;
export declare function allPairs<T1, T2>(xs: FSharpList<T1>, ys: FSharpList<T2>): FSharpList<[T1, T2]>;
export declare function skip<T>(count_mut: int32, xs_mut: FSharpList<T>): FSharpList<T>;
export declare function skipWhile<T>(predicate_mut: ((arg0: T) => boolean), xs_mut: FSharpList<T>): FSharpList<T>;
export declare function take<T>(count: int32, xs: FSharpList<T>): FSharpList<T>;
export declare function takeWhile<T>(predicate: ((arg0: T) => boolean), xs: FSharpList<T>): FSharpList<T>;
export declare function truncate<T>(count: int32, xs: FSharpList<T>): FSharpList<T>;
export declare function getSlice<T>(startIndex: Option<int32>, endIndex: Option<int32>, xs: FSharpList<T>): FSharpList<T>;
export declare function splitAt<T>(index: int32, xs: FSharpList<T>): [FSharpList<T>, FSharpList<T>];
export declare function exactlyOne<T>(xs: FSharpList<T>): T;
export declare function tryExactlyOne<T>(xs: FSharpList<T>): Option<T>;
export declare function where<T>(predicate: ((arg0: T) => boolean), xs: FSharpList<T>): FSharpList<T>;
export declare function pairwise<T>(xs: FSharpList<T>): FSharpList<[T, T]>;
export declare function windowed<T>(windowSize: int32, xs: FSharpList<T>): FSharpList<FSharpList<T>>;
export declare function splitInto<T>(chunks: int32, xs: FSharpList<T>): FSharpList<FSharpList<T>>;
export declare function transpose<T>(lists: Iterable<FSharpList<T>>): FSharpList<FSharpList<T>>;
export declare function insertAt<T>(index: int32, y: T, xs: FSharpList<T>): FSharpList<T>;
export declare function insertManyAt<T>(index: int32, ys: Iterable<T>, xs: FSharpList<T>): FSharpList<T>;
export declare function removeAt<T>(index: int32, xs: FSharpList<T>): FSharpList<T>;
export declare function removeManyAt<T>(index: int32, count: int32, xs: FSharpList<T>): FSharpList<T>;
export declare function updateAt<T>(index: int32, y: T, xs: FSharpList<T>): FSharpList<T>;
