import { TypeInfo } from "./Reflection.js";
import { Option } from "./Option.js";
import { int32 } from "./Int32.js";
import { IMap, IEnumerator, IComparer } from "./Util.js";
import { FSharpList } from "./List.js";
import { FSharpRef, Record } from "./Types.js";
export declare class MapTreeLeaf$2<Key, Value> {
    readonly v: Value;
    readonly k: Key;
    constructor(k: Key, v: Value);
}
export declare function MapTreeLeaf$2_$reflection(gen0: TypeInfo, gen1: TypeInfo): TypeInfo;
export declare function MapTreeLeaf$2_$ctor_5BDDA1<Key, Value>(k: Key, v: Value): MapTreeLeaf$2<Key, Value>;
export declare function MapTreeLeaf$2__get_Key<Key, Value>(_: MapTreeLeaf$2<Key, Value>): Key;
export declare function MapTreeLeaf$2__get_Value<Key, Value>(_: MapTreeLeaf$2<Key, Value>): Value;
export declare class MapTreeNode$2<Key, Value> extends MapTreeLeaf$2<Key, Value> {
    readonly right: Option<MapTreeLeaf$2<Key, Value>>;
    readonly left: Option<MapTreeLeaf$2<Key, Value>>;
    readonly h: int32;
    constructor(k: Key, v: Value, left: Option<MapTreeLeaf$2<Key, Value>>, right: Option<MapTreeLeaf$2<Key, Value>>, h: int32);
}
export declare function MapTreeNode$2_$reflection(gen0: TypeInfo, gen1: TypeInfo): TypeInfo;
export declare function MapTreeNode$2_$ctor_Z39DE9543<Key, Value>(k: Key, v: Value, left: Option<MapTreeLeaf$2<Key, Value>>, right: Option<MapTreeLeaf$2<Key, Value>>, h: int32): MapTreeNode$2<Key, Value>;
export declare function MapTreeNode$2__get_Left<Key, Value>(_: MapTreeNode$2<Key, Value>): Option<MapTreeLeaf$2<Key, Value>>;
export declare function MapTreeNode$2__get_Right<Key, Value>(_: MapTreeNode$2<Key, Value>): Option<MapTreeLeaf$2<Key, Value>>;
export declare function MapTreeNode$2__get_Height<Key, Value>(_: MapTreeNode$2<Key, Value>): int32;
export declare function MapTreeModule_empty<Key, Value>(): Option<MapTreeLeaf$2<Key, Value>>;
export declare function MapTreeModule_sizeAux<Key, Value>(acc_mut: int32, m_mut: Option<MapTreeLeaf$2<Key, Value>>): int32;
export declare function MapTreeModule_size<$a, $b>(x: Option<MapTreeLeaf$2<$a, $b>>): int32;
export declare function MapTreeModule_mk<Key, Value>(l: Option<MapTreeLeaf$2<Key, Value>>, k: Key, v: Value, r: Option<MapTreeLeaf$2<Key, Value>>): Option<MapTreeLeaf$2<Key, Value>>;
export declare function MapTreeModule_rebalance<Key, Value>(t1: Option<MapTreeLeaf$2<Key, Value>>, k: Key, v: Value, t2: Option<MapTreeLeaf$2<Key, Value>>): Option<MapTreeLeaf$2<Key, Value>>;
export declare function MapTreeModule_add<Key, Value>(comparer: IComparer<Key>, k: Key, v: Value, m: Option<MapTreeLeaf$2<Key, Value>>): Option<MapTreeLeaf$2<Key, Value>>;
export declare function MapTreeModule_tryFind<Key, Value>(comparer_mut: IComparer<Key>, k_mut: Key, m_mut: Option<MapTreeLeaf$2<Key, Value>>): Option<Value>;
export declare function MapTreeModule_find<Key, Value>(comparer: IComparer<Key>, k: Key, m: Option<MapTreeLeaf$2<Key, Value>>): Value;
export declare function MapTreeModule_partition1<Key, $a>(comparer: IComparer<Key>, f: any, k: Key, v: $a, acc1: Option<MapTreeLeaf$2<Key, $a>>, acc2: Option<MapTreeLeaf$2<Key, $a>>): [Option<MapTreeLeaf$2<Key, $a>>, Option<MapTreeLeaf$2<Key, $a>>];
export declare function MapTreeModule_partitionAux<Key, Value>(comparer_mut: IComparer<Key>, f_mut: any, m_mut: Option<MapTreeLeaf$2<Key, Value>>, acc__mut: Option<MapTreeLeaf$2<Key, Value>>, acc__1_mut: Option<MapTreeLeaf$2<Key, Value>>): [Option<MapTreeLeaf$2<Key, Value>>, Option<MapTreeLeaf$2<Key, Value>>];
export declare function MapTreeModule_partition<Key, $a>(comparer: IComparer<Key>, f: ((arg0: Key, arg1: $a) => boolean), m: Option<MapTreeLeaf$2<Key, $a>>): [Option<MapTreeLeaf$2<Key, $a>>, Option<MapTreeLeaf$2<Key, $a>>];
export declare function MapTreeModule_filter1<Key, $a>(comparer: IComparer<Key>, f: any, k: Key, v: $a, acc: Option<MapTreeLeaf$2<Key, $a>>): Option<MapTreeLeaf$2<Key, $a>>;
export declare function MapTreeModule_filterAux<Key, Value>(comparer_mut: IComparer<Key>, f_mut: any, m_mut: Option<MapTreeLeaf$2<Key, Value>>, acc_mut: Option<MapTreeLeaf$2<Key, Value>>): Option<MapTreeLeaf$2<Key, Value>>;
export declare function MapTreeModule_filter<Key, $a>(comparer: IComparer<Key>, f: ((arg0: Key, arg1: $a) => boolean), m: Option<MapTreeLeaf$2<Key, $a>>): Option<MapTreeLeaf$2<Key, $a>>;
export declare function MapTreeModule_spliceOutSuccessor<Key, Value>(m: Option<MapTreeLeaf$2<Key, Value>>): [Key, Value, Option<MapTreeLeaf$2<Key, Value>>];
export declare function MapTreeModule_remove<Key, Value>(comparer: IComparer<Key>, k: Key, m: Option<MapTreeLeaf$2<Key, Value>>): Option<MapTreeLeaf$2<Key, Value>>;
export declare function MapTreeModule_change<Key, Value>(comparer: IComparer<Key>, k: Key, u: ((arg0: Option<Value>) => Option<Value>), m: Option<MapTreeLeaf$2<Key, Value>>): Option<MapTreeLeaf$2<Key, Value>>;
export declare function MapTreeModule_mem<Key, Value>(comparer_mut: IComparer<Key>, k_mut: Key, m_mut: Option<MapTreeLeaf$2<Key, Value>>): boolean;
export declare function MapTreeModule_iterOpt<Key, Value>(f_mut: any, m_mut: Option<MapTreeLeaf$2<Key, Value>>): void;
export declare function MapTreeModule_iter<$a, $b>(f: ((arg0: $a, arg1: $b) => void), m: Option<MapTreeLeaf$2<$a, $b>>): void;
export declare function MapTreeModule_tryPickOpt<Key, Value, $a>(f_mut: any, m_mut: Option<MapTreeLeaf$2<Key, Value>>): Option<$a>;
export declare function MapTreeModule_tryPick<$a, $b, $c>(f: ((arg0: $a, arg1: $b) => Option<$c>), m: Option<MapTreeLeaf$2<$a, $b>>): Option<$c>;
export declare function MapTreeModule_existsOpt<Key, Value>(f_mut: any, m_mut: Option<MapTreeLeaf$2<Key, Value>>): boolean;
export declare function MapTreeModule_exists<$a, $b>(f: ((arg0: $a, arg1: $b) => boolean), m: Option<MapTreeLeaf$2<$a, $b>>): boolean;
export declare function MapTreeModule_forallOpt<Key, Value>(f_mut: any, m_mut: Option<MapTreeLeaf$2<Key, Value>>): boolean;
export declare function MapTreeModule_forall<$a, $b>(f: ((arg0: $a, arg1: $b) => boolean), m: Option<MapTreeLeaf$2<$a, $b>>): boolean;
export declare function MapTreeModule_map<Value, Result, Key>(f: ((arg0: Value) => Result), m: Option<MapTreeLeaf$2<Key, Value>>): Option<MapTreeLeaf$2<Key, Result>>;
export declare function MapTreeModule_mapiOpt<Key, Value, Result>(f: any, m: Option<MapTreeLeaf$2<Key, Value>>): Option<MapTreeLeaf$2<Key, Result>>;
export declare function MapTreeModule_mapi<$a, $b, $c>(f: ((arg0: $a, arg1: $b) => $c), m: Option<MapTreeLeaf$2<$a, $b>>): Option<MapTreeLeaf$2<$a, $c>>;
export declare function MapTreeModule_foldBackOpt<Key, Value, $a>(f_mut: any, m_mut: Option<MapTreeLeaf$2<Key, Value>>, x_mut: $a): $a;
export declare function MapTreeModule_foldBack<$a, $b, $c>(f: ((arg0: $a, arg1: $b, arg2: $c) => $c), m: Option<MapTreeLeaf$2<$a, $b>>, x: $c): $c;
export declare function MapTreeModule_foldOpt<$a, Key, Value>(f_mut: any, x_mut: $a, m_mut: Option<MapTreeLeaf$2<Key, Value>>): $a;
export declare function MapTreeModule_fold<$a, $b, $c>(f: ((arg0: $a, arg1: $b, arg2: $c) => $a), x: $a, m: Option<MapTreeLeaf$2<$b, $c>>): $a;
export declare function MapTreeModule_foldSectionOpt<Key, Value, a>(comparer: IComparer<Key>, lo: Key, hi: Key, f: any, m: Option<MapTreeLeaf$2<Key, Value>>, x: a): a;
export declare function MapTreeModule_foldSection<Key, $a, $b>(comparer: IComparer<Key>, lo: Key, hi: Key, f: ((arg0: Key, arg1: $a, arg2: $b) => $b), m: Option<MapTreeLeaf$2<Key, $a>>, x: $b): $b;
export declare function MapTreeModule_toList<Key, Value>(m: Option<MapTreeLeaf$2<Key, Value>>): FSharpList<[Key, Value]>;
export declare function MapTreeModule_copyToArray<$a, $b>(m: Option<MapTreeLeaf$2<$a, $b>>, arr: [$a, $b][], i: int32): void;
export declare function MapTreeModule_toArray<$a, $b>(m: Option<MapTreeLeaf$2<$a, $b>>): [$a, $b][];
export declare function MapTreeModule_ofList<$a, $b>(comparer: IComparer<$a>, l: FSharpList<[$a, $b]>): Option<MapTreeLeaf$2<$a, $b>>;
export declare function MapTreeModule_mkFromEnumerator<$a, $b>(comparer_mut: IComparer<$a>, acc_mut: Option<MapTreeLeaf$2<$a, $b>>, e_mut: IEnumerator<[$a, $b]>): Option<MapTreeLeaf$2<$a, $b>>;
export declare function MapTreeModule_ofArray<Key, Value>(comparer: IComparer<Key>, arr: [Key, Value][]): Option<MapTreeLeaf$2<Key, Value>>;
export declare function MapTreeModule_ofSeq<Key, Value>(comparer: IComparer<Key>, c: Iterable<[Key, Value]>): Option<MapTreeLeaf$2<Key, Value>>;
export declare class MapTreeModule_MapIterator$2<Key, Value> extends Record {
    stack: FSharpList<Option<MapTreeLeaf$2<Key, Value>>>;
    started: boolean;
    constructor(stack: FSharpList<Option<MapTreeLeaf$2<Key, Value>>>, started: boolean);
}
export declare function MapTreeModule_MapIterator$2_$reflection(gen0: TypeInfo, gen1: TypeInfo): TypeInfo;
export declare function MapTreeModule_collapseLHS<Key, Value>(stack_mut: FSharpList<Option<MapTreeLeaf$2<Key, Value>>>): FSharpList<Option<MapTreeLeaf$2<Key, Value>>>;
export declare function MapTreeModule_mkIterator<$a, $b>(m: Option<MapTreeLeaf$2<$a, $b>>): MapTreeModule_MapIterator$2<$a, $b>;
export declare function MapTreeModule_notStarted<$a>(): $a;
export declare function MapTreeModule_alreadyFinished<$a>(): $a;
export declare function MapTreeModule_current<Key, Value>(i: MapTreeModule_MapIterator$2<Key, Value>): [Key, Value];
export declare function MapTreeModule_moveNext<Key, Value>(i: MapTreeModule_MapIterator$2<Key, Value>): boolean;
export declare function MapTreeModule_mkIEnumerator<a, b>(m: Option<MapTreeLeaf$2<a, b>>): IEnumerator<[a, b]>;
export declare function MapTreeModule_toSeq<$a, $b>(s: Option<MapTreeLeaf$2<$a, $b>>): Iterable<[$a, $b]>;
export declare function MapTreeModule_leftmost<Key, Value>(m_mut: Option<MapTreeLeaf$2<Key, Value>>): [Key, Value];
export declare function MapTreeModule_rightmost<Key, Value>(m_mut: Option<MapTreeLeaf$2<Key, Value>>): [Key, Value];
export declare class FSharpMap<Key, Value> implements IMap<Key, Value>, Iterable<[Key, Value]>, Iterable<[Key, Value]> {
    readonly tree: Option<MapTreeLeaf$2<Key, Value>>;
    readonly comparer: IComparer<Key>;
    constructor(comparer: IComparer<Key>, tree: Option<MapTreeLeaf$2<Key, Value>>);
    GetHashCode(): int32;
    Equals(that: any): boolean;
    toString(): string;
    get [Symbol.toStringTag](): string;
    toJSON(): any;
    GetEnumerator(): IEnumerator<[Key, Value]>;
    [Symbol.iterator](): Iterator<[Key, Value]>;
    "System.Collections.IEnumerable.GetEnumerator"(): IEnumerator<any>;
    CompareTo(obj: any): int32;
    "System.Collections.Generic.ICollection`1.Add2B595"(x: [Key, Value]): void;
    "System.Collections.Generic.ICollection`1.Clear"(): void;
    "System.Collections.Generic.ICollection`1.Remove2B595"(x: [Key, Value]): boolean;
    "System.Collections.Generic.ICollection`1.Contains2B595"(x: [Key, Value]): boolean;
    "System.Collections.Generic.ICollection`1.CopyToZ3B4C077E"(arr: [Key, Value][], i: int32): void;
    "System.Collections.Generic.ICollection`1.get_IsReadOnly"(): boolean;
    "System.Collections.Generic.ICollection`1.get_Count"(): int32;
    "System.Collections.Generic.IReadOnlyCollection`1.get_Count"(): int32;
    get size(): int32;
    clear(): void;
    delete(_arg: Key): boolean;
    entries(): Iterable<[Key, Value]>;
    get(k: Key): Value;
    has(k: Key): boolean;
    keys(): Iterable<Key>;
    set(k: Key, v: Value): IMap<Key, Value>;
    values(): Iterable<Value>;
    forEach(f: ((arg0: Value, arg1: Key, arg2: IMap<Key, Value>) => void), thisArg?: Option<any>): void;
}
export declare function FSharpMap_$reflection(gen0: TypeInfo, gen1: TypeInfo): TypeInfo;
export declare function FSharpMap_$ctor<Key, Value>(comparer: IComparer<Key>, tree: Option<MapTreeLeaf$2<Key, Value>>): FSharpMap<Key, Value>;
export declare function FSharpMap_Empty<Key, Value>(comparer: IComparer<Key>): FSharpMap<Key, Value>;
export declare function FSharpMap__get_Comparer<Key, Value>(m: FSharpMap<Key, Value>): IComparer<Key>;
export declare function FSharpMap__get_Tree<Key, Value>(m: FSharpMap<Key, Value>): Option<MapTreeLeaf$2<Key, Value>>;
export declare function FSharpMap__Add<Key, Value>(m: FSharpMap<Key, Value>, key: Key, value: Value): FSharpMap<Key, Value>;
export declare function FSharpMap__Change<Key, Value>(m: FSharpMap<Key, Value>, key: Key, f: ((arg0: Option<Value>) => Option<Value>)): FSharpMap<Key, Value>;
export declare function FSharpMap__get_IsEmpty<Key, Value>(m: FSharpMap<Key, Value>): boolean;
export declare function FSharpMap__get_Item<Key, Value>(m: FSharpMap<Key, Value>, key: Key): Value;
export declare function FSharpMap__TryPick<Key, Value, $a>(m: FSharpMap<Key, Value>, f: ((arg0: Key, arg1: Value) => Option<$a>)): Option<$a>;
export declare function FSharpMap__Exists<Key, Value>(m: FSharpMap<Key, Value>, predicate: ((arg0: Key, arg1: Value) => boolean)): boolean;
export declare function FSharpMap__Filter<Key, Value>(m: FSharpMap<Key, Value>, predicate: ((arg0: Key, arg1: Value) => boolean)): FSharpMap<Key, Value>;
export declare function FSharpMap__ForAll<Key, Value>(m: FSharpMap<Key, Value>, predicate: ((arg0: Key, arg1: Value) => boolean)): boolean;
export declare function FSharpMap__Fold<Key, Value, $a>(m: FSharpMap<Key, Value>, f: ((arg0: Key, arg1: Value, arg2: $a) => $a), acc: $a): $a;
export declare function FSharpMap__FoldSection<Key, Value, z>(m: FSharpMap<Key, Value>, lo: Key, hi: Key, f: ((arg0: Key, arg1: Value, arg2: z) => z), acc: z): z;
export declare function FSharpMap__Iterate<Key, Value>(m: FSharpMap<Key, Value>, f: ((arg0: Key, arg1: Value) => void)): void;
export declare function FSharpMap__MapRange<Key, Value, Result>(m: FSharpMap<Key, Value>, f: ((arg0: Value) => Result)): FSharpMap<Key, Result>;
export declare function FSharpMap__Map<Key, Value, b>(m: FSharpMap<Key, Value>, f: ((arg0: Key, arg1: Value) => b)): FSharpMap<Key, b>;
export declare function FSharpMap__Partition<Key, Value>(m: FSharpMap<Key, Value>, predicate: ((arg0: Key, arg1: Value) => boolean)): [FSharpMap<Key, Value>, FSharpMap<Key, Value>];
export declare function FSharpMap__get_Count<Key, Value>(m: FSharpMap<Key, Value>): int32;
export declare function FSharpMap__ContainsKey<Key, Value>(m: FSharpMap<Key, Value>, key: Key): boolean;
export declare function FSharpMap__Remove<Key, Value>(m: FSharpMap<Key, Value>, key: Key): FSharpMap<Key, Value>;
export declare function FSharpMap__TryGetValue<Key, Value>(_: FSharpMap<Key, Value>, key: Key, value: FSharpRef<Value>): boolean;
export declare function FSharpMap__get_Keys<Key, Value>(_: FSharpMap<Key, Value>): Iterable<Key>;
export declare function FSharpMap__get_Values<Key, Value>(_: FSharpMap<Key, Value>): Iterable<Value>;
export declare function FSharpMap__get_MinKeyValue<Key, Value>(m: FSharpMap<Key, Value>): [Key, Value];
export declare function FSharpMap__get_MaxKeyValue<Key, Value>(m: FSharpMap<Key, Value>): [Key, Value];
export declare function FSharpMap__TryFind<Key, Value>(m: FSharpMap<Key, Value>, key: Key): Option<Value>;
export declare function FSharpMap__ToList<Key, Value>(m: FSharpMap<Key, Value>): FSharpList<[Key, Value]>;
export declare function FSharpMap__ToArray<Key, Value>(m: FSharpMap<Key, Value>): [Key, Value][];
export declare function FSharpMap__ComputeHashCode<Key, Value>(this$: FSharpMap<Key, Value>): int32;
export declare function isEmpty<$a, $b>(table: FSharpMap<$a, $b>): boolean;
export declare function add<$a, $b>(key: $a, value: $b, table: FSharpMap<$a, $b>): FSharpMap<$a, $b>;
export declare function change<$a, $b>(key: $a, f: ((arg0: Option<$b>) => Option<$b>), table: FSharpMap<$a, $b>): FSharpMap<$a, $b>;
export declare function find<$a, $b>(key: $a, table: FSharpMap<$a, $b>): $b;
export declare function tryFind<$a, $b>(key: $a, table: FSharpMap<$a, $b>): Option<$b>;
export declare function remove<$a, $b>(key: $a, table: FSharpMap<$a, $b>): FSharpMap<$a, $b>;
export declare function containsKey<$a, $b>(key: $a, table: FSharpMap<$a, $b>): boolean;
export declare function iterate<$a, $b>(action: ((arg0: $a, arg1: $b) => void), table: FSharpMap<$a, $b>): void;
export declare function tryPick<$a, $b, $c>(chooser: ((arg0: $a, arg1: $b) => Option<$c>), table: FSharpMap<$a, $b>): Option<$c>;
export declare function pick<$a, $b, $c>(chooser: ((arg0: $a, arg1: $b) => Option<$c>), table: FSharpMap<$a, $b>): $c;
export declare function exists<$a, $b>(predicate: ((arg0: $a, arg1: $b) => boolean), table: FSharpMap<$a, $b>): boolean;
export declare function filter<$a, $b>(predicate: ((arg0: $a, arg1: $b) => boolean), table: FSharpMap<$a, $b>): FSharpMap<$a, $b>;
export declare function partition<$a, $b>(predicate: ((arg0: $a, arg1: $b) => boolean), table: FSharpMap<$a, $b>): [FSharpMap<$a, $b>, FSharpMap<$a, $b>];
export declare function forAll<$a, $b>(predicate: ((arg0: $a, arg1: $b) => boolean), table: FSharpMap<$a, $b>): boolean;
export declare function map<$a, $b, $c>(mapping: ((arg0: $a, arg1: $b) => $c), table: FSharpMap<$a, $b>): FSharpMap<$a, $c>;
export declare function fold<Key, T, State>(folder: ((arg0: State, arg1: Key, arg2: T) => State), state: State, table: FSharpMap<Key, T>): State;
export declare function foldBack<Key, T, State>(folder: ((arg0: Key, arg1: T, arg2: State) => State), table: FSharpMap<Key, T>, state: State): State;
export declare function toSeq<$a, $b>(table: FSharpMap<$a, $b>): Iterable<[$a, $b]>;
export declare function findKey<$a, $b>(predicate: ((arg0: $a, arg1: $b) => boolean), table: FSharpMap<$a, $b>): $a;
export declare function tryFindKey<$a, $b>(predicate: ((arg0: $a, arg1: $b) => boolean), table: FSharpMap<$a, $b>): Option<$a>;
export declare function ofList<Key, Value>(elements: FSharpList<[Key, Value]>, comparer: IComparer<Key>): FSharpMap<Key, Value>;
export declare function ofSeq<T, $a>(elements: Iterable<[T, $a]>, comparer: IComparer<T>): FSharpMap<T, $a>;
export declare function ofArray<Key, Value>(elements: [Key, Value][], comparer: IComparer<Key>): FSharpMap<Key, Value>;
export declare function toList<$a, $b>(table: FSharpMap<$a, $b>): FSharpList<[$a, $b]>;
export declare function toArray<$a, $b>(table: FSharpMap<$a, $b>): [$a, $b][];
export declare function keys<K, V>(table: FSharpMap<K, V>): Iterable<K>;
export declare function values<K, V>(table: FSharpMap<K, V>): Iterable<V>;
export declare function minKeyValue<$a, $b>(table: FSharpMap<$a, $b>): [$a, $b];
export declare function maxKeyValue<$a, $b>(table: FSharpMap<$a, $b>): [$a, $b];
export declare function empty<Key, Value>(comparer: IComparer<Key>): FSharpMap<Key, Value>;
export declare function count<$a, $b>(table: FSharpMap<$a, $b>): int32;
