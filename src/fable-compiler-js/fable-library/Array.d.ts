import { int32 } from "./Int32.js";
import { Option } from "./Option.js";
import { IComparer, IEqualityComparer } from "./Util.js";
export declare function append<T>(array1: T[], array2: T[], cons?: any): T[];
export declare function filter<T>(predicate: ((arg0: T) => boolean), array: T[]): T[];
export declare function fill<T>(target: T[], targetIndex: int32, count: int32, value: T): T[];
export declare function getSubArray<T>(array: T[], start: int32, count: int32): T[];
export declare function last<T>(array: T[]): T;
export declare function tryLast<T>(array: T[]): Option<T>;
export declare function mapIndexed<T, U>(f: ((arg0: int32, arg1: T) => U), source: T[], cons?: any): U[];
export declare function map<T, U>(f: ((arg0: T) => U), source: T[], cons?: any): U[];
export declare function mapIndexed2<T1, T2, U>(f: ((arg0: int32, arg1: T1, arg2: T2) => U), source1: T1[], source2: T2[], cons?: any): U[];
export declare function map2<T1, T2, U>(f: ((arg0: T1, arg1: T2) => U), source1: T1[], source2: T2[], cons?: any): U[];
export declare function mapIndexed3<T1, T2, T3, U>(f: ((arg0: int32, arg1: T1, arg2: T2, arg3: T3) => U), source1: T1[], source2: T2[], source3: T3[], cons?: any): U[];
export declare function map3<T1, T2, T3, U>(f: ((arg0: T1, arg1: T2, arg2: T3) => U), source1: T1[], source2: T2[], source3: T3[], cons?: any): U[];
export declare function mapFold<T, State, Result>(mapping: ((arg0: State, arg1: T) => [Result, State]), state: State, array: T[], cons?: any): [Result[], State];
export declare function mapFoldBack<T, State, Result>(mapping: ((arg0: T, arg1: State) => [Result, State]), array: T[], state: State, cons?: any): [Result[], State];
export declare function indexed<T>(source: T[]): [int32, T][];
export declare function truncate<T>(count: int32, array: T[]): T[];
export declare function concat<T>(arrays: Iterable<T[]>, cons?: any): T[];
export declare function collect<T, U>(mapping: ((arg0: T) => U[]), array: T[], cons?: any): U[];
export declare function where<$a>(predicate: ((arg0: $a) => boolean), array: $a[]): $a[];
export declare function indexOf<T>(array: T[], item_1: T, start: Option<int32>, count: Option<int32>, eq: IEqualityComparer<T>): int32;
export declare function contains<T>(value: T, array: T[], eq: IEqualityComparer<T>): boolean;
export declare function empty<$a>(cons: any): $a[];
export declare function singleton<T>(value: T, cons?: any): T[];
export declare function initialize<T>(count: int32, initializer: ((arg0: int32) => T), cons?: any): T[];
export declare function pairwise<T>(array: T[]): [T, T][];
export declare function replicate<T>(count: int32, initial: T, cons?: any): T[];
export declare function copy<T>(array: T[]): T[];
export declare function copyTo<T>(source: T[], sourceIndex: int32, target: T[], targetIndex: int32, count: int32): void;
export declare function reverse<T>(array: T[]): T[];
export declare function scan<T, State>(folder: ((arg0: State, arg1: T) => State), state: State, array: T[], cons?: any): State[];
export declare function scanBack<T, State>(folder: ((arg0: T, arg1: State) => State), array: T[], state: State, cons?: any): State[];
export declare function skip<T>(count: int32, array: T[], cons?: any): T[];
export declare function skipWhile<T>(predicate: ((arg0: T) => boolean), array: T[], cons?: any): T[];
export declare function take<T>(count: int32, array: T[], cons?: any): T[];
export declare function takeWhile<T>(predicate: ((arg0: T) => boolean), array: T[], cons?: any): T[];
export declare function addInPlace<T>(x: T, array: T[]): void;
export declare function addRangeInPlace<T>(range: Iterable<T>, array: T[]): void;
export declare function insertRangeInPlace<T>(index: int32, range: Iterable<T>, array: T[]): void;
export declare function removeInPlace<T>(item_1: T, array: T[], eq: IEqualityComparer<T>): boolean;
export declare function removeAllInPlace<T>(predicate: ((arg0: T) => boolean), array: T[]): int32;
export declare function partition<T>(f: ((arg0: T) => boolean), source: T[], cons?: any): [T[], T[]];
export declare function find<T>(predicate: ((arg0: T) => boolean), array: T[]): T;
export declare function tryFind<T>(predicate: ((arg0: T) => boolean), array: T[]): Option<T>;
export declare function findIndex<T>(predicate: ((arg0: T) => boolean), array: T[]): int32;
export declare function tryFindIndex<T>(predicate: ((arg0: T) => boolean), array: T[]): Option<int32>;
export declare function pick<$a, $b>(chooser: ((arg0: $a) => Option<$b>), array: $a[]): $b;
export declare function tryPick<$a, $b>(chooser: ((arg0: $a) => Option<$b>), array: $a[]): Option<$b>;
export declare function findBack<$a>(predicate: ((arg0: $a) => boolean), array: $a[]): $a;
export declare function tryFindBack<$a>(predicate: ((arg0: $a) => boolean), array: $a[]): Option<$a>;
export declare function findLastIndex<$a>(predicate: ((arg0: $a) => boolean), array: $a[]): int32;
export declare function findIndexBack<$a>(predicate: ((arg0: $a) => boolean), array: $a[]): int32;
export declare function tryFindIndexBack<$a>(predicate: ((arg0: $a) => boolean), array: $a[]): Option<int32>;
export declare function choose<T, U>(chooser: ((arg0: T) => Option<U>), array: T[], cons?: any): U[];
export declare function foldIndexed<T, State>(folder: ((arg0: int32, arg1: State, arg2: T) => State), state: State, array: T[]): State;
export declare function fold<T, State>(folder: ((arg0: State, arg1: T) => State), state: State, array: T[]): State;
export declare function iterate<T>(action: ((arg0: T) => void), array: T[]): void;
export declare function iterateIndexed<T>(action: ((arg0: int32, arg1: T) => void), array: T[]): void;
export declare function iterate2<T1, T2>(action: ((arg0: T1, arg1: T2) => void), array1: T1[], array2: T2[]): void;
export declare function iterateIndexed2<T1, T2>(action: ((arg0: int32, arg1: T1, arg2: T2) => void), array1: T1[], array2: T2[]): void;
export declare function isEmpty<T>(array: T[]): boolean;
export declare function forAll<T>(predicate: ((arg0: T) => boolean), array: T[]): boolean;
export declare function permute<T>(f: ((arg0: int32) => int32), array: T[]): T[];
export declare function setSlice<T>(target: T[], lower: Option<int32>, upper: Option<int32>, source: T[]): void;
export declare function sortInPlaceBy<a, b>(projection: ((arg0: a) => b), xs: a[], comparer: IComparer<b>): void;
export declare function sortInPlace<T>(xs: T[], comparer: IComparer<T>): void;
export declare function sort<T>(xs: T[], comparer: IComparer<T>): T[];
export declare function sortBy<a, b>(projection: ((arg0: a) => b), xs: a[], comparer: IComparer<b>): a[];
export declare function sortDescending<T>(xs: T[], comparer: IComparer<T>): T[];
export declare function sortByDescending<a, b>(projection: ((arg0: a) => b), xs: a[], comparer: IComparer<b>): a[];
export declare function sortWith<T>(comparer: ((arg0: T, arg1: T) => int32), xs: T[]): T[];
export declare function allPairs<T1, T2>(xs: T1[], ys: T2[]): [T1, T2][];
export declare function unfold<T, State>(generator: ((arg0: State) => Option<[T, State]>), state: State): T[];
export declare function unzip<$a, $b>(array: [$a, $b][]): [$a[], $b[]];
export declare function unzip3<$a, $b, $c>(array: [$a, $b, $c][]): [$a[], $b[], $c[]];
export declare function zip<T, U>(array1: T[], array2: U[]): [T, U][];
export declare function zip3<T, U, V>(array1: T[], array2: U[], array3: V[]): [T, U, V][];
export declare function chunkBySize<T>(chunkSize: int32, array: T[]): T[][];
export declare function splitAt<T>(index: int32, array: T[]): [T[], T[]];
export declare function compareWith<T>(comparer: ((arg0: T, arg1: T) => int32), source1: T[], source2: T[]): int32;
export declare function compareTo<T>(comparer: ((arg0: T, arg1: T) => int32), source1: T[], source2: T[]): int32;
export declare function equalsWith<T>(equals: ((arg0: T, arg1: T) => boolean), array1: T[], array2: T[]): boolean;
export declare function exactlyOne<T>(array: T[]): T;
export declare function tryExactlyOne<T>(array: T[]): Option<T>;
export declare function head<T>(array: T[]): T;
export declare function tryHead<T>(array: T[]): Option<T>;
export declare function tail<T>(array: T[]): T[];
export declare function item<$a>(index: int32, array: $a[]): $a;
export declare function tryItem<T>(index: int32, array: T[]): Option<T>;
export declare function foldBackIndexed<T, State>(folder: ((arg0: int32, arg1: T, arg2: State) => State), array: T[], state: State): State;
export declare function foldBack<T, State>(folder: ((arg0: T, arg1: State) => State), array: T[], state: State): State;
export declare function foldIndexed2<$a, $b, $c>(folder: ((arg0: int32, arg1: $a, arg2: $b, arg3: $c) => $a), state: $a, array1: $b[], array2: $c[]): $a;
export declare function fold2<T1, T2, State>(folder: ((arg0: State, arg1: T1, arg2: T2) => State), state: State, array1: T1[], array2: T2[]): State;
export declare function foldBackIndexed2<T1, T2, State>(folder: ((arg0: int32, arg1: T1, arg2: T2, arg3: State) => State), array1: T1[], array2: T2[], state: State): State;
export declare function foldBack2<T1, T2, State>(f: ((arg0: T1, arg1: T2, arg2: State) => State), array1: T1[], array2: T2[], state: State): State;
export declare function reduce<T>(reduction: ((arg0: T, arg1: T) => T), array: T[]): T;
export declare function reduceBack<T>(reduction: ((arg0: T, arg1: T) => T), array: T[]): T;
export declare function forAll2<$a, $b>(predicate: ((arg0: $a, arg1: $b) => boolean), array1: $a[], array2: $b[]): boolean;
export declare function existsOffset<T>(predicate_mut: ((arg0: T) => boolean), array_mut: T[], index_mut: int32): boolean;
export declare function exists<$a>(predicate: ((arg0: $a) => boolean), array: $a[]): boolean;
export declare function existsOffset2<$a, $b>(predicate_mut: ((arg0: $a, arg1: $b) => boolean), array1_mut: $a[], array2_mut: $b[], index_mut: int32): boolean;
export declare function exists2<$a, $b>(predicate: ((arg0: $a, arg1: $b) => boolean), array1: $a[], array2: $b[]): boolean;
export declare function sum<T>(array: T[], adder: any): T;
export declare function sumBy<T, T2>(projection: ((arg0: T) => T2), array: T[], adder: any): T2;
export declare function maxBy<a, b>(projection: ((arg0: a) => b), xs: a[], comparer: IComparer<b>): a;
export declare function max<a>(xs: a[], comparer: IComparer<a>): a;
export declare function minBy<a, b>(projection: ((arg0: a) => b), xs: a[], comparer: IComparer<b>): a;
export declare function min<a>(xs: a[], comparer: IComparer<a>): a;
export declare function average<T>(array: T[], averager: any): T;
export declare function averageBy<T, T2>(projection: ((arg0: T) => T2), array: T[], averager: any): T2;
export declare function windowed<T>(windowSize: int32, source: T[]): T[][];
export declare function splitInto<T>(chunks: int32, array: T[]): T[][];
export declare function transpose<T>(arrays: Iterable<T[]>, cons?: any): T[][];
export declare function insertAt<T>(index: int32, y: T, xs: T[], cons?: any): T[];
export declare function insertManyAt<T>(index: int32, ys: Iterable<T>, xs: T[], cons?: any): T[];
export declare function removeAt<T>(index: int32, xs: T[]): T[];
export declare function removeManyAt<T>(index: int32, count: int32, xs: T[]): T[];
export declare function updateAt<T>(index: int32, y: T, xs: T[], cons?: any): T[];
