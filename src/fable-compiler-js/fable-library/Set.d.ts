import { TypeInfo } from "./Reflection.js";
import { Option } from "./Option.js";
import { int32 } from "./Int32.js";
import { ISet, IEnumerator, IComparer } from "./Util.js";
import { Record } from "./Types.js";
import { FSharpList } from "./List.js";
export declare class SetTreeLeaf$1<T> {
    readonly k: T;
    constructor(k: T);
}
export declare function SetTreeLeaf$1_$reflection(gen0: TypeInfo): TypeInfo;
export declare function SetTreeLeaf$1_$ctor_2B595<T>(k: T): SetTreeLeaf$1<T>;
export declare function SetTreeLeaf$1__get_Key<T>(_: SetTreeLeaf$1<T>): T;
export declare class SetTreeNode$1<T> extends SetTreeLeaf$1<T> {
    readonly right: Option<SetTreeLeaf$1<T>>;
    readonly left: Option<SetTreeLeaf$1<T>>;
    readonly h: int32;
    constructor(v: T, left: Option<SetTreeLeaf$1<T>>, right: Option<SetTreeLeaf$1<T>>, h: int32);
}
export declare function SetTreeNode$1_$reflection(gen0: TypeInfo): TypeInfo;
export declare function SetTreeNode$1_$ctor_5F465FC9<T>(v: T, left: Option<SetTreeLeaf$1<T>>, right: Option<SetTreeLeaf$1<T>>, h: int32): SetTreeNode$1<T>;
export declare function SetTreeNode$1__get_Left<T>(_: SetTreeNode$1<T>): Option<SetTreeLeaf$1<T>>;
export declare function SetTreeNode$1__get_Right<T>(_: SetTreeNode$1<T>): Option<SetTreeLeaf$1<T>>;
export declare function SetTreeNode$1__get_Height<T>(_: SetTreeNode$1<T>): int32;
export declare function SetTreeModule_empty<T>(): Option<SetTreeLeaf$1<T>>;
export declare function SetTreeModule_countAux<T>(t_mut: Option<SetTreeLeaf$1<T>>, acc_mut: int32): int32;
export declare function SetTreeModule_count<$a>(s: Option<SetTreeLeaf$1<$a>>): int32;
export declare function SetTreeModule_mk<T>(l: Option<SetTreeLeaf$1<T>>, k: T, r: Option<SetTreeLeaf$1<T>>): Option<SetTreeLeaf$1<T>>;
export declare function SetTreeModule_rebalance<T>(t1: Option<SetTreeLeaf$1<T>>, v: T, t2: Option<SetTreeLeaf$1<T>>): Option<SetTreeLeaf$1<T>>;
export declare function SetTreeModule_add<T>(comparer: IComparer<T>, k: T, t: Option<SetTreeLeaf$1<T>>): Option<SetTreeLeaf$1<T>>;
export declare function SetTreeModule_balance<T>(comparer: IComparer<T>, t1: Option<SetTreeLeaf$1<T>>, k: T, t2: Option<SetTreeLeaf$1<T>>): Option<SetTreeLeaf$1<T>>;
export declare function SetTreeModule_split<T>(comparer: IComparer<T>, pivot: T, t: Option<SetTreeLeaf$1<T>>): [Option<SetTreeLeaf$1<T>>, boolean, Option<SetTreeLeaf$1<T>>];
export declare function SetTreeModule_spliceOutSuccessor<T>(t: Option<SetTreeLeaf$1<T>>): [T, Option<SetTreeLeaf$1<T>>];
export declare function SetTreeModule_remove<T>(comparer: IComparer<T>, k: T, t: Option<SetTreeLeaf$1<T>>): Option<SetTreeLeaf$1<T>>;
export declare function SetTreeModule_mem<T>(comparer_mut: IComparer<T>, k_mut: T, t_mut: Option<SetTreeLeaf$1<T>>): boolean;
export declare function SetTreeModule_iter<T>(f_mut: ((arg0: T) => void), t_mut: Option<SetTreeLeaf$1<T>>): void;
export declare function SetTreeModule_foldBackOpt<T, $a>(f_mut: any, t_mut: Option<SetTreeLeaf$1<T>>, x_mut: $a): $a;
export declare function SetTreeModule_foldBack<$a, $b>(f: ((arg0: $a, arg1: $b) => $b), m: Option<SetTreeLeaf$1<$a>>, x: $b): $b;
export declare function SetTreeModule_foldOpt<$a, T>(f_mut: any, x_mut: $a, t_mut: Option<SetTreeLeaf$1<T>>): $a;
export declare function SetTreeModule_fold<$a, $b>(f: ((arg0: $a, arg1: $b) => $a), x: $a, m: Option<SetTreeLeaf$1<$b>>): $a;
export declare function SetTreeModule_forall<T>(f_mut: ((arg0: T) => boolean), t_mut: Option<SetTreeLeaf$1<T>>): boolean;
export declare function SetTreeModule_exists<T>(f_mut: ((arg0: T) => boolean), t_mut: Option<SetTreeLeaf$1<T>>): boolean;
export declare function SetTreeModule_subset<$a>(comparer: IComparer<$a>, a: Option<SetTreeLeaf$1<$a>>, b: Option<SetTreeLeaf$1<$a>>): boolean;
export declare function SetTreeModule_properSubset<$a>(comparer: IComparer<$a>, a: Option<SetTreeLeaf$1<$a>>, b: Option<SetTreeLeaf$1<$a>>): boolean;
export declare function SetTreeModule_filterAux<T>(comparer_mut: IComparer<T>, f_mut: ((arg0: T) => boolean), t_mut: Option<SetTreeLeaf$1<T>>, acc_mut: Option<SetTreeLeaf$1<T>>): Option<SetTreeLeaf$1<T>>;
export declare function SetTreeModule_filter<$a>(comparer: IComparer<$a>, f: ((arg0: $a) => boolean), s: Option<SetTreeLeaf$1<$a>>): Option<SetTreeLeaf$1<$a>>;
export declare function SetTreeModule_diffAux<T>(comparer_mut: IComparer<T>, t_mut: Option<SetTreeLeaf$1<T>>, acc_mut: Option<SetTreeLeaf$1<T>>): Option<SetTreeLeaf$1<T>>;
export declare function SetTreeModule_diff<$a>(comparer: IComparer<$a>, a: Option<SetTreeLeaf$1<$a>>, b: Option<SetTreeLeaf$1<$a>>): Option<SetTreeLeaf$1<$a>>;
export declare function SetTreeModule_union<T>(comparer: IComparer<T>, t1: Option<SetTreeLeaf$1<T>>, t2: Option<SetTreeLeaf$1<T>>): Option<SetTreeLeaf$1<T>>;
export declare function SetTreeModule_intersectionAux<T>(comparer_mut: IComparer<T>, b_mut: Option<SetTreeLeaf$1<T>>, t_mut: Option<SetTreeLeaf$1<T>>, acc_mut: Option<SetTreeLeaf$1<T>>): Option<SetTreeLeaf$1<T>>;
export declare function SetTreeModule_intersection<$a>(comparer: IComparer<$a>, a: Option<SetTreeLeaf$1<$a>>, b: Option<SetTreeLeaf$1<$a>>): Option<SetTreeLeaf$1<$a>>;
export declare function SetTreeModule_partition1<$a>(comparer: IComparer<$a>, f: ((arg0: $a) => boolean), k: $a, acc1: Option<SetTreeLeaf$1<$a>>, acc2: Option<SetTreeLeaf$1<$a>>): [Option<SetTreeLeaf$1<$a>>, Option<SetTreeLeaf$1<$a>>];
export declare function SetTreeModule_partitionAux<T>(comparer_mut: IComparer<T>, f_mut: ((arg0: T) => boolean), t_mut: Option<SetTreeLeaf$1<T>>, acc__mut: Option<SetTreeLeaf$1<T>>, acc__1_mut: Option<SetTreeLeaf$1<T>>): [Option<SetTreeLeaf$1<T>>, Option<SetTreeLeaf$1<T>>];
export declare function SetTreeModule_partition<$a>(comparer: IComparer<$a>, f: ((arg0: $a) => boolean), s: Option<SetTreeLeaf$1<$a>>): [Option<SetTreeLeaf$1<$a>>, Option<SetTreeLeaf$1<$a>>];
export declare function SetTreeModule_minimumElementAux<T>(t_mut: Option<SetTreeLeaf$1<T>>, n_mut: T): T;
export declare function SetTreeModule_minimumElementOpt<T>(t: Option<SetTreeLeaf$1<T>>): Option<T>;
export declare function SetTreeModule_maximumElementAux<T>(t_mut: Option<SetTreeLeaf$1<T>>, n_mut: T): T;
export declare function SetTreeModule_maximumElementOpt<T>(t: Option<SetTreeLeaf$1<T>>): Option<T>;
export declare function SetTreeModule_minimumElement<$a>(s: Option<SetTreeLeaf$1<$a>>): $a;
export declare function SetTreeModule_maximumElement<$a>(s: Option<SetTreeLeaf$1<$a>>): $a;
export declare class SetTreeModule_SetIterator$1<T> extends Record {
    stack: FSharpList<Option<SetTreeLeaf$1<T>>>;
    started: boolean;
    constructor(stack: FSharpList<Option<SetTreeLeaf$1<T>>>, started: boolean);
}
export declare function SetTreeModule_SetIterator$1_$reflection(gen0: TypeInfo): TypeInfo;
export declare function SetTreeModule_collapseLHS<T>(stack_mut: FSharpList<Option<SetTreeLeaf$1<T>>>): FSharpList<Option<SetTreeLeaf$1<T>>>;
export declare function SetTreeModule_mkIterator<$a>(s: Option<SetTreeLeaf$1<$a>>): SetTreeModule_SetIterator$1<$a>;
export declare function SetTreeModule_notStarted<$a>(): $a;
export declare function SetTreeModule_alreadyFinished<$a>(): $a;
export declare function SetTreeModule_current<$a>(i: SetTreeModule_SetIterator$1<$a>): $a;
export declare function SetTreeModule_moveNext<T>(i: SetTreeModule_SetIterator$1<T>): boolean;
export declare function SetTreeModule_mkIEnumerator<a>(s: Option<SetTreeLeaf$1<a>>): IEnumerator<a>;
/**
 * Set comparison.  Note this can be expensive.
 */
export declare function SetTreeModule_compareStacks<T>(comparer_mut: IComparer<T>, l1_mut: FSharpList<Option<SetTreeLeaf$1<T>>>, l2_mut: FSharpList<Option<SetTreeLeaf$1<T>>>): int32;
export declare function SetTreeModule_compare<T>(comparer: IComparer<T>, t1: Option<SetTreeLeaf$1<T>>, t2: Option<SetTreeLeaf$1<T>>): int32;
export declare function SetTreeModule_choose<$a>(s: Option<SetTreeLeaf$1<$a>>): $a;
export declare function SetTreeModule_toList<T>(t: Option<SetTreeLeaf$1<T>>): FSharpList<T>;
export declare function SetTreeModule_copyToArray<$a>(s: Option<SetTreeLeaf$1<$a>>, arr: $a[], i: int32): void;
export declare function SetTreeModule_toArray<$a>(s: Option<SetTreeLeaf$1<$a>>): $a[];
export declare function SetTreeModule_mkFromEnumerator<$a>(comparer_mut: IComparer<$a>, acc_mut: Option<SetTreeLeaf$1<$a>>, e_mut: IEnumerator<$a>): Option<SetTreeLeaf$1<$a>>;
export declare function SetTreeModule_ofArray<$a>(comparer: IComparer<$a>, l: $a[]): Option<SetTreeLeaf$1<$a>>;
export declare function SetTreeModule_ofList<$a>(comparer: IComparer<$a>, l: FSharpList<$a>): Option<SetTreeLeaf$1<$a>>;
export declare function SetTreeModule_ofSeq<T>(comparer: IComparer<T>, c: Iterable<T>): Option<SetTreeLeaf$1<T>>;
export declare class FSharpSet<T> implements ISet<T>, Iterable<T>, Iterable<T> {
    readonly tree: Option<SetTreeLeaf$1<T>>;
    readonly comparer: IComparer<T>;
    constructor(comparer: IComparer<T>, tree: Option<SetTreeLeaf$1<T>>);
    GetHashCode(): int32;
    Equals(that: any): boolean;
    toString(): string;
    get [Symbol.toStringTag](): string;
    toJSON(): any;
    CompareTo(that: any): int32;
    "System.Collections.Generic.ICollection`1.Add2B595"(x: T): void;
    "System.Collections.Generic.ICollection`1.Clear"(): void;
    "System.Collections.Generic.ICollection`1.Remove2B595"(x: T): boolean;
    "System.Collections.Generic.ICollection`1.Contains2B595"(x: T): boolean;
    "System.Collections.Generic.ICollection`1.CopyToZ3B4C077E"(arr: T[], i: int32): void;
    "System.Collections.Generic.ICollection`1.get_IsReadOnly"(): boolean;
    "System.Collections.Generic.ICollection`1.get_Count"(): int32;
    "System.Collections.Generic.IReadOnlyCollection`1.get_Count"(): int32;
    GetEnumerator(): IEnumerator<T>;
    [Symbol.iterator](): Iterator<T>;
    "System.Collections.IEnumerable.GetEnumerator"(): IEnumerator<any>;
    get size(): int32;
    add(k: T): ISet<T>;
    clear(): void;
    delete(k: T): boolean;
    has(k: T): boolean;
    keys(): Iterable<T>;
    values(): Iterable<T>;
    entries(): Iterable<[T, T]>;
    forEach(f: ((arg0: T, arg1: T, arg2: ISet<T>) => void), thisArg?: Option<any>): void;
}
export declare function FSharpSet_$reflection(gen0: TypeInfo): TypeInfo;
export declare function FSharpSet_$ctor<T>(comparer: IComparer<T>, tree: Option<SetTreeLeaf$1<T>>): FSharpSet<T>;
export declare function FSharpSet__get_Comparer<T>(set$: FSharpSet<T>): IComparer<T>;
export declare function FSharpSet__get_Tree<T>(set$: FSharpSet<T>): Option<SetTreeLeaf$1<T>>;
export declare function FSharpSet_Empty<T>(comparer: IComparer<T>): FSharpSet<T>;
export declare function FSharpSet__Add<T>(s: FSharpSet<T>, value: T): FSharpSet<T>;
export declare function FSharpSet__Remove<T>(s: FSharpSet<T>, value: T): FSharpSet<T>;
export declare function FSharpSet__get_Count<T>(s: FSharpSet<T>): int32;
export declare function FSharpSet__Contains<T>(s: FSharpSet<T>, value: T): boolean;
export declare function FSharpSet__Iterate<T>(s: FSharpSet<T>, x: ((arg0: T) => void)): void;
export declare function FSharpSet__Fold<T, $a>(s: FSharpSet<T>, f: ((arg0: T, arg1: $a) => $a), z: $a): $a;
export declare function FSharpSet__get_IsEmpty<T>(s: FSharpSet<T>): boolean;
export declare function FSharpSet__Partition<T>(s: FSharpSet<T>, f: ((arg0: T) => boolean)): [FSharpSet<T>, FSharpSet<T>];
export declare function FSharpSet__Filter<T>(s: FSharpSet<T>, f: ((arg0: T) => boolean)): FSharpSet<T>;
export declare function FSharpSet__Map<T, U>(s: FSharpSet<T>, f: ((arg0: T) => U), comparer: IComparer<U>): FSharpSet<U>;
export declare function FSharpSet__Exists<T>(s: FSharpSet<T>, f: ((arg0: T) => boolean)): boolean;
export declare function FSharpSet__ForAll<T>(s: FSharpSet<T>, f: ((arg0: T) => boolean)): boolean;
export declare function FSharpSet_op_Subtraction<T>(set1: FSharpSet<T>, set2: FSharpSet<T>): FSharpSet<T>;
export declare function FSharpSet_op_Addition<T>(set1: FSharpSet<T>, set2: FSharpSet<T>): FSharpSet<T>;
export declare function FSharpSet_Intersection<T>(a: FSharpSet<T>, b: FSharpSet<T>): FSharpSet<T>;
export declare function FSharpSet_IntersectionMany<T>(sets: Iterable<FSharpSet<T>>): FSharpSet<T>;
export declare function FSharpSet_Equality<T>(a: FSharpSet<T>, b: FSharpSet<T>): boolean;
export declare function FSharpSet_Compare<T>(a: FSharpSet<T>, b: FSharpSet<T>): int32;
export declare function FSharpSet__get_Choose<T>(x: FSharpSet<T>): T;
export declare function FSharpSet__get_MinimumElement<T>(x: FSharpSet<T>): T;
export declare function FSharpSet__get_MaximumElement<T>(x: FSharpSet<T>): T;
export declare function FSharpSet__IsSubsetOf<T>(x: FSharpSet<T>, otherSet: FSharpSet<T>): boolean;
export declare function FSharpSet__IsSupersetOf<T>(x: FSharpSet<T>, otherSet: FSharpSet<T>): boolean;
export declare function FSharpSet__IsProperSubsetOf<T>(x: FSharpSet<T>, otherSet: FSharpSet<T>): boolean;
export declare function FSharpSet__IsProperSupersetOf<T>(x: FSharpSet<T>, otherSet: FSharpSet<T>): boolean;
export declare function FSharpSet__ToList<T>(x: FSharpSet<T>): FSharpList<T>;
export declare function FSharpSet__ToArray<T>(x: FSharpSet<T>): T[];
export declare function FSharpSet__ComputeHashCode<T>(this$: FSharpSet<T>): int32;
export declare function isEmpty<T>(set$: FSharpSet<T>): boolean;
export declare function contains<T>(element: T, set$: FSharpSet<T>): boolean;
export declare function add<T>(value: T, set$: FSharpSet<T>): FSharpSet<T>;
export declare function singleton<T>(value: T, comparer: IComparer<T>): FSharpSet<T>;
export declare function remove<T>(value: T, set$: FSharpSet<T>): FSharpSet<T>;
export declare function union<T>(set1: FSharpSet<T>, set2: FSharpSet<T>): FSharpSet<T>;
export declare function unionMany<T>(sets: Iterable<FSharpSet<T>>, comparer: IComparer<T>): FSharpSet<T>;
export declare function intersect<T>(set1: FSharpSet<T>, set2: FSharpSet<T>): FSharpSet<T>;
export declare function intersectMany<T>(sets: Iterable<FSharpSet<T>>): FSharpSet<T>;
export declare function iterate<T>(action: ((arg0: T) => void), set$: FSharpSet<T>): void;
export declare function empty<T>(comparer: IComparer<T>): FSharpSet<T>;
export declare function forAll<T>(predicate: ((arg0: T) => boolean), set$: FSharpSet<T>): boolean;
export declare function exists<T>(predicate: ((arg0: T) => boolean), set$: FSharpSet<T>): boolean;
export declare function filter<T>(predicate: ((arg0: T) => boolean), set$: FSharpSet<T>): FSharpSet<T>;
export declare function partition<T>(predicate: ((arg0: T) => boolean), set$: FSharpSet<T>): [FSharpSet<T>, FSharpSet<T>];
export declare function fold<T, State>(folder: ((arg0: State, arg1: T) => State), state: State, set$: FSharpSet<T>): State;
export declare function foldBack<T, State>(folder: ((arg0: T, arg1: State) => State), set$: FSharpSet<T>, state: State): State;
export declare function map<T, U>(mapping: ((arg0: T) => U), set$: FSharpSet<T>, comparer: IComparer<U>): FSharpSet<U>;
export declare function count<T>(set$: FSharpSet<T>): int32;
export declare function ofList<T>(elements: Iterable<T>, comparer: IComparer<T>): FSharpSet<T>;
export declare function ofArray<T>(array: T[], comparer: IComparer<T>): FSharpSet<T>;
export declare function toList<T>(set$: FSharpSet<T>): FSharpList<T>;
export declare function toArray<T>(set$: FSharpSet<T>): T[];
export declare function toSeq<T>(set$: FSharpSet<T>): Iterable<T>;
export declare function ofSeq<T>(elements: Iterable<T>, comparer: IComparer<T>): FSharpSet<T>;
export declare function difference<T>(set1: FSharpSet<T>, set2: FSharpSet<T>): FSharpSet<T>;
export declare function isSubset<T>(set1: FSharpSet<T>, set2: FSharpSet<T>): boolean;
export declare function isSuperset<T>(set1: FSharpSet<T>, set2: FSharpSet<T>): boolean;
export declare function isProperSubset<T>(set1: FSharpSet<T>, set2: FSharpSet<T>): boolean;
export declare function isProperSuperset<T>(set1: FSharpSet<T>, set2: FSharpSet<T>): boolean;
export declare function minElement<T>(set$: FSharpSet<T>): T;
export declare function maxElement<T>(set$: FSharpSet<T>): T;
export declare function unionWith<T>(s1: ISet<T>, s2: Iterable<T>): ISet<T>;
export declare function newMutableSetWith<T>(s1: ISet<T>, s2: Iterable<T>): ISet<T>;
export declare function intersectWith<T>(s1: ISet<T>, s2: Iterable<T>): void;
export declare function exceptWith<T>(s1: ISet<T>, s2: Iterable<T>): void;
export declare function isSubsetOf<T>(s1: ISet<T>, s2: Iterable<T>): boolean;
export declare function isSupersetOf<T>(s1: ISet<T>, s2: Iterable<T>): boolean;
export declare function isProperSubsetOf<T>(s1: ISet<T>, s2: Iterable<T>): boolean;
export declare function isProperSupersetOf<T>(s1: ISet<T>, s2: Iterable<T>): boolean;
