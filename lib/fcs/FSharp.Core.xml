<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharp.Core</name></assembly>
<members>
<member name="T:Microsoft.FSharp.Collections.seq`1">
 <summary>An abbreviation for the CLI type <see cref="T:System.Collections.Generic.IEnumerable`1"/></summary>

 <remarks>
  See the <see cref="T:Microsoft.FSharp.Collections.SeqModule"/> module for further operations related to sequences.

  See also <a href="https://docs.microsoft.com/dotnet/fsharp/language-reference/sequences">F# Language Guide - Sequences</a>.
</remarks>
</member>
<member name="T:Microsoft.FSharp.Collections.ResizeArray`1">
 <summary>An abbreviation for the CLI type <see cref="T:System.Collections.Generic.List`1"/></summary>
</member>
<member name="T:Microsoft.FSharp.Collections.list`1">
 <summary>The type of immutable singly-linked lists. </summary>

 <remarks>See the <see cref="T:Microsoft.FSharp.Collections.ListModule"/> module for further operations related to lists.

 Use the constructors <c>[]</c> and <c>::</c> (infix) to create values of this type, or
 the notation <c>[1; 2; 3]</c>. Use the values in the <c>List</c> module to manipulate 
 values of this type, or pattern match against the values directly.

  See also <a href="https://docs.microsoft.com/dotnet/fsharp/language-reference/lists">F# Language Guide - Lists</a>.
 </remarks>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.Tail">
 <summary>Gets the tail of the list, which is a list containing all the elements of the list, excluding the first element </summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.Length">
 <summary>Gets the number of items contained in the list</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.Item(System.Int32)">
 <summary>Gets the element of the list at the given position.</summary>
 <remarks>Lists are represented as linked lists so this is an O(n) operation.</remarks>
 <param name="index">The index.</param>

 <returns>The value at the given index.</returns>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.IsEmpty">
 <summary>Gets a value indicating if the list contains no entries</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.Head">
 <summary>Gets the first element of the list</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.Empty">
 <summary>Returns an empty list of a particular type</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpList`1.GetSlice(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Gets a slice of the list, the elements of the list from the given start index to the given end index.</summary>

 <param name="startIndex">The start index.</param>
 <param name="endIndex">The end index.</param>

 <returns>The sub list specified by the input indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpList`1.GetReverseIndex(System.Int32,System.Int32)">
 <summary>Get the index for the element offset elements away from the end of the collection.</summary>

 <param name="rank">The rank of the index.</param>
 <param name="offset">The offset from the end.</param>

 <returns>The corresponding index from the start.</returns>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpList`1.Cons(`0,Microsoft.FSharp.Collections.FSharpList{`0})">
 <summary>Returns a list with <c>head</c> as its first element and <c>tail</c> as its subsequent elements</summary>

 <param name="head">A new head value for the list.</param>
 <param name="tail">The existing list.</param>

 <returns>The list with head appended to the front of tail.</returns>
</member>
<member name="T:Microsoft.FSharp.Collections.FSharpList`1">
 <summary>The type of immutable singly-linked lists.</summary>

 <remarks>Use the constructors <c>[]</c> and <c>::</c> (infix) to create values of this type, or
 the notation <c>[1;2;3]</c>. Use the values in the <c>List</c> module to manipulate 
 values of this type, or pattern match against the values directly.
 </remarks>

 <exclude />
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpMap`2.Values">
 <summary>All the values in the map, including the duplicates.
 The sequence will be ordered by the keys of the map.</summary>

 <example id="member-values-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 sample.Values // evaluates to seq ["a"; "b"]
 </code>
 </example>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpMap`2.Keys">
 <summary>The keys in the map.
 The sequence will be ordered by the keys of the map.</summary>

 <example id="member-keys-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 sample.Keys // evaluates to seq [1; 2]
 </code>
 </example>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpMap`2.Item(`0)">
 <summary>Lookup an element in the map. Raise <c>KeyNotFoundException</c> if no binding
 exists in the map.</summary>

 <param name="key">The input key.</param>
 <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when the key is not found.</exception>

 <returns>The value mapped to the key.</returns>

 <example id="member-item-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 sample.[1] // evaluates to "a"
 sample.[3] // throws KeyNotFoundException
 </code>
 </example>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpMap`2.IsEmpty">
 <summary>Returns true if there are no bindings in the map.</summary>

 <example id="member-isempty-1">
 <code lang="fsharp">
 let emptyMap: Map&lt;int, string> = Map.empty
 emptyMap.IsEmpty // evaluates to true

 let notEmptyMap = Map [ (1, "a"); (2, "b") ]
 notEmptyMap.IsEmpty // evaluates to false
 </code>
 </example>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpMap`2.Count">
 <summary>The number of bindings in the map.</summary>

 <example id="member-count-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 sample.Count // evaluates to 2
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpMap`2.TryGetValue(`0,`1@)">
 <summary>Lookup an element in the map, assigning to <c>value</c> if the element is in the domain
 of the map and returning <c>false</c> if not.</summary>

 <param name="key">The input key.</param>
 <param name="value">A reference to the output value.</param>

 <returns><c>true</c> if the value is present, <c>false</c> if not.</returns>

 <example id="member-trygetvalue-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 sample.TryGetValue 1 // evaluates to (true, "a")
 sample.TryGetValue 3 // evaluates to (false, null)

 let mutable x = ""
 sample.TryGetValue (1, &amp;x) // evaluates to true, x set to "a"

 let mutable y = ""
 sample.TryGetValue (3, &amp;y) // evaluates to false, y unchanged
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpMap`2.TryFind(`0)">
 <summary>Lookup an element in the map, returning a <c>Some</c> value if the element is in the domain
 of the map and <c>None</c> if not.</summary>

 <param name="key">The input key.</param>

 <returns>The mapped value, or None if the key is not in the map.</returns>

 <example id="member-tryfind-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 sample.TryFind 1 // evaluates to Some "a"
 sample.TryFind 3 // evaluates to None
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpMap`2.Remove(`0)">
 <summary>Removes an element from the domain of the map. No exception is raised if the element is not present.</summary>

 <param name="key">The input key.</param>

 <returns>The resulting map.</returns>

 <example id="member-remove-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 sample.Remove 1 // evaluates to map [(2, "b")]
 sample.Remove 3 // equal to sample
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpMap`2.ContainsKey(`0)">
 <summary>Tests if an element is in the domain of the map.</summary>

 <param name="key">The input key.</param>

 <returns>True if the map contains the given key.</returns>

 <example id="member-containskey-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 sample.ContainsKey 1 // evaluates to true
 sample.ContainsKey 3 // evaluates to false
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpMap`2.Change(`0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{`1},Microsoft.FSharp.Core.FSharpOption{`1}})">
 <summary>Returns a new map with the value stored under key changed according to f.</summary>

 <param name="key">The input key.</param>
 <param name="f">The change function.</param>

 <returns>The resulting map.</returns>

 <example id="member-change-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 let f x =
     match x with
     | Some s -> Some (s + "z")
     | None -> None

 sample.Change (1, f) // evaluates to map [(1, "az"); (2, "b")]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpMap`2.Add(`0,`1)">
 <summary>Returns a new map with the binding added to the given map.
 If a binding with the given key already exists in the input map, the existing binding is replaced by the new binding in the result map.</summary>
 <param name="key">The key to add.</param>
 <param name="value">The value to add.</param>

 <returns>The resulting map.</returns>

 <example id="member-add-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 sample.Add (3, "c") // evaluates to map [(1, "a"); (2, "b"); (3, "c")]
 sample.Add (2, "aa") // evaluates to map [(1, "a"); (2, "aa")]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpMap`2.#ctor(System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}})">
 <summary>Builds a map that contains the bindings of the given IEnumerable.</summary>

 <param name="elements">The input sequence of key/value pairs.</param>

 <returns>The resulting map.</returns>

 <example id="new-1">
 <code lang="fsharp">
 Map [ (1, "a"); (2, "b") ] // evaluates to map [(1, "a"); (2, "b")]
 </code>
 </example>
</member>
<member name="T:Microsoft.FSharp.Collections.FSharpMap`2">
 <summary>Immutable maps based on binary trees, where keys are ordered by F# generic comparison. By default
 comparison is the F# structural comparison function or uses implementations of the IComparable interface on key values.</summary>

 <remarks>See the <see cref="T:Microsoft.FSharp.Collections.MapModule"/> module for further operations on maps.

 All members of this class are thread-safe and may be used concurrently from multiple threads.</remarks>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.op_Subtraction(Microsoft.FSharp.Collections.FSharpSet{`0},Microsoft.FSharp.Collections.FSharpSet{`0})">
 <summary>Returns a new set with the elements of the second set removed from the first.</summary>

 <param name="set1">The first input set.</param>
 <param name="set2">The second input set.</param>

 <returns>A set containing elements of the first set that are not contained in the second set.</returns>

 <example id="set-subtract">
 <code lang="fsharp">
 let set1 = Set.empty.Add(1).Add(2).Add(3)
 let set2 = Set.empty.Add(2).Add(3).Add(4)
 printfn $"The new set is: {set1 - set2}"
 </code>
 The sample evaluates to the following output: <c>The new set is: set [1]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.op_Addition(Microsoft.FSharp.Collections.FSharpSet{`0},Microsoft.FSharp.Collections.FSharpSet{`0})">
 <summary>Compute the union of the two sets.</summary>

 <param name="set1">The first input set.</param>
 <param name="set2">The second input set.</param>

 <returns>The union of the two input sets.</returns>

 <example id="set-add">
 <code lang="fsharp">
 let set1 = Set.empty.Add(1).Add(2).Add(3)
 let set2 = Set.empty.Add(2).Add(3).Add(4)
 printfn $"Output is %A" {set1 + set2}"
 </code>
 The sample evaluates to the following output: <c>The new set is: set [1; 2; 3; 4]</c>
 </example>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpSet`1.MinimumElement">
 <summary>Returns the lowest element in the set according to the ordering being used for the set.</summary>

 <example id="set-minimumelement">
 <code lang="fsharp">
 let set = Set.empty.Add(1).Add(2).Add(3)
 printfn $"MinimumElement: {set.MinimumElement}"
 </code>
 The sample evaluates to the following output: <c>MinimumElement: 1</c>
 </example>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpSet`1.MaximumElement">
 <summary>Returns the highest element in the set according to the ordering being used for the set.</summary>

 <example id="set-maximumelement">
 <code lang="fsharp">
 let set = Set.empty.Add(1).Add(2).Add(3)
 printfn $"MaximumElement: {set.MaximumElement}"
 </code>
 The sample evaluates to the following output: <c>MaximumElement: 3</c>
 </example>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpSet`1.IsEmpty">
 <summary>A useful shortcut for Set.isEmpty. See the Set module for further operations on sets.</summary>

 <example id="set-isempty">
 <code lang="fsharp">
 let set = Set.empty.Add(2).Add(3)
 printfn $"Is the set empty? {set.IsEmpty}"
 </code>
 The sample evaluates to the following output: <c>Is the set empty? false</c>
 </example>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpSet`1.Count">
 <summary>The number of elements in the set</summary>

 <example id="set-count">
 <code lang="fsharp">
 let set = Set.empty.Add(1).Add(1).Add(2)
 printfn $"The set has {set.Count} elements"
 </code>
 The sample evaluates to the following output: <c>The set has 3 elements</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.Remove(`0)">
 <summary>A useful shortcut for Set.remove. Note this operation produces a new set
 and does not mutate the original set. The new set will share many storage
 nodes with the original. See the Set module for further operations on sets.</summary>

 <param name="value">The value to remove from the set.</param>

 <returns>The result set.</returns>

 <example id="set-remove">
 <code lang="fsharp">
 let set = Set.empty.Add(1).Add(1).Add(2)
 printfn $"The new set is: {set}"
 </code>
 The sample evaluates to the following output: <c>The new set is: set [2]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.IsSupersetOf(Microsoft.FSharp.Collections.FSharpSet{`0})">
 <summary>Evaluates to "true" if all elements of the second set are in the first.</summary>

 <param name="otherSet">The set to test against.</param>

 <returns>True if this set is a superset of <c>otherSet</c>.</returns>

 <example id="set-issupersetof">
 <code lang="fsharp">
 let set1 = Set.empty.Add(1).Add(2).Add(3)
 let set2 = Set.empty.Add(1).Add(2).Add(3).Add(4)
 printfn $"Is {set1} a superset of {set2}? {Set.isSuperset set1 set2}"
 </code>
 The sample evaluates to the following output: <c>Is set [1; 2; 3] a superset of set [1; 2; 3; 4]? false</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.IsSubsetOf(Microsoft.FSharp.Collections.FSharpSet{`0})">
 <summary>Evaluates to "true" if all elements of the first set are in the second.</summary>

 <param name="otherSet">The set to test against.</param>

 <returns>True if this set is a subset of <c>otherSet</c>.</returns>

 <example id="set-issubsetof">
 <code lang="fsharp">
 let set1 = Set.empty.Add(1).Add(2).Add(3)
 let set2 = Set.empty.Add(1).Add(2).Add(3).Add(4)
 printfn $"Is {set1} a subset of {set2}? {Set.isSubset set1 set2}"
 </code>
 The sample evaluates to the following output: <c>Is set [1; 2; 3] a subset of set [1; 2; 3; 4]? true</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.IsProperSupersetOf(Microsoft.FSharp.Collections.FSharpSet{`0})">
 <summary>Evaluates to "true" if all elements of the second set are in the first, and at least
 one element of the first is not in the second.</summary>

 <param name="otherSet">The set to test against.</param>

 <returns>True if this set is a proper superset of <c>otherSet</c>.</returns>

 <example id="set-ispropersupersetof">
 <code lang="fsharp">
 let set1 = Set.empty.Add(1).Add(2).Add(3)
 let set2 = Set.empty.Add(1).Add(2).Add(3).Add(4)
 printfn $"Is {set1} a proper superset of {set2}? {Set.isProperSuperset set1 set2}"
 </code>
 The sample evaluates to the following output: <c>Is set [1; 2; 3] a proper superset of set [1; 2; 3; 4]? false</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.IsProperSubsetOf(Microsoft.FSharp.Collections.FSharpSet{`0})">
 <summary>Evaluates to "true" if all elements of the first set are in the second, and at least
 one element of the second is not in the first.</summary>

 <param name="otherSet">The set to test against.</param>

 <returns>True if this set is a proper subset of <c>otherSet</c>.</returns>

 <example id="set-ispropersubsetof">
 <code lang="fsharp">
 let set1 = Set.empty.Add(1).Add(2).Add(3)
 let set2 = Set.empty.Add(1).Add(2).Add(3).Add(4)
 printfn $"Is {set1} a proper superset of {set2}? {Set.isProperSuperset set1 set2}"
 </code>
 The sample evaluates to the following output: <c>Is set [1; 2; 3] a proper subset of set [1; 2; 3; 4]? true</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.Contains(`0)">
 <summary>A useful shortcut for Set.contains. See the Set module for further operations on sets.</summary>

 <param name="value">The value to check.</param>

 <returns>True if the set contains <c>value</c>.</returns>

 <example id="set-contains">
 <code lang="fsharp">
 let set = Set.empty.Add(2).Add(3)
 printfn $"Does the set contain 1? {set.Contains(1)}"
 </code>
 The sample evaluates to the following output: <c>Does the set contain 1? false</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.Add(`0)">
 <summary>A useful shortcut for Set.add. Note this operation produces a new set
 and does not mutate the original set. The new set will share many storage
 nodes with the original. See the Set module for further operations on sets.</summary>

 <param name="value">The value to add to the set.</param>

 <returns>The result set.</returns>

 <example>
 <code lang="fsharp">
 let set = Set.empty.Add(1).Add(1).Add(2)
 printfn $"The new set is: {set}"
 </code>
 The sample evaluates to the following output: <c>The new set is: set [1; 2]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
 <summary>Create a set containing elements drawn from the given sequence.</summary>
 <param name="elements">The input sequence.</param>

 <returns>The result set.</returns>

 <example id="set-new">
 <code lang="fsharp">
 let sequenceOfNumbers = seq { 1 .. 3 }
 let numbersInSet = Set(sequenceOfNumbers)
 printfn $"The set is {numbersInSet}"
 </code>
 </example>
 Creates a new Set containing the elements of the given sequence. <c> set [1; 2; 3]</c>
</member>
<member name="T:Microsoft.FSharp.Collections.FSharpSet`1">
 <summary>Immutable sets based on binary trees, where elements are ordered by F# generic comparison. By default
 comparison is the F# structural comparison function or uses implementations of the IComparable interface on element values.</summary>

 <remarks>See the <see cref="T:Microsoft.FSharp.Collections.SetModule"/> module for further operations on sets.

 All members of this class are thread-safe and may be used concurrently from multiple threads.</remarks>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Get``1(``0[0:],System.Int32,System.Int32)">
 <summary>Fetches an element from a 2D array. You can also use the syntax <c>array.[index1,index2]</c>.</summary>

 <param name="array">The input array.</param>
 <param name="index1">The index along the first dimension.</param>
 <param name="index2">The index along the second dimension.</param>

 <returns>The value of the array at the given index.</returns>
 <exception cref="T:System.ArgumentException">Thrown when the indices are negative or exceed the bounds of the array.</exception>

 <remarks>
 Indexer syntax is generally preferred, e.g.
 <code lang="fsharp">
 let array = array2D [ [ 1.0; 2.0 ]; [ 3.0; 4.0 ] ]

 array[0,1]
 </code>
 Evaluates to <c>2.0</c>.
 </remarks>

 <example id="set-1">
 <code lang="fsharp">
 let array = array2D [ [ 1.0; 2.0 ]; [ 3.0; 4.0 ] ]

 Array2D.get array 0 1
 </code>
 Evaluates to <c>2.0</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Set``1(``0[0:],System.Int32,System.Int32,``0)">
 <summary>Sets the value of an element in an array. You can also use the syntax <c>array.[index1,index2] &lt;- value</c>.</summary>

 <param name="array">The input array.</param>
 <param name="index1">The index along the first dimension.</param>
 <param name="index2">The index along the second dimension.</param>
 <param name="value">The value to set in the array.</param>

 <exception cref="T:System.ArgumentException">Thrown when the indices are negative or exceed the bounds of the array.</exception>

 <remarks>
 Indexer syntax is generally preferred, e.g.
 <code lang="fsharp">
 let array = Array2D.zeroCreate 2 2

 array[0,1] &lt;- 4.0
 </code>
 </remarks>

 <example id="set-1">
 <code lang="fsharp">
 let array = Array2D.zeroCreate 2 2

 Array2D.set array 0 1 4.0
 </code>
 After evaluation <c>array</c> is a 2x2 array with contents <c>[[0.0; 4.0]; [0.0; 0.0]]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Rebase``1(``0[0:])">
 <summary>Builds a new array whose elements are the same as the input array but
 where a non-zero-based input array generates a corresponding zero-based
 output array.</summary>

 <param name="array">The input array.</param>

 <returns>The zero-based output array.</returns>

 <example id="rebase-1">
 <code lang="fsharp">
 let inputs = Array2D.createBased 1 1 2 3 1

 inputs |> Array2D.rebase
 </code>
 Evaluates to a 2x2 zero-based array with contents <c>[[1; 1]; [1; 1]]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}}},``0[0:])">
 <summary>Builds a new array whose elements are the results of applying the given function
 to each of the elements of the array. The integer indices passed to the
 function indicates the element being transformed.</summary>

 <remarks>For non-zero-based arrays the basing on an input array will be propagated to the output
 array.</remarks>

 <param name="mapping">A function that is applied to transform each element of the array.  The two integers
 provide the index of the element.</param>
 <param name="array">The input array.</param>

 <returns>An array whose elements have been transformed by the given mapping.</returns>

 <example id="mapi-1">
 <code lang="fsharp">
 let inputs = array2D [ [ 3; 4 ]; [ 13; 14 ] ]

 inputs |> Array2D.mapi (fun i j v -> i + j + v)
 </code>
 Evaluates to a 2x2 array with contents <c>[[3; 5;]; [14; 16]]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[0:])">
 <summary>Builds a new array whose elements are the results of applying the given function
 to each of the elements of the array.</summary>

 <remarks>For non-zero-based arrays the basing on an input array will be propagated to the output
 array.</remarks>

 <param name="mapping">A function that is applied to transform each item of the input array.</param>
 <param name="array">The input array.</param>

 <returns>An array whose elements have been transformed by the given mapping.</returns>

 <example id="map-1">
 <code lang="fsharp">
 let inputs = array2D [ [ 3; 4 ]; [ 13; 14 ] ]

 inputs |> Array2D.map (fun v -> 2 * v)
 </code>
 Evaluates to a 2x2 array with contents <c>[[6; 8;]; [26; 28]]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Length2``1(``0[0:])">
 <summary>Returns the length of an array in the second dimension.</summary>

 <param name="array">The input array.</param>

 <returns>The length of the array in the second dimension.</returns>

 <example id="length2-1">
 <code>
 let array = array2D [ [ 3; 4; 5 ]; [ 13; 14; 15 ] ]

 array |> Array2D.length2
 </code>
 Evaluates to <c>3</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Length1``1(``0[0:])">
 <summary>Returns the length of an array in the first dimension.</summary>

 <param name="array">The input array.</param>

 <returns>The length of the array in the first dimension.</returns>

 <example id="length1-1">
 <code>
 let array = array2D [ [ 3; 4; 5 ]; [ 13; 14; 15 ] ]

 array |> Array2D.length1
 </code>
 Evaluates to <c>2</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}}},``0[0:])">
 <summary>Applies the given function to each element of the array.  The integer indices passed to the
 function indicates the index of element.</summary>

 <param name="action">A function to apply to each element of the array with the indices available as an argument.</param>
 <param name="array">The input array.</param>

 <example id="iteri-1">
 <code lang="fsharp">
 let inputs = array2D [ [ 3; 4 ]; [ 13; 14 ] ]

 inputs |> Array2D.iteri (fun i j v -> printfn $"value at ({i},{j}) = {v}")
 </code>
 Evaluates to <c>unit</c> and prints
 <code>
 value at (0,0) = 3
 value at (0,1) = 4
 value at (1,0) = 13
 value at (1,1) = 14
 </code>
 in the console.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},``0[0:])">
 <summary>Applies the given function to each element of the array.</summary>

 <param name="action">A function to apply to each element of the array.</param>
 <param name="array">The input array.</param>

 <example id="iter-1">
 <code lang="fsharp">
 let inputs = array2D [ [ 3; 4 ]; [ 13; 14 ] ]

 inputs |> Array2D.iter (fun v -> printfn $"value = {v}")
 </code>
 Evaluates to <c>unit</c> and prints
 <code>
 value = 3
 value = 4
 value = 13
 value = 14
 </code>
 in the console.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.ZeroCreateBased``1(System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>Creates a based array where the entries are initially Unchecked.defaultof&lt;'T&gt;.</summary>

 <param name="base1">The base for the first dimension of the array.</param>
 <param name="base2">The base for the second dimension of the array.</param>
 <param name="length1">The length of the first dimension of the array.</param>
 <param name="length2">The length of the second dimension of the array.</param>

 <returns>The created array.</returns>
 <exception cref="T:System.ArgumentException">Thrown when base1, base2, length1, or length2 is negative.</exception>

 <example id="zerocreatebased-1">
 <code lang="fsharp">
 Array2D.zeroCreateBased 1 1 2 3
 </code>
 Evaluates to a 2x3 1-based array with contents <c>[[0; 0; 0]; [0; 0; 0]]</c>
 </example>

</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.CreateBased``1(System.Int32,System.Int32,System.Int32,System.Int32,``0)">
 <summary>Creates a based array whose elements are all initially the given value.</summary>

 <param name="base1">The base for the first dimension of the array.</param>
 <param name="base2">The base for the second dimension of the array.</param>
 <param name="length1">The length of the first dimension of the array.</param>
 <param name="length2">The length of the second dimension of the array.</param>
 <param name="initial">The value to populate the new array.</param>

 <returns>The created array.</returns>
 <exception cref="T:System.ArgumentException">Thrown when base1, base2, length1, or length2 is negative.</exception>

 <example id="createbased-1">
 <code lang="fsharp">
 Array2D.createBased 1 1 2 3 1
 </code>
 Evaluates to a 2x3 1-based array with contents <c>[[1; 1; 1]; [1; 1; 1]]</c>
 </example>

</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.InitializeBased``1(System.Int32,System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}})">
 <summary>Creates a based array given the dimensions and a generator function to compute the elements.</summary>

 <param name="base1">The base for the first dimension of the array.</param>
 <param name="base2">The base for the second dimension of the array.</param>
 <param name="length1">The length of the first dimension of the array.</param>
 <param name="length2">The length of the second dimension of the array.</param>
 <param name="initializer">A function to produce elements of the array given the two indices.</param>

 <returns>The created array.</returns>
 <exception cref="T:System.ArgumentException">Thrown when base1, base2, length1, or length2 is negative.</exception>

 <example id="initbased-1">
 <code lang="fsharp">
 Array2D.initBased 1 1 2 3 (fun i j -> i + j)
 </code>
 Evaluates to a 2x3 1-based array with contents <c>[[2; 3; 4]; [3; 4; 5]]</c>
 </example>

</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.ZeroCreate``1(System.Int32,System.Int32)">
 <summary>Creates an array where the entries are initially Unchecked.defaultof&lt;'T&gt;.</summary>

 <param name="length1">The length of the first dimension of the array.</param>
 <param name="length2">The length of the second dimension of the array.</param>

 <returns>The created array.</returns>
 <exception cref="T:System.ArgumentException">Thrown when length1 or length2 is negative.</exception>

 <example id="zeroCreate-1">
 <code lang="fsharp">
 Array2D.zeroCreate 2 3
 </code>
 Evaluates to a 2x3 array with contents <c>[[0; 0; 0]; [0; 0; 0]]</c>
 </example>

</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Create``1(System.Int32,System.Int32,``0)">
 <summary>Creates an array whose elements are all initially the given value.</summary>

 <param name="length1">The length of the first dimension of the array.</param>
 <param name="length2">The length of the second dimension of the array.</param>
 <param name="value">The value to populate the new array.</param>

 <returns>The created array.</returns>
 <exception cref="T:System.ArgumentException">Thrown when length1 or length2 is negative.</exception>

 <example id="create-1">
 <code lang="fsharp">
 Array2D.create 2 3 1
 </code>
 Evaluates to a 2x3 array with contents <c>[[1; 1; 1]; [1; 1; 1]]</c>
 </example>

</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Initialize``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}})">
 <summary>Creates an array given the dimensions and a generator function to compute the elements.</summary>

 <param name="length1">The length of the first dimension of the array.</param>
 <param name="length2">The length of the second dimension of the array.</param>
 <param name="initializer">A function to produce elements of the array given the two indices.</param>

 <returns>The generated array.</returns>
 <exception cref="T:System.ArgumentException">Thrown when either of the lengths is negative.</exception>

 <example id="init-1">
 <code lang="fsharp">
 Array2D.init 2 3 (fun i j -> i + j)
 </code>
 Evaluates to a 2x3 array with contents <c>[[0; 1; 2]; [1; 2; 3]]</c>
 </example>

</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.CopyTo``1(``0[0:],System.Int32,System.Int32,``0[0:],System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>Reads a range of elements from the first array and write them into the second.</summary>

 <param name="source">The source array.</param>
 <param name="sourceIndex1">The first-dimension index to begin copying from in the source array.</param>
 <param name="sourceIndex2">The second-dimension index to begin copying from in the source array.</param>
 <param name="target">The target array.</param>
 <param name="targetIndex1">The first-dimension index to begin copying into in the target array.</param>
 <param name="targetIndex2">The second-dimension index to begin copying into in the target array.</param>
 <param name="length1">The number of elements to copy across the first dimension of the arrays.</param>
 <param name="length2">The number of elements to copy across the second dimension of the arrays.</param>
 <exception cref="T:System.ArgumentException">Thrown when any of the indices are negative or if either of
 the counts are larger than the dimensions of the array allow.</exception>

 <remarks>
 Slicing syntax is generally preferred, e.g.
 <code lang="fsharp">
 let source = array2D [ [ 3; 4 ]; [ 13; 14 ] ]
 let target = array2D [ [ 2; 2; 2 ]; [ 12; 12; 12 ] ]
 target[0..1,1..2] &lt;- source
 </code>
 </remarks>

 <example id="blit-1">
 <code lang="fsharp">
 let source = array2D [ [ 3; 4 ]; [ 13; 14 ] ]
 let target = array2D [ [ 2; 2; 2 ]; [ 12; 12; 12 ] ]

 Array2D.blit source 0 0 target 0 1 2 2
 </code>
 After evaluation <c>target</c> contains <c>[ [ 2; 3; 4 ]; [ 12; 13; 14 ] ]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Copy``1(``0[0:])">
 <summary>Builds a new array whose elements are the same as the input array.</summary>

 <remarks>For non-zero-based arrays the basing on an input array will be propagated to the output
 array.</remarks>

 <param name="array">The input array.</param>

 <returns>A copy of the input array.</returns>

 <example id="copy-1">
 <code>
 open System

 let array = Array2D.zeroCreate&lt;int&gt; 10 10

 array |> Array2D.copy
 </code>
 Evaluates to a new copy of the 10x10 array.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Base2``1(``0[0:])">
 <summary>Fetches the base-index for the second dimension of the array.</summary>

 <param name="array">The input array.</param>

 <returns>The base-index of the second dimension of the array.</returns>

 <example id="base2-1">Create a 10x10 1-based array:
 <code>
 open System

 let array = Array.CreateInstance(typeof&lt;int&gt;, [| 10; 10 |], [| 1; 1 |]) :?> int[,]

 array |> Array2D.base2
 </code>
 Evaluates to <c>1</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Base1``1(``0[0:])">
 <summary>Fetches the base-index for the first dimension of the array.</summary>

 <param name="array">The input array.</param>

 <returns>The base-index of the first dimension of the array.</returns>

 <example id="base1-1">Create a 10x10 1-based array:
 <code>
 open System

 let array = Array.CreateInstance(typeof&lt;int&gt;, [| 10; 10 |], [| 1; 1 |]) :?> int[,]

 array |> Array2D.base1
 </code>
 Evaluates to <c>1</c>.
 </example>
</member>
<member name="T:Microsoft.FSharp.Collections.Array2DModule">
 <summary>Contains operations for working with 2-dimensional arrays.</summary>

 <remarks>
  <para>See also <a href="https://docs.microsoft.com/dotnet/fsharp/language-reference/arrays">F# Language Guide - Arrays</a>.</para>

 <para>F# and CLI multi-dimensional arrays are typically zero-based.
 However, CLI multi-dimensional arrays used in conjunction with external
 libraries (e.g. libraries associated with Visual Basic) be
 non-zero based, using a potentially different base for each dimension.
 The operations in this module will accept such arrays, and
 the basing on an input array will be propagated to a matching output
 array on the <c>Array2D.map</c> and <c>Array2D.mapi</c> operations.
 Non-zero-based arrays can also be created using <c>Array2D.zeroCreateBased</c>,
 <c>Array2D.createBased</c> and <c>Array2D.initBased</c>.</para>
 </remarks>
</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.FromFunctions``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}})">
 <summary>Get an implementation of equality semantics using the given functions.</summary>

 <param name="hasher">A function to generate a hash code from a value.</param>
 <param name="equality">A function to test equality of two values.</param>

 <returns>An object implementing <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> using the given functions.</returns>

 <example id="fromfunctions-1">Create a dictionary which uses the given functions for equality and hashing:
 <code>
 open System.Collections.Generic

 let modIdentity = HashIdentity.FromFunctions((fun i -> i%5), (fun i1 i2 -> i1%5 = i2%5))
 let dict = new Dictionary&lt;int,int&gt;(HashIdentity.FromFunctions)

 dict.[2] &lt;- 6
 dict.[7] &lt;- 10
 </code>
 In this example, only one entry is added, as the keys <c>2</c> and <c>7</c> have the same hash and are equal according to the provided functions.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.Reference``1">
 <summary>Get an implementation of equality semantics using reference equality and reference hashing.</summary>

 <returns>
  An object implementing <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> using <see cref="M:Microsoft.FSharp.Core.LanguagePrimitives.PhysicalEquality"/>
  and <see cref="M:Microsoft.FSharp.Core.LanguagePrimitives.PhysicalHash"/>.
 </returns>

 <example id="reference-1">Create a dictionary which uses reference equality and hashing on the key, giving each key reference identity:
 <code>
 open System.Collections.Generic

 let dict = new Dictionary&lt;int[],int&gt;(HashIdentity.Structural)

 let arr1 = [| 1;2;3 |]
 let arr2 = [| 1;2;3 |]
 dict.Add(arr1, 6)
 dict.Add(arr2, 7)
 </code>
 In this example, two entries are added to the dictionary, as the arrays have different object reference identity.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.LimitedStructural``1(System.Int32)">
 <summary>Get an implementation of equality semantics semantics using limited structural equality and structural hashing.</summary>

 <param name="limit">The limit on the number of hashing operations used.</param>

 <returns>An object implementing <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.</returns>

 <example id="limitedstructural-1">Create a dictionary which uses limited structural equality and structural hashing on the key, allowing trees as efficient keys:
 <code>
 open System.Collections.Generic

 type Tree = Tree of int * Tree list

 let dict = new Dictionary&lt;Tree,int&gt;(HashIdentity.LimitedStructural 4)

 let tree1 = Tree(0, [])
 let tree2 = Tree(0, [tree1; tree1])
 dict.Add(tree1, 6)
 dict.Add(tree2, 7)
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.NonStructural``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}})">
 <summary>Get an implementation of equality semantics using non-structural equality and non-structural hashing.</summary>

 <returns>
  An object implementing <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> using <see cref="M:Microsoft.FSharp.Core.Operators.NonStructuralComparison.op_Equality"/>
  and <see cref="M:Microsoft.FSharp.Core.Operators.NonStructuralComparison.hash"/>.
 </returns>

 <example id="nonstructural-1">Create a dictionary which uses non-structural equality and hashing on the key:
 <code>
 open System.Collections.Generic

 let dict = new Dictionary&lt;System.DateTime,int&gt;(HashIdentity.NonStructural)

 dict.Add(System.DateTime.Now, 1)
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.Structural``1">
 <summary>Get an implementation of equality semantics using structural equality and structural hashing.</summary>

 <returns>An object implementing <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> using <see cref="M:Microsoft.FSharp.Core.Operators.op_Equality"/> and <see cref="M:Microsoft.FSharp.Core.Operators.hash"/>.</returns>

 <example id="structural-1">Create a dictionary which uses structural equality and structural hashing on the key, allowing an array as a key:
 <code>
 open System.Collections.Generic

 let dict = new Dictionary&lt;int[],int&gt;(HashIdentity.Structural)

 let arr1 = [| 1;2;3 |]
 let arr2 = [| 1;2;3 |]

 dict.[arr1] &lt;- 6
 dict.[arr2] &gt;- 7
 </code>
 In this example, only one entry is added to the dictionary, as the arrays identical by structural equality.
 </example>
</member>
<member name="T:Microsoft.FSharp.Collections.HashIdentity">
 <summary>Common notions of value identity implementing the <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>
 interface, for constructing <see cref="T:System.Collections.Generic.Dictionary`2"/> objects and other collections</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ComparisonIdentity.FromFunction``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}})">
 <summary>Get an implementation of comparison semantics using the given function.</summary>

 <param name="comparer">A function to compare two values.</param>

 <returns>An object implementing <see cref="T:System.Collections.Generic.IComparer`1"/> using the supplied function.</returns>

 <example id="fromfunction-1">Create and use a comparer using the given function:
 <code>
 let comparer = ComparisonIdentity.FromFunction(fun i1 i2 -> compare (i1%5) (i2%5))

 comparer.Compare(7, 2)
 </code>
 Evaluates to <c>0</c>because <c>7</c> and <c>2</c> compare as equal using to the provided function.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ComparisonIdentity.NonStructural``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}})">
 <summary>Get an implementation of comparison semantics using non-structural comparison.</summary>

 <returns>An object implementing <see cref="T:System.Collections.Generic.IComparer`1"/> using <see cref="M:Microsoft.FSharp.Core.Operators.NonStructuralComparison.Compare"/>.</returns>

 <example id="nonstructural-1">Create and use a comparer using structural comparison:
 <code>
 let comparer = ComparisonIdentity.NonStructural&lt;System.DateTime>

 comparer.Compare(System.DateTime.Now, System.DateTime.Today)
 </code>
 Evaluates to <c>1</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ComparisonIdentity.Structural``1">
 <summary>Get an implementation of comparison semantics using structural comparison.</summary>

 <returns>An object implementing <see cref="T:System.Collections.Generic.IComparer`1"/> using <see cref="M:Microsoft.FSharp.Core.Operators.compare"/>.</returns>

 <example id="structural-1">Create and use a comparer using structural comparison:
 <code>
 let compareTuples = ComparisonIdentity.Structural&lt;int * int>

 compareTuples.Compare((1, 4), (1, 5))
 </code>
 Evaluates to <c>-1</c>.
 </example>
</member>
<member name="T:Microsoft.FSharp.Collections.ComparisonIdentity">
 <summary>Common notions of value ordering implementing the <see cref="T:System.Collections.Generic.IComparer`1"/>
 interface, for constructing sorted data structures and performing sorting operations.</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.InsertManyAt``1(System.Int32,System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
 <summary>Return a new sequence with new items inserted before the given index.</summary>

 <param name="index">The index where the items should be inserted.</param>
 <param name="values">The values to insert.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentException">Thrown when index is below 0 or greater than source.Length.</exception>

 <example id="insertManyAt-1">
 <code>
     seq { 0; 1; 2 } |> Seq.insertManyAt 1 [8; 9]
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 0; 8; 9; 1; 2 }</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.InsertAt``1(System.Int32,``0,System.Collections.Generic.IEnumerable{``0})">
 <summary>Return a new sequence with a new item inserted before the given index.</summary>

 <param name="index">The index where the item should be inserted.</param>
 <param name="value">The value to insert.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentException">Thrown when index is below 0 or greater than source.Length.</exception>

 <example id="insertAt-1">
 <code>
 seq { 0; 1; 2 } |> Seq.insertAt 1 9
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 0; 9; 1; 2 }</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.UpdateAt``1(System.Int32,``0,System.Collections.Generic.IEnumerable{``0})">
 <summary>Return a new sequence with the item at a given index set to the new value.</summary>

 <param name="index">The index of the item to be replaced.</param>
 <param name="value">The new value.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentException">Thrown when index is outside 0..source.Length - 1</exception>

 <example id="updateAt-1">
 <code>
 seq { 0; 1; 2 } |> Seq.updateAt 1 9
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 0; 9; 2 }</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.RemoveManyAt``1(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{``0})">
 <summary>Return a new sequence with the number of items starting at a given index removed.</summary>

 <param name="index">The index of the item to be removed.</param>
 <param name="count">The number of items to remove.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentException">Thrown when index is outside 0..source.Length - count</exception>

 <example id="removeManyAt-1">
 <code>
 seq { 0; 1; 2; 3 } |> Seq.removeManyAt 1 2
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 0; 3 }</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.RemoveAt``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
 <summary>Return a new sequence with the item at a given index removed.</summary>

 <param name="index">The index of the item to be removed.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentException">Thrown when index is outside 0..source.Length - 1</exception>

 <example id="removeAt-1">
 <code>
 seq { 0; 1; 2 } |> Seq.removeAt 1
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 0; 2 }</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Zip3``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})">
 <summary>Combines the three sequences into a sequence of triples. The sequences need not have equal lengths:
 when one sequence is exhausted any remaining elements in the other
 sequences are ignored.</summary>

 <param name="source1">The first input sequence.</param>
 <param name="source2">The second input sequence.</param>
 <param name="source3">The third input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when any of the input sequences is null.</exception>

 <example id="zip3-1">
 <code lang="fsharp">
 let numbers = [1; 2]
 let names = ["one"; "two"]
 let roman = ["I"; "II"]

 Seq.zip3 numbers names roman
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { (1, "one", "I"); (2, "two", "II") }</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Zip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Combines the two sequences into a sequence of pairs. The two sequences need not have equal lengths:
 when one sequence is exhausted any remaining elements in the other
 sequence are ignored.</summary>

 <param name="source1">The first input sequence.</param>
 <param name="source2">The second input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when either of the input sequences is null.</exception>

 <example id="zip-1">
 <code lang="fsharp">
 let numbers = [1; 2]
 let names = ["one"; "two"]

 Seq.zip numbers names
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { (1, "one"); (2, "two") }</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Windowed``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a sequence yielding sliding windows containing elements drawn from the input
 sequence. Each window is returned as a fresh array.</summary>

 <param name="windowSize">The number of elements in each window.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>
 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when windowSize is not positive.</exception>
 
 <example id="windowed-1">
 <code lang="fsharp">
 let inputs = [1; 2; 3; 4; 5]

 inputs |> Seq.windowed 3
 </code>
 Evaluates to a sequence of arrays yielding the results <c>seq { [| 1; 2; 3 |]; [| 2; 3; 4 |]; [| 3; 4; 5 |] }</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Unfold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``1,``0}}},``0)">
 <summary>Returns a sequence that contains the elements generated by the given computation.
 The given initial <c>state</c> argument is passed to the element generator.
 For each IEnumerator elements in the stream are generated on-demand by applying the element
 generator, until a None value is returned by the element generator. Each call to the element
 generator returns a new residual <c>state</c>.</summary>

 <remarks>The stream will be recomputed each time an IEnumerator is requested and iterated for the Seq.</remarks>

 <param name="generator">A function that takes in the current state and returns an option tuple of the next
 element of the sequence and the next state value.</param>
 <param name="state">The initial state value.</param>

 <returns>The result sequence.</returns>

 <example id="unfold-1">
 <code lang="fsharp">
 1 |> Seq.unfold (fun state -> if state > 100 then None else Some (state, state * 2))
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 1; 2; 4; 8; 16; 32; 64 }</c>
 </example>

 <example id="unfold-2">
 <code lang="fsharp">
 1I |> Seq.unfold (fun state -> Some (state, state * 2I))
 </code>
 Evaluates to an infinite sequence yielding the results <c>seq { 1I; 2I; 4I; 8I; ... }</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Truncate``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a sequence that when enumerated returns at most N elements.</summary>

 <param name="count">The maximum number of items to enumerate.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="truncate-1">
 <code lang="fsharp">
 let inputs = ["a"; "b"; "c"; "d"]

 inputs |> Seq.truncate 2
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { "a"; "b" }</c>
 </example>

 <example id="truncate-2">
 <code lang="fsharp">
 let inputs = ["a"; "b"; "c"; "d"]

 inputs |> Seq.truncate 6
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { "a"; "b"; "c"; "d" }</c>
 </example>

 <example id="truncate-3">
 <code lang="fsharp">
 let inputs = ["a"; "b"; "c"; "d"]

 inputs |> Seq.truncate 0
 </code>
 Evaluates to the empty sequence.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Transpose``2(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the transpose of the given sequence of sequences.</summary>

 <remarks>This function returns a sequence that digests the whole initial sequence as soon as
 that sequence is iterated. As a result this function should not be used with
 large or infinite sequences.</remarks>

 <param name="source">The input sequence.</param>

 <returns>The transposed sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="transpose-1">
 <code lang="fsharp">
 let inputs =
     [ [ 10; 20; 30 ]
       [ 11; 21; 31 ] ]

 inputs |> Seq.transpose
 </code>
 Evaluates to a sequence of sequences yielding the same results as <c>[ [10; 11]; [20; 21]; [30; 31] ]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.TryPick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Applies the given function to successive elements, returning the first
 result where the function returns "Some(x)".</summary>

 <param name="chooser">A function that transforms items from the input sequence into options.</param>
 <param name="source">The input sequence.</param>

 <returns>The chosen element or <c>None</c>.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="trypick-1">
 <code lang="fsharp">
 let input = [1; 2; 3]

 input |> Seq.tryPick (fun n -> if n % 2 = 0 then Some (string n) else None)
 </code>
 Evaluates to <c>Some "2"</c>.
 </example>

 <example id="trypick-2">
 <code lang="fsharp">
 let input = [1; 2; 3]

 input |> Seq.tryPick (fun n -> if n > 3 = 0 then Some (string n) else None)
 </code>
 Evaluates to <c>None</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.TryFindIndexBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the index of the last element in the sequence
 that satisfies the given predicate. Return <c>None</c> if no such element exists.</summary>

 <remarks>This function digests the whole initial sequence as soon as it is called. As a
 result this function should not be used with large or infinite sequences.</remarks>

 <param name="predicate">A function that evaluates to a Boolean when given an item in the sequence.</param>
 <param name="source">The input sequence.</param>

 <returns>The found index or <c>None</c>.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="tryfindindexback-1">Try to find the index of the first even number from the back:
 <code lang="fsharp">
 let inputs = [1; 2; 3; 4; 5]

 inputs |> Seq.tryFindIndexBack (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>Some 3</c>
 </example>

 <example id="tryfindindexback-2">Try to find the index of the first even number from the back:
 <code lang="fsharp">
 let inputs = [1; 3; 5; 7]

 inputs |> Seq.tryFindIndexBack (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>None</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.TryItem``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
 <summary>Tries to find the nth element in the sequence.
 Returns <c>None</c> if index is negative or the input sequence does not contain enough elements.</summary>

 <param name="index">The index of element to retrieve.</param>
 <param name="source">The input sequence.</param>

 <returns>The nth element of the sequence or <c>None</c>.</returns>
 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="tryitem-1">
 <code lang="fsharp">
 let inputs = ["a"; "b"; "c"]

 inputs |> Seq.tryItem 1
 </code>
 Evaluates to <c>Some "b"</c>.
 </example>

 <example id="tryitem-2">
 <code lang="fsharp">
 let inputs = ["a"; "b"; "c"]

 inputs |> Seq.tryItem 4
 </code>
 Evaluates to <c>None</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.TryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the index of the first element in the sequence
 that satisfies the given predicate. Return <c>None</c> if no such element exists.</summary>

 <param name="predicate">A function that evaluates to a Boolean when given an item in the sequence.</param>
 <param name="source">The input sequence.</param>

 <returns>The found index or None.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="tryfindindex-1">Try to find the index of the first even number:
 <code lang="fsharp">
 let inputs = [1; 2; 3; 4; 5]

 inputs |> Seq.tryFindIndex (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>Some 1</c>
 </example>

 <example id="tryfindindex-2">Try to find the index of the first even number:
 <code lang="fsharp">
 let inputs = [1; 3; 5; 7]

 inputs |> Seq.tryFindIndex (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>None</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.TryFindBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the last element for which the given function returns True.
 Return None if no such element exists.</summary>

 <remarks>This function digests the whole initial sequence as soon as it is called. As a
 result this function should not be used with large or infinite sequences.</remarks>

 <param name="predicate">A function that evaluates to a Boolean when given an item in the sequence.</param>
 <param name="source">The input sequence.</param>

 <returns>The found element or None.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="tryfindback-1">Try to find the first even number from the back:
 <code lang="fsharp">
 let inputs = [1; 2; 3; 4; 5]

 inputs |> Seq.tryFindBack (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>Some 4</c>
 </example>

 <example id="tryfindback-2">Try to find the first even number from the back:
 <code lang="fsharp">
 let inputs = [1; 5; 3]

 inputs |> Seq.tryFindBack (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>None</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.TryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the first element for which the given function returns True.
 Return None if no such element exists.</summary>

 <param name="predicate">A function that evaluates to a Boolean when given an item in the sequence.</param>
 <param name="source">The input sequence.</param>

 <returns>The found element or None.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="tryfind-1">Try to find the first even number:
 <code lang="fsharp">
 let inputs = [1; 2; 3]

 inputs |> Seq.tryFind (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>Some 2</c>
 </example>

 <example id="tryfind-2">Try to find the first even number:
 <code lang="fsharp">
 let inputs = [1; 5; 3]

 inputs |> Seq.tryFind (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>None</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.ToList``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a list from the given collection.</summary>

 <param name="source">The input sequence.</param>

 <returns>The result list.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="tolist-1">
 <code lang="fsharp">
 let inputs = seq { 1; 2; 5 }

 inputs |> Seq.toList
 </code>
 Evaluates to <c>[ 1; 2; 5 ]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.ToArray``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds an array from the given collection.</summary>

 <param name="source">The input sequence.</param>

 <returns>The result array.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="toarray-1">
 <code lang="fsharp">
 let inputs = seq { 1; 2; 5 }

 inputs |> Seq.toArray
 </code>
 Evaluates to <c>[| 1; 2; 5 |]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.TakeWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a sequence that, when iterated, yields elements of the underlying sequence while the
 given predicate returns True, and then returns no further elements.</summary>

 <param name="predicate">A function that evaluates to false when no more items should be returned.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="takewhile-1">
 <code lang="fsharp">
 let inputs = ["a"; "bb"; "ccc"; "d"]

 inputs |> Seq.takeWhile (fun x -> x.Length &lt; 3)
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { "a"; "bb" }</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Take``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the first N elements of the sequence.</summary>

 <remarks>Throws <c>InvalidOperationException</c>
 if the count exceeds the number of elements in the sequence. <c>Seq.truncate</c>
 returns as many items as the sequence contains instead of throwing an exception.</remarks>

 <param name="count">The number of items to take.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input sequence is empty and the count is greater than zero.</exception>
 <exception cref="T:System.InvalidOperationException">Thrown when count exceeds the number of elements
 in the sequence.</exception>

 <example id="take-1">
 <code lang="fsharp">
 let inputs = ["a"; "b"; "c"; "d"]

 inputs |> Seq.take 2
 </code>
 Evaluates to a sequence yielding the same results as <c>["a"; "b"]</c>
 </example>

 <example id="take-2">
 <code lang="fsharp">
 let inputs = ["a"; "b"; "c"; "d"]

 inputs |> Seq.take 6
 </code>
 Throws <c>InvalidOperationException</c>.
 </example>

 <example id="take-3">
 <code lang="fsharp">
 let inputs = ["a"; "b"; "c"; "d"]

 inputs |> Seq.take 0
 </code>
 Evaluates to a sequence yielding no results.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Tail``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a sequence that skips 1 element of the underlying sequence and then yields the
 remaining elements of the sequence.</summary>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="T:System.InvalidOperationException">Thrown when the input sequence is empty.</exception>

 <example id="tail-1">
 <code lang="fsharp">
 let inputs = ["a"; "bb"; "ccc"]

 inputs |> Seq.tail
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { "bb"; "ccc" }</c>
 </example>

</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.SumBy``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the sum of the results generated by applying the function to each element of the sequence.</summary>

 <remarks>The generated elements are summed using the <c>+</c> operator and <c>Zero</c> property associated with the generated type.</remarks>

 <param name="projection">A function to transform items from the input sequence into the type that will be summed.</param>
 <param name="source">The input sequence.</param>

 <returns>The computed sum.</returns>
 
 <example id="sumby-1">
 <code lang="fsharp">
 let input = [ "aa"; "bbb"; "cc" ]

 input |> Seq.sumBy (fun s -> s.Length)
 </code>
 Evaluates to <c>7</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Sum``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the sum of the elements in the sequence.</summary>

 <remarks>The elements are summed using the <c>+</c> operator and <c>Zero</c> property associated with the generated type.</remarks>

 <param name="source">The input sequence.</param>

 <returns>The computed sum.</returns>
 
 <example id="sum-1">
 <code lang="fsharp">
 let input = [ 1; 5; 3; 2 ]

 input |> Seq.sum
 </code>
 Evaluates to <c>11</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.SortByDescending``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Applies a key-generating function to each element of a sequence and yield a sequence ordered
 descending by keys.  The keys are compared using generic comparison as implemented by <see cref="M:Microsoft.FSharp.Core.Operators.compare"/>.</summary>

 <remarks>This function returns a sequence that digests the whole initial sequence as soon as
 that sequence is iterated. As a result this function should not be used with
 large or infinite sequences. The function makes no assumption on the ordering of the original
 sequence.

 This is a stable sort, that is the original order of equal elements is preserved.</remarks>

 <param name="projection">A function to transform items of the input sequence into comparable keys.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 
 <example id="sortbydescending-1">
 <code lang="fsharp">
 let input = ["a"; "bbb"; "cccc"; "dd"]

 input |> Seq.sortByDescending (fun s -> s.Length)
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { "cccc"; "bbb"; "dd"; "a" }</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.SortDescending``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Yields a sequence ordered descending by keys.</summary>

 <remarks>This function returns a sequence that digests the whole initial sequence as soon as
 that sequence is iterated. As a result this function should not be used with
 large or infinite sequences. The function makes no assumption on the ordering of the original
 sequence.

 This is a stable sort, that is the original order of equal elements is preserved.</remarks>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 
 <example id="sortdescending-1">
 <code lang="fsharp">
 let input = seq { 8; 4; 3; 1; 6; 1 }

 input |> Seq.sortDescending
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 8; 6; 4; 3; 1; 1 }</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.SortBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Applies a key-generating function to each element of a sequence and yield a sequence ordered
 by keys.  The keys are compared using generic comparison as implemented by <see cref="M:Microsoft.FSharp.Core.Operators.compare"/>.</summary>

 <remarks>This function returns a sequence that digests the whole initial sequence as soon as
 that sequence is iterated. As a result this function should not be used with
 large or infinite sequences.

 The function makes no assumption on the ordering of the original
 sequence and uses a stable sort, that is the original order of equal elements is preserved.</remarks>

 <param name="projection">A function to transform items of the input sequence into comparable keys.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 
 <example id="sortby-1">
 <code lang="fsharp">
 let input = [ "a"; "bbb"; "cccc"; "dd" ]

 input |> Seq.sortBy (fun s -> s.Length)
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { "a"; "dd"; "bbb"; "cccc" }</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.SortWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Yields a sequence ordered using the given comparison function.</summary>

 <remarks>This function returns a sequence that digests the whole initial sequence as soon as
 that sequence is iterated. As a result this function should not be used with
 large or infinite sequences.

 The function makes no assumption on the ordering of the original
 sequence and uses a stable sort, that is the original order of equal elements is preserved.</remarks>

 <param name="comparer">The function to compare the collection elements.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <example id="sortwith-1">Sort a sequence of pairs using a comparison function that compares string lengths then index numbers:
 <code lang="fsharp">
 let compareEntries (n1: int, s1: string) (n2: int, s2: string) =
     let c = compare s1.Length s2.Length
     if c &lt;> 0 then c else
     compare n1 n2

 let input = [ (0,"aa"); (1,"bbb"); (2,"cc"); (3,"dd") ]

 input |> Seq.sortWith compareEntries
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { (0, "aa"); (2, "cc"); (3, "dd"); (1, "bbb") }</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Sort``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Yields a sequence ordered by keys.</summary>

 <remarks>This function returns a sequence that digests the whole initial sequence as soon as
 that sequence is iterated. As a result this function should not be used with
 large or infinite sequences.

 The function makes no assumption on the ordering of the original
 sequence and uses a stable sort, that is the original order of equal elements is preserved.</remarks>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 
 <example id="sort-1">
 <code lang="fsharp">
 let input = seq { 8; 4; 3; 1; 6; 1 }

 Seq.sort input
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 1; 1 3; 4; 6; 8 }</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.SkipWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a sequence that, when iterated, skips elements of the underlying sequence while the
 given predicate returns True, and then yields the remaining elements of the sequence.</summary>

 <param name="predicate">A function that evaluates an element of the sequence to a boolean value.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="skipwhile-1">
 <code lang="fsharp">
 let inputs = seq { "a"; "bbb"; "cc"; "d" }

 inputs |> Seq.skipWhile (fun x -> x.Length &lt; 3)
 </code>
 Evaluates a sequence yielding the same results as <c>seq { "bbb"; "cc"; "d" }</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Skip``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a sequence that skips N elements of the underlying sequence and then yields the
 remaining elements of the sequence.</summary>

 <param name="count">The number of items to skip.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="T:System.InvalidOperationException">Thrown when count exceeds the number of elements
 in the sequence.</exception>

 <example id="skip-1">
 <code lang="fsharp">
 let inputs = ["a"; "b"; "c"; "d"]

 inputs |> Seq.skip 2
 </code>
 Evaluates a sequence yielding the same results as <c>seq { "c"; "d" }</c>
 </example>

 <example id="skip-2">
 <code lang="fsharp">
 let inputs = ["a"; "b"; "c"; "d"]

 inputs |> Seq.skip 5
 </code>
 Throws <c>ArgumentException</c>.
 </example>

 <example id="skip-3">
 <code lang="fsharp">
 let inputs = ["a"; "b"; "c"; "d"]

 inputs |> Seq.skip -1
 </code>
 Evaluates a sequence yielding the same results as <c>seq { "a"; "b"; "c"; "d" }</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Singleton``1(``0)">
 <summary>Returns a sequence yielding one item only.</summary>

 <param name="value">The input item.</param>

 <returns>The result sequence of one item.</returns>
 
 <example id="singleton-1">
 <code lang="fsharp">
 Seq.singleton 7
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 7 }</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.ScanBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.IEnumerable{``0},``1)">
 <summary>Like <c>foldBack</c>, but returns the sequence of intermediary and final results.</summary>

 <remarks>This function returns a sequence that digests the whole initial sequence as soon as that
 sequence is iterated. As a result this function should not be used with large or infinite sequences.
 </remarks>

 <param name="folder">A function that updates the state with each element from the sequence.</param>
 <param name="source">The input sequence.</param>
 <param name="state">The initial state.</param>

 <returns>The resulting sequence of computed states.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 
 <example id="scanback-1">Apply a list charges from back to front, and collect the running balances as each is applied:
 <code lang="fsharp">
 type Charge =
     | In of int
     | Out of int

 let inputs = [ In 1; Out 2; In 3 ]

 (inputs, 0) ||> Seq.scanBack (fun charge acc ->
     match charge with
     | In i -> acc + i
     | Out o -> acc - o)
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 2; 1; 3; 0 }</c> by processing each input from back to front. Note <c>0</c> is the intial
 state, <c>3</c> the next state, <c>1</c> the next state, and <c>2</c> the final state, and the states
 are produced from back to front.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Scan``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1,System.Collections.Generic.IEnumerable{``0})">
 <summary>Like fold, but computes on-demand and returns the sequence of intermediary and final results.</summary>

 <param name="folder">A function that updates the state with each element from the sequence.</param>
 <param name="state">The initial state.</param>
 <param name="source">The input sequence.</param>

 <returns>The resulting sequence of computed states.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 
 <example id="scan-1">Apply a list charges and collect the running balances as each is applied:
 <code lang="fsharp">
 type Charge =
     | In of int
     | Out of int

 let inputs = seq { In 1; Out 2; In 3 }

 (0, inputs) ||> Seq.scan (fun acc charge ->
     match charge with
     | In i -> acc + i
     | Out o -> acc - o)
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 0; 1; -1; 2 }</c>. Note <c>0</c> is the intial
 state, <c>1</c> the next state, <c>-1</c> the next state, and <c>2</c> the final state.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Reverse``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a new sequence with the elements in reverse order.</summary>

 <param name="source">The input sequence.</param>

 <returns>The reversed sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <remarks>This function consumes the whole input sequence before yielding the first element of the reversed sequence.</remarks>
 
 <example id="rev-1">
 <code lang="fsharp">
 let input = seq { 0; 1; 2 }

 input |> Seq.rev
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 2; 1; 0 }</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.ReduceBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Applies a function to each element of the sequence, starting from the end, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c>
 then computes <c>f i0 (...(f iN-1 iN))</c>.</summary>

 <param name="reduction">A function that takes in the next-to-last element of the sequence and the
 current accumulated result to produce the next accumulated result.</param>
 <param name="source">The input sequence.</param>

 <returns>The final result of the reductions.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input sequence is empty.</exception>

 <remarks>This function consumes the whole input sequence before returning the result.</remarks>
 
 <example id="reduceback-1">
 <code lang="fsharp">
 let inputs = [1; 3; 4; 2]

 inputs |> Seq.reduceBack (fun a b -> a + b * 10)
 </code>
 Evaluates to <c>2431</c>, by computing <c>1 + (3 + (4 + 2 * 10) * 10) * 10</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Replicate``1(System.Int32,``0)">
 <summary>Creates a sequence by replicating the given initial value.</summary>

 <param name="count">The number of elements to replicate.</param>
 <param name="initial">The value to replicate</param>

 <returns>The generated sequence.</returns>
 
 <example id="replicate-1">
 <code lang="fsharp">
 Seq.replicate 3 "a"
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { "a"; "a"; "a" }</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Applies a function to each element of the sequence, threading an accumulator argument
 through the computation. Begin by applying the function to the first two elements.
 Then feed this result into the function along with the third element and so on.
 Return the final result.</summary>

 <param name="reduction">A function that takes in the current accumulated result and the next
 element of the sequence to produce the next accumulated result.</param>
 <param name="source">The input sequence.</param>

 <returns>The final result of the reduction function.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input sequence is empty.</exception>
 
 <example id="reduce-1">
 <code lang="fsharp">
 let inputs = [1; 3; 4; 2]

 inputs |> Seq.reduce (fun a b -> a * 10 + b)
 </code>
 Evaluates to <c>1342</c>, by computing <c>((1 * 10 + 3) * 10 + 4) * 10 + 2</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.ReadOnly``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a new sequence object that delegates to the given sequence object. This ensures
 the original sequence cannot be rediscovered and mutated by a type cast. For example,
 if given an array the returned sequence will return the elements of the array, but
 you cannot cast the returned sequence object to an array.</summary>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="readonly-1">
 <code lang="fsharp">
 let input = [| 1; 2; 3 |]

 input |> Seq.readonly
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 1; 2; 3 }</c>.
 </example>

 <example id="readonly-2">
 <code lang="fsharp">
 let input = [| 1; 2; 3 |]

 let readonlyView = input |> Seq.readonly

 (readonlyView :?> int[]).[1] &lt;- 4
 </code>
 Throws an <c>InvalidCastException</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Pick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Applies the given function to successive elements, returning the first
 <c>x</c> where the function returns "Some(x)".</summary>

 <param name="chooser">A function to transform each item of the input sequence into an option of the output type.</param>
 <param name="source">The input sequence.</param>

 <returns>The selected element.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when every item of the sequence
 evaluates to <c>None</c> when the given function is applied.</exception>

 <example id="pick-1">
 <code lang="fsharp">
 let input = [1; 2; 3]

 input |> Seq.pick (fun n -> if n % 2 = 0 then Some (string n) else None)
 </code>
 Evaluates to <c>"2"</c>.
 </example>

 <example id="pick-2">
 <code lang="fsharp">
 let input = [1; 2; 3]

 input |> Seq.pick (fun n -> if n > 3 = 0 then Some (string n) else None)
 </code>
 Throws <c>KeyNotFoundException</c>.
 </example>

</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Permute``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a sequence with all elements permuted according to the
 specified permutation.</summary>

 <remarks>This function consumes the whole input sequence before yielding the first element of the result sequence.</remarks>

 <param name="indexMap">The function that maps input indices to output indices.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when indexMap does not produce a valid permutation.</exception>
 
 <example id="permute-1">
 <code lang="fsharp">
 let inputs = [1; 2; 3; 4]

 inputs |> Seq.permute (fun x -> (x + 1) % 4)
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 4; 1; 2; 3 }</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Pairwise``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a sequence of each element in the input sequence and its predecessor, with the
 exception of the first element which is only returned as the predecessor of the second element.</summary>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 
 <example id="pairwise-1">
 <code lang="fsharp">
 let inputs = seq { 1; 2; 3; 4 }

 inputs |> Seq.pairwise
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { (1, 2); (2, 3); (3, 4) }</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Views the given list as a sequence.</summary>

 <param name="source">The input list.</param>

 <returns>The result sequence.</returns>

 <example id="oflist-1">
 <code lang="fsharp">
 let inputs = [ 1; 2; 5 ]

 inputs |> Seq.ofList
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 1; 2; 5 }</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.OfArray``1(``0[])">
 <summary>Views the given array as a sequence.</summary>

 <param name="source">The input array.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="ofarray-1">
 <code lang="fsharp">
 let inputs = [| 1; 2; 5 |]

 inputs |> Seq.ofArray
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 1; 2; 5 }</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Get``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
 <summary>Computes the nth element in the collection.</summary>

 <param name="index">The index of element to retrieve.</param>
 <param name="source">The input sequence.</param>

 <returns>The nth element of the sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the index is negative or the input sequence does not contain enough elements.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.MinBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the lowest of all elements of the sequence, compared via Operators.min on the function result.</summary>

 <param name="projection">A function to transform items from the input sequence into comparable keys.</param>
 <param name="source">The input sequence.</param>

 <returns>The smallest element of the sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input sequence is empty.</exception>

 <example id="minby-1">
 <code lang="fsharp">
 let inputs = [ "aaa"; "b"; "cccc" ]

 inputs |> Seq.minBy (fun s -> s.Length)
 </code>
 Evaluates to <c>"b"</c>
 </example>

 <example id="minby-2">
 <code lang="fsharp">
 let inputs = []

 inputs |> Seq.minBy (fun (s: string) -> s.Length)
 </code>
 Throws <c>System.ArgumentException</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Min``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the lowest of all elements of the sequence, compared via <c>Operators.min</c>.</summary>

 <param name="source">The input sequence.</param>

 <returns>The smallest element of the sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input sequence is empty.</exception>

 <example id="min-1">
 <code lang="fsharp">
 let inputs = [10; 12; 11]

 inputs |> Seq.min
 </code>
 Evaluates to <c>10</c>
 </example>

 <example id="min-2">
 <code lang="fsharp">
 let inputs = []

 inputs |> Seq.min
 </code>
 Throws <c>System.ArgumentException</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.MaxBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the greatest of all elements of the sequence, compared via Operators.max on the function result.</summary>

 <param name="projection">A function to transform items from the input sequence into comparable keys.</param>
 <param name="source">The input sequence.</param>

 <returns>The largest element of the sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input sequence is empty.</exception>

 <example id="maxby-1">
 <code lang="fsharp">
 let inputs = ["aaa"; "b"; "cccc"]

 inputs |> Seq.maxBy (fun s -> s.Length)
 </code>
 Evaluates to <c>"cccc"</c>
 </example>

 <example id="maxby-2">
 <code lang="fsharp">
 let inputs = [ ]

 inputs |> Seq.maxBy (fun s -> s.Length)
 </code>
 Throws <c>System.ArgumentException</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Max``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the greatest of all elements of the sequence, compared via Operators.max</summary>

 <param name="source">The input sequence.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input sequence is empty.</exception>

 <returns>The largest element of the sequence.</returns>

 <example id="max-1">
 <code lang="fsharp">
 let inputs = [ 10; 12; 11 ]

 inputs |> Seq.max
 </code>
 Evaluates to <c>12</c>
 </example>

 <example id="max-2">
 <code lang="fsharp">
 let inputs = [ ]

 inputs |> Seq.max
 </code>
 Throws <c>System.ArgumentException</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.MapIndexed2``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding pairs of elements from the two sequences. If one input sequence is shorter than
 the other then the remaining elements of the longer sequence are ignored. The integer index passed to the
 function indicates the index (from 0) of element being transformed.</summary>

 <param name="mapping">A function to transform pairs of items from the input sequences that also supplies the current index.</param>
 <param name="source1">The first input sequence.</param>
 <param name="source2">The second input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when either of the input sequences is null.</exception>

 <example id="mapi2-1">
 <code lang="fsharp">
 let inputs1 = ["a"; "bad"; "good"]
 let inputs2 = [0; 2; 1]

 (inputs1, inputs2) ||> Seq.mapi2 (fun i x y -> i, x[y])
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { (0, 'a'); (1, 'd'); (2, 'o') }</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The integer index passed to the
 function indicates the index (from 0) of element being transformed.</summary>

 <param name="mapping">A function to transform items from the input sequence that also supplies the current index.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="item-1">
 <code lang="fsharp">
 let inputs = [ 10; 10; 10 ]

 inputs |> Seq.mapi (fun i x -> i + x)
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 10; 11; 12 }</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Map3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding triples of elements from the three sequences. If one input sequence if shorter than
 the others then the remaining elements of the longer sequences are ignored.</summary>

 <param name="mapping">The function to transform triples of elements from the input sequences.</param>
 <param name="source1">The first input sequence.</param>
 <param name="source2">The second input sequence.</param>
 <param name="source3">The third input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when any of the input sequences is null.</exception>

 <example id="item-1">
 <code lang="fsharp">
 let inputs1 = [ "a"; "t"; "ti" ]
 let inputs2 = [ "l"; "h"; "m" ]
 let inputs3 = [ "l"; "e"; "e" ]

 (inputs1, inputs2, inputs3) |||> Seq.map3 (fun x y z -> x + y + z)
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { "all"; "the"; "time" } </c>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.MapFoldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}}},System.Collections.Generic.IEnumerable{``0},``1)">
 <summary>Combines map and foldBack. Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The function is also used to accumulate a final value.</summary>

 <remarks>This function digests the whole initial sequence as soon as it is called. As a result this function should
 not be used with large or infinite sequences.</remarks>

 <param name="mapping">The function to transform elements from the input collection and accumulate the final value.</param>
 <param name="source">The input collection.</param>
 <param name="state">The initial state.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when the input collection is null.</exception>

 <returns>The collection of transformed elements, and the final accumulated value.</returns>

 <example id="mapfold-1">Accumulate the charges from back to front, and double them as well
 <code lang="fsharp">
 type Charge =
     | In of int
     | Out of int

 let inputs = seq { In 1; Out 2; In 3 }

 let newCharges, balance =
     (inputs, 0) ||> Seq.mapFoldBack (fun charge acc ->
         match charge with
         | In i -> In (i*2), acc + i
         | Out o -> Out (o*2), acc - o)
 </code>
 Evaluates <c>newCharges</c> to <c>seq { In 2; Out 4; In 6 }</c> and <c>balance</c> to <c>2</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.MapFold``3(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``2,``1}}},``1,System.Collections.Generic.IEnumerable{``0})">
 <summary>Combines map and fold. Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The function is also used to accumulate a final value.</summary>

 <remarks>This function digests the whole initial sequence as soon as it is called. As a result this function should
 not be used with large or infinite sequences.</remarks>

 <param name="mapping">The function to transform elements from the input collection and accumulate the final value.</param>
 <param name="state">The initial state.</param>
 <param name="source">The input collection.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when the input collection is null.</exception>

 <returns>The collection of transformed elements, and the final accumulated value.</returns>

 <example id="mapfold-1">
 <code lang="fsharp">Accumulate the charges, and double them as well
 type Charge =
     | In of int
     | Out of int

 let inputs = seq { In 1; Out 2; In 3 }

 let newCharges, balance =
     (0, inputs) ||> Seq.mapFold (fun acc charge ->
         match charge with
         | In i -> In (i*2), acc + i
         | Out o -> Out (o*2), acc - o)
 </code>
 Evaluates <c>newCharges</c> to <c>seq { In 2; Out 4; In 6 }</c> and <c>balance</c> to <c>2</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding pairs of elements from the two sequences. If one input sequence is shorter than
 the other then the remaining elements of the longer sequence are ignored.</summary>

 <param name="mapping">A function to transform pairs of items from the input sequences.</param>
 <param name="source1">The first input sequence.</param>
 <param name="source2">The second input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when either of the input sequences is null.</exception>

 <example id="item-1">
 <code lang="fsharp">
 let inputs1 = ["a"; "bad"; "good"]
 let inputs2 = [0; 2; 1]

 (inputs1, inputs2) ||> Seq.map2 (fun x y -> x.[y])
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 'a'; 'd'; 'o' }</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection.  The given function will be applied
 as elements are demanded using the <c>MoveNext</c> method on enumerators retrieved from the
 object.</summary>

 <remarks>The returned sequence may be passed between threads safely. However,
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.</remarks>

 <param name="mapping">A function to transform items from the input sequence.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="item-1">
 <code lang="fsharp">
 let inputs = ["a"; "bbb"; "cc"]

 inputs |> Seq.map (fun x -> x.Length)
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 1; 3; 2 }</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Length``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the length of the sequence</summary>

 <param name="source">The input sequence.</param>

 <returns>The length of the sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="item-1">
 <code lang="fsharp">
 let inputs = ["a"; "b"; "c"]

 inputs |> Seq.length
 </code>
 Evaluates to <c>3</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.IterateIndexed2``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Applies the given function to two collections simultaneously. If one sequence is shorter than
 the other then the remaining elements of the longer sequence are ignored. The integer passed to the
 function indicates the index of element.</summary>

 <param name="action">A function to apply to each pair of elements from the input sequences along with their index.</param>
 <param name="source1">The first input sequence.</param>
 <param name="source2">The second input sequence.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when either of the input sequences is null.</exception>

 <example id="iteri2-1">
 <code lang="fsharp">
 let inputs1 = ["a"; "b"; "c"]
 let inputs2 = ["banana"; "pear"; "apple"]

 (inputs1, inputs2) ||> Seq.iteri2 (fun i s1 s2 -> printfn "Index {i}: {s1} - {s2}")
 </code>
 Evaluates to <c>unit</c> and prints
 <code>
 Index 0: a - banana
 Index 1: b - pear
 Index 2: c - apple
 </code>
 in the console.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Iterate2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Applies the given function to two collections simultaneously. If one sequence is shorter than
 the other then the remaining elements of the longer sequence are ignored.</summary>

 <param name="action">A function to apply to each pair of elements from the input sequences.</param>
 <param name="source1">The first input sequence.</param>
 <param name="source2">The second input sequence.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when either of the input sequences is null.</exception>

 <example id="iter2-1">
 <code lang="fsharp">
 let inputs1 = ["a"; "b"; "c"]
 let inputs2 = [1; 2; 3]

 (inputs1, inputs2) ||> Seq.iter2 (printfn "%s: %i")
 </code>
 Evaluates to <c>unit</c> and prints
 <code>
 a: 1
 b: 2
 c: 3
 </code>
 in the console.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Applies the given function to each element of the collection. The integer passed to the
 function indicates the index of element.</summary>

 <param name="action">A function to apply to each element of the sequence that can also access the current index.</param>
 <param name="source">The input sequence.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="iteri-1">
 <code lang="fsharp">
 let inputs = ["a"; "b"; "c"]

 inputs |> Seq.iteri (fun i v -> printfn "{i}: {v}")

 </code>
 Evaluates to <c>unit</c> and prints
 <code>
 0: a
 1: b
 2: c
 </code>
 in the console.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},System.Collections.Generic.IEnumerable{``0})">
 <summary>Applies the given function to each element of the collection.</summary>

 <param name="action">A function to apply to each element of the sequence.</param>
 <param name="source">The input sequence.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="iter-1">
 <code lang="fsharp">
 ["a"; "b"; "c"] |> Seq.iter (printfn "%s")
 </code>
 Evaluates to <c>unit</c> and prints
 <code>
 a
 b
 c
 </code>
 in the console.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Item``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
 <summary>Computes the element at the specified index in the collection.</summary>

 <param name="index">The index of the element to retrieve.</param>
 <param name="source">The input sequence.</param>

 <returns>The element at the specified index of the sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the index is negative or the input sequence does not contain enough elements.</exception>

 <example id="item-1">
 <code lang="fsharp">
 let inputs = ["a"; "b"; "c"]

 inputs |> Seq.item 1
 </code>
 Evaluates to <c>"b"</c>
 </example>

 <example id="item-2">
 <code lang="fsharp">
 let inputs = ["a"; "b"; "c"]

 inputs |> Seq.item 4
 </code>
 Throws <c>ArgumentException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.InitializeInfinite``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
 <summary>Generates a new sequence which, when iterated, will return successive
 elements by calling the given function.  The results of calling the function
 will not be saved, that is the function will be reapplied as necessary to
 regenerate the elements.  The function is passed the index of the item being
 generated.</summary>

 <remarks>The returned sequence may be passed between threads safely. However,
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
 Iteration can continue up to <c>Int32.MaxValue</c>.</remarks>

 <param name="initializer">A function that generates an item in the sequence from a given index.</param>

 <returns>The result sequence.</returns>

 <example id="init-infinite-1">
 <code lang="fsharp">
 (+) 5 |> Seq.initInfinite
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 5; 6; 7; 8; ... }</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Initialize``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
 <summary>Generates a new sequence which, when iterated, will return successive
 elements by calling the given function, up to the given count.  Each element is saved after its
 initialization.  The function is passed the index of the item being
 generated.</summary>

 <remarks>The returned sequence may be passed between threads safely. However,
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.</remarks>

 <param name="count">The maximum number of items to generate for the sequence.</param>
 <param name="initializer">A function that generates an item in the sequence from a given index.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentException">Thrown when count is negative.</exception>

 <example id="init-1">
 <code lang="fsharp">
 Seq.init 4 (fun v -> v + 5)
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 5; 6; 7; 8 }</c>
 </example>

 <example id="init-2">
 <code lang="fsharp">
 Seq.init -5 (fun v -> v + 5)
 </code>
 Throws <c>ArgumentException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Indexed``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a new collection whose elements are the corresponding elements of the input collection
 paired with the integer index (from 0) of each element.</summary>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="indexed-1">
 <code lang="fsharp">
 ["a"; "b"; "c"] |> Seq.indexed
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { (0, "a"); (1, "b"); (2, "c") }</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.IsEmpty``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns true if the sequence contains no elements, false otherwise.</summary>

 <param name="source">The input sequence.</param>

 <returns>True if the sequence is empty; false otherwise.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="empty-1">
 <code lang="fsharp">
 [] |> Seq.isEmpty
 </code>
 Evaluates to <c>true</c>
 </example>

 <example id="empty-2">
 <code lang="fsharp">
 ["pear"; "banana"] |> Seq.isEmpty
 </code>
 Evaluates to <c>false</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.TryExactlyOne``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the only element of the sequence or <c>None</c> if sequence is empty or contains more than one element.</summary>

 <param name="source">The input sequence.</param>

 <returns>The only element of the sequence or None.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="try-exacly-one-1">
 <code lang="fsharp">
 let inputs = ["banana"]

 inputs |> Seq.tryExactlyOne
 </code>
 Evaluates to <c>Some banana</c>
 </example>

 <example id="try-exacly-one-2">
 <code lang="fsharp">
 let inputs = ["pear"; "banana"]

 inputs |> Seq.tryExactlyOne
 </code>
 Evaluates to <c>None</c>
 </example>

 <example id="try-exacly-one-3">
 <code lang="fsharp">
 [] |> Seq.tryExactlyOne
 </code>
 Evaluates to <c>None</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.ExactlyOne``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the only element of the sequence.</summary>

 <param name="source">The input sequence.</param>

 <returns>The only element of the sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input does not have precisely one element.</exception>

 <example id="exacly-one-1">
 <code lang="fsharp">
 let inputs = ["banana"]

 inputs |> Seq.exactlyOne
 </code>
 Evaluates to <c>banana</c>
 </example>

 <example id="exacly-one-2">
 <code lang="fsharp">
 let inputs = ["pear"; "banana"]

 inputs |> Seq.exactlyOne
 </code>
 Throws <c>ArgumentException</c>
 </example>

 <example id="exacly-one-3">
 <code lang="fsharp">
 [] |> Seq.exactlyOne
 </code>
 Throws <c>ArgumentException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.TryLast``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the last element of the sequence.
 Return <c>None</c> if no such element exists.</summary>

 <param name="source">The input sequence.</param>

 <returns>The last element of the sequence or None.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="try-last-1">
 <code lang="fsharp">
 ["pear"; "banana"] |> Seq.tryLast
 </code>
 Evaluates to <c>Some "banana"</c>
 </example>

 <example id="try-last-2">
 <code lang="fsharp">
 [] |> Seq.tryLast
 </code>
 Evaluates to <c>None</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Last``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the last element of the sequence.</summary>

 <param name="source">The input sequence.</param>

 <returns>The last element of the sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input does not have any elements.</exception>

 <example id="last-1">
 <code lang="fsharp">
 ["pear"; "banana"] |> Seq.last
 </code>
 Evaluates to <c>banana</c>
 </example>

 <example id="last-2">
 <code lang="fsharp">
 [] |> Seq.last
 </code>
 Throws <c>ArgumentException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.TryHead``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the first element of the sequence, or None if the sequence is empty.</summary>

 <param name="source">The input sequence.</param>

 <returns>The first element of the sequence or None.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="try-head-1">
 <code lang="fsharp">
 ["banana"; "pear"] |> Seq.tryHead
 </code>
 Evaluates to <c>Some "banana"</c>
 </example>

 <example id="try-head-2">
 <code lang="fsharp">
 [] |> Seq.tryHead
 </code>
 Evaluates to <c>None</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Head``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the first element of the sequence.</summary>

 <param name="source">The input sequence.</param>

 <returns>The first element of the sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input does not have any elements.</exception>

 <example id="head-1">
 <code lang="fsharp">
 let inputs = ["banana"; "pear"]

 inputs |> Seq.head
 </code>
 Evaluates to <c>banana</c>
 </example>

 <example id="head-2">
 <code lang="fsharp">
 [] |> Seq.head
 </code>
 Throws <c>ArgumentException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.GroupBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Applies a key-generating function to each element of a sequence and yields a sequence of
 unique keys. Each unique key contains a sequence of all elements that match
 to this key.</summary>

 <remarks>This function returns a sequence that digests the whole initial sequence as soon as
 that sequence is iterated. As a result this function should not be used with
 large or infinite sequences. The function makes no assumption on the ordering of the original
 sequence.</remarks>

 <param name="projection">A function that transforms an element of the sequence into a comparable key.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <example id="group-by-1">
 <code lang="fsharp">
 let inputs = [1; 2; 3; 4; 5]

 inputs |> Seq.groupBy (fun n -> n % 2)
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { (1, seq { 1; 3; 5 }); (0, seq { 2; 4 }) }</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.ForAll2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Tests the all pairs of elements drawn from the two sequences satisfy the
 given predicate. If one sequence is shorter than
 the other then the remaining elements of the longer sequence are ignored.</summary>

 <param name="predicate">A function to test pairs of elements from the input sequences.</param>
 <param name="source1">The first input sequence.</param>
 <param name="source2">The second input sequence.</param>

 <returns>True if all pairs satisfy the predicate; false otherwise.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when either of the input sequences is null.</exception>

 <example id="forall2-1">
 <code lang="fsharp">
 let inputs1 = [1; 2; 3; 4; 5; 6]
 let inputs2 = [1; 2; 3; 4; 5]

 (inputs1, inputs2)  ||> Seq.forall2 (=)
 </code>
 Evaluates to <c>true</c>.
 </example>

 <example id="forall2-2">
 <code lang="fsharp">
 let items1 = [2017; 1; 1]
 let items2 = [2019; 19; 8]

 (items1, items2) ||> Seq.forall2 (=)
 </code>
 Evaluates to <c>false</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.ForAll``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Tests if all elements of the sequence satisfy the given predicate.</summary>

 <remarks>The predicate is applied to the elements of the input sequence. If any application
 returns false then the overall result is false and no further elements are tested.
 Otherwise, true is returned.</remarks>

 <param name="predicate">A function to test an element of the input sequence.</param>
 <param name="source">The input sequence.</param>

 <returns>True if every element of the sequence satisfies the predicate; false otherwise.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="forall-1">
 <code lang="fsharp">
 let isEven a = a % 2 = 0

 [2; 42] |> Seq.forall isEven // evaluates to true

 [1; 2] |> Seq.forall isEven // evaluates to false
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.FoldBack2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},``2)">
 <summary>Applies a function to corresponding elements of two collections, starting from the end of the shorter collection,
 threading an accumulator argument through the computation. The two sequences need not have equal lengths.
 If the input function is <c>f</c> and the elements are <c>i0...iN</c> and <c>j0...jM</c>, N &lt; M
 then computes <c>f i0 j0 (... (f iN jN s)...)</c>.</summary>

 <param name="folder">The function to update the state given the input elements.</param>
 <param name="source1">The first input sequence.</param>
 <param name="source2">The second input sequence.</param>
 <param name="state">The initial state.</param>

 <returns>The final state value.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the either of the input sequences is null.</exception>

 <remarks>
 This function consumes the whole of both inputs sequences before returning the result. As a
 result this function should not be used with large or infinite sequences.
 </remarks>

 <example id="foldback2-1">
 <code lang="fsharp">
 type Count =
   { Positive: int
     Negative: int
     Text: string }

 let inputs1 = [-1; -2; -3]
 let inputs2 = [3; 2; 1; 0]
 let initialState = {Positive = 0; Negative = 0; Text = ""}

 (inputs1, inputs2, initialState) |||> Seq.foldBack2 (fun a b acc  ->
     let text = acc.Text + "(" + string a + "," + string b + ") "
     if a + b >= 0 then
         { acc with
             Positive = acc.Positive + 1
             Text = text }
     else
         { acc with
             Negative = acc.Negative + 1
             Text = text }
 )
 </code>
 Evaluates to
 <code>
 { Positive = 2
   Negative = 1
   Text = " (-3,1) (-2,2) (-1,3)" }
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.IEnumerable{``0},``1)">
 <summary>Applies a function to each element of the collection, starting from the end, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c>
 then computes <c>f i0 (... (f iN s)...)</c></summary>

 <param name="folder">The function to update the state given the input elements.</param>
 <param name="source">The input sequence.</param>
 <param name="state">The initial state.</param>

 <returns>The state object after the folding function is applied to each element of the sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <remarks>This function consumes the whole input sequence before returning the result.</remarks>

 <example id="foldback-1">
 <code lang="fsharp">
 type Count =
   { Positive: int
     Negative: int
     Text: string }

 let sequence = [1; 0; -1; -2; 3]
 let initialState = {Positive = 0; Negative = 0; Text = ""}

 (sequence, initialState) ||> Seq.foldBack (fun a acc  ->
     let text = acc.Text + " " + string a
     if a >= 0 then
         { acc with
             Positive = acc.Positive + 1
             Text = text }
     else
         { acc with
             Negative = acc.Negative + 1
             Text = text })
 </code>
 Evaluates to
 <code>
 { Positive = 2
   Negative = 3
   Text = " 3 -2 -1 0 1" }
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Fold2``3(Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},``2,System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Applies a function to corresponding elements of two collections, threading an accumulator argument
 through the computation.</summary>

 <remarks> The two sequences need not have equal lengths:
 when one sequence is exhausted any remaining elements in the other sequence are ignored.
 If the input function is <c>f</c> and the elements are <c>i0...iN</c> and <c>j0...jN</c>
 then computes <c>f (... (f s i0 j0)...) iN jN</c>.</remarks>

 <param name="folder">The function to update the state given the input elements.</param>
 <param name="state">The initial state.</param>
 <param name="source1">The first input sequence.</param>
 <param name="source2">The second input sequence.</param>

 <returns>The final state value.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the either of the input sequences is null.</exception>

 <example id="fold2-1">
 <code lang="fsharp">
 type CoinToss = Head | Tails

 let data1 = [Tails; Head; Tails]
 let data2 = [Tails; Head; Head]

 (0, data1, data2) |||> Seq.fold2 (fun acc a b ->
     match (a, b) with
     | Head, Head -> acc + 1
     | Tails, Tails -> acc + 1
     | _ -> acc - 1)
 </code>
 Evaluates to <c>1</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1,System.Collections.Generic.IEnumerable{``0})">
 <summary>Applies a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c>
 then computes <c>f (... (f s i0)...) iN</c></summary>

 <param name="folder">A function that updates the state with each element from the sequence.</param>
 <param name="state">The initial state.</param>
 <param name="source">The input sequence.</param>

 <returns>The state object after the folding function is applied to each element of the sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="fold-1">
 <code lang="fsharp">
 type Charge =
     | In of int
     | Out of int

 let inputs = [In 1; Out 2; In 3]

 (0, inputs) ||> Seq.fold (fun acc charge ->
     match charge with
     | In i -> acc + i
     | Out o -> acc - o)
 </code>
 Evaluates to <c>2</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.FindIndexBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the index of the last element for which the given function returns True.</summary>

 <remarks>This function digests the whole initial sequence as soon as it is called. As a
 result this function should not be used with large or infinite sequences.</remarks>

 <param name="predicate">A function to test whether the index of a particular element should be returned.</param>
 <param name="source">The input sequence.</param>

 <returns>The index of the last element for which the predicate returns True.</returns>

 <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if no element returns true when
 evaluated by the predicate</exception>
 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null</exception>

 <example id="find-index-1">
 <code lang="fsharp">
 let input = [1; 2; 3; 4; 5]

 input |> Seq.findIndex (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>3</c>
 </example>

 <example id="find-index-back-2">
 <code lang="fsharp">
 let input = [1; 2; 3; 4; 5]

 input |> Seq.findIndex (fun elm -> elm % 6 = 0)
 </code>
 Throws <c>KeyNotFoundException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.FindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the index of the first element for which the given function returns True.</summary>

 <param name="predicate">A function to test whether the index of a particular element should be returned.</param>
 <param name="source">The input sequence.</param>

 <returns>The index of the first element for which the predicate returns True.</returns>

 <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if no element returns true when
 evaluated by the predicate</exception>
 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null</exception>

 <example id="find-index-1">
 <code lang="fsharp">
 let inputs = [1; 2; 3; 4; 5]

 inputs |> Seq.findIndex (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>1</c>
 </example>

 <example id="find-index-2">
 <code lang="fsharp">
 let inputs = [1; 2; 3; 4; 5]
 inputs |> Seq.findIndex (fun elm -> elm % 6 = 0)
 </code>
 Throws <c>KeyNotFoundException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.FindBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the last element for which the given function returns True.</summary>

 <remarks>This function digests the whole initial sequence as soon as it is called. As a
 result this function should not be used with large or infinite sequences.</remarks>

 <param name="predicate">A function to test whether an item in the sequence should be returned.</param>
 <param name="source">The input sequence.</param>

 <returns>The last element for which the predicate returns True.</returns>

 <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if no element returns true when
 evaluated by the predicate</exception>
 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null</exception>

 <example id="find-back-1">
 <code lang="fsharp">
 let inputs = [2; 3; 4]

 inputs |> Seq.findBack (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>4</c>
 </example>

 <example id="find-back-2">
 <code lang="fsharp">
 let inputs = [2; 3; 4]

 inputs |> Seq.findBack (fun elm -> elm % 6 = 0)
 </code>
 Throws <c>KeyNotFoundException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Find``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the first element for which the given function returns True.</summary>

 <param name="predicate">A function to test whether an item in the sequence should be returned.</param>
 <param name="source">The input sequence.</param>

 <returns>The first element for which the predicate returns True.</returns>

 <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if no element returns true when
 evaluated by the predicate</exception>
 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null</exception>

 <example id="find-1">
 <code lang="fsharp">
 let inputs = [1; 2; 3]

 inputs |> Seq.find (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>2</c>
 </example>

 <example id="find-2">
 <code lang="fsharp">
 let inputs = [1; 2; 3]

 inputs |> Seq.find (fun elm -> elm % 6 = 0)
 </code>
 Throws <c>KeyNotFoundException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Where``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a new collection containing only the elements of the collection
 for which the given predicate returns "true".</summary>

 <remarks>The returned sequence may be passed between threads safely. However,
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.

 Remember sequence is lazy, effects are delayed until it is enumerated.

 A synonym for Seq.filter.</remarks>

 <param name="predicate">A function to test whether each item in the input sequence should be included in the output.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="where-1">
 <code lang="fsharp">
 [1; 2; 3; 4] |> Seq.where (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 2; 4 }</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a new collection containing only the elements of the collection
 for which the given predicate returns "true". This is a synonym for Seq.where.</summary>

 <remarks>The returned sequence may be passed between threads safely. However,
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.

 Remember sequence is lazy, effects are delayed until it is enumerated.</remarks>

 <param name="predicate">A function to test whether each item in the input sequence should be included in the output.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="filter-1">
 <code lang="fsharp">
 let inputs = [1; 2; 3; 4]

 inputs |> Seq.filter (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 2; 4 }</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Exists2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Tests if any pair of corresponding elements of the input sequences satisfies the given predicate.</summary>

 <remarks>The predicate is applied to matching elements in the two sequences up to the lesser of the
 two lengths of the collections. If any application returns true then the overall result is
 true and no further elements are tested. Otherwise, false is returned. If one sequence is shorter than
 the other then the remaining elements of the longer sequence are ignored.</remarks>

 <param name="predicate">A function to test each pair of items from the input sequences.</param>
 <param name="source1">The first input sequence.</param>
 <param name="source2">The second input sequence.</param>

 <returns>True if any result from the predicate is true; false otherwise.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when either of the two input sequences is null.</exception>

 <example id="exists2-1">
 <code lang="fsharp">
 let inputs1 = [1; 2]
 let inputs2 = [1; 2; 0]

 (inputs1, inputs2) ||> Seq.exists2 (fun a b -> a > b)
 </code>
 Evaluates to <c>false</c>
 </example>

 <example id="exists2-2">
 <code lang="fsharp">
 let inputs1 = [1; 4]
 let inputs2 = [1; 3; 5]

 (inputs1, inputs2) ||> Seq.exists2 (fun a b -> a > b)
 </code>
 Evaluates to <c>true</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>Tests if any element of the sequence satisfies the given predicate.</summary>

 <remarks>The predicate is applied to the elements of the input sequence. If any application
 returns true then the overall result is true and no further elements are tested.
 Otherwise, false is returned.</remarks>

 <param name="predicate">A function to test each item of the input sequence.</param>
 <param name="source">The input sequence.</param>

 <returns>True if any result from the predicate is true; false otherwise.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="exists-1">
 <code lang="fsharp">
 let input = [1; 2; 3; 4; 5]

 input |> Seq.exists (fun elm -> elm % 4 = 0)
 </code>
 Evaluates to <c>true</c>
 </example>

 <example id="exists-2">
 <code lang="fsharp">
 let input = [1; 2; 3; 4; 5]

 input |> Seq.exists (fun elm -> elm % 6 = 0)
 </code>
 Evaluates to <c>false</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a new sequence with the distinct elements of the second sequence which do not appear in the first sequence,
 using generic hash and equality comparisons to compare values.</summary>

 <remarks>Note that this function returns a sequence that digests the whole of the first input sequence as soon as
 the result sequence is iterated. As a result this function should not be used with
 large or infinite sequences in the first parameter. The function makes no assumption on the ordering of the first input
 sequence.</remarks>

 <param name="itemsToExclude">A sequence whose elements that also occur in the second sequence will cause those elements to be
 removed from the returned sequence.</param>
 <param name="source">A sequence whose elements that are not also in first will be returned.</param>

 <returns>A sequence that contains the set difference of the elements of two sequences.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when either of the two input sequences is null.</exception>

 <example id="except-1">
 <code lang="fsharp">
 let original = [1; 2; 3; 4; 5]
 let itemsToExclude = [1; 3; 5]

 original |> Seq.except itemsToExclude
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 2; 4 }</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Empty``1">
 <summary>Creates an empty sequence.</summary>

 <returns>An empty sequence.</returns>

 <example id="empty">
 <code lang="fsharp">
 Seq.empty // Evaluates to seq { }
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.SplitInto``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
 <summary>Splits the input sequence into at most <c>count</c> chunks.</summary>

 <remarks>This function returns a sequence that digests the whole initial sequence as soon as that
 sequence is iterated. As a result this function should not be used with large or infinite sequences.</remarks>

 <param name="count">The maximum number of chunks.</param>
 <param name="source">The input sequence.</param>

 <returns>The sequence split into chunks.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when <c>count</c> is not positive.</exception>

 <remarks>This function consumes the whole input sequence before yielding the first element of the result sequence.</remarks>

 <example id="split-into-1">
 <code lang="fsharp">
 let inputs = [1; 2; 3; 4; 5]

 inputs |> Seq.splitInto 3
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { [|1; 2|]; [|3; 4|]; [|5|] }</c>
 </example>

 <example id="split-into-2">
 <code lang="fsharp">
 let inputs = [1; 2; 3; 4; 5]

 inputs |> Seq.splitInto -1
 </code>
 Throws <c>ArgumentException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.DistinctBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a sequence that contains no duplicate entries according to the
 generic hash and equality comparisons on the keys returned by the given key-generating function.
 If an element occurs multiple times in the sequence then the later occurrences are discarded.</summary>

 <param name="projection">A function transforming the sequence items into comparable keys.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="distinct-by-1">
 <code lang="fsharp">
 let inputs = [{Bar = 1 };{Bar = 1}; {Bar = 2}; {Bar = 3}]

 inputs |> Seq.distinctBy (fun foo -> foo.Bar)
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { { Bar = 1 }; { Bar = 2 }; { Bar = 3 } }</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Distinct``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a sequence that contains no duplicate entries according to generic hash and
 equality comparisons on the entries.
 If an element occurs multiple times in the sequence then the later occurrences are discarded.</summary>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="distinct-1">
 <code lang="fsharp">
 [1; 1; 2; 3] |> Seq.distinct
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 1; 2; 3 }</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Delay``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Collections.Generic.IEnumerable{``0}})">
 <summary>Returns a sequence that is built from the given delayed specification of a
 sequence.</summary>

 <remarks>The input function is evaluated each time an IEnumerator for the sequence
 is requested.</remarks>

 <param name="generator">The generating function for the sequence.</param>
 <returns>The result sequence.</returns>

 <example id="delay-1">
 <code lang="fsharp">
 Seq.delay (fun () -> Seq.ofList [1; 2; 3])
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 1; 2; 3 }</c>, executing
 the generator function every time is consumed.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.CountBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Applies a key-generating function to each element of a sequence and returns a sequence yielding unique
 keys and their number of occurrences in the original sequence.</summary>

 <remarks>Note that this function returns a sequence that digests the whole initial sequence as soon as
 that sequence is iterated. As a result this function should not be used with
 large or infinite sequences. The function makes no assumption on the ordering of the original
 sequence.</remarks>

 <param name="projection">A function transforming each item of the input sequence into a key to be
 compared against the others.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="count-by-1">
 <code lang="fsharp">
 type Foo = { Bar: string }

 let inputs = [{Bar = "a"}; {Bar = "b"}; {Bar = "a"}]

 inputs |> Seq.countBy (fun foo -> foo.Bar)
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { ("a", 2); ("b", 1) }</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Contains``1(``0,System.Collections.Generic.IEnumerable{``0})">
 <summary>Tests if the sequence contains the specified element.</summary>

 <param name="value">The value to locate in the input sequence.</param>
 <param name="source">The input sequence.</param>

 <returns>True if the input sequence contains the specified element; false otherwise.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="contains-1">
 <code lang="fsharp">
 [1; 2] |> Seq.contains 2 // evaluates to true
 [1; 2] |> Seq.contains 5 // evaluates to false
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Concat``2(System.Collections.Generic.IEnumerable{``0})">
 <summary>Combines the given enumeration-of-enumerations as a single concatenated
 enumeration.</summary>

 <remarks>The returned sequence may be passed between threads safely. However,
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.</remarks>

 <param name="sources">The input enumeration-of-enumerations.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="concat-1">
 <code lang="fsharp">
 let inputs = [[1; 2]; [3]; [4; 5]]

 inputs |> Seq.concat
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 1; 2; 3; 4; 5 }</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.CompareWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
 <summary>Compares two sequences using the given comparison function, element by element.</summary>

 <param name="comparer">A function that takes an element from each sequence and returns an int.
 If it evaluates to a non-zero value iteration is stopped and that value is returned.</param>
 <param name="source1">The first input sequence.</param>
 <param name="source2">The second input sequence.</param>

 <returns>Returns the first non-zero result from the comparison function.  If the end of a sequence
 is reached it returns a -1 if the first sequence is shorter and a 1 if the second sequence
 is shorter.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when either of the input sequences
 is null.</exception>

 <example id="compare-with-1">
 <code lang="fsharp">
 let closerToNextDozen a b =
   (a % 12).CompareTo(b % 12)

 let input1 = [1; 10]
 let input2 = [1; 10]

 (input1, input2) ||> Seq.compareWith closerToNextDozen
 </code>
 Evaluates to <c>0</c>
 </example>

 <example id="compare-with-2">
 <code lang="fsharp">
 let closerToNextDozen a b =
   (a % 12).CompareTo(b % 12)

 let input1 = [1; 5]
 let input2 = [1; 8]

 (input1, input2) ||> Seq.compareWith closerToNextDozen
 </code>
 Evaluates to <c>-1</c>
 </example>

 <example id="compare-with-3">
 <code lang="fsharp">
 let closerToNextDozen a b =
   (a % 12).CompareTo(b % 12)

 let input1 = [1; 11]
 let input2 = [1; 13]

 (input1, input2) ||> Seq.compareWith closerToNextDozen
 </code>
 Evaluates to <c>1</c>
 </example>

 <example id="compare-with-4">
 <code lang="fsharp">
 let closerToNextDozen a b =
   (a % 12).CompareTo(b % 12)

 let input1 = [1; 2]
 let input2 = [1]

 (input1, input2) ||> Seq.compareWith closerToNextDozen
 </code>
 Evaluates to <c>1</c>
 </example>

 <example id="compare-with-5">
 <code lang="fsharp">
 let closerToNextDozen a b =
   (a % 12).CompareTo(b % 12)

 let input1 = [1]
 let input2 = [1; 2]

 (input1, input2) ||> Seq.compareWith closerToNextDozen
 </code>
 Evaluates to <c>-1</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Collect``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Applies the given function to each element of the sequence and concatenates all the
 results.</summary>

 <remarks>Remember sequence is lazy, effects are delayed until it is enumerated.</remarks>

 <param name="mapping">A function to transform elements of the input sequence into the sequences
 that will then be concatenated.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="collect-1">
 <code lang="fsharp">
 type Foo = { Bar: int seq }

 let input = seq { {Bar = [1; 2]}; {Bar = [3; 4]} }

 input |> Seq.collect (fun foo -> foo.Bar)
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 1; 2; 3; 4 }</c>
 </example>

 <example id="collect-2">
 <code lang="fsharp">
 let input = [[1; 2]; [3; 4]]

 input |> Seq.collect id
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 1; 2; 3; 4 }</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.ChunkBySize``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
 <summary>Divides the input sequence into chunks of size at most <c>chunkSize</c>.</summary>

 <param name="chunkSize">The maximum size of each chunk.</param>
 <param name="source">The input sequence.</param>

 <returns>The sequence divided into chunks.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when <c>chunkSize</c> is not positive.</exception>

 <example id="chunk-by-size-1">
 <code lang="fsharp">
 [1; 2; 3] |> Seq.chunkBySize 2
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { [|1; 2|]; [|3|] }</c>
 </example>

 <example id="chunk-by-size-2">
 <code lang="fsharp">
 [1; 2; 3] |> Seq.chunkBySize -2
 </code>
 Throws <c>ArgumentException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Applies the given function to each element of the sequence. Returns
 a sequence comprised of the results "x" for each element where
 the function returns Some(x).</summary>

 <remarks>The returned sequence may be passed between threads safely. However,
 individual IEnumerator values generated from the returned sequence should not
 be accessed concurrently.</remarks>

 <param name="chooser">A function to transform items of type T into options of type U.</param>
 <param name="source">The input sequence of type T.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="choose-1">
 <code lang="fsharp">
 [Some 1; None; Some 2] |> Seq.choose id
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 1; 2 }</c>
 </example>

 <example id="choose-2">
 <code lang="fsharp">
 [1; 2; 3] |> Seq.choose (fun n -> if n % 2 = 0 then Some n else None)
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 2 }</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Cast``1(System.Collections.IEnumerable)">
 <summary>Wraps a loosely-typed System.Collections sequence as a typed sequence.</summary>

 <remarks>The use of this function usually requires a type annotation.
 An incorrect type annotation may result in runtime type
 errors.
 Individual IEnumerator values generated from the returned sequence should not be accessed concurrently.</remarks>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="cast-1">
 <code lang="fsharp">
 [box 1; box 2; box 3] |> Seq.cast&lt;int&gt;
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 1; 2; 3 }</c>, explicitly typed as <c>seq&lt;int&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Cache``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a sequence that corresponds to a cached version of the input sequence.</summary>

 <remarks>
 The result sequence will have the same elements as the input sequence. The result
 can be enumerated multiple times. The input sequence will be enumerated at most
 once and only as far as is necessary.  Caching a sequence is typically useful when repeatedly
 evaluating items in the original sequence is computationally expensive or if
 iterating the sequence causes side-effects that the user does not want to be
 repeated multiple times.

 Enumeration of the result sequence is thread safe in the sense that multiple independent IEnumerator
 values may be used simultaneously from different threads (accesses to
 the internal lookaside table are thread safe). Each individual IEnumerator
 is not typically thread safe and should not be accessed concurrently.

 Once enumeration of the input sequence has started,
 it's enumerator will be kept live by this object until the enumeration has completed.
 At that point, the enumerator will be disposed.

 The enumerator may be disposed and underlying cache storage released by
 converting the returned sequence object to type IDisposable, and calling the Dispose method
 on this object. The sequence object may then be re-enumerated and a fresh enumerator will
 be used.</remarks>

 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="cache-1">
 <code lang="fsharp">
 let fibSeq =(0, 1) |> Seq.unfold (fun (a,b) -> Some(a + b, (b, a + b)))

 let fibSeq3 = fibSeq |> Seq.take 3 |> Seq.cache
 fibSeq3
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 1; 2; 3 }</c>,
 and it will not do the calculation again when called.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.AverageBy``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the average of the results generated by applying the function to each element
 of the sequence.</summary>

 <remarks>The elements are averaged using the <c>+</c> operator, <c>DivideByInt</c> method and <c>Zero</c> property
 associated with the generated type.</remarks>

 <param name="projection">A function applied to transform each element of the sequence.</param>
 <param name="source">The input sequence.</param>

 <returns>The average.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input sequence has zero elements.</exception>

 <example id="average-by-1">
 <code lang="fsharp">
 type Foo = { Bar: float }

 let input = seq { {Bar = 2.0}; {Bar = 4.0} }

 input |> Seq.averageBy (fun foo -> foo.Bar)
 </code>
 Evaluates to <c>3.0</c>
 </example>

 <example id="average-by-2">
 <code lang="fsharp">
 type Foo = { Bar: float }

 Seq.empty |> Seq.averageBy (fun (foo: Foo) -> foo.Bar)
 </code>
 Throws <c>ArgumentException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Average``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns the average of the elements in the sequence.</summary>

 <remarks>The elements are averaged using the <c>+</c> operator, <c>DivideByInt</c> method and <c>Zero</c> property
 associated with the element type.</remarks>

 <param name="source">The input sequence.</param>

 <returns>The average.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input sequence has zero elements.</exception>

 <example id="average-1">
 <code lang="fsharp">
 [1.0; 2.0; 3.0] |> Seq.average
 </code>
 Evaluates to <c>2.0</c>
 </example>

 <example id="average-2">
 <code lang="fsharp">
 [] |> Seq.average
 </code>
 Throws <c>ArgumentException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Append``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
 <summary>Wraps the two given enumerations as a single concatenated
 enumeration.</summary>

 <remarks>The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed
 concurrently.</remarks>

 <param name="source1">The first sequence.</param>
 <param name="source2">The second sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when either of the two provided sequences is
 null.</exception>

 <example id="append-1">
 <code lang="fsharp">
 Seq.append [1; 2] [3; 4]
 </code>
 Evaluates to a sequence yielding the same results as <c>seq { 1; 2; 3; 4 }</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.AllPairs``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Returns a new sequence that contains all pairings of elements from the first and second sequences.</summary>

 <param name="source1">The first sequence.</param>
 <param name="source2">The second sequence.</param>

 <returns>The result sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when either of the input sequences is null.</exception>

 <example id="all-pairs-1">
 <code lang="fsharp">
 ([1; 2], [3; 4]) ||> Seq.allPairs
 </code>
 Evaluates to a sequence yielding the same results as
 <code>
 seq { (1, 3); (1, 4); (2, 3); (2, 4) }
 </code>
 </example>
</member>
<member name="T:Microsoft.FSharp.Collections.SeqModule">
 <summary>Contains operations for working with values of type <see cref="T:Microsoft.FSharp.Collections.seq`1"/>.</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.InsertManyAt``1(System.Int32,System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Return a new list with new items inserted before the given index.</summary>

 <param name="index">The index where the items should be inserted.</param>
 <param name="values">The values to insert.</param>
 <param name="source">The input list.</param>
 
 <returns>The result list.</returns>

 <exception cref="T:System.ArgumentException">Thrown when index is below 0 or greater than source.Length.</exception>

 <example id="insertManyAt-1">
 <code lang="fsharp">
 let inputs = [ 0; 1; 2 ]

 inputs |> List.insertManyAt 1 [ 8; 9 ]
 Evaluates to <c>[ 0; 8; 9; 1; 2 ]</c>.
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.InsertAt``1(System.Int32,``0,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Return a new list with a new item inserted before the given index.</summary>

 <param name="index">The index where the item should be inserted.</param>
 <param name="value">The value to insert.</param>
 <param name="source">The input list.</param>
 
 <returns>The result list.</returns>

 <exception cref="T:System.ArgumentException">Thrown when index is below 0 or greater than source.Length.</exception>

 <example id="insertAt-1">
 <code lang="fsharp">
 let inputs = [ 0; 1; 2 ]

 inputs |> List.insertAt 1 9
 </code>
 Evaluates to <c>[ 0; 9; 1; 2 ]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.UpdateAt``1(System.Int32,``0,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Return a new list with the item at a given index set to the new value.</summary>

 <param name="index">The index of the item to be replaced.</param>
 <param name="value">The new value.</param>
 <param name="source">The input list.</param>

 <returns>The result list.</returns>

 <exception cref="T:System.ArgumentException">Thrown when index is outside 0..source.Length - 1</exception>

 <example id="updateAt-1">
 <code lang="fsharp">
 let inputs = [ 0; 1; 2 ]

 inputs |> List.updateAt 1 9
 </code>
 Evaluates to <c>[ 0; 9; 2 ]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.RemoveManyAt``1(System.Int32,System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Return a new list with the number of items starting at a given index removed.</summary>

 <param name="index">The index of the item to be removed.</param>
 <param name="count">The number of items to remove.</param>
 <param name="source">The input list.</param>

 <returns>The result list.</returns>

 <exception cref="T:System.ArgumentException">Thrown when index is outside 0..source.Length - count</exception>

 <example id="removeManyAt-1">
 <code lang="fsharp">
 let inputs = [ 0; 1; 2; 3 ]

 inputs |> List.removeManyAt 1 2
 </code>
 Evaluates to <c>[ 0; 3 ]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.RemoveAt``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Return a new list with the item at a given index removed.</summary>

 <param name="index">The index of the item to be removed.</param>
 <param name="source">The input list.</param>

 <returns>The result list.</returns>

 <exception cref="T:System.ArgumentException">Thrown when index is outside 0..source.Length - 1</exception>

 <example id="removeAt-1">
 <code lang="fsharp">
 let inputs = [ 0; 1; 2 ]

 inputs |> List.removeAt 1
 </code>
 let inputs = [ 0; 2 ]
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Zip3``3(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``2})">
 <summary>Combines the three lists into a list of triples. The lists must have equal lengths.</summary>

 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>
 <param name="list3">The third input list.</param>

 <returns>A single list containing triples of matching elements from the input lists.</returns>

 <example id="zip3-1">
 <code lang="fsharp">
 let numbers = [1; 2]
 let names = ["one"; "two"]
 let roman = ["I"; "II"]

 Array.zip3 numbers names roman
 </code>
 Evaluates to <c>[(1, "one", "I"); (2, "two", "II")]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Zip``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Combines the two lists into a list of pairs. The two lists must have equal lengths.</summary>

 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>

 <returns>A single list containing pairs of matching elements from the input lists.</returns>

 <example id="zip-1">
 <code lang="fsharp">
 let numbers = [1; 2]
 let names = ["one"; "two"]

 List.zip numbers names
 </code>
 Evaluates to <c>[(1, "one"); (2, "two")]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Windowed``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns a list of sliding windows containing elements drawn from the input
 list. Each window is returned as a fresh list.</summary>

 <param name="windowSize">The number of elements in each window.</param>
 <param name="list">The input list.</param>

 <returns>The result list.</returns>

 <exception cref="T:System.ArgumentException">Thrown when windowSize is not positive.</exception>
 
 <example id="windowed-1">
 <code lang="fsharp">
 let inputs = [1; 2; 3; 4; 5]

 inputs |> List.windowed 3
 </code>
 Evaluates to <c>[[1; 2; 3]; [2; 3; 4]; [3; 4; 5]]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Where``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns a new list containing only the elements of the list
 for which the given predicate returns "true"</summary>

 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>

 <returns>A list containing only the elements that satisfy the predicate.</returns>

 <remarks>This is identical to <c>List.filter</c>.</remarks>

 <example id="where-1">Select only the even numbers:
 <code lang="fsharp">
 let inputs = [1; 2; 3; 4]

 inputs |> List.where (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>[2; 4]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Unzip3``3(Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1,``2}})">
 <summary>Splits a list of triples into three lists.</summary>

 <param name="list">The input list.</param>

 <returns>Three lists of split elements.</returns>
 
 <example id="unzip3-1">
 <code lang="fsharp">
 let inputs = [(1, "one", "I"); (2, "two", "II")]

 let numbers, names, roman = inputs |> List.unzip3
 </code>
 Evaluates <c>numbers</c> to <c>[1; 2]</c>, <c>names</c> to <c>["one"; "two"]</c> and <c>roman</c> to <c>["I"; "II"]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Unzip``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
 <summary>Splits a list of pairs into two lists.</summary>

 <param name="list">The input list.</param>

 <returns>Two lists of split elements.</returns>

 <example id="unzip-1">
 <code lang="fsharp">
 let inputs = [(1, "one"); (2, "two")]

 let numbers, names = inputs |> List.unzip
 </code>
 Evaluates <c>numbers</c> to <c>[1; 2]</c> and <c>names</c> to <c>["one"; "two"]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Unfold``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``0,``1}}},``1)">
 <summary>Returns a list that contains the elements generated by the given computation.
 The generator is repeatedly called to build the list until it returns `None`.
 The given initial <c>state</c> argument is passed to the element generator. </summary>

 <param name="generator">A function that takes in the current state and returns an option tuple of the next
 element of the list and the next state value.</param>
 <param name="state">The initial state value.</param>

 <returns>The result list.</returns>

 <example id="unfold-1">
 <code lang="fsharp">
 1 |> List.unfold (fun state -> if state > 100 then None else Some (state, state * 2))
 </code>
 Evaluates to <c>[1; 2; 4; 8; 16; 32; 64]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.TryFindIndexBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the index of the last element in the list
 that satisfies the given predicate.
 Return <c>None</c> if no such element exists.</summary>

 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>

 <returns>The index of the last element for which the predicate returns true, or None if
 every element evaluates to false.</returns>

 <example id="tryfindindexback-1">Try to find the index of the first even number from the back:
 <code lang="fsharp">
 let inputs = [1; 2; 3; 4; 5]

 inputs |> List.tryFindIndexBack (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>Some 3</c>
 </example>

 <example id="tryfindindexback-2">Try to find the index of the first even number from the back:
 <code lang="fsharp">
 let inputs = [1; 3; 5; 7]

 inputs |> List.tryFindIndexBack (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>None</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.TryItem``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Tries to find the nth element in the list.
 Returns <c>None</c> if index is negative or the list does not contain enough elements.</summary>

 <param name="index">The index to retrieve.</param>
 <param name="list">The input list.</param>

 <returns>The value at the given index or <c>None</c>.</returns>

 <example id="tryitem-1">
 <code lang="fsharp">
 let inputs = ["a"; "b"; "c"]

 inputs |> List.tryItem 1
 </code>
 Evaluates to <c>Some "b"</c>.
 </example>

 <example id="tryitem-2">
 <code lang="fsharp">
 let inputs = ["a"; "b"; "c"]

 inputs |> List.tryItem 4
 </code>
 Evaluates to <c>None</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.TryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the index of the first element in the list
 that satisfies the given predicate.
 Return <c>None</c> if no such element exists.</summary>

 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>

 <returns>The index of the first element for which the predicate returns true, or None if
 every element evaluates to false.</returns>

 <example id="tryfindindex-1">Try to find the index of the first even number:
 <code lang="fsharp">
 let inputs = [1; 2; 3; 4; 5]

 inputs |> List.tryFindIndex (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>Some 1</c>
 </example>

 <example id="tryfindindex-2">Try to find the index of the first even number:
 <code lang="fsharp">
 let inputs = [1; 3; 5; 7]

 inputs |> List.tryFindIndex (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>None</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.TryFindBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the last element for which the given function returns True.
 Return None if no such element exists.</summary>

 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>

 <returns>The last element for which the predicate returns true, or None if
 every element evaluates to false.</returns>

 <example id="tryfindback-1">Try to find the first even number from the back:
 <code lang="fsharp">
 let inputs = [1; 2; 3; 4; 5]

 inputs |> List.tryFindBack (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>Some 4</c>
 </example>

 <example id="tryfindback-2">Try to find the first even number from the back:
 <code lang="fsharp">
 let inputs = [1; 5; 3]

 inputs |> List.tryFindBack (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>None</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.TryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the first element for which the given function returns True.
 Return None if no such element exists.</summary>

 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>

 <returns>The first element for which the predicate returns true, or None if
 every element evaluates to false.</returns>

 <example id="tryfind-1">Try to find the first even number:
 <code lang="fsharp">
 let inputs = [1; 2; 3]

 inputs |> List.tryFind (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>Some 2</c>
 </example>

 <example id="tryfind-2">Try to find the first even number:
 <code lang="fsharp">
 let inputs = [1; 5; 3]

 inputs |> List.tryFind (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>None</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.TryPick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Applies the given function to successive elements, returning <c>Some(x)</c> the first
 result where function returns <c>Some(x)</c> for some x. If no such element 
 exists then return <c>None</c>.</summary>

 <param name="chooser">The function to generate options from the elements.</param>
 <param name="list">The input list.</param>

 <returns>The first resulting value or None.</returns>

 <example id="trypick-1">
 <code lang="fsharp">
 let input = [1; 2; 3]

 input |> List.tryPick (fun n -> if n % 2 = 0 then Some (string n) else None)
 </code>
 Evaluates to <c>Some "2"</c>.
 </example>

 <example id="trypick-2">
 <code lang="fsharp">
 let input = [1; 2; 3]

 input |> List.tryPick (fun n -> if n > 3 then Some (string n) else None)
 </code>
 Evaluates to <c>None</c>.
 </example>

</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Truncate``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns at most N elements in a new list.</summary>

 <param name="count">The maximum number of items to return.</param>
 <param name="list">The input list.</param>

 <returns>The result list.</returns>

 <example id="truncate-1">
 <code lang="fsharp">
 let inputs = ["a"; "b"; "c"; "d"]

 inputs |> List.truncate 2
 </code>
 Evaluates to <c>["a"; "b"]</c>
 </example>

 <example id="truncate-2">
 <code lang="fsharp">
 let inputs = ["a"; "b"; "c"; "d"]

 inputs |> List.truncate 6
 </code>
 Evaluates to <c>["a"; "b"; "c"; "d"]</c>
 </example>

 <example id="truncate-3">
 <code lang="fsharp">
 let inputs = ["a"; "b"; "c"; "d"]

 inputs |> List.truncate 0
 </code>
 Evaluates to the empty list.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Transpose``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Collections.FSharpList{``0}})">
 <summary>Returns the transpose of the given sequence of lists.</summary>

 <param name="lists">The input sequence of list.</param>

 <returns>The transposed list.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input lists differ in length.</exception>

 <example id="transpose-1">
 <code lang="fsharp">
 let inputs =
     [ [ 10; 20; 30 ]
       [ 11; 21; 31 ] ]

 inputs |> List.transpose
 </code>
 Evaluates to <c>[ [10; 11]; [20; 21]; [30; 31] ]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.TryHead``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the first element of the list, or
 <c>None</c> if the list is empty.</summary>

 <param name="list">The input list.</param>

 <returns>The first element of the list or None.</returns>

 <example id="try-head-1">
 <code lang="fsharp">
 let inputs = [ "banana"; "pear" ]

 inputs |> List.tryHead
 </code>
 Evaluates to <c>Some "banana"</c>
 </example>

 <example id="try-head-2">
 <code lang="fsharp">
 let inputs : int list = []

 inputs |> List.tryHead
 </code>
 Evaluates to <c>None</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.ToSeq``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Views the given list as a sequence.</summary>

 <param name="list">The input list.</param>

 <returns>The sequence of elements in the list.</returns>

 <example id="toseq-1">
 <code lang="fsharp">
 let inputs = [ 1; 2; 5 ]

 inputs |> List.toSeq
 </code>
 Evaluates to <c>seq { 1; 2; 5 }</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.ToArray``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Builds an array from the given list.</summary>

 <param name="list">The input list.</param>

 <returns>The array containing the elements of the list.</returns>

 <example id="toarray-1">
 <code lang="fsharp">
 let inputs = [ 1; 2; 5 ]

 inputs |> List.toArray
 </code>
 Evaluates to <c>[| 1; 2; 5 |]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.TakeWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns a list that contains all elements of the original list while the 
 given predicate returns True, and then returns no further elements.</summary>

 <param name="predicate">A function that evaluates to false when no more items should be returned.</param>
 <param name="list">The input list.</param>

 <returns>The result list.</returns>

 <example id="takewhile-1">
 <code lang="fsharp">
 let inputs = ["a"; "bb"; "ccc"; "d"]

 inputs |> List.takeWhile (fun x -> x.Length &lt; 3)
 </code>
 Evaluates to <c>["a"; "bb"]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Take``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the first N elements of the list.</summary>
 <remarks>Throws <c>InvalidOperationException</c>
 if the count exceeds the number of elements in the list. <c>List.truncate</c>
 returns as many items as the list contains instead of throwing an exception.</remarks>

 <param name="count">The number of items to take.</param>
 <param name="list">The input list.</param>

 <returns>The result list.</returns>

 <exception cref="T:System.ArgumentException">Thrown when the input list is empty.</exception>
 <exception cref="T:System.InvalidOperationException">Thrown when count exceeds the number of elements
 in the list.</exception>

 <example id="take-1">
 <code lang="fsharp">
 let inputs = ["a"; "b"; "c"; "d"]

 inputs |> List.take 2
 </code>
 Evaluates to <c>["a"; "b"]</c>
 </example>

 <example id="take-2">
 <code lang="fsharp">
 let inputs = ["a"; "b"; "c"; "d"]

 inputs |> List.take 6
 </code>
 Throws <c>InvalidOperationException</c>.
 </example>

 <example id="take-3">
 <code lang="fsharp">
 let inputs = ["a"; "b"; "c"; "d"]

 inputs |> List.take 0
 </code>
 Evaluates to the empty list.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Tail``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the list after removing the first element.</summary>

 <param name="list">The input list.</param>

 <exception cref="T:System.ArgumentException">Thrown when the list is empty.</exception>

 <returns>The list after removing the first element.</returns>

 <example id="tail-1">
 <code lang="fsharp">
 let inputs = ["a"; "bb"; "ccc"]

 inputs |> List.tail
 </code>
 Evaluates to <c>["bb"; "ccc"]</c>
 </example>

</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.SumBy``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the sum of the results generated by applying the function to each element of the list.</summary>

 <param name="projection">The function to transform the list elements into the type to be summed.</param>
 <param name="list">The input list.</param>

 <returns>The resulting sum.</returns>
 
 <example id="sumby-1">
 <code lang="fsharp">
 let input = [ "aa"; "bbb"; "cc" ]

 input |> List.sumBy (fun s -> s.Length)
 </code>
 Evaluates to <c>7</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Sum``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the sum of the elements in the list.</summary>

 <param name="list">The input list.</param>

 <returns>The resulting sum.</returns>
 
 <example id="sum-1">
 <code lang="fsharp">
 let input = [ 1; 5; 3; 2 ]

 input |> List.sum
 </code>
 Evaluates to <c>11</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.SortDescending``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Sorts the given list in descending order using <see cref="M:Microsoft.FSharp.Core.Operators.compare"/>.</summary>

 <remarks>This is a stable sort, i.e. the original order of equal elements is preserved.</remarks>
 <param name="list">The input list.</param>

 <returns>The sorted list.</returns>
 
 <example id="sortdescending-1">
 <code lang="fsharp">
 let input = [8; 4; 3; 1; 6; 1]

 input |> List.sortDescending
 </code>
 Evaluates to <c>[8; 6; 4; 3; 1; 1]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.SortByDescending``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Sorts the given list in descending order using keys given by the given projection. Keys are compared using <see cref="M:Microsoft.FSharp.Core.Operators.compare"/>.</summary>

 <remarks>This is a stable sort, i.e. the original order of equal elements is preserved.</remarks>
 <param name="projection">The function to transform the list elements into the type to be compared.</param>
 <param name="list">The input list.</param>

 <returns>The sorted list.</returns>
 
 <example id="sortbydescending-1">
 <code lang="fsharp">
 let input = ["a"; "bbb"; "cccc"; "dd"]

 input |> List.sortByDescending (fun s -> s.Length)
 </code>
 Evaluates to <c>["cccc"; "bbb"; "dd"; "a"]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.SplitAt``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Splits a list into two lists, at the given index.</summary>

 <param name="index">The index at which the list is split.</param>
 <param name="list">The input list.</param>

 <returns>The two split lists.</returns>

 <exception cref="T:System.InvalidOperationException">Thrown when split index exceeds the number of elements
 in the list.</exception>
 
 <example id="splitat-1">
 <code lang="fsharp">
 let input = [8; 4; 3; 1; 6; 1]

 let front, back = input |> List.splitAt 3
 </code>
 Evaluates <c>front</c> to <c>[8; 4; 3]</c> and <c>back</c> to <c>[1; 6; 1]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Sort``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Sorts the given list using <see cref="M:Microsoft.FSharp.Core.Operators.compare"/>.</summary>

 <remarks>This is a stable sort, i.e. the original order of equal elements is preserved.</remarks>
 <param name="list">The input list.</param>

 <returns>The sorted list.</returns>
 
 <example id="sort-1">
 <code lang="fsharp">
 let input = [8; 4; 3; 1; 6; 1]

 List.sort input
 </code>
 Evaluates to <c>[1; 1 3; 4; 6; 8]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.SortBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Sorts the given list using keys given by the given projection. Keys are compared using <see cref="M:Microsoft.FSharp.Core.Operators.compare"/>.</summary>

 <remarks>This is a stable sort, i.e. the original order of equal elements is preserved.</remarks>
 <param name="projection">The function to transform the list elements into the type to be compared.</param>
 <param name="list">The input list.</param>

 <returns>The sorted list.</returns>
 
 <example id="sortby-1">
 <code lang="fsharp">
 let input = [ "a"; "bbb"; "cccc"; "dd" ]

 input |> List.sortBy (fun s -> s.Length)
 </code>
 Evaluates to <c>["a"; "dd"; "bbb"; "cccc"]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.SortWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Sorts the given list using the given comparison function.</summary>

 <remarks>This is a stable sort, i.e. the original order of equal elements is preserved.</remarks>
 <param name="comparer">The function to compare the list elements.</param>
 <param name="list">The input list.</param>

 <returns>The sorted list.</returns>
 
 <example id="sortwith-1">Sort a list of pairs using a comparison function that compares string lengths then index numbers:
 <code lang="fsharp">
 let compareEntries (n1: int, s1: string) (n2: int, s2: string) =
     let c = compare s1.Length s2.Length
     if c &lt;> 0 then c else
     compare n1 n2

 let input = [ (0,"aa"); (1,"bbb"); (2,"cc"); (3,"dd") ]

 input |> List.sortWith compareEntries
 </code>
 Evaluates to <c>[(0, "aa"); (2, "cc"); (3, "dd"); (1, "bbb")]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.SkipWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Bypasses elements in a list while the given predicate returns True, and then returns
 the remaining elements of the list.</summary>

 <param name="predicate">A function that evaluates an element of the list to a boolean value.</param>
 <param name="list">The input list.</param>

 <returns>The result list.</returns>

 <example id="skipwhile-1">
 <code lang="fsharp">
 let inputs = ["a"; "bbb"; "cc"; "d"]

 inputs |> List.skipWhile (fun x -> x.Length &lt; 3)
 </code>
 Evaluates to <c>["bbb"; "cc"; "d"]</c>
 </example>

</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Skip``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the list after removing the first N elements.</summary>

 <param name="count">The number of elements to skip. If the number is 0 or negative the input list is returned.</param>
 <param name="list">The input list.</param>

 <returns>The list after removing the first N elements.</returns>

 <exception cref="T:System.ArgumentException">Thrown when count exceeds the number of 
 elements in the list.</exception>

 <example id="skip-1">
 <code lang="fsharp">
 let inputs = ["a"; "b"; "c"; "d"]

 inputs |> List.skip 2
 </code>
 Evaluates to <c>["c"; "d"]</c>
 </example>

 <example id="skip-2">
 <code lang="fsharp">
 let inputs = ["a"; "b"; "c"; "d"]

 inputs |> List.skip 5
 </code>
 Throws <c>ArgumentException</c>.
 </example>

 <example id="skip-3">
 <code lang="fsharp">
 let inputs = ["a"; "b"; "c"; "d"]

 inputs |> List.skip -1
 </code>
 Evaluates to <c>["a"; "b"; "c"; "d"]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Singleton``1(``0)">
 <summary>Returns a list that contains one item only.</summary>

 <param name="value">The input item.</param>

 <returns>The result list of one item.</returns>
 
 <example id="singleton-1">
 <code lang="fsharp">
 List.singleton 7
 </code>
 Evaluates to <c>[ 7 ]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.ScanBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
 <summary>Like <c>foldBack</c>, but returns both the intermediary and final results</summary>

 <param name="folder">The function to update the state given the input elements.</param>
 <param name="list">The input list.</param>
 <param name="state">The initial state.</param>

 <returns>The list of states.</returns>
 
 <example id="scanback-1">Apply a list charges from back to front, and collect the running balances as each is applied:
 <code lang="fsharp">
 type Charge =
     | In of int
     | Out of int

 let inputs = [ In 1; Out 2; In 3 ]

 (inputs, 0) ||> List.scanBack (fun charge acc ->
     match charge with
     | In i -> acc + i
     | Out o -> acc - o)
 </code>
 Evaluates to <c> [2; 1; 3; 0]</c> by processing each input from back to front. Note <c>0</c> is the initial
 state, <c>3</c> the next state, <c>1</c> the next state, and <c>2</c> the final state, and the states
 are produced from back to front.
 Note <c>acc</c> is a commonly used abbreviation for "accumulator".
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Scan``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Applies a function to each element of the collection, threading an accumulator argument
 through the computation. Take the second argument, and apply the function to it
 and the first element of the list. Then feed this result into the function along
 with the second element and so on. Returns the list of intermediate results and the final result.</summary>

 <param name="folder">The function to update the state given the input elements.</param>
 <param name="state">The initial state.</param>
 <param name="list">The input list.</param>

 <returns>The list of states.</returns>
 
 <example id="scan-1">Apply a list charges and collect the running balances as each is applied:
 <code lang="fsharp">
 type Charge =
     | In of int
     | Out of int

 let inputs = [In 1; Out 2; In 3]

 (0, inputs) ||> List.scan (fun acc charge ->
     match charge with
     | In i -> acc + i
     | Out o -> acc - o)
 </code>
 Evaluates to <c>[0; 1; -1; 2]</c>. Note <c>0</c> is the initial
 state, <c>1</c> the next state, <c>-1</c> the next state, and <c>2</c> the final state.
 Note <c>acc</c> is a commonly used abbreviation for "accumulator".
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Reverse``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns a new list with the elements in reverse order.</summary>

 <param name="list">The input list.</param>

 <returns>The reversed list.</returns>
 
 <example id="rev-1">
 <code lang="fsharp">
 let inputs = [ 0; 1; 2 ]

 inputs |> List.rev
 </code>
 Evaluates to <c>[ 2; 1; 0 ]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Replicate``1(System.Int32,``0)">
 <summary>Creates a list by replicating the given initial value.</summary>

 <param name="count">The number of elements to replicate.</param>
 <param name="initial">The value to replicate</param>

 <returns>The generated list.</returns>
 
 <example id="replicate-1">
 <code lang="fsharp">
 List.replicate 3 "a"
 </code>
 Evaluates to <c>[ "a"; "a"; "a" ]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.ReduceBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Applies a function to each element of the collection, starting from the end, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f i0 (...(f iN-1 iN))</c>.</summary>

 <param name="reduction">A function that takes in the next-to-last element of the list and the
 current accumulated result to produce the next accumulated result.</param>
 <param name="list">The input list.</param>

 <exception cref="T:System.ArgumentException">Thrown when the list is empty.</exception>

 <returns>The final result of the reductions.</returns>
 
 <example id="reduceback-1">
 <code lang="fsharp">
 let inputs = [1; 3; 4; 2]

 inputs |> List.reduceBack (fun a b -> a + b * 10)
 </code>
 Evaluates to <c>2431</c>, by computing <c>1 + (3 + (4 + 2 * 10) * 10) * 10</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Apply a function to each element of the collection, threading an accumulator argument
 through the computation. Apply the function to the first two elements of the list.
 Then feed this result into the function along with the third element and so on. 
 Return the final result. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f (... (f i0 i1) i2 ...) iN</c>.</summary>

 <remarks>Raises <see cref="T:System.ArgumentException"/> if <c>list</c> is empty</remarks>

 <param name="reduction">The function to reduce two list elements to a single element.</param>
 <param name="list">The input list.</param>

 <exception cref="T:System.ArgumentException">Thrown when the list is empty.</exception>

 <returns>The final reduced value.</returns>
 
 <example id="reduce-1">
 <code lang="fsharp">
 let inputs = [1; 3; 4; 2]

 inputs |> List.reduce (fun a b -> a * 10 + b)
 </code>
 Evaluates to <c>1342</c>, by computing <c>((1 * 10 + 3) * 10 + 4) * 10 + 2</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Permute``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns a list with all elements permuted according to the
 specified permutation.</summary>

 <param name="indexMap">The function to map input indices to output indices.</param>
 <param name="list">The input list.</param>

 <returns>The permuted list.</returns>

 <exception cref="T:System.ArgumentException">Thrown when indexMap does not produce a valid permutation.</exception>
 
 <example id="permute-1">
 <code lang="fsharp">
 let inputs = [1; 2; 3; 4]

 inputs |> List.permute (fun x -> (x + 1) % 4)
 </code>
 Evaluates to <c>[4; 1; 2; 3]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Pick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Applies the given function to successive elements, returning the first
 result where function returns <c>Some(x)</c> for some x. If no such
 element exists then raise <see cref="T:System.Collections.Generic.KeyNotFoundException"/></summary>

 <param name="chooser">The function to generate options from the elements.</param>
 <param name="list">The input list.</param>

 <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when the list is empty.</exception>

 <returns>The first resulting value.</returns>

 <example id="pick-1">
 <code lang="fsharp">
 let input = [1; 2; 3]

 input |> List.pick (fun n -> if n % 2 = 0 then Some (string n) else None)
 </code>
 Evaluates to <c>"2"</c>.
 </example>

 <example id="pick-2">
 <code lang="fsharp">
 let input = [1; 2; 3]

 input |> List.pick (fun n -> if n > 3 then Some (string n) else None)
 </code>
 Throws <c>KeyNotFoundException</c>.
 </example>

</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Splits the collection into two collections, containing the 
 elements for which the given predicate returns True and False
 respectively. Element order is preserved in both of the created lists.</summary>

 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>

 <returns>A list containing the elements for which the predicate evaluated to true and a list
 containing the elements for which the predicate evaluated to false.</returns>
 
 <example id="partition-1">
 <code lang="fsharp">
 let inputs = [1; 2; 3; 4]

 let evens, odds = inputs |> List.partition (fun x -> x % 2 = 0)
 </code>
 Evaluates <c>evens</c> to <c>[2; 4]</c> and <c>odds</c> to <c>[1; 3]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Pairwise``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns a list of each element in the input list and its predecessor, with the
 exception of the first element which is only returned as the predecessor of the second element.</summary>

 <param name="list">The input list.</param>

 <returns>The result list.</returns>
 
 <example id="pairwise-1">
 <code lang="fsharp">
 let inputs = [1; 2; 3; 4]

 inputs |> List.pairwise
 </code>
 Evaluates to <c>[(1, 2); (2, 3); (3, 4)]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.OfSeq``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a new list from the given enumerable object.</summary>

 <param name="source">The input sequence.</param>

 <returns>The list of elements from the sequence.</returns>
 
 <example id="oflist-1">
 <code lang="fsharp">
 let inputs = seq { 1; 2; 5 }

 inputs |> List.ofSeq    
 </code>
 Evaluates to <c>[ 1; 2; 5 ]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.OfArray``1(``0[])">
 <summary>Builds a list from the given array.</summary>

 <param name="array">The input array.</param>

 <returns>The list of elements from the array.</returns>
 
 <example id="oflist-1">
 <code lang="fsharp">
 let inputs = [| 1; 2; 5 |]

 inputs |> List.ofArray
 </code>
 Evaluates to <c>[ 1; 2; 5 ]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Get``1(Microsoft.FSharp.Collections.FSharpList{``0},System.Int32)">
 <summary>Indexes into the list. The first element has index 0.</summary>

 <param name="list">The input list.</param>
 <param name="index">The index to retrieve.</param>

 <returns>The value at the given index.</returns>

 <exception cref="T:System.ArgumentException">Thrown when the index is negative or the input list does not contain enough elements.</exception>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.MinBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the lowest of all elements of the list, compared via Operators.min on the function result</summary>

 <remarks>Raises <see cref="T:System.ArgumentException"/> if <c>list</c> is empty.</remarks>
 <param name="projection">The function to transform list elements into the type to be compared.</param>
 <param name="list">The input list.</param>

 <exception cref="T:System.ArgumentException">Thrown when the list is empty.</exception>

 <returns>The minimum value.</returns>

 <example id="minby-1">
 <code lang="fsharp">
 let inputs = ["aaa"; "b"; "cccc"]

 inputs |> List.minBy (fun s -> s.Length)
 </code>
 Evaluates to <c>"b"</c>
 </example>

 <example id="minby-2">
 <code lang="fsharp">
 let inputs = []

 inputs |> List.minBy (fun (s: string) -> s.Length)
 </code>
 Throws <c>System.ArgumentException</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Min``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the lowest of all elements of the list, compared via Operators.min.</summary>

 <remarks>Raises <see cref="T:System.ArgumentException"/> if <c>list</c> is empty</remarks>
 <param name="list">The input list.</param>

 <exception cref="T:System.ArgumentException">Thrown when the list is empty.</exception>

 <returns>The minimum value.</returns>

 <example id="min-1">
 <code lang="fsharp">
 let inputs = [10; 12; 11]

 inputs |> List.min
 </code>
 Evaluates to <c>10</c>
 </example>

 <example id="min-2">
 <code lang="fsharp">
 let inputs = []

 inputs |> List.min
 </code>
 Throws <c>System.ArgumentException</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.MaxBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the greatest of all elements of the list, compared via Operators.max on the function result.</summary>

 <remarks>Raises <see cref="T:System.ArgumentException"/> if <c>list</c> is empty.</remarks>
 <param name="projection">The function to transform the list elements into the type to be compared.</param>
 <param name="list">The input list.</param>

 <exception cref="T:System.ArgumentException">Thrown when the list is empty.</exception>

 <returns>The maximum element.</returns>

 <example id="maxby-1">
 <code lang="fsharp">
 let inputs = ["aaa"; "b"; "cccc"]

 inputs |> List.maxBy (fun s -> s.Length)
 </code>
 Evaluates to <c>"cccc"</c>
 </example>

 <example id="maxby-2">
 <code lang="fsharp">
 let inputs = []

 inputs |> List.maxBy (fun (s: string) -> s.Length)
 </code>
 Throws <c>System.ArgumentException</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Max``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Return the greatest of all elements of the list, compared via Operators.max.</summary>

 <remarks>Raises <see cref="T:System.ArgumentException"/> if <c>list</c> is empty</remarks>
 <param name="list">The input list.</param>

 <exception cref="T:System.ArgumentException">Thrown when the list is empty.</exception>

 <returns>The maximum element.</returns>

 <example id="max-1">
 <code lang="fsharp">
 let inputs = [ 10; 12; 11 ]

 inputs |> List.max
 </code>
 Evaluates to <c>12</c>
 </example>

 <example id="max-2">
 <code lang="fsharp">
 let inputs = [ ]

 inputs |> List.max
 </code>
 Throws <c>System.ArgumentException</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.MapIndexed2``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Like mapi, but mapping corresponding elements from two lists of equal length.</summary>

 <param name="mapping">The function to transform pairs of elements from the two lists and their index.</param>
 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>

 <returns>The list of transformed elements.</returns>

 <example id="mapi2-1">
 <code lang="fsharp">
 let inputs1 = ["a"; "bad"; "good"]
 let inputs2 = [0; 2; 1]

 (inputs1, inputs2) ||> List.mapi2 (fun i x y -> i, x[y])
 </code>
 Evaluates to <c>[(0, 'a'); (1, 'd'); (2, 'o')]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The integer index passed to the
 function indicates the index (from 0) of element being transformed.</summary>

 <param name="mapping">The function to transform elements and their indices.</param>
 <param name="list">The input list.</param>

 <returns>The list of transformed elements.</returns>

 <example id="item-1">
 <code lang="fsharp">
 let inputs = [ 10; 10; 10 ]

 inputs |> List.mapi (fun i x -> i + x)
 </code>
 Evaluates to <c>[ 10; 11; 12 ]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.MapFoldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
 <summary>Combines map and foldBack. Builds a new list whose elements are the results of applying the given function
 to each of the elements of the input list. The function is also used to accumulate a final value.</summary>

 <param name="mapping">The function to transform elements from the input list and accumulate the final value.</param>
 <param name="list">The input list.</param>
 <param name="state">The initial state.</param>

 <returns>The list of transformed elements, and the final accumulated value.</returns>

 <example id="mapfold-1">Accumulate the charges from back to front, and double them as well
 <code lang="fsharp">
 type Charge =
     | In of int
     | Out of int

 let charges = [ In 1; Out 2; In 3 ]

 let newCharges, balance =
     (charges, 0) ||> List.mapFoldBack (fun charge acc ->
         match charge with
         | In i -> In (i*2), acc + i
         | Out o -> Out (o*2), acc - o)
 </code>
 Evaluates <c>newCharges</c> to <c>[In 2; Out 4; In 6]</c> and <c>balance</c> to <c>2</c>.
 Note <c>acc</c> is a commonly used abbreviation for "accumulator".
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.MapFold``3(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``2,``1}}},``1,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Combines map and fold. Builds a new list whose elements are the results of applying the given function
 to each of the elements of the input list. The function is also used to accumulate a final value.</summary>

 <param name="mapping">The function to transform elements from the input list and accumulate the final value.</param>
 <param name="state">The initial state.</param>
 <param name="list">The input list.</param>

 <returns>The list of transformed elements, and the final accumulated value.</returns>

 <example id="mapfold-1">
 <code lang="fsharp">Accumulate the charges, and double them as well
 type Charge =
     | In of int
     | Out of int

 let inputs = [ In 1; Out 2; In 3 ]

 let newCharges, balance =
     (0, inputs) ||> List.mapFold (fun acc charge ->
         match charge with
         | In i -> In (i*2), acc + i
         | Out o -> Out (o*2), acc - o)
 </code>
 Evaluates <c>newCharges</c> to <c>[In 2; Out 4; In 6]</c> and <c>balance</c> to <c>2</c>.
 Note <c>acc</c> is a commonly used abbreviation for "accumulator".
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Map3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``2})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding elements of the three collections simultaneously.</summary>

 <param name="mapping">The function to transform triples of elements from the input lists.</param>
 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>
 <param name="list3">The third input list.</param>

 <returns>The list of transformed elements.</returns>

 <example id="item-1">
 <code lang="fsharp">
 let inputs1 = [ "a"; "t"; "ti" ]
 let inputs2 = [ "l"; "h"; "m" ]
 let inputs3 = [ "l"; "e"; "e" ]

 (inputs1, inputs2, inputs3) |||> List.map3 (fun x y z -> x + y + z)
 </code>
 Evaluates to <c>[ "all"; "the"; "time" ]</c>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise.</summary>

 <param name="mapping">The function to transform pairs of elements from the input lists.</param>
 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>

 <returns>The list of transformed elements.</returns>

 <example id="item-1">
 <code lang="fsharp">
 let inputs1 = ["a"; "bad"; "good"]
 let inputs2 = [0; 2; 1]

 (inputs1, inputs2) ||> List.map2 (fun x y -> x.[y])
 </code>
 Evaluates to <c>seq ['a'; 'd'; 'o']</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection.</summary>

 <param name="mapping">The function to transform elements from the input list.</param>
 <param name="list">The input list.</param>

 <returns>The list of transformed elements.</returns>

 <example id="map-1">
 <code lang="fsharp">
 let inputs = [ "a"; "bbb"; "cc" ]

 inputs |> List.map (fun x -> x.Length)
 </code>
 Evaluates to <c>[ 1; 3; 2 ]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.TryLast``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the last element of the list.
 Return <c>None</c> if no such element exists.</summary>

 <param name="list">The input list.</param>

 <returns>The last element of the list or None.</returns>

 <example id="trylast-1">
 <code lang="fsharp">
 [ "pear"; "banana" ] |> List.tryLast
 </code>
 Evaluates to <c>Some "banana"</c>
 </example>

 <example id="trylast-2">
 <code lang="fsharp">
 [ ] |> List.tryLast
 </code>
 Evaluates to <c>None</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Length``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the length of the list.</summary>

 <param name="list">The input list.</param>

 <returns>The length of the list.</returns>

 <remarks>The notation <c>array.Length</c> is preferred.</remarks>

 <example id="length-1">
 <code lang="fsharp">
 let inputs = [ "a"; "b"; "c" ]

 inputs |> List.length
 </code>
 Evaluates to <c>3</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Last``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the last element of the list.</summary>

 <param name="list">The input list.</param>

 <returns>The last element of the list.</returns>

 <exception cref="T:System.ArgumentException">Thrown when the input does not have any elements.</exception>

 <example id="last-1">
 <code lang="fsharp">
 [ "pear"; "banana" ] |> List.last
 </code>
 Evaluates to <c>banana</c>
 </example>

 <example id="last-2">
 <code lang="fsharp">
 [ ] |> List.last
 </code>
 Throws <c>ArgumentException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.IterateIndexed2``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Applies the given function to two collections simultaneously. The
 collections must have identical size. The integer passed to the
 function indicates the index of element.</summary>

 <param name="action">The function to apply to a pair of elements from the input lists along with their index.</param>
 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>

 <example id="iteri2-1">
 <code lang="fsharp">
 let inputs1 = [ "a"; "b"; "c" ]
 let inputs2 = [ "banana"; "pear"; "apple" ]

 (inputs1, inputs2) ||> List.iteri2 (fun i s1 s2 -> printfn "Index {i}: {s1} - {s2}")
 </code>
 Evaluates to <c>unit</c> and prints
 <code lang="fsharp">
 Index 0: a - banana
 Index 1: b - pear
 Index 2: c - apple
 </code>
 in the console.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Applies the given function to each element of the collection. The integer passed to the
 function indicates the index of element.</summary>

 <param name="action">The function to apply to the elements of the list along with their index.</param>
 <param name="list">The input list.</param>

 <example id="iteri-1">
 <code lang="fsharp">
 let inputs = [ "a"; "b"; "c" ]

 inputs |> List.iteri (fun i v -> printfn "{i}: {v}")
 </code>
 Evaluates to <c>unit</c> and prints
 <code lang="fsharp">
 0: a
 1: b
 2: c
 </code>
 in the console.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Iterate2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Applies the given function to two collections simultaneously. The
 collections must have identical size.</summary>

 <param name="action">The function to apply to pairs of elements from the input lists.</param>
 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>

 <example id="iter2-1">
 <code lang="fsharp">
 let inputs1 = [ "a"; "b"; "c" ]
 let inputs2 = [ 1; 2; 3 ]

 (inputs1, inputs2) ||> List.iter2 (printfn "%s: %i")
 </code>
 Evaluates to <c>unit</c> and prints
 <code lang="fsharp">
 a: 1
 b: 2
 c: 3
 </code>
 in the console.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Applies the given function to each element of the collection.</summary>

 <param name="action">The function to apply to elements from the input list.</param>
 <param name="list">The input list.</param>

 <example id="iter-1">
 <code lang="fsharp">
 let inputs = [ "a"; "b"; "c" ]

 inputs |> List.iter (printfn "%s")
 </code>
 Evaluates to <c>unit</c> and prints
 <code lang="fsharp">
 a
 b
 c
 </code>
 in the console.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Item``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Indexes into the list. The first element has index 0.</summary>

 <param name="index">The index to retrieve.</param>
 <param name="list">The input list.</param>

 <returns>The value at the given index.</returns>

 <exception cref="T:System.ArgumentException">Thrown when the index is negative or the input list does not contain enough elements.</exception>

 <example id="item-1">
 <code lang="fsharp">
 let inputs = [ "a"; "b"; "c" ]

 inputs |> List.item 1
 </code>
 Evaluates to <c>"b"</c>
 </example>

 <example id="item-2">
 <code lang="fsharp">
 let inputs = [ "a"; "b"; "c" ]

 inputs |> List.item 4
 </code>
 Throws <c>ArgumentException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.IsEmpty``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns true if the list contains no elements, false otherwise.</summary>

 <param name="list">The input list.</param>

 <returns>True if the list is empty.</returns>

 <example id="empty-1">
 <code lang="fsharp">
 [ ] |> List.isEmpty
 </code>
 Evaluates to <c>true</c>
 </example>

 <example id="empty-2">
 <code lang="fsharp">
 [ "pear"; "banana" ] |> List.isEmpty
 </code>
 Evaluates to <c>false</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Initialize``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
 <summary>Creates a list by calling the given generator on each index.</summary>

 <param name="length">The length of the list to generate.</param>
 <param name="initializer">The function to generate an element from an index.</param>

 <exception cref="T:System.ArgumentException">Thrown when the input length is negative.</exception>

 <returns>The list of generated elements.</returns>

 <example id="init-1">
 <code lang="fsharp">
 List.init 4 (fun v -> v + 5)
 </code>
 Evaluates to <c>[5; 6; 7; 8]</c>
 </example>

 <example id="init-2">
 <code lang="fsharp">
 List.init -5 (fun v -> v + 5)
 </code>
 Throws <c>ArgumentException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Indexed``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns a new list whose elements are the corresponding elements
 of the input list paired with the index (from 0) of each element.</summary>

 <param name="list">The input list.</param>

 <returns>The list of indexed elements.</returns>

 <example id="indexed-1">
 <code lang="fsharp">
 let inputs = ["a"; "b"; "c"]

 inputs |> List.indexed
 </code>
 Evaluates to <c>[(0, "a"); (1, "b"); (2, "c")]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Head``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the first element of the list.</summary>

 <param name="list">The input list.</param>

 <exception cref="T:System.ArgumentException">Thrown when the list is empty.</exception>

 <returns>The first element of the list.</returns>

 <example id="head-1">
 <code lang="fsharp">
 let inputs = ["banana"; "pear"]

 inputs |> List.head
 </code>
 Evaluates to <c>banana</c>
 </example>

 <example id="head-2">
 <code lang="fsharp">
 [] |> List.head
 </code>
 Throws <c>ArgumentException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.GroupBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Applies a key-generating function to each element of a list and yields a list of 
 unique keys. Each unique key contains a list of all elements that match 
 to this key.</summary>

 <param name="projection">A function that transforms an element of the list into a comparable key.</param>
 <param name="list">The input list.</param>

 <returns>The result list.</returns>

 <example id="group-by-1">
 <code lang="fsharp">
 let inputs = [1; 2; 3; 4; 5]

 inputs |> List.groupBy (fun n -> n % 2)
 </code>
 Evaluates to <c>[(1, [1; 3; 5]); (0, [2; 4])]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.ForAll2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Tests if all corresponding elements of the collection satisfy the given predicate pairwise.</summary>

 <remarks>The predicate is applied to matching elements in the two collections up to the lesser of the 
 two lengths of the collections. If any application returns false then the overall result is 
 false and no further elements are tested. Otherwise, if one collection is longer 
 than the other then the <see cref="T:System.ArgumentException"/> exception is raised. 
 Otherwise, true is returned.</remarks>
 <param name="predicate">The function to test the input elements.</param>
 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>

 <exception cref="T:System.ArgumentException">Thrown when the input lists differ in length.</exception>

 <returns>True if all of the pairs of elements satisfy the predicate.</returns>

 <example id="forall2-1">
 <code lang="fsharp">
 let inputs1 = [1; 2; 3]
 let inputs2 = [1; 2; 3]

 (inputs1, inputs2) ||> List.forall2 (=)
 </code>
 Evaluates to <c>true</c>.
 </example>

 <example id="forall2-2">
 <code lang="fsharp">
 let items1 = [2017; 1; 1]
 let items2 = [2019; 19; 8]

 (items1, items2) ||> List.forall2 (=)
 </code>
 Evaluates to <c>false</c>.
 </example>

 <example id="forall2-3">
 <code lang="fsharp">
 let items1 = [1; 2; 3]
 let items2 = [1; 2]

 (items1, items2) ||> List.forall2 (=)
 </code>
 Throws <c>ArgumentException</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.ForAll``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Tests if all elements of the collection satisfy the given predicate.</summary>

 <remarks>The predicate is applied to the elements of the input list. If any application 
 returns false then the overall result is false and no further elements are tested. 
 Otherwise, true is returned.</remarks>
 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>

 <returns>True if all of the elements satisfy the predicate.</returns>

 <example id="forall-1">
 <code lang="fsharp">
 let isEven a = a % 2 = 0

 [2; 42] |> List.forall isEven // evaluates to true

 [1; 2] |> List.forall isEven // evaluates to false
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.FoldBack2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1},``2)">
 <summary>Applies a function to corresponding elements of two collections, threading an accumulator argument
 through the computation. The collections must have identical sizes.
 If the input function is <c>f</c> and the elements are <c>i0...iN</c> and <c>j0...jN</c>
 then computes <c>f i0 j0 (...(f iN jN s))</c>.</summary>

 <param name="folder">The function to update the state given the input elements.</param>
 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>
 <param name="state">The initial state.</param>

 <returns>The final state value.</returns>

 <example id="foldback2-1">
 <code lang="fsharp">Count the positives, negatives and accumulate some text from back to front:
 type Count =
   { Positive: int
     Negative: int
     Text: string }

 let inputs1 = [ -1; -2; -3 ]
 let inputs2 = [ 3; 2; 1 ]
 let initialState = {Positive = 0; Negative = 0; Text = ""}

 (inputs1, inputs2, initialState) |||> List.foldBack2 (fun a b acc  ->
     let text = acc.Text + "(" + string a + "," + string b + ") "
     if a + b >= 0 then
         { acc with
             Positive = acc.Positive + 1
             Text = text }
     else
         { acc with
             Negative = acc.Negative + 1
             Text = text }
 )
 </code>
 Evaluates to
 <code lang="fsharp">
 { Positive = 2
   Negative = 1
   Text = "(-3,1) (-2,2) (-1,3) " }
 </code>
 Note <c>acc</c> is a commonly used abbreviation for "accumulator".
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
 <summary>Applies a function to each element of the collection, starting from the end, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then 
 computes <c>f i0 (...(f iN s))</c>.</summary>

 <param name="folder">The function to update the state given the input elements.</param>
 <param name="list">The input list.</param>
 <param name="state">The initial state.</param>

 <returns>The state object after the folding function is applied to each element of the list.</returns>
 
 <example id="foldBack-1"> Making the sum of squares for the first 5 natural numbers
 <code lang="fsharp">
 ([1..5], 0) ||> List.foldBack (fun v acc -> acc + v * v)  // evaluates 55
 </code>
 Note <c>acc</c> is a commonly used abbreviation for "accumulator".
 </example>
 
 <example id="foldBack-2"> Shopping for fruits hungry, you tend to take more of each as the hunger grows
 <code lang="fsharp">
 type Fruit = Apple | Pear | Orange

 type BagItem = { fruit: Fruit; quantity: int }

 let takeMore fruit (previous: BagItem list) =
     let toTakeThisTime = 
         match previous with 
         | bagItem :: otherBagItems -> bagItem.quantity + 1 
         | [] -> 1 
     { fruit = fruit; quantity = toTakeThisTime } :: previous

 let input = [ Apple; Pear; Orange ]
 
 (input, []) ||> List.foldBack takeMore
 </code>
 Evaluates to
 <code lang="fsharp">
  [{ fruit = Apple; quantity = 3 }
   { fruit = Pear; quantity = 2 }
   { fruit = Orange; quantity = 1 }]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Fold2``3(Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},``2,Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Applies a function to corresponding elements of two collections, threading an accumulator argument
 through the computation. The collections must have identical sizes.
 If the input function is <c>f</c> and the elements are <c>i0...iN</c> and <c>j0...jN</c>
 then computes <c>f (... (f s i0 j0)...) iN jN</c>.</summary>

 <param name="folder">The function to update the state given the input elements.</param>
 <param name="state">The initial state.</param>
 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>

 <returns>The final state value.</returns>

 <example id="fold2-1">
 <code lang="fsharp">Count the number of times the coins match:
 type CoinToss = Head | Tails

 let inputs1 = [Tails; Head; Tails]
 let inputs2 = [Tails; Head; Head]

 (0, inputs1, inputs2) |||> List.fold2 (fun acc input1 input2 ->
     match (input1, input2) with
     | Head, Head -> acc + 1
     | Tails, Tails -> acc + 1
     | _ -> acc - 1)
 </code>
 Evaluates to <c>1</c>. Note <c>acc</c> is a commonly used abbreviation for "accumulator".
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Applies a function to each element of the collection, threading an accumulator argument
 through the computation. Take the second argument, and apply the function to it
 and the first element of the list. Then feed this result into the function along
 with the second element and so on. Return the final result.
 If the input function is <c>f</c> and the elements are <c>i0...iN</c> then 
 computes <c>f (... (f s i0) i1 ...) iN</c>.</summary>

 <param name="folder">The function to update the state given the input elements.</param>
 <param name="state">The initial state.</param>
 <param name="list">The input list.</param>

 <returns>The final state value.</returns>
 
 <example id="fold-1"> Making the sum of squares for the first 5 natural numbers
 <code lang="fsharp">
 (0, [1..5]) ||> List.fold (fun s v -> s + v * v)  // evaluates 55
 </code>
 </example>
 
 <example id="fold-2"> Shopping for fruits hungry, you tend to take more of each as the hunger grows
 <code lang="fsharp">
 type Fruit = Apple | Pear | Orange

 type BagItem = { fruit: Fruit; quantity: int }

 let takeMore (previous: BagItem list) fruit = 
     let toTakeThisTime = 
         match previous with 
         | bagItem :: otherBagItems -> bagItem.quantity + 1 
         | [] -> 1 
     { fruit = fruit; quantity = toTakeThisTime } :: previous

 let inputs = [ Apple; Pear; Orange ]
 
 ([], inputs) ||> List.fold takeMore
 </code>
 Evaluates to
 <code lang="fsharp">
  [{ fruit = Orange; quantity = 3 }
   { fruit = Pear; quantity = 2 }
   { fruit = Apple; quantity = 1 }]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns a new collection containing only the elements of the collection
 for which the given predicate returns "true"</summary>

 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>

 <returns>A list containing only the elements that satisfy the predicate.</returns>
 
 <example id="filter-1">
 <code lang="fsharp">
 let input = [1, "Luke"; 2, "Kirk"; 3, "Kenobi"; 4, "Spock"]

 let isComingFromStarTrek (x,_) = isEven x
 
 input |> List.filter isComingFromStarTrek
 </code>
 Evaluates to <c>[(2, "Kirk"); (4, "Spock")]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.FindIndexBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the index of the last element in the list
 that satisfies the given predicate.
 Raises <c>KeyNotFoundException</c> if no such element exists.</summary>

 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>

 <exception cref="T:System.ArgumentException">Thrown if the predicate evaluates to false for all the
 elements of the list.</exception>

 <returns>The index of the last element that satisfies the predicate.</returns>
 
 <example id="findIndexBack-1">
 <code lang="fsharp">
 let isEven x  = 0 = x % 2

 let isGreaterThan x y = y > x

 let input = [1, "Luke"; 2, "Kirk"; 3, "Spock"; 4, "Kenobi"]
 
 input |> List.findIndexBack (fun (x,_) -> isEven x)              // evaluates 3
 input |> List.findIndexBack (fun (x,_) -> x |> isGreaterThan 6)  // raises an exception
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.FindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the index of the first element in the list
 that satisfies the given predicate.
 Raises <c>KeyNotFoundException</c> if no such element exists.</summary>

 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>

 <exception cref="T:System.ArgumentException">Thrown if the predicate evaluates to false for all the
 elements of the list.</exception>

 <returns>The index of the first element that satisfies the predicate.</returns>
 
 <example id="findIndex-1">
 <code lang="fsharp">
 let isEven x  = 0 = x % 2

 let isGreaterThan x y = y > x

 let input = [1, "Luke"; 2, "Kirk"; 3, "Spock"; 4, "Kenobi"]
 
 input |> List.findIndex (fun (x,_) -> isEven x)              // evaluates 1
 input |> List.findIndex (fun (x,_) -> x |> isGreaterThan 6)  // raises an exception
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.FindBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the last element for which the given function returns True.
 Raises <c>KeyNotFoundException</c> if no such element exists.</summary>

 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>

 <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the predicate evaluates to false for
 all the elements of the list.</exception>

 <returns>The last element that satisfies the predicate.</returns>
 
 <example id="findBack-1">
 <code lang="fsharp">
 let isEven x  = 0 = x % 2

 let isGreaterThan x y = y > x

 let input = [1, "Luke"; 2, "Kirk"; 3, "Spock"; 4, "Kenobi"]
 
 input |> List.findBack (fun (x,_) -> isEven x)              // evaluates (4, "Kenobi")
 input |> List.findBack (fun (x,_) -> x |> isGreaterThan 6)  // raises an exception
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Find``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the first element for which the given function returns True.
 Raises <c>KeyNotFoundException</c> if no such element exists.</summary>

 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>

 <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the predicate evaluates to false for
 all the elements of the list.</exception>

 <returns>The first element that satisfies the predicate.</returns>
 
 <example id="find-1">
 <code lang="fsharp">
 let isEven x  = 0 = x % 2

 let isGreaterThan x y = y > x

 let input = [1, "Luke"; 2, "Kirk"; 3, "Spock"; 4, "Kenobi"]
 
 input |> List.find (fun (x,_) -> isEven x)              // evaluates (2, "Kirk")
 input |> List.find (fun (x,_) -> x |> isGreaterThan 6)  // raises an exception
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Exists2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Tests if any pair of corresponding elements of the lists satisfies the given predicate.</summary>

 <remarks>The predicate is applied to matching elements in the two collections up to the lesser of the 
 two lengths of the collections. If any application returns true then the overall result is 
 true and no further elements are tested. Otherwise, if one collections is longer 
 than the other then the <see cref="T:System.ArgumentException"/> exception is raised. 
 Otherwise, false is returned.</remarks>

 <param name="predicate">The function to test the input elements.</param>
 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>

 <exception cref="T:System.ArgumentException">Thrown when the input lists differ in length.</exception>

 <returns>True if any pair of elements satisfy the predicate.</returns>
 
 <example id="exists2-1"> Check if the sum of pairs (from 2 different lists) have at least one even number
 <code lang="fsharp">
 let anEvenSum a b  = 0 = (a + b) % 2
 
 ([1..4], [2..5]) 
 ||> List.exists2 anEvenSum     // evaluates false
 
 ([1..4], [2;4;5;6])
 ||> List.exists2 anEvenSum   // evaluates true
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Tests if any element of the list satisfies the given predicate.</summary>

 <remarks>The predicate is applied to the elements of the input list. If any application 
 returns true then the overall result is true and no further elements are tested. 
 Otherwise, false is returned.</remarks>
 <param name="predicate">The function to test the input elements.</param>
 <param name="list">The input list.</param>

 <returns>True if any element satisfies the predicate.</returns>
 
 <example id="exists-1">
 <code lang="fsharp">
 let input = [1, "Kirk"; 2, "Spock"; 3, "Kenobi"] 
 
 input |> List.exists (fun x -> x = (3, "Kenobi"))  // evaluates true
 
 input |> List.exists (fun (n, name) -> n > 5)      // evaluates false
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.TryExactlyOne``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the only element of the list or <c>None</c> if it is empty or contains more than one element.</summary>

 <param name="list">The input list.</param>

 <returns>The only element of the list or None.</returns>
 
 <example id="tryExactlyOne-1">
 <code lang="fsharp">
 [1] |> List.tryExactlyOne               // evaluates Some 1
 [1;2] |> List.tryExactlyOne             // evaluates None
 ([] : int list) |> List.tryExactlyOne   // evaluates None
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.ExactlyOne``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the only element of the list.</summary>

 <param name="list">The input list.</param>

 <returns>The only element of the list.</returns>
        
 <exception cref="T:System.ArgumentException">Thrown when the input does not have precisely one element.</exception>
 
 <example id="exactlyOne-1">
 <code lang="fsharp">
 ["the chosen one"] |> List.exactlyOne // evaluates "the chosen one"
 </code>
 </example>
 
 <example id="exactlyOne-2">
 <code lang="fsharp">
 let input : string list = []

 input |> List.exactlyOne
 </code>
 Will throw the exception: <c>System.ArgumentException: The input sequence was empty</c>
 </example>
 
 <example id="exactlyOne-3">
 <code lang="fsharp">
 [1..5] |> List.exactlyOne
 </code>
 Will throw the exception: <c>System.ArgumentException: The input sequence contains more than one element</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Except``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns a new list with the distinct elements of the input list which do not appear in the itemsToExclude sequence,
 using generic hash and equality comparisons to compare values.</summary>

 <param name="itemsToExclude">A sequence whose elements that also occur in the input list will cause those elements to be
 removed from the result.</param>
 <param name="list">A list whose elements that are not also in itemsToExclude will be returned.</param>

 <returns>A list that contains the distinct elements of <c>list</c> that do not appear in <c>itemsToExclude</c>.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when itemsToExclude is null.</exception>
 
 <example id="except-1">
 <code lang="fsharp">
 let input = [1, "Kirk"; 2, "Spock"; 3, "Kenobi"] 

 input |> List.except [3, "Kenobi"]
 </code>
 Evaluates to <c>[(1, "Kirk"); (2, "Spock")]</c>.
 </example>
 
 <example id="except-2">
 <code lang="fsharp">
 [0..10] |> List.except [1..5]  // evaluates [0; 6; 7; 8; 9; 10]
 </code>
 </example>
 
 <example id="except-3">
 <code lang="fsharp">
 [1..5] |> List.except [0..10]  // evaluates []
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Empty``1">
 <summary>Returns an empty list of the given type.</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.SplitInto``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Splits the input list into at most <c>count</c> chunks.</summary>

 <param name="count">The maximum number of chunks.</param>
 <param name="list">The input list.</param>

 <returns>The list split into chunks.</returns>

 <exception cref="T:System.ArgumentException">Thrown when <c>count</c> is not positive.</exception>
 
 <example id="splitInto-1">
 <code lang="fsharp">
 [1..10] |> List.splitInto 2
 </code>
 Evaluates to <c>[[1; 2; 3; 4; 5]; [6; 7; 8; 9; 10]]</c>.
 </example>
 
 <example id="splitInto-2">
 <code lang="fsharp">
 [1..10] |> List.splitInto 4
 </code>
 Evaluates to <c>[[1; 2; 3]; [4; 5; 6]; [7; 8]; [9; 10]]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.CountBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Applies a key-generating function to each element of a list and returns a list yielding unique
 keys and their number of occurrences in the original list.</summary>

 <param name="projection">A function transforming each item of the input list into a key to be
 compared against the others.</param>
 <param name="list">The input list.</param>

 <returns>The result list.</returns>
 
 <example id="countBy-1"> Counting the number of occurrences of chars
 <code lang="fsharp">
 let input = ['H'; 'a'; 'p'; 'p'; 'y']

 input |> List.countBy id
 </code>
 Evaluates <c>[('H', 1); ('a', 1); ('p', 2); ('y', 1)]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.DistinctBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns a list that contains no duplicate entries according to the 
 generic hash and equality comparisons on the keys returned by the given key-generating function.
 If an element occurs multiple times in the list then the later occurrences are discarded.</summary>

 <param name="projection">A function transforming the list items into comparable keys.</param>
 <param name="list">The input list.</param>

 <returns>The result list.</returns>
 
 <example id="distinctBy-1">
 <code lang="fsharp">
 let isEven x = 0 = x % 2

 let input = [6;1;2;3;1;4;5;5]

 input |> List.distinctBy isEven  // evaluates [6; 1]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Distinct``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns a list that contains no duplicate entries according to generic hash and
 equality comparisons on the entries.
 If an element occurs multiple times in the list then the later occurrences are discarded.</summary>

 <param name="list">The input list.</param>

 <returns>The result list.</returns>
 
 <example id="distinct-1">
 <code lang="fsharp">
 let input = [6;1;2;3;1;4;5;5]

 input |> List.distinct
 </code>
 Evaluates to <c>[6; 1; 2; 3; 4; 5]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Contains``1(``0,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Tests if the list contains the specified element.</summary>

 <param name="value">The value to locate in the input list.</param>
 <param name="source">The input list.</param>

 <returns>True if the input list contains the specified element; false otherwise.</returns>
 
 <example id="contains-1">
 <code lang="fsharp">
 [1..9] |> List.contains 0
 </code>
 Evaluates to <c>false</c>.
 </example>
 
 <example id="contains-2">
 <code lang="fsharp">
 [1..9] |> List.contains 3
 </code>
 Evaluates to <c>true</c>.
 </example>
 
 <example id="contains-3">
 <code lang="fsharp">
 let input = [1, "SpongeBob"; 2, "Patrick"; 3, "Squidward"; 4, "Mr. Krabs"]

 input |> List.contains (2, "Patrick")
 </code>
 Evaluates to <c>true</c>.
 </example>
 
 <example id="contains-4">
 <code lang="fsharp">
 let input = [1, "SpongeBob"; 2, "Patrick"; 3, "Squidward"; 4, "Mr. Krabs"]

 input |> List.contains (22, "Patrick")
 </code>
 Evaluates to <c>false</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Concat``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Collections.FSharpList{``0}})">
 <summary>Returns a new list that contains the elements of each the lists in order.</summary>

 <param name="lists">The input sequence of lists.</param>

 <returns>The resulting concatenated list.</returns>
 
 <example id="concat-1">
 <code lang="fsharp">
 let input = [ [1;2]
               [3;4;5]
               [6;7;8;9] ]
 input |> List.concat  // evaluates [1; 2; 3; 4; 5; 6; 7; 8; 9]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.CompareWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Compares two lists using the given comparison function, element by element.</summary>

 <param name="comparer">A function that takes an element from each list and returns an int.
 If it evaluates to a non-zero value iteration is stopped and that value is returned.</param>
 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>
 
 <returns>Returns the first non-zero result from the comparison function. If the first list has a 
 larger element, the return value is always positive. If the second list has a larger 
 element, the return value is always negative. When the elements are equal in the two 
 lists, 1 is returned if the first list is longer, 0 is returned if they are equal in 
 length, and -1 is returned when the second list is longer.</returns>

 <example id="compare-with-1">
 <code lang="fsharp">
 let closerToNextDozen a b =
   (a % 12).CompareTo(b % 12)

 let input1 = [1; 10]
 let input2 = [1; 10]

 (input1, input2) ||> List.compareWith closerToNextDozen
 </code>
 Evaluates to <c>0</c>
 </example>

 <example id="compare-with-2">
 <code lang="fsharp">
 let closerToNextDozen a b =
   (a % 12).CompareTo(b % 12)

 let input1 = [1; 5]
 let input2 = [1; 8]

 (input1, input2) ||> List.compareWith closerToNextDozen
 </code>
 Evaluates to <c>-1</c>
 </example>

 <example id="compare-with-3">
 <code lang="fsharp">
 let closerToNextDozen a b =
   (a % 12).CompareTo(b % 12)

 let input1 = [1; 11]
 let input2 = [1; 13]

 (input1, input2) ||> List.compareWith closerToNextDozen
 </code>
 Evaluates to <c>1</c>
 </example>

 <example id="compare-with-4">
 <code lang="fsharp">
 let closerToNextDozen a b =
   (a % 12).CompareTo(b % 12)

 let input1 = [1; 2]
 let input2 = [1]

 (input1, input2) ||> List.compareWith closerToNextDozen
 </code>
 Evaluates to <c>1</c>
 </example>

 <example id="compare-with-5">
 <code lang="fsharp">
 let closerToNextDozen a b =
   (a % 12).CompareTo(b % 12)

 let input1 = [1]
 let input2 = [1; 2]

 (input1, input2) ||> List.compareWith closerToNextDozen
 </code>
 Evaluates to <c>-1</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Collect``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Collections.FSharpList{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>For each element of the list, applies the given function. Concatenates all the results and return the combined list.</summary>

 <param name="mapping">The function to transform each input element into a sublist to be concatenated.</param>
 <param name="list">The input list.</param>

 <returns>The concatenation of the transformed sublists.</returns>
 
 <example id="collect-1"> For each positive number in the array we are generating all the previous positive numbers
 <code lang="fsharp">
 [1..4] |> List.collect (fun x -> [1..x])
 </code>
 The sample evaluates to <c>[1;   1; 2;   1; 2; 3;   1; 2; 3; 4]</c> (added extra spaces for easy reading)
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.ChunkBySize``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Divides the input list into lists (chunks) with at a positive number of at most <c>chunkSize</c> elements.
 Returns a new list containing the generated lists (chunks) as its elements.
 
 Returns an empty list when the input list is empty.</summary>

 <param name="chunkSize">The maximum size of each chunk.</param>
 <param name="list">The input list.</param>

 <returns>The list divided into chunks.</returns>

 <exception cref="T:System.ArgumentException">Thrown when <c>chunkSize</c> is not positive.</exception>
 
 <example id="chunkBySize-1">
 <code lang="fsharp">
 [ 1..10 ] |> List.chunkBySize 3     
 </code>
 Evaluates to
 <code lang="fsharp">
 [ [ 1; 2; 3 ]
   [ 4; 5; 6 ]
   [ 7; 8; 9 ]
   [ 10 ] ]
 </code>
 </example>
 
 <example id="chunkBySize-2">
 <code lang="fsharp">
 [ 1..5 ] |> List.chunkBySize 10
 </code>
 Evaluates to
 <code lang="fsharp">
 [ [ 1; 2; 3; 4; 5 ] ]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Applies a function to each element in a list and then returns
 a list of values <c>v</c> where the applied function returned <c>Some(v)</c>.
 
 Returns an empty list when the input list is empty or when the applied chooser function
 returns <c>None</c> for all elements.
 </summary>

 <param name="chooser">The function to be applied to the list elements.</param>
 <param name="list">The input list.</param>

 <returns>The resulting list comprising the values <c>v</c> where the chooser function returned <c>Some(x)</c>.</returns>
 
 <example id="choose-1">
 Using the identity function <c>id</c> (is defined like <c>fun x -> x</c>):
 <code lang="fsharp">
 
 let input1 = [ Some 1; None; Some 3; None ]

 input1 |> List.choose id
 </code>
 Evaluates to
 <code lang="fsharp">
 [ 1; 3 ]
 </code>
 </example>
 
 <example id="choose-2">
 <code lang="fsharp">
 type Happiness =
     | AlwaysHappy
     | MostOfTheTimeGrumpy

 type People = { Name: string; Happiness: Happiness }

 let takeJustHappyPersons person =
     match person.Happiness with
     | AlwaysHappy -> Some person.Name
     | MostOfTheTimeGrumpy -> None

 let candidatesForTheTrip = 
     [ { Name = "SpongeBob"
         Happiness = AlwaysHappy }
       { Name = "Patrick"
         Happiness = AlwaysHappy }
       { Name = "Squidward"
         Happiness = MostOfTheTimeGrumpy } ]

 candidatesForTheTrip
 |> List.choose takeJustHappyPersons
 </code>
 Evaluates to
 <code lang="fsharp">
 [ "SpongeBob"; "Patrick" ]
 </code>
 </example>

 <example id="choose-3">
 <code lang="fsharp">
 let input3: int option list = [] 

 input3 |> List.choose id
 Evaluates to:
 empty list
 </code>
 </example>

 <example id="choose-4">
 <code lang="fsharp">
 let input4: string option list = [None; None]

 input4 |> List.choose id
 Evaluates to
 empty list
 </code>
 </example>
 
 <example id="choose-5">
 Using the identity function <c>id</c> (is defined like <c>fun x -> x</c>):
 <code lang="fsharp">
 
 let input5 = [ Some 1; None; Some 3; None ]

 input5 |> List.choose id  // evaluates [1; 3]
 </code>
 </example>

</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.AverageBy``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the average of values in a list generated by applying a function to each element of the list.</summary>

 <param name="projection">The function to transform the list elements into the values to be averaged.</param>
 <param name="list">The input list.</param>

 <exception cref="T:System.ArgumentException">Thrown when the list is empty.</exception>

 <returns>The resulting average.</returns>
 
 <example id="averageBy-1"> Calculate average age of persons by extracting their age from a record type.
 <code lang="fsharp">
 type People = { Name: string; Age: int }

 let getAgeAsFloat person = float person.Age

 let people = 
     [ { Name = "Kirk"; Age = 26 }
       { Name = "Spock"; Age = 90 }
       { Name = "McCoy"; Age = 37 } ]

 people |> List.averageBy getAgeAsFloat
 </code>
 Evaluates to
 <code lang="fsharp">
 51.0
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Average``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns the average of the values in a non-empty list.</summary>

 <param name="list">The input list.</param>

 <exception cref="T:System.ArgumentException">Thrown when the input list is empty.</exception>

 <returns>The resulting average.</returns>
 
 <example id="average-1">
 <code lang="fsharp">
 [1.0 .. 9.0] |> List.average 
 </code>
 Evaluates to
 <code lang="fsharp">
 5.0
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Append``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Returns a new list that contains the elements of the first list
 followed by elements of the second list.</summary>

 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>

 <returns>The resulting list.</returns>
 
 <example id="append-1">
 <code lang="fsharp">
 List.append [ 1..3 ] [ 4..7 ]
 
 [ 4..7 ] |> List.append [ 1..3 ]
 </code>
 Evaluates to
 <code lang="fsharp">
 [ 1; 2; 3; 4; 5; 6; 7 ]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.AllPairs``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
 <summary>Returns a new list that contains all pairings of elements from two lists.</summary>

 <param name="list1">The first input list.</param>
 <param name="list2">The second input list.</param>

 <returns>The resulting list of pairs.</returns>
 
 <example id="allPairs-1">
 <code lang="fsharp">
 let people = [ "Kirk"; "Spock"; "McCoy" ]
 let numbers = [ 1; 2 ]

 people |> List.allPairs numbers 
 </code>
 Evaluates to
 <code lang="fsharp">
 [ (1, "Kirk"); (1, "Spock"); (1, "McCoy"); (2, "Kirk"); (2, "Spock"); (2, "McCoy") ]
 </code>
 </example>
</member>
<member name="T:Microsoft.FSharp.Collections.ListModule">
 <summary>Contains operations for working with values of type <see cref="T:Microsoft.FSharp.Collections.list`1"/>.</summary>

 <namespacedoc><summary>Operations for collections such as lists, arrays, sets, maps and sequences. See also 
    <a href="https://docs.microsoft.com/dotnet/fsharp/language-reference/fsharp-collection-types">F# Collection Types</a> in the F# Language Guide.
 </summary></namespacedoc>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.InsertManyAt``1(System.Int32,System.Collections.Generic.IEnumerable{``0},``0[])">
 <summary>Return a new array with new items inserted before the given index.</summary>

 <param name="index">The index where the items should be inserted.</param>
 <param name="values">The values to insert.</param>
 <param name="source">The input array.</param>
 
 <returns>The result array.</returns>

 <exception cref="T:System.ArgumentException">Thrown when index is below 0 or greater than source.Length.</exception>

 <example id="insertManyAt-1">
 <code>
 let inputs = [| 0; 1; 2 |]

 inputs |> Array.insertManyAt 1 [8; 9]
 </code>
 Evaluates to <c>[| 0; 8; 9; 1; 2 |]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.InsertAt``1(System.Int32,``0,``0[])">
 <summary>Return a new array with a new item inserted before the given index.</summary>

 <param name="index">The index where the item should be inserted.</param>
 <param name="value">The value to insert.</param>
 <param name="source">The input array.</param>
 
 <returns>The result array.</returns>

 <exception cref="T:System.ArgumentException">Thrown when index is below 0 or greater than source.Length.</exception>

 <example id="insertAt-1">
 <code>
 let inputs = [| 0; 1; 2 |]

 inputs |> Array.insertAt 1 9
 </code>
 Evaluates to <c>[| 0; 9; 1; 2 |]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.UpdateAt``1(System.Int32,``0,``0[])">
 <summary>Return a new array with the item at a given index set to the new value.</summary>

 <param name="index">The index of the item to be replaced.</param>
 <param name="value">The new value.</param>
 <param name="source">The input array.</param>
 
 <returns>The result array.</returns>

 <exception cref="T:System.ArgumentException">Thrown when index is outside 0..source.Length - 1</exception>

 <example id="updateAt-1">
 <code>
 let inputs = [| 0; 1; 2 |]

 inputs |> Array.updateAt 1 9
 </code>
 Evaluates to <c>[| 0; 9; 2 |]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.RemoveManyAt``1(System.Int32,System.Int32,``0[])">
 <summary>Return a new array with the number of items starting at a given index removed.</summary>

 <param name="index">The index of the item to be removed.</param>
 <param name="count">The number of items to remove.</param>
 <param name="source">The input array.</param>
 
 <returns>The result array.</returns>

 <exception cref="T:System.ArgumentException">Thrown when index is outside 0..source.Length - count</exception>

 <example id="removeManyAt-1">
 <code>
 let inputs = [| 0; 1; 2; 3 |]

 inputs |> Array.removeManyAt 1 2
 </code>
 Evaluates to <c>[| 0; 3 |]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.RemoveAt``1(System.Int32,``0[])">
 <summary>Return a new array with the item at a given index removed.</summary>

 <param name="index">The index of the item to be removed.</param>
 <param name="source">The input array.</param>
 
 <returns>The result array.</returns>
 
 <exception cref="T:System.ArgumentException">Thrown when index is outside 0..source.Length - 1</exception>
 
 <example id="removeAt-1">
 <code>
 let inputs = [| 0; 1; 2 |]

 inputs |> Array.removeAt 1
 </code>
 Evaluates to <c>[| 0; 2 |]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Zip3``3(``0[],``1[],``2[])">
 <summary>Combines three arrays into an array of pairs. The three arrays must have equal lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>

 <param name="array1">The first input array.</param>
 <param name="array2">The second input array.</param>
 <param name="array3">The third input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when any of the input arrays are null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input arrays differ in length.</exception>

 <returns>The array of tupled elements.</returns>

 <example id="zip3-1">
 <code lang="fsharp">
 let numbers = [| 1; 2 |]
 let names = [| "one"; "two" |]
 let roman = [| "I"; "II" |]

 Array.zip3 numbers names roman
 </code>
 Evaluates to <c>[|(1, "one", "I"); (2, "two", "II")|]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Zip``2(``0[],``1[])">
 <summary>Combines the two arrays into an array of pairs. The two arrays must have equal lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>

 <param name="array1">The first input array.</param>
 <param name="array2">The second input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input arrays differ in length.</exception>

 <returns>The array of tupled elements.</returns>

 <example id="zip-1">
 <code lang="fsharp">
 let numbers = [|1; 2|]
 let names = [|"one"; "two"|]

 Array.zip numbers names
 </code>
 Evaluates to <c>[| (1, "one"); (2, "two") |]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Windowed``1(System.Int32,``0[])">
 <summary>Returns an array of sliding windows containing elements drawn from the input
 array. Each window is returned as a fresh array.</summary>

 <param name="windowSize">The number of elements in each window.</param>
 <param name="array">The input array.</param>

 <returns>The result array.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when windowSize is not positive.</exception>
 
 <example id="windowed-1">
 <code lang="fsharp">
 let inputs = [| 1; 2; 3; 4; 5 |]

 inputs |> Array.windowed 3
 </code>
 Evaluates to <c>[|[|1; 2; 3|]; [|2; 3; 4|]; [|3; 4; 5|]|]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Where``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>Returns a new array containing only the elements of the array
 for which the given predicate returns "true".</summary>

 <param name="predicate">The function to test the input elements.</param>
 <param name="array">The input array.</param>

 <returns>An array containing the elements for which the given predicate returns true.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <remarks>This is identical to <c>Array.filter</c>.</remarks>

 <example id="where-1">Select only the even numbers:
 <code lang="fsharp">
 let inputs = [| 1; 2; 3; 4 |]

 inputs |> Array.where (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>[| 2; 4 |]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Unzip3``3(System.Tuple{``0,``1,``2}[])">
 <summary>Splits an array of triples into three arrays.</summary>

 <param name="array">The input array.</param>

 <returns>The tuple of three arrays.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 
 <example id="unzip3-1">
 <code lang="fsharp">
 let inputs = [| (1, "one", "I"); (2, "two", "II") |]

 let numbers, names, roman = inputs |> Array.unzip3
 </code>
 Evaluates <c>numbers</c> to <c>[|1; 2|]</c>, <c>names</c> to <c>[|"one"; "two"|]</c> and <c>roman</c> to <c>[|"I"; "II"|]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Unzip``2(System.Tuple{``0,``1}[])">
 <summary>Splits an array of pairs into two arrays.</summary>

 <param name="array">The input array.</param>

 <returns>The two arrays.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="unzip-1">
 <code lang="fsharp">
 let inputs = [| (1, "one"); (2, "two") |]

 let numbers, names = inputs |> Array.unzip
 </code>
 Evaluates <c>numbers</c> to <c>[|1; 2|]</c> and <c>names</c> to <c>[|"one"; "two"|]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Unfold``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``0,``1}}},``1)">
 <summary>Returns an array that contains the elements generated by the given computation.
 The generator is repeatedly called to build the list until it returns `None`.
 The given initial <c>state</c> argument is passed to the element generator.</summary>

 <param name="generator">A function that takes in the current state and returns an option tuple of the next
 element of the array and the next state value.</param>
 <param name="state">The initial state value.</param>

 <returns>The result array.</returns>

 <example id="unfold-1">
 <code lang="fsharp">
 1 |> Array.unfold (fun state -> if state > 100 then None else Some (state, state * 2))
 </code>
 Evaluates to <c>[| 1; 2; 4; 8; 16; 32; 64 |]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.TryFindIndexBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>Returns the index of the last element in the array
 that satisfies the given predicate.</summary>

 <param name="predicate">The function to test the input elements.</param>
 <param name="array">The input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <returns>The index of the last element that satisfies the predicate, or None.</returns>

 <example id="tryfindindexback-1">Try to find the index of the first even number from the back:
 <code lang="fsharp">
 let inputs = [| 1; 2; 3; 4; 5 |]

 inputs |> Array.tryFindIndexBack (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>Some 3</c>
 </example>

 <example id="tryfindindexback-2">Try to find the index of the first even number from the back:
 <code lang="fsharp">
 let inputs = [| 1; 3; 5; 7 |]

 inputs |> Array.tryFindIndexBack (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>None</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.TryItem``1(System.Int32,``0[])">
 <summary>Tries to find the nth element in the array.
 Returns <c>None</c> if index is negative or the input array does not contain enough elements.</summary>

 <param name="index">The index of element to retrieve.</param>
 <param name="array">The input array.</param>

 <returns>The nth element of the array or <c>None</c>.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="tryitem-1">
 <code lang="fsharp">
 let inputs = [| "a"; "b"; "c" |]

 inputs |> Array.tryItem 1
 </code>
 Evaluates to <c>Some "b"</c>.
 </example>

 <example id="tryitem-2">
 <code lang="fsharp">
 let inputs = [| "a"; "b"; "c" |]

 inputs |> Array.tryItem 4
 </code>
 Evaluates to <c>None</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.TryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>Returns the index of the first element in the array
 that satisfies the given predicate.</summary>

 <param name="predicate">The function to test the input elements.</param>
 <param name="array">The input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <returns>The index of the first element that satisfies the predicate, or None.</returns>

 <example id="tryfindindex-1">Try to find the index of the first even number:
 <code lang="fsharp">
 let inputs = [| 1; 2; 3; 4; 5 |]

 inputs |> Array.tryFindIndex (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>Some 1</c>
 </example>

 <example id="tryfindindex-2">Try to find the index of the first even number:
 <code lang="fsharp">
 let inputs = [| 1; 3; 5; 7 |]

 inputs |> Array.tryFindIndex (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>None</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.TryFindBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>Returns the last element for which the given function returns True.
 Return None if no such element exists.</summary>

 <param name="predicate">The function to test the input elements.</param>
 <param name="array">The input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <returns>The last element that satisfies the predicate, or None.</returns>

 <example id="tryfindback-1">Try to find the first even number from the back:
 <code lang="fsharp">
 let inputs = [| 1; 2; 3; 4; 5 |]

 inputs |> Array.tryFindBack (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>Some 4</c>
 </example>

 <example id="tryfindback-2">Try to find the first even number from the back:
 <code lang="fsharp">
 let inputs = [| 1; 5; 3 |]

 inputs |> Array.tryFindBack (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>None</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.TryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>Returns the first element for which the given function returns True.
 Return None if no such element exists.</summary>

 <param name="predicate">The function to test the input elements.</param>
 <param name="array">The input array.</param>

 <returns>The first element that satisfies the predicate, or None.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="tryfind-1">Try to find the first even number:
 <code lang="fsharp">
 let inputs = [| 1; 2; 3 |]

 inputs |> Array.tryFind (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>Some 2</c>
 </example>

 <example id="tryfind-2">Try to find the first even number:
 <code lang="fsharp">
 let inputs = [| 1; 5; 3 |]

 inputs |> Array.tryFind (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>None</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Truncate``1(System.Int32,``0[])">
 <summary>Returns at most N elements in a new array.</summary>

 <param name="count">The maximum number of items to return.</param>
 <param name="array">The input array.</param>

 <returns>The result array.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="truncate-1">
 <code lang="fsharp">
 let inputs = [| "a"; "b"; "c"; "d" |]

 inputs |> Array.truncate 2
 </code>
 Evaluates to <c>[| "a"; "b" |]</c>
 </example>

 <example id="truncate-2">
 <code lang="fsharp">
 let inputs = [| "a"; "b"; "c"; "d" |]

 inputs |> Array.truncate 6
 </code>
 Evaluates to <c>[| "a"; "b"; "c"; "d" |]</c>
 </example>

 <example id="truncate-3">
 <code lang="fsharp">
 let inputs = [| "a"; "b"; "c"; "d" |]

 inputs |> Array.truncate 0
 </code>
 Evaluates to <c>[| |]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Transpose``1(System.Collections.Generic.IEnumerable{``0[]})">
 <summary>Returns the transpose of the given sequence of arrays.</summary>

 <param name="arrays">The input sequence of arrays.</param>

 <returns>The transposed array.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input arrays differ in length.</exception>

 <example id="transpose-1">
 <code lang="fsharp">
 let inputs =
     [| [| 10; 20; 30 |]
        [| 11; 21; 31 |] |]

 inputs |> Array.transpose
 </code>
 Evaluates to <c>[|[|10; 11|]; [|20; 21|]; [|30; 31|]|]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ToSeq``1(``0[])">
 <summary>Views the given array as a sequence.</summary>

 <param name="array">The input array.</param>

 <returns>The sequence of array elements.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="toseq-1">
 <code lang="fsharp">
 let inputs = [| 1; 2; 5 |]

 inputs |> Array.toSeq
 </code>
 Evaluates to <c>seq { 1; 2; 5 }</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ToList``1(``0[])">
 <summary>Builds a list from the given array.</summary>

 <param name="array">The input array.</param>

 <returns>The list of array elements.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="tolist-1">
 <code lang="fsharp">
 let inputs = [| 1; 2; 5 |]

 inputs |> Array.toList
 </code>
 Evaluates to <c>[ 1; 2; 5 ]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Tail``1(``0[])">
 <summary>Returns a new array containing the elements of the original except the first element.</summary>

 <param name="array">The input array.</param>

 <exception cref="T:System.ArgumentException">Thrown when the array is empty.</exception>
 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <returns>A new array containing the elements of the original except the first element.</returns>

 <example id="tail-1">
 <code lang="fsharp">
 let inputs = [| "a"; "bb"; "ccc" |]

 inputs |> Array.tail
 </code>
 Evaluates to <c>[| "bb"; "ccc" |]</c>
 </example>

</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.TakeWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>Returns an array that contains all elements of the original array while the 
 given predicate returns True, and then returns no further elements.</summary>

 <param name="predicate">A function that evaluates to false when no more items should be returned.</param>
 <param name="array">The input array.</param>

 <returns>The result array.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="takewhile-1">
 <code lang="fsharp">
 let inputs = [| "a"; "bb"; "ccc"; "d" |]

 inputs |> Array.takeWhile (fun x -> x.Length &lt; 3)
 </code>
 Evaluates to <c>[| "a"; "bb" |]</c>
 </example>

</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Take``1(System.Int32,``0[])">
 <summary>Returns the first N elements of the array.</summary>
 <remarks>Throws <c>InvalidOperationException</c>
 if the count exceeds the number of elements in the array. <c>Array.truncate</c>
 returns as many items as the array contains instead of throwing an exception.</remarks>

 <param name="count">The number of items to take.</param>
 <param name="array">The input array.</param>

 <returns>The result array.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input array is empty.</exception>
 <exception cref="T:System.InvalidOperationException">Thrown when count exceeds the number of elements
 in the list.</exception>

 <example id="take-1">
 <code lang="fsharp">
 let inputs = [| "a"; "b"; "c"; "d" |]

 inputs |> Array.take 2
 </code>
 Evaluates to <c>[| "a"; "b" |]</c>
 </example>

 <example id="take-2">
 <code lang="fsharp">
 let inputs = [| "a"; "b"; "c"; "d" |]

 inputs |> Array.take 6
 </code>
 Throws <c>InvalidOperationException</c>.
 </example>

 <example id="take-3">
 <code lang="fsharp">
 let inputs = [| "a"; "b"; "c"; "d" |]

 inputs |> Array.take 0
 </code>
 Evaluates to <c>[| |]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SumBy``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
 <summary>Returns the sum of the results generated by applying the function to each element of the array.</summary>

 <param name="projection">The function to transform the array elements into the type to be summed.</param>
 <param name="array">The input array.</param>

 <returns>The resulting sum.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 
 <example id="sumby-1">
 <code lang="fsharp">
 let input = [| "aa"; "bbb"; "cc" |]

 input |> Array.sumBy (fun s -> s.Length)
 </code>
 Evaluates to <c>7</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Sum``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0[])">
 <summary>Returns the sum of the elements in the array.</summary>

 <param name="array">The input array.</param>

 <returns>The resulting sum.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 
 <example id="sum-1">
 <code lang="fsharp">
 let input = [| 1; 5; 3; 2 |]

 input |> Array.sum
 </code>
 Evaluates to <c>11</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SortByDescending``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
 <summary>Sorts the elements of an array, in descending order, using the given projection for the keys and returning a new array. 
 Elements are compared using <see cref="M:Microsoft.FSharp.Core.Operators.compare"/>.</summary>

 <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using <see cref="M:Microsoft.FSharp.Collections.SeqModule.Sort"/>.</remarks>

 <param name="projection">The function to transform array elements into the type that is compared.</param>
 <param name="array">The input array.</param>

 <returns>The sorted array.</returns>
 
 <example id="sortbydescending-1">
 <code lang="fsharp">
 let input = [| "a"; "bbb"; "cccc"; "dd" |]

 input |> Array.sortByDescending (fun s -> s.Length)
 </code>
 Evaluates to <c>[|"cccc"; "bbb"; "dd"; "a"|]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SortDescending``1(``0[])">
 <summary>Sorts the elements of an array, in descending order, returning a new array. Elements are compared using <see cref="M:Microsoft.FSharp.Core.Operators.compare"/>. </summary>

 <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using <see cref="M:Microsoft.FSharp.Collections.SeqModule.Sort"/>.</remarks>

 <param name="array">The input array.</param>

 <returns>The sorted array.</returns>
 
 <example id="sortdescending-1">
 <code lang="fsharp">
 let input = [| 8; 4; 3; 1; 6; 1 |]

 input |> Array.sortDescending
 </code>
 Evaluates to <c>[| 8; 6; 4; 3; 1; 1 |]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SplitAt``1(System.Int32,``0[])">
 <summary>Splits an array into two arrays, at the given index.</summary>

 <param name="index">The index at which the array is split.</param>
 <param name="array">The input array.</param>

 <returns>The two split arrays.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="T:System.InvalidOperationException">Thrown when split index exceeds the number of elements
 in the array.</exception>
 
 <example id="splitat-1">
 <code lang="fsharp">
 let input = [| 8; 4; 3; 1; 6; 1 |]

 let front, back = input |> Array.splitAt 3
 </code>
 Evaluates <c>front</c> to <c>[|8; 4; 3|]</c> and <c>back</c> to <c>[|1; 6; 1|]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SortInPlace``1(``0[])">
 <summary>Sorts the elements of an array by mutating the array in-place, using the given comparison function. 
 Elements are compared using <see cref="M:Microsoft.FSharp.Core.Operators.compare"/>.</summary>

 <param name="array">The input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 
 <example id="sortinplace-1">
 <code lang="fsharp">
 let array = [| 8; 4; 3; 1; 6; 1 |]

 Array.sortInPlace array
 </code>
 After evaluation <c>array</c> contains <c>[| 1; 1; 3; 4; 6; 8 |]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SortInPlaceWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},``0[])">
 <summary>Sorts the elements of an array by mutating the array in-place, using the given comparison function as the order.</summary>

 <param name="comparer">The function to compare pairs of array elements.</param>
 <param name="array">The input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 
 <example id="sortinplacewith-1"> The following sorts entries using a comparison function that compares string lengths then index numbers:
 <code lang="fsharp">
 let compareEntries (n1: int, s1: string) (n2: int, s2: string) =
     let c = compare s1.Length s2.Length
     if c &lt;> 0 then c else
     compare n1 n2

 let array = [| (0,"aa"); (1,"bbb"); (2,"cc"); (3,"dd") |]

 array |> Array.sortInPlaceWith compareEntries
 </code>
 After evaluation <c>array</c> contains <c>[|(0, "aa"); (2, "cc"); (3, "dd"); (1, "bbb")|]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SortInPlaceBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
 <summary>Sorts the elements of an array by mutating the array in-place, using the given projection for the keys. 
 Elements are compared using <see cref="M:Microsoft.FSharp.Core.Operators.compare"/>.</summary>

 <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using <see cref="M:Microsoft.FSharp.Collections.SeqModule.Sort"/>.</remarks>

 <param name="projection">The function to transform array elements into the type that is compared.</param>
 <param name="array">The input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 
 <example id="sortinplaceby-1">
 <code lang="fsharp">
 let array = [| "a"; "bbb"; "cccc"; "dd" |]

 array |> Array.sortInPlaceBy (fun s -> s.Length)
 </code>
 After evaluation <c>array</c> contains <c>[|"a"; "dd"; "bbb"; "cccc"|]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SortWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},``0[])">
 <summary>Sorts the elements of an array, using the given comparison function as the order, returning a new array.</summary>

 <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using <see cref="M:Microsoft.FSharp.Collections.SeqModule.Sort"/>.</remarks>

 <param name="comparer">The function to compare pairs of array elements.</param>
 <param name="array">The input array.</param>

 <returns>The sorted array.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 
 <example id="sortwith-1">Sort an array of pairs using a comparison function that compares string lengths then index numbers:
 <code lang="fsharp">
 let compareEntries (n1: int, s1: string) (n2: int, s2: string) =
     let c = compare s1.Length s2.Length
     if c &lt;> 0 then c else
     compare n1 n2

 let input = [| (0,"aa"); (1,"bbb"); (2,"cc"); (3,"dd") |]

 input |> Array.sortWith compareEntries
 </code>
 Evaluates to <c>[|(0, "aa"); (2, "cc"); (3, "dd"); (1, "bbb")|]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SortBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
 <summary>Sorts the elements of an array, using the given projection for the keys and returning a new array. 
 Elements are compared using <see cref="M:Microsoft.FSharp.Core.Operators.compare"/>.</summary>

 <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using <see cref="M:Microsoft.FSharp.Collections.SeqModule.Sort"/>.</remarks>

 <param name="projection">The function to transform array elements into the type that is compared.</param>
 <param name="array">The input array.</param>

 <returns>The sorted array.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 
 <example id="sortby-1">
 <code lang="fsharp">
 let input = [| "a"; "bbb"; "cccc"; "dd" |]

 input |> Array.sortBy (fun s -> s.Length)
 </code>
 Evaluates to <c>[|"a"; "dd"; "bbb"; "cccc"|]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Sort``1(``0[])">
 <summary>Sorts the elements of an array, returning a new array. Elements are compared using <see cref="M:Microsoft.FSharp.Core.Operators.compare"/>. </summary>

 <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using <see cref="M:Microsoft.FSharp.Collections.SeqModule.Sort"/>.</remarks>

 <param name="array">The input array.</param>

 <returns>The sorted array.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 
 <example id="sort-1">
 <code lang="fsharp">
 let input = [| 8; 4; 3; 1; 6; 1 |]

 Array.sort input
 </code>
 Evaluates to <c>[| 1; 1 3; 4; 6; 8 |]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.GetSubArray``1(``0[],System.Int32,System.Int32)">
 <summary>Builds a new array that contains the given subrange specified by
 starting index and length.</summary>

 <param name="array">The input array.</param>
 <param name="startIndex">The index of the first element of the sub array.</param>
 <param name="count">The length of the sub array.</param>

 <returns>The created sub array.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when either startIndex or count is negative,
 or when there aren't enough elements in the input array.</exception>

 <remarks>
 Slicing syntax is generally preferred, e.g.
 <code lang="fsharp">
 let input = [| 0; 1; 2; 3; 4; 5 |]

 input.[2..4]
 </code>
 </remarks>

 <example id="sub-1">
 <code lang="fsharp">
 let input = [| 0; 1; 2; 3; 4; 5 |]

 Array.sub input 2 3
 </code>
 Evaluates to <c>[| 2; 3; 4 |]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SkipWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>Bypasses elements in an array while the given predicate returns True, and then returns
 the remaining elements in a new array.</summary>

 <param name="predicate">A function that evaluates an element of the array to a boolean value.</param>
 <param name="array">The input array.</param>

 <returns>The created sub array.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="skipwhile-1">
 <code lang="fsharp">
 let inputs = [| "a"; "bbb"; "cc"; "d" |]

 inputs |> Array.skipWhile (fun x -> x.Length &lt; 3)
 </code>
 Evaluates to <c>[|"bbb"; "cc"; "d"|]</c>
 </example>

</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Skip``1(System.Int32,``0[])">
 <summary>Builds a new array that contains the elements of the given array, excluding the first N elements.</summary>

 <param name="count">The number of elements to skip. If negative the full array will be returned as a copy.</param>
 <param name="array">The input array.</param>

 <returns>A copy of the input array, after removing the first N elements.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when count exceeds the number of 
 elements in the array.</exception>

 <example id="skip-1">
 <code lang="fsharp">
 let inputs = [| "a"; "b"; "c"; "d" |]

 inputs |> Array.skip 2
 </code>
 Evaluates to <c>[| "c"; "d" |]</c>
 </example>

 <example id="skip-2">
 <code lang="fsharp">
 let inputs = [| "a"; "b"; "c"; "d" |]

 inputs |> Array.skip 5
 </code>
 Throws <c>ArgumentException</c>.
 </example>

 <example id="skip-3">
 <code lang="fsharp">
 let inputs = [| "a"; "b"; "c"; "d" |]

 inputs |> Array.skip -1
 </code>
 Evaluates to <c>[| "a"; "b"; "c"; "d" |]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Set``1(``0[],System.Int32,``0)">
 <summary>Sets an element of an array.</summary>

 <param name="array">The input array.</param>
 <param name="index">The input index.</param>
 <param name="value">The input value.</param>

 <exception cref="T:System.NullReferenceException">Thrown when the input array is null.</exception>
 <exception cref="T:System.IndexOutOfRangeException">Thrown when the index is negative or the input array does not contain enough elements.</exception>

 <example id="set-1">
 <code lang="fsharp">
 let inputs = [| "a"; "b"; "c" |]

 Array.set inputs 1 "B"
 </code>
 After evaluation <c>inputs</c> contains <c>[| "a"; "B"; "c" |]</c>
 </example>

 <example id="set-2">
 <code lang="fsharp">
 let inputs = [| "a"; "b"; "c" |]

 Array.set inputs 4 "d"
 </code>
 Throws <c>IndexOutOfRangeException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Singleton``1(``0)">
 <summary>Returns an array that contains one item only.</summary>

 <param name="value">The input item.</param>

 <returns>The result array of one item.</returns>
 
 <example id="singleton-1">
 <code lang="fsharp">
 Array.singleton 7
 </code>
 Evaluates to <c>[| 7 |]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ScanBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``0[],``1)">
 <summary>Like <c>foldBack</c>, but return both the intermediary and final results.</summary>

 <param name="folder">The function to update the state given the input elements.</param>
 <param name="array">The input array.</param>
 <param name="state">The initial state.</param>

 <returns>The array of state values.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 
 <example id="scan-1">Apply a list charges from back to front, and collect the running balances as each is applied:
 <code lang="fsharp">
 type Charge =
     | In of int
     | Out of int

 let inputs = [| In 1; Out 2; In 3 |]

 (inputs, 0) ||> Array.scanBack (fun charge acc ->
     match charge with
     | In i -> acc + i
     | Out o -> acc - o)
 </code>
 Evaluates to <c> [|2; 1; 3; 0|]</c> by processing each input from back to front. Note <c>0</c> is the intial
 state, <c>3</c> the next state, <c>1</c> the next state, and <c>2</c> the final state.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Scan``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1,``0[])">
 <summary>Like <c>fold</c>, but return the intermediary and final results.</summary>

 <param name="folder">The function to update the state given the input elements.</param>
 <param name="state">The initial state.</param>
 <param name="array">The input array.</param>

 <returns>The array of state values.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 
 <example id="scan-1">Apply a list charges and collect the running balances as each is applied:
 <code lang="fsharp">
 type Charge =
     | In of int
     | Out of int

 let inputs = [| In 1; Out 2; In 3 |]

 (0, inputs) ||> Array.scan (fun acc charge ->
     match charge with
     | In i -> acc + i
     | Out o -> acc - o)
 </code>
 Evaluates to <c>[|0; 1; -1; 2|]</c>. Note <c>0</c> is the intial
 state, <c>1</c> the next state, <c>-1</c> the next state, and <c>2</c> the final state.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Reverse``1(``0[])">
 <summary>Returns a new array with the elements in reverse order.</summary>

 <param name="array">The input array.</param>

 <returns>The reversed array.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 
 <example id="rev-1">
 <code lang="fsharp">
 Array.rev [| 0; 1; 2 |]
 </code>
 Evaluates to <c>[| 2; 1; 0 |]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Replicate``1(System.Int32,``0)">
 <summary>Creates an array by replicating the given initial value.</summary>

 <param name="count">The number of elements to replicate.</param>
 <param name="initial">The value to replicate</param>

 <returns>The generated array.</returns>

 <exception cref="T:System.ArgumentException">Thrown when count is negative.</exception>
 
 <example id="replicate-1">
 <code lang="fsharp">
 Array.replicate 3 "a"
 </code>
 Evaluates to <c>[| "a"; "a"; "a" |]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ReduceBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0[])">
 <summary>Applies a function to each element of the array, starting from the end, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
 then computes <c>f i0 (...(f iN-1 iN))</c>.</summary>

 <param name="reduction">A function that takes in the next-to-last element of the list and the
 current accumulated result to produce the next accumulated result.</param>
 <param name="array">The input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input array is empty.</exception>

 <returns>The final result of the reductions.</returns>
 
 <example id="reduceback-1">
 <code lang="fsharp">
 let inputs = [| 1; 3; 4; 2 |]

 inputs |> Array.reduceBack (fun a b -> a + b * 10)
 </code>
 Evaluates to <c>2431</c>, by computing <c>1 + (3 + (4 + 2 * 10) * 10) * 10</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0[])">
 <summary>Applies a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
 then computes <c>f (... (f i0 i1)...) iN</c>.
 Raises ArgumentException if the array has size zero.</summary>

 <param name="reduction">The function to reduce a pair of elements to a single element.</param>
 <param name="array">The input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input array is empty.</exception>

 <returns>The final result of the reductions.</returns>
 
 <example id="reduce-1">
 <code lang="fsharp">
 let inputs = [| 1; 3; 4; 2 |]

 inputs |> Array.reduce (fun a b -> a * 10 + b)
 </code>
 Evaluates to <c>1342</c>, by computing <c>((1 * 10 + 3) * 10 + 4) * 10 + 2</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Permute``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32},``0[])">
 <summary>Returns an array with all elements permuted according to the
 specified permutation.</summary>

 <param name="indexMap">The function that maps input indices to output indices.</param>
 <param name="array">The input array.</param>

 <returns>The output array.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when indexMap does not produce a valid permutation.</exception>
 
 <example id="permute-1">
 <code lang="fsharp">
 let inputs = [| 1; 2; 3; 4 |]

 inputs |> Array.permute (fun x -> (x + 1) % 4)
 </code>
 Evaluates to <c>[|4; 1; 2; 3|]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>Splits the collection into two collections, containing the 
 elements for which the given predicate returns "true" and "false"
 respectively.</summary>

 <param name="predicate">The function to test the input elements.</param>
 <param name="array">The input array.</param>

 <returns>A pair of arrays. The first containing the elements the predicate evaluated to true,
 and the second containing those evaluated to false.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 
 <example id="partition-1">
 <code lang="fsharp">
 let inputs = [| 1; 2; 3; 4 |]

 inputs |> Array.partition (fun x -> x % 2 = 0)
 </code>
 Evaluates to <c>([|2; 4|], [|1; 3|])</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Pairwise``1(``0[])">
 <summary>Returns an array of each element in the input array and its predecessor, with the
 exception of the first element which is only returned as the predecessor of the second element.</summary>

 <param name="array">The input array.</param>

 <returns>The result array.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 
 <example id="pairwise-1">
 <code lang="fsharp">
 let inputs = [| 1; 2; 3; 4 |]

 inputs |> Array.pairwise
 </code>
 Evaluates to <c>[|(1, 2); (2, 3); (3, 4)|]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.OfSeq``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a new array from the given enumerable object.</summary>

 <param name="source">The input sequence.</param>

 <returns>The array of elements from the sequence.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>
 
 <example id="ofseq-1">
 <code lang="fsharp">
 let inputs = seq { 1; 2; 5 }

 inputs |> Array.ofSeq
 </code>
 Evaluates to <c>[| 1; 2; 5 |]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Builds an array from the given list.</summary>

 <param name="list">The input list.</param>

 <returns>The array of elements from the list.</returns>
 
 <example id="oflist-1">
 <code lang="fsharp">
 let inputs = [ 1; 2; 5 ]

 inputs |> Array.ofList
 </code>
 Evaluates to <c>[| 1; 2; 5 |]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.MinBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
 <summary>Returns the lowest of all elements of the array, compared via Operators.min on the function result.</summary>

 <remarks>Throws ArgumentException for empty arrays.</remarks>

 <param name="projection">The function to transform the elements into a type supporting comparison.</param>
 <param name="array">The input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input array is empty.</exception>

 <returns>The minimum element.</returns>

 <example id="minby-1">
 <code lang="fsharp">
 let inputs = [| "aaa"; "b"; "cccc" |]

 inputs |> Array.minBy (fun s -> s.Length)
 </code>
 Evaluates to <c>"b"</c>
 </example>

 <example id="minby-2">
 <code lang="fsharp">
 let inputs: string[]= [| |]

 inputs |> Array.minBy (fun s -> s.Length)
 </code>
 Throws <c>System.ArgumentException</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Min``1(``0[])">
 <summary>Returns the lowest of all elements of the array, compared via Operators.min.</summary>

 <remarks>Throws ArgumentException for empty arrays</remarks>

 <param name="array">The input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input array is empty.</exception>

 <returns>The minimum element.</returns>

 <example id="min-1">
 <code lang="fsharp">
 let inputs = [| 10; 12; 11 |]

 inputs |> Array.min
 </code>
 Evaluates to <c>10</c>
 </example>

 <example id="min-2">
 <code lang="fsharp">
 let inputs: int[]= [| |]

 inputs |> Array.min
 </code>
 Throws <c>System.ArgumentException</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.MaxBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
 <summary>Returns the greatest of all elements of the array, compared via Operators.max on the function result.</summary>

 <remarks>Throws ArgumentException for empty arrays.</remarks>

 <param name="projection">The function to transform the elements into a type supporting comparison.</param>
 <param name="array">The input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input array is empty.</exception>

 <returns>The maximum element.</returns>

 <example id="maxby-1">
 <code lang="fsharp">
 let inputs = [| "aaa"; "b"; "cccc" |]

 inputs |> Array.maxBy (fun s -> s.Length)
 </code>
 Evaluates to <c>"cccc"</c>
 </example>

 <example id="maxby-2">
 <code lang="fsharp">
 let inputs: string[]= [| |]

 inputs |> Array.maxBy (fun s -> s.Length)
 </code>
 Throws <c>System.ArgumentException</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Max``1(``0[])">
 <summary>Returns the greatest of all elements of the array, compared via Operators.max on the function result.</summary>

 <remarks>Throws ArgumentException for empty arrays.</remarks>

 <param name="array">The input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input array is empty.</exception>

 <returns>The maximum element.</returns>

 <example id="max-1">
 <code lang="fsharp">
 let inputs = [| 10; 12; 11 |]

 inputs |> Array.max
 </code>
 Evaluates to <c>12</c>
 </example>

 <example id="max-2">
 <code lang="fsharp">
 let inputs: int[]= [| |]

 inputs |> Array.max
 </code>
 Throws <c>System.ArgumentException</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``0[])">
 <summary>Builds a new array whose elements are the results of applying the given function
 to each of the elements of the array. The integer index passed to the
 function indicates the index of element being transformed, starting at zero.</summary>

 <param name="mapping">The function to transform elements and their indices.</param>
 <param name="array">The input array.</param>

 <returns>The array of transformed elements.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="mapi-1">
 <code lang="fsharp">
 let inputs = [| 10; 10; 10 |]

 inputs |> Array.mapi (fun i x -> i + x)
 </code>
 Evaluates to <c>[| 10; 11; 12 |]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.MapIndexed2``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},``0[],``1[])">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise, also passing the index of 
 the elements. The two input arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>

 <param name="mapping">The function to transform pairs of input elements and their indices.</param>
 <param name="array1">The first input array.</param>
 <param name="array2">The second input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input arrays differ in length.</exception>

 <returns>The array of transformed elements.</returns>

 <example id="mapi2-1">
 <code lang="fsharp">
 let inputs1 = [| "a"; "bad"; "good" |]
 let inputs2 = [| 0; 2; 1 |]

 (inputs1, inputs2) ||> Array.mapi2 (fun i x y -> i, x[y])
 </code>
 Evaluates to <c>[|(0, 'a'); (1, 'd'); (2, 'o')|]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Map3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},``0[],``1[],``2[])">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding triples from the three collections. The three input
 arrays must have the same length, otherwise an <c>ArgumentException</c> is
 raised.</summary>

 <param name="mapping">The function to transform the pairs of the input elements.</param>
 <param name="array1">The first input array.</param>
 <param name="array2">The second input array.</param>
 <param name="array3">The third input array.</param>

 <exception cref="T:System.ArgumentException">Thrown when the input arrays differ in length.</exception>
 <exception cref="T:System.ArgumentNullException">Thrown when any of the input arrays is null.</exception>

 <returns>The array of transformed elements.</returns>

 <example id="map3-1">
 <code lang="fsharp">
 let inputs1 = [| "a"; "t"; "ti" |]
 let inputs2 = [| "l"; "h"; "m" |]
 let inputs3 = [| "l"; "e"; "e" |]

 (inputs1, inputs2, inputs3) |||> Array.map3 (fun x y z -> x + y + z)
 </code>
 Evaluates to <c>[| "all"; "the"; "time" |]</c>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.MapFoldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}}},``0[],``1)">
 <summary>Combines map and foldBack. Builds a new array whose elements are the results of applying the given function
 to each of the elements of the input array. The function is also used to accumulate a final value.</summary>

 <param name="mapping">The function to transform elements from the input array and accumulate the final value.</param>
 <param name="array">The input array.</param>
 <param name="state">The initial state.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <returns>The array of transformed elements, and the final accumulated value.</returns>

 <example id="mapfold-1">Accumulate the charges from back to front, and double them as well
 <code lang="fsharp">
 type Charge =
     | In of int
     | Out of int

 let inputs = [| In 1; Out 2; In 3 |]

 let newCharges, balance =
     (inputs, 0) ||> Array.mapFoldBack (fun charge acc ->
         match charge with
         | In i -> In (i*2), acc + i
         | Out o -> Out (o*2), acc - o)
 </code>
 Evaluates <c>newCharges</c> to <c>[|In 2; Out 4; In 6|]</c> and <c>balance</c> to <c>2</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.MapFold``3(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``2,``1}}},``1,``0[])">
 <summary>Combines map and fold. Builds a new array whose elements are the results of applying the given function
 to each of the elements of the input array. The function is also used to accumulate a final value.</summary>

 <param name="mapping">The function to transform elements from the input array and accumulate the final value.</param>
 <param name="state">The initial state.</param>
 <param name="array">The input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <returns>The array of transformed elements, and the final accumulated value.</returns>

 <example id="mapfold-1">
 <code lang="fsharp">Accumulate the charges, and double them as well
 type Charge =
     | In of int
     | Out of int

 let inputs = [| In 1; Out 2; In 3 |]

 let newCharges, balance =
     (0, inputs) ||> Array.mapFold (fun acc charge ->
         match charge with
         | In i -> In (i*2), acc + i
         | Out o -> Out (o*2), acc - o)
 </code>
 Evaluates <c>newCharges</c> to <c>[|In 2; Out 4; In 6|]</c> and <c>balance</c> to <c>2</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0[],``1[])">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise. The two input
 arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>

 <param name="mapping">The function to transform the pairs of the input elements.</param>
 <param name="array1">The first input array.</param>
 <param name="array2">The second input array.</param>

 <exception cref="T:System.ArgumentException">Thrown when the input arrays differ in length.</exception>
 <exception cref="T:System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>

 <returns>The array of transformed elements.</returns>

 <example id="map2-1">
 <code lang="fsharp">
 let inputs1 = [| "a"; "bad"; "good" |]
 let inputs2 = [| 0; 2; 1 |]

 (inputs1, inputs2) ||> Array.map2 (fun x y -> x[y])
 </code>
 Evaluates to <c>[| 'a'; 'd'; 'o' |]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
 <summary>Builds a new array whose elements are the results of applying the given function
 to each of the elements of the array.</summary>

 <param name="mapping">The function to transform elements of the array.</param>
 <param name="array">The input array.</param>

 <returns>The array of transformed elements.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="map-1">
 <code lang="fsharp">
 let inputs = [| "a"; "bbb"; "cc" |]

 inputs |> Array.map (fun x -> x.Length)
 </code>
 Evaluates to <c>[| 1; 3; 2 |]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.TryLast``1(``0[])">
 <summary>Returns the last element of the array.
 Return <c>None</c> if no such element exists.</summary>

 <param name="array">The input array.</param>

 <returns>The last element of the array or None.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception> 

 <example id="trylast-1">
 <code lang="fsharp">
 [| "pear"; "banana" |] |> Array.tryLast
 </code>
 Evaluates to <c>Some "banana"</c>
 </example>

 <example id="trylast-2">
 <code lang="fsharp">
 [| |] |> Array.tryLast
 </code>
 Evaluates to <c>None</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Length``1(``0[])">
 <summary>Returns the length of an array. You can also use property arr.Length.</summary>

 <param name="array">The input array.</param>

 <returns>The length of the array.</returns>

 <remarks>The notation <c>array.Length</c> is preferred.</remarks>

 <exception cref="T:System.NullReferenceException">Thrown when the input array is null.</exception>

 <example id="length-1">
 <code lang="fsharp">
 let inputs = [| "a"; "b"; "c" |]

 inputs |> Array.length
 </code>
 Evaluates to <c>3</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Item``1(System.Int32,``0[])">
 <summary>Gets an element from an array.</summary>

 <param name="index">The input index.</param>
 <param name="array">The input array.</param>

 <returns>The value of the array at the given index.</returns>

 <remarks>Normally the syntax <c>array[index]</c> is preferred.</remarks>

 <exception cref="T:System.NullReferenceException">Thrown when the input array is null.</exception>
 <exception cref="T:System.IndexOutOfRangeException">Thrown when the index is negative or the input array does not contain enough elements.</exception>

 <example id="item-1">
 <code lang="fsharp">
 let inputs = [| "a"; "b"; "c" |]

 inputs |> Array.item 1
 </code>
 Evaluates to <c>"b"</c>
 </example>

 <example id="item-2">
 <code lang="fsharp">
 let inputs = [| "a"; "b"; "c" |]

 inputs |> Array.item 4
 </code>
 Throws <c>ArgumentException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Last``1(``0[])">
 <summary>Returns the last element of the array.</summary>

 <param name="array">The input array.</param>

 <returns>The last element of the array.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input does not have any elements.</exception>

 <example id="last-1">
 <code lang="fsharp">
 [| "pear"; "banana" |] |> Array.last
 </code>
 Evaluates to <c>banana</c>
 </example>

 <example id="last-2">
 <code lang="fsharp">
 [| |] |> Array.last
 </code>
 Throws <c>ArgumentException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.IterateIndexed2``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}},``0[],``1[])">
 <summary>Applies the given function to pair of elements drawn from matching indices in two arrays,
 also passing the index of the elements. The two arrays must have the same lengths, 
 otherwise an <c>ArgumentException</c> is raised.</summary>

 <param name="action">The function to apply to each index and pair of elements.</param>
 <param name="array1">The first input array.</param>
 <param name="array2">The second input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input arrays differ in length.</exception>

 <example id="iteri2-1">
 <code lang="fsharp">
 let inputs1 = [| "a"; "b"; "c" |]
 let inputs2 = [| "banana"; "pear"; "apple" |]

 (inputs1, inputs2) ||> Array.iteri2 (fun i s1 s2 -> printfn "Index {i}: {s1} - {s2}")
 </code>
 Evaluates to <c>unit</c> and prints
 <code>
 Index 0: a - banana
 Index 1: b - pear
 Index 2: c - apple
 </code>
 in the console.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},``0[])">
 <summary>Applies the given function to each element of the array. The integer passed to the
 function indicates the index of element.</summary>

 <param name="action">The function to apply to each index and element.</param>
 <param name="array">The input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="iteri-1">
 <code lang="fsharp">
 let inputs = [| "a"; "b"; "c" |]

 inputs |> Array.iteri (fun i v -> printfn "{i}: {v}")
 </code>
 Evaluates to <c>unit</c> and prints
 <code>
 0: a
 1: b
 2: c
 </code>
 in the console.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Iterate2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},``0[],``1[])">
 <summary>Applies the given function to pair of elements drawn from matching indices in two arrays. The
 two arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>

 <param name="action">The function to apply.</param>
 <param name="array1">The first input array.</param>
 <param name="array2">The second input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input arrays differ in length.</exception>

 <example id="iter2-1">
 <code lang="fsharp">
 let inputs1 = [| "a"; "b"; "c" |]
 let inputs2 = [| 1; 2; 3 |]

 (inputs1, inputs2) ||> Array.iter2 (printfn "%s: %i")
 </code>
 Evaluates to <c>unit</c> and prints
 <code>
 a: 1
 b: 2
 c: 3
 </code>
 in the console.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},``0[])">
 <summary>Applies the given function to each element of the array.</summary>

 <param name="action">The function to apply.</param>
 <param name="array">The input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="iter-1">
 <code lang="fsharp">
 let inputs = [| "a"; "b"; "c" |]

 inputs |> Array.iter (printfn "%s")
 </code>
 Evaluates to <c>unit</c> and prints
 <code>
 a
 b
 c
 </code>
 in the console.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.IsEmpty``1(``0[])">
 <summary>Returns true if the given array is empty, otherwise false.</summary>

 <param name="array">The input array.</param>

 <returns>True if the array is empty.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="empty-1">
 <code lang="fsharp">
 [| |] |> Array.isEmpty
 </code>
 Evaluates to <c>true</c>
 </example>

 <example id="empty-2">
 <code lang="fsharp">
 [| "pear"; "banana" |] |> Array.isEmpty
 </code>
 Evaluates to <c>false</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ZeroCreate``1(System.Int32)">
 <summary>Creates an array where the entries are initially the default value Unchecked.defaultof&lt;'T&gt;.</summary>

 <param name="count">The length of the array to create.</param>

 <returns>The created array.</returns>

 <exception cref="T:System.ArgumentException">Thrown when count is negative.</exception>

 <example id="zerocreate-1">
 <code lang="fsharp">
 let arr : int[] = Array.zeroCreate 4
 </code>
 Evaluates to <c>[| 0; 0; 0; 0 |]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Initialize``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
 <summary>Creates an array given the dimension and a generator function to compute the elements.</summary>

 <param name="count">The number of elements to initialize.</param>
 <param name="initializer">The function to generate the initial values for each index.</param>

 <returns>The created array.</returns>

 <exception cref="T:System.ArgumentException">Thrown when count is negative.</exception>

 <example id="init-1">
 <code lang="fsharp">
 Array.init 4 (fun v -> v + 5)
 </code>
 Evaluates to <c>[| 5; 6; 7; 8 |]</c>
 </example>

 <example id="init-2">
 <code lang="fsharp">
 Array.init -5 (fun v -> v + 5)
 </code>
 Throws <c>ArgumentException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Indexed``1(``0[])">
 <summary>Builds a new array whose elements are the corresponding elements of the input array
 paired with the integer index (from 0) of each element.</summary>

 <param name="array">The input array.</param>

 <returns>The array of indexed elements.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="indexed-1">
 <code lang="fsharp">
 let inputs = [| "a"; "b"; "c" |]

 inputs |> Array.indexed
 </code>
 Evaluates to <c>[| (0, "a"); (1, "b"); (2, "c") |]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.GroupBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
 <summary>Applies a key-generating function to each element of an array and yields an array of 
 unique keys. Each unique key contains an array of all elements that match 
 to this key.</summary>

 <param name="projection">A function that transforms an element of the array into a comparable key.</param>
 <param name="array">The input array.</param>

 <returns>The result array.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="group-by-1">
 <code lang="fsharp">
 let inputs = [| 1; 2; 3; 4; 5 |]

 inputs |> Array.groupBy (fun n -> n % 2)
 </code>
 Evaluates to <c>[| (1, [| 1; 3; 5 |]); (0, [| 2; 4 |]) |]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Head``1(``0[])">
 <summary>Returns the first element of the array.</summary>

 <param name="array">The input array.</param>

 <returns>The first element of the array.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input array is empty.</exception>

 <example id="head-1">
 <code lang="fsharp">
 let inputs = [| "banana"; "pear" |]

 inputs |> Array.head
 </code>
 Evaluates to <c>banana</c>
 </example>

 <example id="head-2">
 <code lang="fsharp">
 [| |] |> Array.head
 </code>
 Throws <c>ArgumentException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Get``1(``0[],System.Int32)">
 <summary>Gets an element from an array.</summary>

 <param name="array">The input array.</param>
 <param name="index">The input index.</param>

 <remarks>Normally the syntax <c>array[index]</c> is preferred.</remarks>

 <returns>The value of the array at the given index.</returns>

 <exception cref="T:System.NullReferenceException">Thrown when the input array is null.</exception>
 <exception cref="T:System.IndexOutOfRangeException">Thrown when the index is negative or the input array does not contain enough elements.</exception>

 <example id="get-1">
 <code lang="fsharp">
 let inputs = [| "a"; "b"; "c" |]

 Array.get inputs 1
 </code>
 Evaluates to <c>"b"</c>
 </example>

 <example id="get-2">
 <code lang="fsharp">
 let inputs = [| "a"; "b"; "c" |]

 Array.get inputs 4
 </code>
 Throws <c>IndexOutOfRangeException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.FoldBack2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},``0[],``1[],``2)">
 <summary>Apply a function to pairs of elements drawn from the two collections, right-to-left, 
 threading an accumulator argument through the computation. The two input
 arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>

 <param name="folder">The function to update the state given the input elements.</param>
 <param name="array1">The first input array.</param>
 <param name="array2">The second input array.</param>
 <param name="state">The initial state.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input arrays differ in length.</exception>

 <returns>The final state.</returns>

 <example id="foldback2-1">
 <code lang="fsharp">Count the positives, negatives and accumulate some text from back to front:
 type Count =
   { Positive: int
     Negative: int
     Text: string }

 let inputs1 = [| -1; -2; -3 |]
 let inputs2 = [| 3; 2; 1 |]
 let initialState = {Positive = 0; Negative = 0; Text = ""}

 (inputs1, inputs2, initialState) |||> Array.foldBack2 (fun a b acc  ->
     let text = acc.Text + "(" + string a + "," + string b + ") "
     if a + b >= 0 then
         { acc with
             Positive = acc.Positive + 1
             Text = text }
     else
         { acc with
             Negative = acc.Negative + 1
             Text = text }
 )
 </code>
 Evaluates to
 <code>
 { Positive = 2
   Negative = 1
   Text = "(-3,1) (-2,2) (-1,3) " }
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Fold2``3(Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},``2,``0[],``1[])">
 <summary>Applies a function to pairs of elements drawn from the two collections, 
 left-to-right, threading an accumulator argument
 through the computation. The two input
 arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>

 <param name="folder">The function to update the state given the input elements.</param>
 <param name="state">The initial state.</param>
 <param name="array1">The first input array.</param>
 <param name="array2">The second input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input arrays differ in length.</exception>

 <returns>The final state.</returns>

 <example id="fold2-1">
 <code lang="fsharp">
 type CoinToss = Head | Tails

 let data1 = [| Tails; Head; Tails |]
 let data2 = [| Tails; Head; Head |]

 (0, data1, data2) |||> Array.fold2 (fun acc a b ->
     match (a, b) with
     | Head, Head -> acc + 1
     | Tails, Tails -> acc + 1
     | _ -> acc - 1)
 </code>
 Evaluates to <c>1</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``0[],``1)">
 <summary>Applies a function to each element of the array, starting from the end, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f i0 (...(f iN s))</c></summary>

 <param name="folder">The function to update the state given the input elements.</param>
 <param name="array">The input array.</param>
 <param name="state">The initial state.</param>

 <returns>The state object after the folding function is applied to each element of the array.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="foldback-1">
 <code lang="fsharp">
 type Count =
   { Positive: int
     Negative: int
     Text: string }

 let sequence = [| 1; 0; -1; -2; 3 |]
 let initialState = {Positive = 0; Negative = 0; Text = "" }

 (sequence, initialState) ||> Array.foldBack (fun a acc  ->
     let text = acc.Text + " " + string a
     if a >= 0 then
         { acc with
             Positive = acc.Positive + 1
             Text = text }
     else
         { acc with
             Negative = acc.Negative + 1
             Text = text })
 </code>
 Evaluates to
 <code>
 { Positive = 2
   Negative = 3
   Text = " 3 -2 -1 0 1" }
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1,``0[])">
 <summary>Applies a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f (... (f s i0)...) iN</c></summary>

 <param name="folder">The function to update the state given the input elements.</param>
 <param name="state">The initial state.</param>
 <param name="array">The input array.</param>

 <returns>The final state.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="fold-1">
 <code lang="fsharp">
 type Charge =
     | In of int
     | Out of int

 let inputs = [| In 1; Out 2; In 3 |]

 (0, inputs) ||> Array.fold (fun acc charge ->
     match charge with
     | In i -> acc + i
     | Out o -> acc - o)
 </code>
 Evaluates to <c>2</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ForAll2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},``0[],``1[])">
 <summary>Tests if all corresponding elements of the array satisfy the given predicate pairwise.</summary>

 <remarks>The predicate is applied to matching elements in the two collections up to the lesser of the 
 two lengths of the collections. If any application returns false then the overall result is 
 false and no further elements are tested. Otherwise, if one collection is longer 
 than the other then the <c>ArgumentException</c> exception is raised. 
 Otherwise, true is returned.</remarks>

 <param name="predicate">The function to test the input elements.</param>
 <param name="array1">The first input array.</param>
 <param name="array2">The second input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input arrays differ in length.</exception>

 <returns>True if all of the array elements satisfy the predicate.</returns>

 <example id="forall2-1">
 <code lang="fsharp">
 let inputs1 = [| 1; 2; 3 |]
 let inputs2 = [| 1; 2; 3 |]

 (inputs1, inputs2) ||> Array.forall2 (=)
 </code>
 Evaluates to <c>true</c>.
 </example>

 <example id="forall2-2">
 <code lang="fsharp">
 let items1 = [| 2017; 1; 1 |]
 let items2 = [| 2019; 19; 8 |]

 (items1, items2) ||> Array.forall2 (=)
 </code>
 Evaluates to <c>false</c>.
 </example>

 <example id="forall2-3">
 <code lang="fsharp">
 let items1 = [| 1; 2; 3 |]
 let items2 = [| 1; 2 |]

 (items1, items2) ||> Array.forall2 (=)
 </code>
 Throws <c>ArgumentException</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ForAll``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>Tests if all elements of the array satisfy the given predicate.</summary>

 <remarks>The predicate is applied to the elements of the input collection. If any application 
 returns false then the overall result is false and no further elements are tested. 
 Otherwise, true is returned.</remarks>

 <param name="predicate">The function to test the input elements.</param>
 <param name="array">The input array.</param>

 <returns>True if all of the array elements satisfy the predicate.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="forall-1">
 <code lang="fsharp">
 let isEven a = a % 2 = 0

 [2; 42] |> Array.forall isEven // evaluates to true

 [1; 2] |> Array.forall isEven // evaluates to false
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.FindIndexBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>Returns the index of the last element in the array
 that satisfies the given predicate. Raise <see cref="T:System.Collections.Generic.KeyNotFoundException"/> if
 none of the elements satisfy the predicate.</summary>

 <param name="predicate">The function to test the input elements.</param>
 <param name="array">The input array.</param>

 <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if <c>predicate</c>
 never returns true.</exception>
 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <returns>The index of the last element in the array that satisfies the given predicate.</returns>

 <example id="findindexback-1">
 <code lang="fsharp">
 let inputs = [| 1; 2; 3; 4; 5 |]

 inputs |> Array.findIndex (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>3</c>
 </example>

 <example id="findindexback-2">
 <code lang="fsharp">
 let inputs = [| 1; 2; 3; 4; 5 |]

 inputs |> Array.findIndex (fun elm -> elm % 6 = 0)
 </code>
 Throws <c>KeyNotFoundException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.FindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>Returns the index of the first element in the array
 that satisfies the given predicate. Raise <see cref="T:System.Collections.Generic.KeyNotFoundException"/> if 
 none of the elements satisfy the predicate.</summary>

 <param name="predicate">The function to test the input elements.</param>
 <param name="array">The input array.</param>

 <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if <c>predicate</c>
 never returns true.</exception>
 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <returns>The index of the first element in the array that satisfies the given predicate.</returns>

 <example id="findindex-1">
 <code lang="fsharp">
 let inputs = [| 1; 2; 3; 4; 5 |]

 inputs |> Array.findIndex (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>1</c>
 </example>

 <example id="findindex-2">
 <code lang="fsharp">
 let inputs = [| 1; 2; 3; 4; 5 |]
 inputs |> Array.findIndex (fun elm -> elm % 6 = 0)
 </code>
 Throws <c>KeyNotFoundException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.FindBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>Returns the last element for which the given function returns 'true'.
 Raise <see cref="T:System.Collections.Generic.KeyNotFoundException"/> if no such element exists.</summary>

 <param name="predicate">The function to test the input elements.</param>
 <param name="array">The input array.</param>

 <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if <c>predicate</c>
 never returns true.</exception>
 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <returns>The last element for which <c>predicate</c> returns true.</returns>

 <example id="findback-1">
 <code lang="fsharp">
 let inputs = [| 2; 3; 4 |]

 inputs |> Array.findBack (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>4</c>
 </example>

 <example id="findback-2">
 <code lang="fsharp">
 let inputs = [| 2; 3; 4 |]

 inputs |> Array.findBack (fun elm -> elm % 6 = 0)
 </code>
 Throws <c>KeyNotFoundException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Find``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>Returns the first element for which the given function returns 'true'.
 Raise <see cref="T:System.Collections.Generic.KeyNotFoundException"/> if no such element exists.</summary>

 <param name="predicate">The function to test the input elements.</param>
 <param name="array">The input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if <c>predicate</c>
 never returns true.</exception>

 <returns>The first element for which <c>predicate</c> returns true.</returns>

 <example id="find-1">
 <code lang="fsharp">
 let inputs = [| 1; 2; 3 |]

 inputs |> Array.find (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>2</c>
 </example>

 <example id="find-2">
 <code lang="fsharp">
 let inputs = [| 1; 2; 3 |]

 inputs |> Array.find (fun elm -> elm % 6 = 0)
 </code>
 Throws <c>KeyNotFoundException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>Returns a new collection containing only the elements of the collection
 for which the given predicate returns "true".</summary>

 <param name="predicate">The function to test the input elements.</param>
 <param name="array">The input array.</param>

 <returns>An array containing the elements for which the given predicate returns true.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="filter-1">
 <code lang="fsharp">
 let inputs = [| 1; 2; 3; 4 |]

 inputs |> Array.filter (fun elm -> elm % 2 = 0)
 </code>
 Evaluates to <c>[| 2; 4 |]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Exists2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},``0[],``1[])">
 <summary>Tests if any pair of corresponding elements of the arrays satisfies the given predicate.</summary>

 <remarks>The predicate is applied to matching elements in the two collections up to the lesser of the 
 two lengths of the collections. If any application returns true then the overall result is 
 true and no further elements are tested. Otherwise, if one collections is longer 
 than the other then the <c>ArgumentException</c> exception is raised. 
 Otherwise, false is returned.</remarks>

 <param name="predicate">The function to test the input elements.</param>
 <param name="array1">The first input array.</param>
 <param name="array2">The second input array.</param>

 <returns>True if any result from <c>predicate</c> is true.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input arrays differ in length.</exception>

 <example id="exists2-1">
 <code lang="fsharp">
 let inputs1 = [| 1; 2 |]
 let inputs2 = [| 1; 2; 0 |]

 (inputs1, inputs2) ||> Array.exists2 (fun a b -> a > b)
 </code>
 Evaluates to <c>false</c>
 </example>

 <example id="exists2-2">
 <code lang="fsharp">
 let inputs1 = [| 1; 4 |]
 let inputs2 = [| 1; 3; 5 |]

 (inputs1, inputs2) ||> Array.exists2 (fun a b -> a > b)
 </code>
 Evaluates to <c>true</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>Tests if any element of the array satisfies the given predicate.</summary>

 <remarks>The predicate is applied to the elements of the input array. If any application 
 returns true then the overall result is true and no further elements are tested. 
 Otherwise, false is returned.</remarks>

 <param name="predicate">The function to test the input elements.</param>
 <param name="array">The input array.</param>

 <returns>True if any result from <c>predicate</c> is true.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="exists-1">
 <code lang="fsharp">
 let input = [| 1; 2; 3; 4; 5 |]

 input |> Array.exists (fun elm -> elm % 4 = 0)
 </code>
 Evaluates to <c>true</c>
 </example>

 <example id="exists-2">
 <code lang="fsharp">
 let input = [| 1; 2; 3; 4; 5 |]

 input |> Array.exists (fun elm -> elm % 6 = 0)
 </code>
 Evaluates to <c>false</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Except``1(System.Collections.Generic.IEnumerable{``0},``0[])">
 <summary>Returns a new list with the distinct elements of the input array which do not appear in the itemsToExclude sequence,
 using generic hash and equality comparisons to compare values.</summary>

 <param name="itemsToExclude">A sequence whose elements that also occur in the input array will cause those elements to be
 removed from the result.</param>
 <param name="array">An array whose elements that are not also in itemsToExclude will be returned.</param>

 <returns>An array that contains the distinct elements of <c>array</c> that do not appear in <c>itemsToExclude</c>.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when either itemsToExclude or array is null.</exception>

 <example id="except-1">
 <code lang="fsharp">
 let original = [| 1; 2; 3; 4; 5 |]
 let itemsToExclude = [| 1; 3; 5 |]

 original |> Array.except itemsToExclude
 </code>
 Evaluates to <c>[| 2; 4 |]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.TryExactlyOne``1(``0[])">
 <summary>Returns the only element of the array or <c>None</c> if array is empty or contains more than one element.</summary>

 <param name="array">The input array.</param>

 <returns>The only element of the array or None.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="try-exactly-one-1">
 <code lang="fsharp">
 let inputs = [| "banana" |]

 inputs |> Array.tryExactlyOne
 </code>
 Evaluates to <c>Some banana</c>
 </example>

 <example id="try-exactly-one-2">
 <code lang="fsharp">
 let inputs = [| "pear"; "banana" |]

 inputs |> Array.tryExactlyOne
 </code>
 Evaluates to <c>None</c>
 </example>

 <example id="try-exactly-one-3">
 <code lang="fsharp">
 let inputs: int[] = [| |]

 inputs |> Array.tryExactlyOne
 </code>
 Evaluates to <c>None</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ExactlyOne``1(``0[])">
 <summary>Returns the only element of the array.</summary>

 <param name="array">The input array.</param>

 <returns>The only element of the array.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when the input does not have precisely one element.</exception>

 <example id="exactly-one-1">
 <code lang="fsharp">
 let inputs = [| "banana" |]

 inputs |> Array.exactlyOne
 </code>
 Evaluates to <c>banana</c>
 </example>

 <example id="exactly-one-2">
 <code lang="fsharp">
 let inputs = [| "pear"; "banana" |]

 inputs |> Array.exactlyOne
 </code>
 Throws <c>ArgumentException</c>
 </example>

 <example id="exactly-one-3">
 <code lang="fsharp">
 let inputs: int[] = [| |]

 inputs |> Array.exactlyOne
 </code>
 Throws <c>ArgumentException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Empty``1">
 <summary>Returns an empty array of the given type.</summary>
 <returns>The empty array.</returns>

 <example id="empty">
 <code lang="fsharp">
 Array.empty // Evaluates to [| |]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SplitInto``1(System.Int32,``0[])">
 <summary>Splits the input array into at most <c>count</c> chunks.</summary>

 <param name="count">The maximum number of chunks.</param>
 <param name="array">The input array.</param>

 <returns>The array split into chunks.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when <c>count</c> is not positive.</exception>

 <example id="split-into-1">
 <code lang="fsharp">
 let inputs = [| 1; 2; 3; 4; 5 |]

 inputs |> Array.splitInto 3
 </code>
 Evaluates to <c>seq [| [|1; 2|]; [|3; 4|]; [|5|] |]</c>
 </example>

 <example id="split-into-2">
 <code lang="fsharp">
 let inputs = [| 1; 2; 3; 4; 5 |]

 inputs |> Array.splitInto -1
 </code>
 Throws <c>ArgumentException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.DistinctBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
 <summary>Returns an array that contains no duplicate entries according to the 
 generic hash and equality comparisons on the keys returned by the given key-generating function.
 If an element occurs multiple times in the array then the later occurrences are discarded.</summary>

 <param name="projection">A function transforming the array items into comparable keys.</param>
 <param name="array">The input array.</param>

 <returns>The result array.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="distinct-by-1">
 <code lang="fsharp">
 let inputs = [| {Bar = 1 };{Bar = 1}; {Bar = 2}; {Bar = 3} |]

 inputs |> Array.distinctBy (fun foo -> foo.Bar)
 </code>
 Evaluates to <c>[| { Bar = 1 }; { Bar = 2 }; { Bar = 3 } |]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Distinct``1(``0[])">
 <summary>Returns an array that contains no duplicate entries according to generic hash and
 equality comparisons on the entries.
 If an element occurs multiple times in the array then the later occurrences are discarded.</summary>

 <param name="array">The input array.</param>

 <returns>The result array.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="distinct-1">
 <code lang="fsharp">
 let input = [| 1; 1; 2; 3 |]

 input |> Array.distinct
 </code>
 Evaluates to <c>[| 1; 2; 3 |]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ChunkBySize``1(System.Int32,``0[])">
 <summary>Divides the input array into chunks of size at most <c>chunkSize</c>.</summary>

 <param name="chunkSize">The maximum size of each chunk.</param>
 <param name="array">The input array.</param>

 <returns>The array divided into chunks.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when <c>chunkSize</c> is not positive.</exception>

 <example id="chunk-by-size-1">
 <code lang="fsharp">
 let input = [| 1; 2; 3 |]

 input |> Array.chunkBySize 2
 </code>
 Evaluates to <c>[| [|1; 2|]; [|3|] |]</c>
 </example>

 <example id="chunk-by-size-2">
 <code lang="fsharp">
 let input = [| 1; 2; 3 |]

 input |> Array.chunkBySize -2
 </code>
 Throws <c>ArgumentException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``0[])">
 <summary>Applies the given function to each element of the array. Returns
 the array comprised of the results <c>x</c> for each element where
 the function returns <c>Some(x)</c></summary>

 <param name="chooser">The function to generate options from the elements.</param>
 <param name="array">The input array.</param>

 <returns>The array of results.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="choose-1">
 <code lang="fsharp">
 let input = [| Some 1; None; Some 2 |]

 input |> Array.choose id
 </code>
 Evaluates to <c>[| 1; 2 |]</c>
 </example>

 <example id="choose-2">
 <code lang="fsharp">
 let input = [| 1; 2; 3 |]

 input |> Array.choose (fun n -> if n % 2 = 0 then Some n else None)
 </code>
 Evaluates to <c>[| 2 |]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Pick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``0[])">
 <summary>Applies the given function to successive elements, returning the first
 result where the function returns <c>Some(x)</c> for some <c>x</c>. If the function 
 never returns <c>Some(x)</c> then <see cref="T:System.Collections.Generic.KeyNotFoundException"/> is raised.</summary>

 <param name="chooser">The function to generate options from the elements.</param>
 <param name="array">The input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if every result from
 <c>chooser</c> is <c>None</c>.</exception>

 <returns>The first result.</returns>

 <example id="pick-1">
 <code lang="fsharp">
 let input = [| 1; 2; 3 |]

 input |> Array.pick (fun n -> if n % 2 = 0 then Some (string n) else None)
 </code>
 Evaluates to <c>"2"</c>.
 </example>

 <example id="pick-2">
 <code lang="fsharp">
 let input = [| 1; 2; 3 |]

 input |> Array.pick (fun n -> if n > 3 = 0 then Some (string n) else None)
 </code>
 Throws <c>KeyNotFoundException</c>.
 </example>

</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Fill``1(``0[],System.Int32,System.Int32,``0)">
 <summary>Fills a range of elements of the array with the given value.</summary>

 <param name="target">The target array.</param>
 <param name="targetIndex">The index of the first element to set.</param>
 <param name="count">The number of elements to set.</param>
 <param name="value">The value to set.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when either targetIndex or count is negative.</exception>

 <example id="fill-1">
 <code lang="fsharp">
 let target = [| 0; 1; 2; 3; 4; 5 |]

 Array.fill target 3 2 100
 </code>
 After evaluation <c>target</c> contains <c>[| 0; 1; 2; 100; 100; 5 |]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.TryPick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``0[])">
 <summary>Applies the given function to successive elements, returning the first
 result where the function returns <c>Some(x)</c> for some <c>x</c>. If the function 
 never returns <c>Some(x)</c> then <c>None</c> is returned.</summary>

 <param name="chooser">The function to transform the array elements into options.</param>
 <param name="array">The input array.</param>

 <returns>The first transformed element that is <c>Some(x)</c>.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="trypick-1">
 <code lang="fsharp">
 let input = [| 1; 2; 3 |]

 input |> Array.tryPick (fun n -> if n % 2 = 0 then Some (string n) else None)
 </code>
 Evaluates to <c>Some "2"</c>.
 </example>

 <example id="trypick-2">
 <code lang="fsharp">
 let input = [| 1; 2; 3 |]

 input |> Array.tryPick (fun n -> if n > 3 = 0 then Some (string n) else None)
 </code>
 Evaluates to <c>None</c>.
 </example>

</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.TryHead``1(``0[])">
 <summary>Returns the first element of the array, or
 <c>None</c> if the array is empty.</summary>

 <param name="array">The input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <returns>The first element of the array or None.</returns>

 <example id="tryhead-1">
 <code lang="fsharp">
 let inputs = [| "banana"; "pear" |]

 inputs |> Array.tryHead
 </code>
 Evaluates to <c>Some "banana"</c>
 </example>

 <example id="tryhead-2">
 <code lang="fsharp">
 let inputs : int[] = [| |]

 inputs |> Array.tryHead
 </code>
 Evaluates to <c>None</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Create``1(System.Int32,``0)">
 <summary>Creates an array whose elements are all initially the given value.</summary>

 <param name="count">The length of the array to create.</param>
 <param name="value">The value for the elements.</param>

 <returns>The created array.</returns>

 <exception cref="T:System.ArgumentException">Thrown when count is negative.</exception>

 <example id="create-1">
 <code lang="fsharp">
 Array.create 4 "a"
 </code>
 Evaluates to a new array containing<c>[| "a"; "a"; "a"; "a" |]</c>.
 </example>

 <example id="create-2">
 <code lang="fsharp">
 let cell = ref "a"
 let array = Array.create 2 cell
 cell.Value &lt;- "b"

 </code>
 Before evaluation of the last line, <c>array</c> contains<c>[| { contents = "a"}; { contents = "a"} |]</c>.
 After evaluation of the last line <c>array</c> contains<c>[| { contents = "b"}; { contents = "b"} |]</c>.
 Note each entry in the array is the same mutable cell object.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.CountBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
 <summary>Applies a key-generating function to each element of an array and returns an array yielding unique
 keys and their number of occurrences in the original array.</summary>

 <param name="projection">A function transforming each item of the input array into a key to be
 compared against the others.</param>
 <param name="array">The input array.</param>

 <returns>The result array.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="count-by-1">
 <code lang="fsharp">
 type Foo = { Bar: string }

 let inputs = [| {Bar = "a"}; {Bar = "b"}; {Bar = "a"} |]

 inputs |> Array.countBy (fun foo -> foo.Bar)
 </code>
 Evaluates to <c>[| ("a", 2); ("b", 1) |]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Copy``1(``0[])">
 <summary>Builds a new array that contains the elements of the given array.</summary>

 <param name="array">The input array.</param>

 <returns>A copy of the input array.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="copy-1">
 <code lang="fsharp">
 let source = [| 12; 13; 14 |]

 Array.copy source
 </code>
 Evaluates to a new array containing<c>[| 12; 13; 14 |]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Contains``1(``0,``0[])">
 <summary>Tests if the array contains the specified element.</summary>

 <param name="value">The value to locate in the input array.</param>
 <param name="array">The input array.</param>

 <returns>True if the input array contains the specified element; false otherwise.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="contains-1">
 <code lang="fsharp">
 [| 1; 2 |] |> Array.contains 2 // evaluates to true
 [| 1; 2 |] |> Array.contains 5 // evaluates to false
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Concat``1(System.Collections.Generic.IEnumerable{``0[]})">
 <summary>Builds a new array that contains the elements of each of the given sequence of arrays.</summary>

 <param name="arrays">The input sequence of arrays.</param>

 <returns>The concatenation of the sequence of input arrays.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input sequence is null.</exception>

 <example id="concat-1">
 <code lang="fsharp">
 let inputs = [ [| 1; 2 |]; [| 3 |]; [| 4; 5 |] ]

 inputs |> Array.concat
 </code>
 Evaluates to <c>[| 1; 2; 3; 4; 5 |]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.CompareWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},``0[],``0[])">
 <summary>Compares two arrays using the given comparison function, element by element.</summary>

 <param name="comparer">A function that takes an element from each array and returns an int.
 If it evaluates to a non-zero value iteration is stopped and that value is returned.</param>
 <param name="array1">The first input array.</param>
 <param name="array2">The second input array.</param>

 <returns>Returns the first non-zero result from the comparison function. If the first array has 
 a larger element, the return value is always positive. If the second array has a larger 
 element, the return value is always negative. When the elements are equal in the two 
 arrays, 1 is returned if the first array is longer, 0 is returned if they are equal in 
 length, and -1 is returned when the second array is longer.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when either of the input arrays
 is null.</exception>

 <example id="compare-with-1">
 <code lang="fsharp">
 let closerToNextDozen a b =
   (a % 12).CompareTo(b % 12)

 let input1 = [| 1; 10 |]
 let input2 = [| 1; 10 |]

 (input1, input2) ||> Array.compareWith closerToNextDozen
 </code>
 Evaluates to <c>0</c>
 </example>

 <example id="compare-with-2">
 <code lang="fsharp">
 let closerToNextDozen a b =
   (a % 12).CompareTo(b % 12)

 let input1 = [| 1; 5 |]
 let input2 = [| 1; 8 |]

 (input1, input2) ||> Array.compareWith closerToNextDozen
 </code>
 Evaluates to <c>-1</c>
 </example>

 <example id="compare-with-3">
 <code lang="fsharp">
 let closerToNextDozen a b =
   (a % 12).CompareTo(b % 12)

 let input1 = [| 1; 11 |]
 let input2 = [| 1; 13 |]

 (input1, input2) ||> Array.compareWith closerToNextDozen
 </code>
 Evaluates to <c>1</c>
 </example>

 <example id="compare-with-4">
 <code lang="fsharp">
 let closerToNextDozen a b =
   (a % 12).CompareTo(b % 12)

 let input1 = [| 1; 2 |]
 let input2 = [| 1 |]

 (input1, input2) ||> Array.compareWith closerToNextDozen
 </code>
 Evaluates to <c>1</c>
 </example>

 <example id="compare-with-5">
 <code lang="fsharp">
 let closerToNextDozen a b =
   (a % 12).CompareTo(b % 12)

 let input1 = [| 1 |]
 let input2 = [| 1; 2 |]

 (input1, input2) ||> Array.compareWith closerToNextDozen
 </code>
 Evaluates to <c>-1</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Collect``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1[]},``0[])">
 <summary>For each element of the array, applies the given function. Concatenates all the results and return the combined array.</summary>

 <param name="mapping">The function to create sub-arrays from the input array elements.</param>
 <param name="array">The input array.</param>

 <returns>The concatenation of the sub-arrays.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="collect-1">
 <code lang="fsharp">
 type Foo = { Bar: int[] }

 let input = [| {Bar = [| 1; 2 |]}; {Bar = [| 3; 4 |]} |]

 input |> Array.collect (fun foo -> foo.Bar)
 </code>
 Evaluates to <c>[| 1; 2; 3; 4 |]</c>
 </example>

 <example id="collect-2">
 <code lang="fsharp">
 let input = [[1; 2]; [3; 4]]

 input |> Array.collect id
 </code>
 Evaluates to <c>[| 1; 2; 3; 4 |]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.CopyTo``1(``0[],System.Int32,``0[],System.Int32,System.Int32)">
 <summary>Reads a range of elements from the first array and write them into the second.</summary>

 <param name="source">The source array.</param>
 <param name="sourceIndex">The starting index of the source array.</param>
 <param name="target">The target array.</param>
 <param name="targetIndex">The starting index of the target array.</param>
 <param name="count">The number of elements to copy.</param>

 <remarks>
 Slicing syntax is generally preferred, e.g.
 <code lang="fsharp">
 let source = [| 12; 13; 14 |]
 let target = [| 0; 1; 2; 3; 4; 5 |]
 target[3..4] &lt;- source[1..2]
 </code>
 </remarks>

 <exception cref="T:System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
 <exception cref="T:System.ArgumentException">Thrown when any of sourceIndex, targetIndex or count are negative,
 or when there aren't enough elements in source or target.</exception>

 <example id="blit-1">
 <code lang="fsharp">
 let source = [| 12; 13; 14 |]
 let target = [| 0; 1; 2; 3; 4; 5 |]

 Array.blit source 1 target 3 2
 </code>
 After evaluation <c>target</c> contains <c>[| 0; 1; 2; 13; 14; 5 |]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.AverageBy``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
 <summary>Returns the average of the elements generated by applying the function to each element of the array.</summary>

 <param name="projection">The function to transform the array elements before averaging.</param>
 <param name="array">The input array.</param>

 <exception cref="T:System.ArgumentException">Thrown when <c>array</c> is empty.</exception>

 <returns>The computed average.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="average-by-1">
 <code lang="fsharp">
 type Foo = { Bar: float }

 let input = [| {Bar = 2.0}; {Bar = 4.0} |]

 input |> Array.averageBy (fun foo -> foo.Bar)
 </code>
 Evaluates to <c>3.0</c>
 </example>

 <example id="average-by-2">
 <code lang="fsharp">
 type Foo = { Bar: float }

 let input : Foo[] = [| |]

 input |> Array.averageBy (fun foo -> foo.Bar)
 </code>
 Throws <c>ArgumentException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Average``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0[])">
 <summary>Returns the average of the elements in the array.</summary>

 <param name="array">The input array.</param>

 <exception cref="T:System.ArgumentException">Thrown when <c>array</c> is empty.</exception>
 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <returns>The average of the elements in the array.</returns>

 <example id="average-1">
 <code lang="fsharp">
 [| 1.0; 2.0; 6.0 |] |> Array.average
 </code>
 Evaluates to <c>3.0</c>
 </example>

 <example id="average-2">
 <code lang="fsharp">
 [| |] |> Array.average
 </code>
 Throws <c>ArgumentException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Append``1(``0[],``0[])">
 <summary>Builds a new array that contains the elements of the first array followed by the elements of the second array.</summary>

 <param name="array1">The first input array.</param>
 <param name="array2">The second input array.</param>

 <returns>The resulting array.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>

 <example id="append-1">
 <code lang="fsharp">
 Array.append [| 1; 2 |] [| 3; 4 |]
 </code>
 Evaluates to <c>[| 1; 2; 3; 4 |]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.AllPairs``2(``0[],``1[])">
 <summary>Returns a new array that contains all pairings of elements from the first and second arrays.</summary>

 <param name="array1">The first input array.</param>
 <param name="array2">The second input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>

 <returns>The resulting array of pairs.</returns>

 <example id="all-pairs-1">
 <code lang="fsharp">
 ([| 1; 2 |], [| 3; 4 |]) ||> Array.allPairs
 </code>
 Evaluates to
 <code>
 [| (1, 3); (1, 4); (2, 3); (2, 4) |]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Parallel.Partition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
 <summary>Split the collection into two collections, containing the 
 elements for which the given predicate returns "true" and "false"
 respectively </summary>

 <remarks>Performs the operation in parallel using <see cref="M:System.Threading.Tasks.Parallel.For" />.
 The order in which the given function is applied to indices is not specified.</remarks>

 <param name="predicate">The function to test the input elements.</param>
 <param name="array">The input array.</param>

 <returns>The two arrays of results.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>
 
 <example id="partition-1">
 <code lang="fsharp">
 let inputs = [| 1; 2; 3; 4 |]

 inputs |> Array.Parallel.partition (fun x -> x % 2 = 0)
 </code>
 Evaluates to <c>([|2; 4|], [|1; 3|])</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Parallel.Initialize``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
 <summary>Create an array given the dimension and a generator function to compute the elements.</summary>

 <remarks>Performs the operation in parallel using <see cref="M:System.Threading.Tasks.Parallel.For" />.
 The order in which the given function is applied to indices is not specified.</remarks>

 <param name="count"></param>
 <param name="initializer"></param>

 <returns>The array of results.</returns>

 <example id="init-1">
 <code lang="fsharp">
 Array.Parallel.init 4 (fun v -> v + 5)
 </code>
 Evaluates to <c>[| 5; 6; 7; 8 |]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Parallel.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},``0[])">
 <summary>Apply the given function to each element of the array. The integer passed to the
 function indicates the index of element.</summary>

 <remarks>Performs the operation in parallel using <see cref="M:System.Threading.Tasks.Parallel.For" />.
 The order in which the given function is applied to elements of the input array is not specified.</remarks>

 <param name="action"></param>
 <param name="array">The input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="iteri-1">
 <code lang="fsharp">
 let inputs = [| "a"; "b"; "c" |]

 inputs |> Array.Parallel.iteri (fun i v -> printfn "{i}: {v}")
 </code>
 Evaluates to <c>unit</c> and prints the following to the console in an unspecified order:
 <code>
 0: a
 2: c
 1: b
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Parallel.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},``0[])">
 <summary>Apply the given function to each element of the array. </summary>

 <remarks>Performs the operation in parallel using <see cref="M:System.Threading.Tasks.Parallel.For" />.
 The order in which the given function is applied to elements of the input array is not specified.</remarks>

 <param name="action"></param>
 <param name="array">The input array.</param>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="iter-1">
 <code lang="fsharp">
 let inputs = [| "a"; "b"; "c" |]

 inputs |> Array.Parallel.iter (printfn "%s")
 </code>
 Evaluates to <c>unit</c> and prints the following to the console in an unspecified order:
 <code>
 a
 c
 b
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Parallel.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``0[])">
 <summary>Build a new array whose elements are the results of applying the given function
 to each of the elements of the array. The integer index passed to the
 function indicates the index of element being transformed.</summary>

 <remarks>Performs the operation in parallel using <see cref="M:System.Threading.Tasks.Parallel.For" />.
 The order in which the given function is applied to elements of the input array is not specified.</remarks>

 <param name="mapping"></param>
 <param name="array">The input array.</param>

 <returns>The array of results.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="mapi-1">
 <code lang="fsharp">
 let inputs = [| 10; 10; 10 |]

 inputs |> Array.Parallel.mapi (fun i x -> i + x)
 </code>
 Evaluates to <c>[| 10; 11; 12 |]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Parallel.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
 <summary>Build a new array whose elements are the results of applying the given function
 to each of the elements of the array.</summary>

 <remarks>Performs the operation in parallel using <see cref="M:System.Threading.Tasks.Parallel.For" />.
 The order in which the given function is applied to elements of the input array is not specified.</remarks>

 <param name="mapping"></param>
 <param name="array">The input array.</param>

 <returns>The array of results.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="map-1">
 <code lang="fsharp">
 let inputs = [| "a"; "bbb"; "cc" |]

 inputs |> Array.Parallel.map (fun x -> x.Length)
 </code>
 Evaluates to <c>[| 1; 3; 2 |]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Parallel.Collect``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1[]},``0[])">
 <summary>For each element of the array, apply the given function. Concatenate all the results and return the combined array.</summary>

 <remarks>Performs the operation in parallel using <see cref="M:System.Threading.Tasks.Parallel.For" />.
 The order in which the given function is applied to elements of the input array is not specified.</remarks>

 <param name="mapping"></param>
 <param name="array">The input array.</param>

 <returns>'U[]</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="collect-1">
 <code lang="fsharp">
 type Foo = { Bar: int[] }

 let input = [| {Bar = [| 1; 2 |]}; {Bar = [| 3; 4 |]} |]

 input |> Array.Parallel.collect (fun foo -> foo.Bar)
 </code>
 Evaluates to <c>[| 1; 2; 3; 4 |]</c>
 </example>

 <example id="collect-2">
 <code lang="fsharp">
 let input = [| [| 1; 2 |]; [| 3; 4 |] |]

 input |> Array.Parallel.collect id
 </code>
 Evaluates to <c>[| 1; 2; 3; 4 |]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Parallel.Choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``0[])">
 <summary>Apply the given function to each element of the array. Return
 the array comprised of the results <c>x</c> for each element where
 the function returns <c>Some(x)</c>.</summary>

 <remarks>Performs the operation in parallel using <see cref="M:System.Threading.Tasks.Parallel.For" />.
 The order in which the given function is applied to elements of the input array is not specified.</remarks>

 <param name="chooser">The function to generate options from the elements.</param>
 <param name="array">The input array.</param>

 <returns>The array of results.</returns>

 <exception cref="T:System.ArgumentNullException">Thrown when the input array is null.</exception>

 <example id="choose-1">
 <code lang="fsharp">
 let input = [| Some 1; None; Some 2 |]

 input |> Array.Parallel.choose id
 </code>
 Evaluates to <c>[| 1; 2 |]</c>
 </example>

 <example id="choose-2">
 <code lang="fsharp">
 let input = [| 1; 2; 3 |]

 input |> Array.Parallel.choose (fun n -> if n % 2 = 0 then Some n else None)
 </code>
 Evaluates to <c>[| 2 |]</c>
 </example>
</member>
<member name="T:Microsoft.FSharp.Collections.ArrayModule.Parallel">
 <summary>Provides parallel operations on arrays </summary>
</member>
<member name="T:Microsoft.FSharp.Collections.ArrayModule">
 <summary>Contains operations for working with arrays.</summary>

 <remarks>
  See also <a href="https://docs.microsoft.com/dotnet/fsharp/language-reference/arrays">F# Language Guide - Arrays</a>.
 </remarks>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Set``1(``0[0:, 0:, 0:],System.Int32,System.Int32,System.Int32,System.Int32,``0)">
 <summary>Sets the value of an element in an array. You can also
 use the syntax 'array.[index1,index2,index3,index4] &lt;- value'.</summary>

 <param name="array">The input array.</param>
 <param name="index1">The index along the first dimension.</param>
 <param name="index2">The index along the second dimension.</param>
 <param name="index3">The index along the third dimension.</param>
 <param name="index4">The index along the fourth dimension.</param>
 <param name="value">The value to set.</param>

 <remarks>
 Indexer syntax is generally preferred, e.g.
 <code lang="fsharp">
 let array: float[,,,] = Array4D.zeroCreate 2 3 4 5

 array[0,2,1,3] &lt;- 5.0
 </code>
 </remarks>

 <example id="get-1">
 <code lang="fsharp">
 let array = Array4D.zeroCreate 2 3 4 5

 Array4D.2et array 0 2 1 3 5.0
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Get``1(``0[0:, 0:, 0:],System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>Fetches an element from a 4D array. You can also use the syntax 'array.[index1,index2,index3,index4]'</summary>

 <param name="array">The input array.</param>
 <param name="index1">The index along the first dimension.</param>
 <param name="index2">The index along the second dimension.</param>
 <param name="index3">The index along the third dimension.</param>
 <param name="index4">The index along the fourth dimension.</param>

 <returns>The value at the given index.</returns>

 <remarks>
 Indexer syntax is generally preferred, e.g.
 <code lang="fsharp">
 let array: float[,,,] = Array4D.zeroCreate 2 3 4 5

 array[0,2,1,3]
 </code>
 </remarks>

 <example id="get-1">
 <code lang="fsharp">
 let array = Array4D.zeroCreate 2 3 4 5

 Array4D.get array 0 2 1 3
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.ZeroCreate``1(System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>Creates an array where the entries are initially the "default" value.</summary>

 <param name="length1">The length of the first dimension.</param>
 <param name="length2">The length of the second dimension.</param>
 <param name="length3">The length of the third dimension.</param>
 <param name="length4">The length of the fourth dimension.</param>

 <returns>The created array.</returns>

 <example id="zerocreate-1">
 <code lang="fsharp">
 let array : float[,,,] = Array4D.zeroCreate 2 3 3 5
 </code>
 After evaluation <c>array</c> is a 2x3x3x5 array with contents all zero.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Length4``1(``0[0:, 0:, 0:])">
 <summary>Returns the length of an array in the fourth dimension.</summary>

 <param name="array">The input array.</param>

 <returns>The length of the array in the fourth dimension.</returns>

 <example id="length4-1">
 <code>
 let array = Array4D.init 2 3 4 5 (fun i j k -> 100*i + 10*j + k)

 array |> Array4D.length4
 </code>
 Evaluates to <c>5</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Length3``1(``0[0:, 0:, 0:])">
 <summary>Returns the length of an array in the third dimension.</summary>

 <param name="array">The input array.</param>

 <returns>The length of the array in the third dimension.</returns>

 <example id="length3-1">
 <code>
 let array = Array4D.init 2 3 4 5 (fun i j k -> 100*i + 10*j + k)

 array |> Array4D.length3
 </code>
 Evaluates to <c>4</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Length2``1(``0[0:, 0:, 0:])">
 <summary>Returns the length of an array in the second dimension.</summary>

 <param name="array">The input array.</param>

 <returns>The length of the array in the second dimension.</returns>

 <example id="length2-1">
 <code>
 let array = Array4D.init 2 3 4 5 (fun i j k -> 100*i + 10*j + k)

 array |> Array4D.length2
 </code>
 Evaluates to <c>3</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Length1``1(``0[0:, 0:, 0:])">
 <summary>Returns the length of an array in the first dimension  </summary>

 <param name="array">The input array.</param>

 <returns>The length of the array in the first dimension.</returns>

 <example id="length1-1">
 <code>
 let array = Array4D.init 2 3 4 5 (fun i j k -> 100*i + 10*j + k)

 array |> Array4D.length1
 </code>
 Evaluates to <c>2</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Initialize``1(System.Int32,System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}}}})">
 <summary>Creates an array given the dimensions and a generator function to compute the elements.</summary>

 <param name="length1">The length of the first dimension.</param>
 <param name="length2">The length of the second dimension.</param>
 <param name="length3">The length of the third dimension.</param>
 <param name="length4">The length of the fourth dimension.</param>
 <param name="initializer">The function to create an initial value at each index in the array.</param>

 <returns>The created array.</returns>

 <example id="init-1">
 <code lang="fsharp">
 Array4D.init 2 2 2 2 (fun i j k l -> i*1000+j*100+k*10+l)
 </code>
 Evaluates to a 2x2x2x2 array with contents <c>[[[[0; 1]; [10; 11]]; [[100; 101]; [110; 111]]];[[[1000; 1]; [1010; 1011]]; [[1100; 1101]; [1110; 1111]]]]</c>
 </example>

</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Create``1(System.Int32,System.Int32,System.Int32,System.Int32,``0)">
 <summary>Creates an array whose elements are all initially the given value</summary>

 <param name="length1">The length of the first dimension.</param>
 <param name="length2">The length of the second dimension.</param>
 <param name="length3">The length of the third dimension.</param>
 <param name="length4">The length of the fourth dimension.</param>
 <param name="initial">The initial value for each element of the array.</param>

 <returns>The created array.</returns>

 <example id="create-1">
 <code lang="fsharp">
 Array4D.create 2 2 2 2 1
 </code>
 Evaluates to a 2x2x2x2 array with all entries <c>1</c>
 </example>

</member>
<member name="T:Microsoft.FSharp.Collections.Array4DModule">
 <summary>Contains operations for working with rank 4 arrays. </summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.ZeroCreate``1(System.Int32,System.Int32,System.Int32)">
 <summary>Creates an array where the entries are initially the "default" value.</summary>

 <param name="length1">The length of the first dimension.</param>
 <param name="length2">The length of the second dimension.</param>
 <param name="length3">The length of the third dimension.</param>

 <returns>The created array.</returns>

 <example id="zerocreate-1">
 <code lang="fsharp">
 let array : float[,,] = Array3D.zeroCreate 2 3 3
 </code>
 After evaluation <c>array</c> is a 2x3x3 array with contents all zero.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Set``1(``0[0:, 0:],System.Int32,System.Int32,System.Int32,``0)">
 <summary>Sets the value of an element in an array. You can also
 use the syntax 'array.[index1,index2,index3] &lt;- value'.</summary>

 <param name="array">The input array.</param>
 <param name="index1">The index along the first dimension.</param>
 <param name="index2">The index along the second dimension.</param>
 <param name="index3">The index along the third dimension.</param>
 <param name="value">The value to set at the given index.</param>

 <remarks>
 Indexer syntax is generally preferred, e.g.
 <code lang="fsharp">
 let array = Array3D.zeroCreate 2 3 3

 array[0,2,1] &lt; 4.0
 </code>
 Evaluates to <c>11</c>.
 </remarks>

 <example id="set-1">
 <code lang="fsharp">
 let array = Array3D.zeroCreate 2 3 3

 Array3D.set array 0 2 1 4.0
 </code>
 After evaluation <c>array</c> is a 2x3x3 array with contents <c>[[[0.0; 0.0; 0.0]; [0.0; 4.0; 0.0]]; [[0.0; 0.0; 0.0]; [0.0; 0.0; 0.0]]]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}}}},``0[0:, 0:])">
 <summary>Builds a new array whose elements are the results of applying the given function
 to each of the elements of the array. The integer indices passed to the
 function indicates the element being transformed.</summary>

 <remarks>For non-zero-based arrays the basing on an input array will be propagated to the output
 array.</remarks>
 <param name="mapping">The function to transform the elements at each index in the array.</param>
 <param name="array">The input array.</param>

 <returns>The array created from the transformed elements.</returns>

 <example id="mapi-1">
 <code lang="fsharp">
 let inputs = Array3D.zeroCreate 2 3 3

 inputs |> Array3D.mapi (fun i j k v -> 100*i + 10*j + k)
 </code>
 Evaluates to a 2x3x3 array with contents <c>[[[0; 2; 4]; [20; 22; 24]]; [[200; 202; 204]; [220; 222; 224]]]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[0:, 0:])">
 <summary>Builds a new array whose elements are the results of applying the given function
 to each of the elements of the array.</summary>

 <remarks>For non-zero-based arrays the basing on an input array will be propagated to the output
 array.</remarks>
 <param name="mapping">The function to transform each element of the array.</param>
 <param name="array">The input array.</param>

 <returns>The array created from the transformed elements.</returns>

 <example id="map-1">
 <code lang="fsharp">
 let inputs = Array3D.init 2 3 3 (fun i j k -> 100*i + 10*j + k)

 inputs |> Array3D.map (fun v -> 2 * v)
 </code>
 Evaluates to a 2x3x3 array with contents <c> <c>[[[0; 2; 4]; [20; 22; 24]]; [[200; 202; 204]; [220; 222; 224]]]</c></c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Length3``1(``0[0:, 0:])">
 <summary>Returns the length of an array in the third dimension.</summary>

 <param name="array">The input array.</param>

 <returns>The length of the array in the third dimension.</returns>

 <example id="length3-1">
 <code>
 let array = Array3D.init 2 3 4 (fun i j k -> 100*i + 10*j + k)

 array |> Array3D.length3
 </code>
 Evaluates to <c>4</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Length2``1(``0[0:, 0:])">
 <summary>Returns the length of an array in the second dimension.</summary>

 <param name="array">The input array.</param>

 <returns>The length of the array in the second dimension.</returns>

 <example id="length2-1">
 <code>
 let array = Array3D.init 2 3 4 (fun i j k -> 100*i + 10*j + k)

 array |> Array3D.length2
 </code>
 Evaluates to <c>3</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Length1``1(``0[0:, 0:])">
 <summary>Returns the length of an array in the first dimension  </summary>

 <param name="array">The input array.</param>

 <returns>The length of the array in the first dimension.</returns>

 <example id="length1-1">
 <code>
 let array = Array3D.init 2 3 4 (fun i j k -> 100*i + 10*j + k)

 array |> Array3D.length1
 </code>
 Evaluates to <c>2</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}}}},``0[0:, 0:])">
 <summary>Applies the given function to each element of the array. The integer indices passed to the
 function indicates the index of element.</summary>

 <param name="action">The function to apply to each element of the array.</param>
 <param name="array">The input array.</param>

 <example id="iter-1">
 <code lang="fsharp">
 let inputs = Array3D.init 2 2 3 (fun i j k -> 100*i + 10*j + k)

 inputs |> Array3D.iteri (fun i j k v -> printfn $"value at ({i},{j},{k}) = {v}")
 </code>
 Evaluates to <c>unit</c> and prints
 <code>
 value at (0,0,0) = 0
 value at (0,0,1) = 1
 value at (0,0,2) = 2
 value at (0,1,0) = 10
 value at (0,1,1) = 11
 value at (0,1,2) = 12
 value at (1,0,0) = 100
 value at (1,0,1) = 101
 value at (1,0,2) = 102
 value at (1,1,0) = 110
 value at (1,1,1) = 111
 value at (1,1,2) = 112
 </code>
 in the console.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},``0[0:, 0:])">
 <summary>Applies the given function to each element of the array.</summary>

 <param name="action">The function to apply to each element of the array.</param>
 <param name="array">The input array.</param>

 <example id="iter-1">
 <code lang="fsharp">
 let inputs = Array3D.init 2 2 3 (fun i j k -> 100*i + 10*j + k)

 inputs |> Array3D.iter (fun v -> printfn $"value = {v}")
 </code>
 Evaluates to <c>unit</c> and prints
 <code>
 value = 0
 value = 1
 value = 2
 value = 10
 value = 11
 value = 12
 value = 100
 value = 101
 value = 102
 value = 110
 value = 111
 value = 112
 </code>
 in the console.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Get``1(``0[0:, 0:],System.Int32,System.Int32,System.Int32)">
 <summary>Fetches an element from a 3D array. You can also use the syntax 'array.[index1,index2,index3]'</summary>

 <param name="array">The input array.</param>
 <param name="index1">The index along the first dimension.</param>
 <param name="index2">The index along the second dimension.</param>
 <param name="index3">The index along the third dimension.</param>

 <returns>The value at the given index.</returns>

 <remarks>
 Indexer syntax is generally preferred, e.g.
 <code lang="fsharp">
 let array = Array3D.init 2 3 3 (fun i j k -> 100*i + 10*j + k)

 array[0,2,1]
 </code>
 Evaluates to <c>11</c>.
 </remarks>

 <example id="set-1">
 <code lang="fsharp">
 let array = Array3D.init 2 3 3 (fun i j k -> 100*i + 10*j + k)

 Array3D.get array 0 2 1
 </code>
 Evaluates to <c>21</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Initialize``1(System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}}})">
 <summary>Creates an array given the dimensions and a generator function to compute the elements.</summary>

 <param name="length1">The length of the first dimension.</param>
 <param name="length2">The length of the second dimension.</param>
 <param name="length3">The length of the third dimension.</param>
 <param name="initializer">The function to create an initial value at each index into the array.</param>

 <returns>The created array.</returns>

 <example id="init-1">
 <code lang="fsharp">
 Array3D.init 2 2 3 (fun i j k -> 100*i + 10*j + k)
 </code>
 Evaluates to a 2x2x3 array with contents <c>[[[0; 1; 2]; [10; 11; 12]]; [[100; 101; 102]; [110; 111; 112]]]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Create``1(System.Int32,System.Int32,System.Int32,``0)">
 <summary>Creates an array whose elements are all initially the given value.</summary>
 <param name="length1">The length of the first dimension.</param>
 <param name="length2">The length of the second dimension.</param>
 <param name="length3">The length of the third dimension.</param>
 <param name="initial">The value of the array elements.</param>

 <returns>The created array.</returns>

 <example id="create-1">
 <code lang="fsharp">
 Array3D.create 2 2 3 1
 </code>
 Evaluates to a 2x3 array with contents <c>[[[1; 1; 1]; [1; 1; 1]]; [[1; 1; 1]; [1; 1; 1]]]</c>
 </example>

</member>
<member name="T:Microsoft.FSharp.Collections.Array3DModule">
 <summary>Contains operations for working with rank 3 arrays.</summary>

 <remarks>
  See also <a href="https://docs.microsoft.com/dotnet/fsharp/language-reference/arrays">F# Language Guide - Arrays</a>.
 </remarks>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.MaxKeyValue``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Returns binding for the largest key in the map.
 Raise <c>KeyNotFoundException</c> when map is empty.</summary>

 <param name="table">The input map.</param>
 <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the map is empty.</exception>

 <example id="maxkeyvalue-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 sample |> Map.maxKeyValue // evaluates to (2, "b")
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.MinKeyValue``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Returns binding for the smallest key in the map.
 Raise <c>KeyNotFoundException</c> when map is empty.</summary>

 <param name="table">The input map.</param>
 <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the map is empty.</exception>

 <example id="minkeyvalue-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 sample |> Map.minKeyValue // evaluates to (1, "a")
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Values``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>The values in the map, including the duplicates.
 The sequence will be ordered by the keys of the map.</summary>

 <example id="values-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 sample |> Map.values // evaluates to seq ["a"; "b"]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Keys``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>The keys in the map.
 The sequence will be ordered by the keys of the map.</summary>

 <example id="keys-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 sample |> Map.keys // evaluates to seq [1; 2]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Count``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>The number of bindings in the map.</summary>

 <example id="count-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 sample |> Map.count // evaluates to 2
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.TryFindKey``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Returns the key of the first mapping in the collection that satisfies the given predicate.
 Returns 'None' if no such element exists.</summary>

 <param name="predicate">The function to test the input elements.</param>
 <param name="table">The input map.</param>

 <returns>The first key for which the predicate returns true or None if the predicate evaluates to false for each key/value pair.</returns>

 <example id="tryfindkey-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 sample |> Map.tryFindKey (fun n s -> n = s.Length) // evaluates to Some 1
 sample |> Map.tryFindKey (fun n s -> n &lt; s.Length) // evaluates to None
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.FindKey``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Evaluates the function on each mapping in the collection. Returns the key for the first mapping
 where the function returns 'true'. Raise <c>KeyNotFoundException</c> if no such element exists.</summary>

 <param name="predicate">The function to test the input elements.</param>
 <param name="table">The input map.</param>
 <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the key does not exist in the map.</exception>

 <returns>The first key for which the predicate evaluates true.</returns>

 <example id="findkey-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 sample |> Map.findKey (fun n s -> n = s.Length) // evaluates to 1
 sample |> Map.findKey (fun n s -> n &lt; s.Length) // throws KeyNotFoundException
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.TryFind``2(``0,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Lookup an element in the map, returning a <c>Some</c> value if the element is in the domain
 of the map and <c>None</c> if not.</summary>

 <param name="key">The input key.</param>
 <param name="table">The input map.</param>

 <returns>The found <c>Some</c> value or <c>None</c>.</returns>

 <example id="tryfind-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 sample |> Map.tryFind 1 // evaluates to Some "a"
 sample |> Map.tryFind 3 // evaluates to None
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Remove``2(``0,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Removes an element from the domain of the map. No exception is raised if the element is not present.</summary>

 <param name="key">The input key.</param>
 <param name="table">The input map.</param>

 <returns>The resulting map.</returns>

 <example id="remove-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 sample |> Map.remove 1 // evaluates to map [(2, "b")]
 sample |> Map.remove 3 // equal to sample
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Partition``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Builds two new maps, one containing the bindings for which the given predicate returns 'true',
 and the other the remaining bindings.</summary>

 <param name="predicate">The function to test the input elements.</param>
 <param name="table">The input map.</param>

 <returns>A pair of maps in which the first contains the elements for which the predicate returned true
 and the second containing the elements for which the predicated returned false.</returns>

 <example id="partition-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 sample |> Map.partition (fun n s -> n = s.Length) // evaluates to (map [(1, "a")], map [(2, "b")])
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.ContainsKey``2(``0,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Tests if an element is in the domain of the map.</summary>

 <param name="key">The input key.</param>
 <param name="table">The input map.</param>

 <returns>True if the map contains the key.</returns>

 <example id="containskey-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 sample |> Map.containsKey 1 // evaluates to true
 sample |> Map.containsKey 3 // evaluates to false
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Map``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The key passed to the
 function indicates the key of element being transformed.</summary>

 <param name="mapping">The function to transform the key/value pairs.</param>
 <param name="table">The input map.</param>

 <returns>The resulting map of keys and transformed values.</returns>

 <example id="map-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 sample |> Map.map (fun n s -> sprintf "%i %s" n s) // evaluates to map [(1, "1 a"); (2, "2 b")]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.ForAll``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Returns true if the given predicate returns true for all of the
 bindings in the map.</summary>

 <param name="predicate">The function to test the input elements.</param>
 <param name="table">The input map.</param>

 <returns>True if the predicate evaluates to true for all of the bindings in the map.</returns>

 <example id="forall-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 sample |> Map.forall (fun n s -> n >= s.Length) // evaluates to true
 sample |> Map.forall (fun n s -> n = s.Length)  // evaluates to false
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Filter``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Builds a new map containing only the bindings for which the given predicate returns 'true'.</summary>

 <param name="predicate">The function to test the key/value pairs.</param>
 <param name="table">The input map.</param>

 <returns>The filtered map.</returns>

 <example id="filter-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 sample |> Map.filter (fun n s -> n = s.Length) // evaluates to map [(1, "a")]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Exists``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Returns true if the given predicate returns true for one of the
 bindings in the map.</summary>

 <param name="predicate">The function to test the input elements.</param>
 <param name="table">The input map.</param>

 <returns>True if the predicate returns true for one of the key/value pairs.</returns>

 <example id="exists-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 sample |> Map.exists (fun n s -> n = s.Length) // evaluates to true
 sample |> Map.exists (fun n s -> n &lt; s.Length) // evaluates to false
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Iterate``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Applies the given function to each binding in the dictionary</summary>

 <param name="action">The function to apply to each key/value pair.</param>
 <param name="table">The input map.</param>

 <example id="iter-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 sample |> Map.iter (fun n s -> printf "%i %s " n s)
 </code>
 Prints <c>"1 a 2 b "</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Fold``3(Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},``2,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Folds over the bindings in the map </summary>

 <param name="folder">The function to update the state given the input key/value pairs.</param>
 <param name="state">The initial state.</param>
 <param name="table">The input map.</param>

 <returns>The final state value.</returns>

 <example id="fold-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 ("initial", sample) ||> Map.fold (fun state n s -> sprintf "%s %i %s" state n s)
 </code>
 Evaluates to <c>"initial 1 a 2 b"</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.FoldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},Microsoft.FSharp.Collections.FSharpMap{``0,``1},``2)">
 <summary>Folds over the bindings in the map.</summary>

 <param name="folder">The function to update the state given the input key/value pairs.</param>
 <param name="table">The input map.</param>
 <param name="state">The initial state.</param>

 <returns>The final state value.</returns>

 <example id="foldback-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 (sample, "initial") ||> Map.foldBack (fun n s state -> sprintf "%i %s %s" n s state)
 </code>
 Evaluates to <c>"1 a 2 b initial"</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Pick``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Searches the map looking for the first element where the given function returns a <c>Some</c> value.
 Raise <c>KeyNotFoundException</c> if no such element exists.</summary>

 <param name="chooser">The function to generate options from the key/value pairs.</param>
 <param name="table">The input map.</param>
 <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if no element returns a <c>Some</c>
 value when evaluated by the chooser function</exception>

 <returns>The first result.</returns>

 <example id="pick-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b"); (10, "ccc"); (20, "ddd") ]

 sample |> Map.pick (fun n s -> if n > 5 &amp;&amp; s.Length > 2 then Some s else None)
 </code>
 Evaluates to <c>"ccc"</c>
 </example>
 <example id="pick-2">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b"); (10, "ccc"); (20, "ddd") ]

 sample |> Map.pick (fun n s -> if n > 5 &amp;&amp; s.Length > 4 then Some s else None)
 </code>
 Raises <c>KeyNotFoundException</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.TryPick``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Searches the map looking for the first element where the given function returns a <c>Some</c> value.</summary>

 <param name="chooser">The function to generate options from the key/value pairs.</param>
 <param name="table">The input map.</param>

 <returns>The first result.</returns>

 <example id="trypick-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b"); (10, "ccc"); (20, "ddd") ]

 sample |> Map.tryPick (fun n s -> if n > 5 &amp;&amp; s.Length > 2 then Some s else None)
 </code>
 Evaluates to <c>Some "ccc"</c>.
 </example>

 <example id="trypick-2">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b"); (10, "ccc"); (20, "ddd") ]

 sample |> Map.tryPick (fun n s -> if n > 5 &amp;&amp; s.Length > 4 then Some s else None)
 </code>
 Evaluates to <c>None</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Find``2(``0,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Lookup an element in the map, raising <c>KeyNotFoundException</c> if no binding
 exists in the map.</summary>

 <param name="key">The input key.</param>
 <param name="table">The input map.</param>
 <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when the key does not exist in the map.</exception>

 <returns>The value mapped to the given key.</returns>

 <example id="find-1">
 <code lang="fsharp">
 let sample = Map [ (1, "a"); (2, "b") ]

 sample |> Map.find 1 // evaluates to "a"
 sample |> Map.find 3 // throws KeyNotFoundException
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Empty``2">
 <summary>The empty map.</summary>

 <example id="empty-1">
 <code lang="fsharp">
 let emptyMap = Map.empty&lt;int, string>
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.IsEmpty``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Is the map empty?</summary>

 <param name="table">The input map.</param>

 <returns>True if the map is empty.</returns>

 <example id="isempty-1">
 <code lang="fsharp">
 let emptyMap = Map.empty&lt;int, string>
 emptyMap |> Map.isEmpty  // evaluates to true

 let notEmptyMap = Map [ (1, "a"); (2, "b") ]
 emptyMap |> Map.isEmpty // evaluates to false
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.ToArray``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Returns an array of all key-value pairs in the mapping.
 The array will be ordered by the keys of the map.</summary>

 <param name="table">The input map.</param>

 <returns>The array of key/value pairs.</returns>

 <example id="toarray-1">
 <code lang="fsharp">
 let input = Map [ (1, "a"); (2, "b") ]

 input |> Map.toArray // evaluates to [|(1, "a"); (2, "b")|]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.ToList``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Returns a list of all key-value pairs in the mapping.
 The list will be ordered by the keys of the map.</summary>

 <param name="table">The input map.</param>

 <returns>The list of key/value pairs.</returns>

 <example id="tolist-1">
 <code lang="fsharp">
 let input = Map [ (1, "a"); (2, "b") ]

 input |> Map.toList // evaluates to [(1, "a"); (2, "b")]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.ToSeq``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Views the collection as an enumerable sequence of pairs.
 The sequence will be ordered by the keys of the map.</summary>

 <param name="table">The input map.</param>

 <returns>The sequence of key/value pairs.</returns>

 <example id="toseq-1">
 <code lang="fsharp">
 let input = Map [ (1, "a"); (2, "b") ]

 input |> Map.toSeq // evaluates to seq [(1, "a"); (2, "b")]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.OfSeq``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
 <summary>Returns a new map made from the given bindings.</summary>

 <param name="elements">The input sequence of key/value pairs.</param>

 <returns>The resulting map.</returns>

 <example id="ofseq-1">
 <code lang="fsharp">
 let input = seq { (1, "a"); (2, "b") }

 input |> Map.ofSeq // evaluates to map [(1, "a"); (2, "b")]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.OfArray``2(System.Tuple{``0,``1}[])">
 <summary>Returns a new map made from the given bindings.</summary>

 <param name="elements">The input array of key/value pairs.</param>

 <returns>The resulting map.</returns>

 <example id="ofarray-1">
 <code lang="fsharp">
 let input = [| (1, "a"); (2, "b") |]

 input |> Map.ofArray // evaluates to map [(1, "a"); (2, "b")]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.OfList``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
 <summary>Returns a new map made from the given bindings.</summary>

 <param name="elements">The input list of key/value pairs.</param>

 <returns>The resulting map.</returns>

 <example id="oflist-1">
 <code lang="fsharp">
 let input = [ (1, "a"); (2, "b") ]

 input |> Map.ofList // evaluates to map [(1, "a"); (2, "b")]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Change``2(``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``1},Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Returns a new map with the value stored under key changed according to f.</summary>

 <param name="key">The input key.</param>
 <param name="f">The change function.</param>
 <param name="table">The input map.</param>

 <returns>The resulting map.</returns>

 <example id="change-1">
 <code lang="fsharp">
 let input = Map [ (1, "a"); (2, "b") ]

 input |> Map.change 1 (fun x ->
     match x with
     | Some s -> Some (s + "z")
     | None -> None
 ) // evaluates to map [(1, "az"); (2, "b")]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Add``2(``0,``1,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
 <summary>Returns a new map with the binding added to the given map.
 If a binding with the given key already exists in the input map, the existing binding is replaced by the new binding in the result map.</summary>

 <param name="key">The input key.</param>
 <param name="value">The input value.</param>
 <param name="table">The input map.</param>

 <returns>The resulting map.</returns>

 <example id="add-1">
 <code lang="fsharp">
 let input = Map [ (1, "a"); (2, "b") ]

 input |> Map.add 3 "c" // evaluates to map [(1, "a"); (2, "b"); (3, "c")]
 input |> Map.add 2 "aa" // evaluates to map [(1, "a"); (2, "aa")]
 </code>
 </example>
</member>
<member name="T:Microsoft.FSharp.Collections.MapModule">
 <summary>Contains operations for working with values of type <see cref="T:Microsoft.FSharp.Collections.FSharpMap`2"/>.</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Difference``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Returns a new set with the elements of the second set removed from the first.</summary>

 <param name="set1">The first input set.</param>
 <param name="set2">The set whose elements will be removed from <c>set1</c>.</param>

 <returns>The set with the elements of <c>set2</c> removed from <c>set1</c>.</returns>

 <example id="set-difference">
 <code lang="fsharp">
 let set1 = Set.empty.Add(1).Add(2).Add(3)
 let set2 = Set.empty.Add(2).Add(3).Add(4)
 printfn $"The difference of {set1} and {set2} is {Set.difference set1 set2}"
 </code>
 The sample evaluates to the following output: <c>The difference of set [1; 2; 3] and set [2; 3; 4] is set [1]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.OfSeq``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a new collection from the given enumerable object.</summary>

 <param name="elements">The input sequence.</param>

 <returns>The set containing <c>elements</c>.</returns>

 <example id="set-ofseq">
 <code lang="fsharp">
 let set = Set.ofSeq [1, 2, 3]
 printfn $"The set is {set} and type is {set.GetType().Name}"
 </code>
 The sample evaluates to the following output: <c>The set is set [(1, 2, 3)] and type is "FSharpSet`1"</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.ToSeq``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Returns an ordered view of the collection as an enumerable object.</summary>

 <param name="set">The input set.</param>

 <returns>An ordered sequence of the elements of <c>set</c>.</returns>

 <example id="set-toseq">
 <code lang="fsharp">
 let set = Set.empty.Add(1).Add(2).Add(3)
 let seq = Set.toSeq set
 printfn $"The set is {set} and type is {seq.GetType().Name}"
 </code>
 The sample evaluates to the following output: <c>he set is set [1; 2; 3] and type is Microsoft.FSharp.Collections.FSharpSet`1[System.Int32]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.ToArray``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Builds an array that contains the elements of the set in order.</summary>

 <param name="set">The input set.</param>

 <returns>An ordered array of the elements of <c>set</c>.</returns>

 <example id="set-toarray">
 <code lang="fsharp">
 let set = Set.empty.Add(1).Add(2).Add(3)
 let array = Set.toArray set
 printfn$ "The set is {set} and type is {array.GetType().Name}"
 </code>
 The sample evaluates to the following output: <c>The set is [|1; 2; 3|] and type is System.Int32[]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.OfArray``1(``0[])">
 <summary>Builds a set that contains the same elements as the given array.</summary>

 <param name="array">The input array.</param>

 <returns>A set containing the elements of <c>array</c>.</returns>

 <example id="set-remove">
 <code lang="fsharp">
 let set = Set.ofArray [|1, 2, 3|]
 printfn $"The set is {set} and type is {set.GetType().Name}"
 </code>
 The sample evaluates to the following output: <c>The set is set [(1, 2, 3)] and type is "FSharpSet`1"</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.ToList``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Builds a list that contains the elements of the set in order.</summary>

 <param name="set">The input set.</param>

 <returns>An ordered list of the elements of <c>set</c>.</returns>

 <example id="set-tolist">
 <code lang="fsharp">
 let set = Set.empty.Add(1).Add(2).Add(3)
 let list = Set.toList set
 printfn $"The set is {list} and type is {list.GetType().Name}"
 </code>
 The sample evaluates to the following output: <c>The set is [1; 2; 3] and type is "FSharpList`1"</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Builds a set that contains the same elements as the given list.</summary>

 <param name="elements">The input list.</param>

 <returns>A set containing the elements form the input list.</returns>

 <example id="set-oflist">
 <code lang="fsharp">
 let set = Set.ofList [1, 2, 3]
 printfn $"The set is {set} and type is {set.GetType().Name}"
 </code>
 The sample evaluates to the following output: <c>The set is set [(1, 2, 3)] and type is "FSharpSet`1"</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.MaxElement``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Returns the highest element in the set according to the ordering being used for the set.</summary>

 <param name="set">The input set.</param>

 <returns>The max value from the set.</returns>

 <example id="set-maxelement">
 <code lang="fsharp">
 let set = Set.empty.Add(1).Add(2).Add(3)
 printfn $"The min element of {set} is {Set.minElement set}"
 </code>
 The sample evaluates to the following output: <c>The max element of set [1; 2; 3] is 3</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.MinElement``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Returns the lowest element in the set according to the ordering being used for the set.</summary>

 <param name="set">The input set.</param>

 <returns>The min value from the set.</returns>

 <example id="set-minelement">
 <code lang="fsharp">
 let set = Set.empty.Add(1).Add(2).Add(3)
 printfn $"The min element of {set} is {Set.minElement set}"
 </code>
 The sample evaluates to the following output: <c>The min element of set [1; 2; 3] is 1</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Remove``1(``0,Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Returns a new set with the given element removed. No exception is raised if
 the set doesn't contain the given element.</summary>

 <param name="value">The element to remove.</param>
 <param name="set">The input set.</param>

 <returns>The input set with <c>value</c> removed.</returns>

 <example id="set-remove">
 <code lang="fsharp">
 let set = Set.empty.Add(1).Add(2).Add(3)
 printfn $"The set without 1 is {Set.remove 1 set}"
 </code>
 The sample evaluates to the following output: <c>The set without 1 is set [2; 3]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Splits the set into two sets containing the elements for which the given predicate
 returns true and false respectively.</summary>

 <param name="predicate">The function to test set elements.</param>
 <param name="set">The input set.</param>

 <returns>A pair of sets with the first containing the elements for which <c>predicate</c> returns
 true and the second containing the elements for which <c>predicate</c> returns false.</returns>

 <example id="set-partition">
 <code lang="fsharp">
 let set = Set.empty.Add(1).Add(2).Add(3).Add(4)
 printfn $"The set with even numbers is {Set.partition (fun x -> x % 2 = 0) set}"
 </code>
 The sample evaluates to the following output: <c>The partitioned sets are: (set [2; 4], set [1; 3])</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Applies the given function to each element of the set, in order according
 to the comparison function.</summary>

 <param name="action">The function to apply to each element.</param>
 <param name="set">The input set.</param>

 <example id="set-iter">
 <code lang="fsharp">
 let set = Set.empty.Add(1).Add(2).Add(3)
 Set.iter (fun x -> printfn $"The set contains {x}") set
 </code>
 The sample evaluates to the following output: <c>
 The set contains 1
 The set contains 2
 The set contains 3</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.IsEmpty``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Returns "true" if the set is empty.</summary>

 <param name="set">The input set.</param>

 <returns>True if <c>set</c> is empty.</returns>

 <example id="set-isempty">
 <code lang="fsharp">
 let set = Set.empty.Add(2).Add(3)
 printfn $"Is the set empty? {set.IsEmpty}"
 </code>
 The sample evaluates to the following output: <c>Is the set empty? false</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.UnionMany``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Collections.FSharpSet{``0}})">
 <summary>Computes the union of a sequence of sets.</summary>

 <param name="sets">The sequence of sets to union.</param>

 <returns>The union of the input sets.</returns>

 <example id="set-unionmany">
 <code lang="fsharp">
 let headersByFile = seq{
 yield [ "id"; "name"; "date"; "color" ]
 yield [ "id"; "age"; "date" ]
 yield [ "id"; "sex"; "date"; "animal" ]
 }
 headersByFile
 |> Seq.map Set.ofList
 |> Set.intersectMany
 |> printfn "The intersection of %A is %A" headersByFile
 </code>
 The sample evaluates to the following output: <c>The union of seq
 [["id"; "name"; "date"; "color"]; ["id"; "age"; "date"];
 ["id"; "sex"; "date"; "animal"]] is set ["age"; "animal"; "color"; "date"; "id"; "name"; "sex"]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Union``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Computes the union of the two sets.</summary>

 <param name="set1">The first input set.</param>
 <param name="set2">The second input set.</param>

 <returns>The union of <c>set1</c> and <c>set2</c>.</returns>

 <example id="set-union">
 <code lang="fsharp">
 let set1 = Set.empty.Add(1).Add(2).Add(3)
 let set2 = Set.empty.Add(2).Add(3).Add(4)
 printfn $"The union of {set1} and {set2} is {(Set.union set1 set2)}"
 </code>
 The sample evaluates to the following output: <c>The union of set [1; 2; 3] and set [2; 3; 4] is set [1; 2; 3; 4]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.IntersectMany``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Collections.FSharpSet{``0}})">
 <summary>Computes the intersection of a sequence of sets. The sequence must be non-empty.</summary>

 <param name="sets">The sequence of sets to intersect.</param>

 <returns>The intersection of the input sets.</returns>

 <example id="set-intersectmany">
 <code lang="fsharp">
 let headersByFile = seq{
 yield [ "id"; "name"; "date"; "color" ]
 yield [ "id"; "age"; "date" ]
 yield [ "id"; "sex"; "date"; "animal" ]
 }
 headersByFile
 |> Seq.map Set.ofList
 |> Set.intersectMany
 |> printfn "The intersection of %A is %A" headersByFile
 </code>
 The sample evaluates to the following output: <c>The intersection of seq
 [["id"; "name"; "date"; "color"]; ["id"; "age"; "date"];
 ["id"; "sex"; "date"; "animal"]] is set ["date"; "id"]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Intersect``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Computes the intersection of the two sets.</summary>

 <param name="set1">The first input set.</param>
 <param name="set2">The second input set.</param>

 <returns>The intersection of <c>set1</c> and <c>set2</c>.</returns>

 <example id="set-intersect">
 <code lang="fsharp">
 let set1 = Set.empty.Add(1).Add(2).Add(3)
 let set2 = Set.empty.Add(2).Add(3).Add(4)
 printfn $"The intersection of {set1} and {set2} is {Set.intersect set1 set2}"
 </code>
 The sample evaluates to the following output: <c>The intersection of set [1; 2; 3] and set [2; 3; 4] is set [2; 3]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.ForAll``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Tests if all elements of the collection satisfy the given predicate.
 If the input function is <c>f</c> and the elements are <c>i0...iN</c> and "j0...jN"
 then computes <c>p i0 &amp;&amp; ... &amp;&amp; p iN</c>.</summary>

 <param name="predicate">The function to test set elements.</param>
 <param name="set">The input set.</param>

 <returns>True if all elements of <c>set</c> satisfy <c>predicate</c>.</returns>

 <example id="set-forall">
 <code lang="fsharp">
 let set = Set.empty.Add(1).Add(2).Add(3)
 printfn $"Does the set contain even numbers? {Set.forall (fun x -> x % 2 = 0) set}"
 </code>
 The sample evaluates to the following output: <c>Does the set contain even numbers? false</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Microsoft.FSharp.Collections.FSharpSet{``0},``1)">
 <summary>Applies the given accumulating function to all the elements of the set.</summary>

 <param name="folder">The accumulating function.</param>
 <param name="set">The input set.</param>
 <param name="state">The initial state.</param>

 <returns>The final state.</returns>

 <example id="set-foldback">
 <code lang="fsharp">
 let set = Set.empty.Add(1).Add(2).Add(3)
 printfn $"The sum of the set is {Set.foldBack (+) set 0}"
 printfn $"The set is {Set.foldBack (fun x acc -> x :: acc) set []}"
 </code>
 The sample evaluates to the following output: <c>The sum of the set is 6
 The set is [1; 2; 3]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1,Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Applies the given accumulating function to all the elements of the set</summary>

 <param name="folder">The accumulating function.</param>
 <param name="state">The initial state.</param>
 <param name="set">The input set.</param>

 <returns>The final state.</returns>

 <example id="set-fold">
 <code lang="fsharp">
 let set = Set.empty.Add(1).Add(2).Add(3)
 printfn $"The sum of the set is {Set.fold (+) 0 set}"
 printfn $"The product of the set is {Set.fold (*) 1 set}"
 printfn $"The reverse of the set is {Set.fold (fun x y -> y :: x) [] set}"
 </code>
 The sample evaluates to the following output: <c>The sum of the set is 6
 The product of the set is 6
 The reverse of the set is [3; 2; 1]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Returns a new collection containing the results of applying the
 given function to each element of the input set.</summary>

 <param name="mapping">The function to transform elements of the input set.</param>
 <param name="set">The input set.</param>

 <returns>A set containing the transformed elements.</returns>

 <example id="set-map">
 <code lang="fsharp">
 let set = Set.empty.Add(1).Add(2).Add(3)
 printfn $"The set with doubled values is {Set.map (fun x -> x * 2) set}"
 </code>
 The sample evaluates to the following output: <c>The set with doubled values is set [2; 4; 6]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Returns a new collection containing only the elements of the collection
 for which the given predicate returns True.</summary>

 <param name="predicate">The function to test set elements.</param>
 <param name="set">The input set.</param>

 <returns>The set containing only the elements for which <c>predicate</c> returns true.</returns>

 <example id="set-filter">
 <code lang="fsharp">
 let set = Set.empty.Add(1).Add(2).Add(3).Add(4)
 printfn $"The set with even numbers is {Set.filter (fun x -> x % 2 = 0) set}"
 </code>
 The sample evaluates to the following output: <c>The set with even numbers is set [2; 4]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Tests if any element of the collection satisfies the given predicate.
 If the input function is <c>predicate</c> and the elements are <c>i0...iN</c>
 then computes <c>p i0 or ... or p iN</c>.</summary>

 <param name="predicate">The function to test set elements.</param>
 <param name="set">The input set.</param>

 <returns>True if any element of <c>set</c> satisfies <c>predicate</c>.</returns>

 <example id="set-exists">
 <code lang="fsharp">
 let set = Set.empty.Add(1).Add(2).Add(3)
 printfn $"Does the set contain 1? {Set.exists (fun x -> x = 1) set}"
 </code>
 The sample evaluates to the following output: <c>Does the set contain 1? true</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Count``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Returns the number of elements in the set. Same as <c>size</c>.</summary>

 <param name="set">The input set.</param>

 <returns>The number of elements in the set.</returns>

 <example id="set-count">
 <code lang="fsharp">
 let set = Set.empty.Add(1).Add(2).Add(3)
 printfn $"The set has {set.Count} elements"
 </code>
 The sample evaluates to the following output: <c>The set has 3 elements</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.IsProperSuperset``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Evaluates to "true" if all elements of the second set are in the first, and at least
 one element of the first is not in the second.</summary>

 <param name="set1">The potential superset.</param>
 <param name="set2">The set to test against.</param>

 <returns>True if <c>set1</c> is a proper superset of <c>set2</c>.</returns>

 <example id="set-ispropersuperset">
 <code lang="fsharp">
 let set1 = Set.empty.Add(1).Add(2).Add(3)
 let set2 = Set.empty.Add(1).Add(2).Add(3).Add(4)
 printfn $"Is {set1} a proper superset of {set2}? {Set.isProperSuperset set1 set2}"
 </code>
 The sample evaluates to the following output: <c>Is set [1; 2; 3] a proper superset of set [1; 2; 3; 4]? false</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.IsSuperset``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Evaluates to "true" if all elements of the second set are in the first.</summary>

 <param name="set1">The potential superset.</param>
 <param name="set2">The set to test against.</param>

 <returns>True if <c>set1</c> is a superset of <c>set2</c>.</returns>

 <example id="set-issuperset">
 <code lang="fsharp">
 let set1 = Set.empty.Add(1).Add(2).Add(3)
 let set2 = Set.empty.Add(1).Add(2).Add(3).Add(4)
 printfn $"Is {set1} a superset of {set2}? {Set.isSuperset set1 set2}"
 </code>
 The sample evaluates to the following output: <c>Is set [1; 2; 3] a superset of set [1; 2; 3; 4]? false</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.IsProperSubset``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Evaluates to "true" if all elements of the first set are in the second, and at least
 one element of the second is not in the first.</summary>

 <param name="set1">The potential subset.</param>
 <param name="set2">The set to test against.</param>

 <returns>True if <c>set1</c> is a proper subset of <c>set2</c>.</returns>

 <example id="set-ispropersubset">
 <code lang="fsharp">
 let set1 = Set.empty.Add(1).Add(2).Add(3)
 let set2 = Set.empty.Add(1).Add(2).Add(3).Add(4)
 printfn $"Is {set1} a proper subset of {set2}? {Set.isProperSubset set1 set2}"
 </code>
 The sample evaluates to the following output: <c>Is set [1; 2; 3] a proper subset of set [1; 2; 3; 4]? true</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.IsSubset``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Evaluates to "true" if all elements of the first set are in the second</summary>

 <param name="set1">The potential subset.</param>
 <param name="set2">The set to test against.</param>

 <returns>True if <c>set1</c> is a subset of <c>set2</c>.</returns>

 <example id="set-issubset">
 <code lang="fsharp">
 let set1 = Set.empty.Add(1).Add(2).Add(3)
 let set2 = Set.empty.Add(1).Add(2).Add(3).Add(4)
 printfn $"Is {set1} a subset of {set2}? {Set.isSubset set1 set2}"
 </code>
 The sample evaluates to the following output: <c>Is set [1; 2; 3] a subset of set [1; 2; 3; 4]? true</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Contains``1(``0,Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Evaluates to "true" if the given element is in the given set.</summary>

 <param name="element">The element to test.</param>
 <param name="set">The input set.</param>

 <returns>True if <c>element</c> is in <c>set</c>.</returns>

 <example id="set-contains">
 <code lang="fsharp">
 let set = Set.empty.Add(2).Add(3)
 printfn $"Does the set contain 1? {set.Contains(1))}"
 </code>
 The sample evaluates to the following output: <c>Does the set contain 1? false</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Add``1(``0,Microsoft.FSharp.Collections.FSharpSet{``0})">
 <summary>Returns a new set with an element added to the set. No exception is raised if
 the set already contains the given element.</summary>

 <param name="value">The value to add.</param>
 <param name="set">The input set.</param>

 <returns>A new set containing <c>value</c>.</returns>

 <example id="set-add">
 <code lang="fsharp">
 let set = Set.empty.Add(1).Add(1).Add(2)
 printfn $"The new set is: {set}"
 </code>
 The sample evaluates to the following output: <c>The new set is: set [1; 2]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Singleton``1(``0)">
 <summary>The set containing the given element.</summary>

 <param name="value">The value for the set to contain.</param>

 <returns>The set containing <c>value</c>.</returns>

 <example id="singleton-1">
 <code lang="fsharp">
 Set.singleton 7
 </code>
 Evaluates to <c>set [ 7 ]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Empty``1">
 <summary>The empty set for the type 'T.</summary>

 <example id="empty-1">
 <code lang="fsharp">
 Set.empty&lt;int&gt;
 </code>
 Evaluates to <c>set [ ]</c>.
 </example>
</member>
<member name="T:Microsoft.FSharp.Collections.SetModule">
 <summary>Contains operations for working with values of type <see cref="T:Microsoft.FSharp.Collections.FSharpSet`1"/>.</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.MakeTupleType(System.Reflection.Assembly,System.Type[])">
 <summary>Returns a <see cref="T:System.Type"/> representing an F# tuple type with the given element types</summary>

 <param name="asm">Runtime assembly containing System.Tuple definitions.</param>
 <param name="types">An array of types for the tuple elements.</param>

 <returns>The type representing the tuple containing the input elements.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.MakeTupleType(System.Type[])">
 <summary>Returns a <see cref="T:System.Type"/> representing an F# tuple type with the given element types</summary>

 <param name="types">An array of types for the tuple elements.</param>

 <returns>The type representing the tuple containing the input elements.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.MakeStructTupleType(System.Reflection.Assembly,System.Type[])">
 <summary>Returns a <see cref="T:System.Type"/> representing an F# struct tuple type with the given element types</summary>

 <param name="asm">Runtime assembly containing System.ValueTuple definitions.</param>
 <param name="types">An array of types for the tuple elements.</param>

 <returns>The type representing the struct tuple containing the input elements.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.MakeFunctionType(System.Type,System.Type)">
 <summary>Returns a <see cref="T:System.Type"/> representing the F# function type with the given domain and range</summary>

 <param name="domain">The input type of the function.</param>
 <param name="range">The output type of the function.</param>

 <returns>The function type with the given domain and range.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsUnion(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Returns true if the <c>typ</c> is a representation of an F# union type or the runtime type of a value of that type</summary>

 <param name="typ">The type to check.</param>
 <param name="bindingFlags">Optional binding flags.</param>

 <returns>True if the type check succeeds.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsTuple(System.Type)">
 <summary>Return true if the <c>typ</c> is a representation of an F# tuple type </summary>

 <param name="typ">The type to check.</param>

 <returns>True if the type check succeeds.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsRecord(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Return true if the <c>typ</c> is a representation of an F# record type </summary>

 <param name="typ">The type to check.</param>
 <param name="bindingFlags">Optional binding flags.</param>

 <returns>True if the type check succeeds.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsModule(System.Type)">
 <summary>Return true if the <c>typ</c> is a <see cref="T:System.Type"/> value corresponding to the compiled form of an F# module </summary>

 <param name="typ">The type to check.</param>

 <returns>True if the type check succeeds.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsFunction(System.Type)">
 <summary>Return true if the <c>typ</c> is a representation of an F# function type or the runtime type of a closure implementing an F# function type</summary>

 <param name="typ">The type to check.</param>

 <returns>True if the type check succeeds.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsExceptionRepresentation(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Returns true if the <c>typ</c> is a representation of an F# exception declaration</summary>

 <param name="exceptionType">The type to check.</param>
 <param name="bindingFlags">Optional binding flags.</param>

 <returns>True if the type check is an F# exception.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetUnionCases(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Gets the cases of a union type.</summary>

 <remarks>Assumes the given type is a union type. If not, <see cref="T:System.ArgumentException" /> is raised during pre-computation.</remarks>

 <param name="unionType">The input union type.</param>
 <param name="bindingFlags">Optional binding flags.</param>

 <exception cref="T:System.ArgumentException">Thrown when the input type is not a union type.</exception>

 <returns>An array of descriptions of the cases of the given union type.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetTupleElements(System.Type)">
 <summary>Gets the tuple elements from the representation of an F# tuple type.</summary>

 <param name="tupleType">The input tuple type.</param>

 <returns>An array of the types contained in the given tuple type.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetRecordFields(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Reads all the fields from a record value, in declaration order</summary>

 <remarks>Assumes the given input is a record value. If not, <see cref="T:System.ArgumentException" /> is raised.</remarks>

 <param name="recordType">The input record type.</param>
 <param name="bindingFlags">Optional binding flags.</param>

 <returns>An array of descriptions of the properties of the record type.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetFunctionElements(System.Type)">
 <summary>Gets the domain and range types from an F# function type  or from the runtime type of a closure implementing an F# type</summary>

 <param name="functionType">The input function type.</param>

 <returns>A tuple of the domain and range types of the input function.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetExceptionFields(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Reads all the fields from an F# exception declaration, in declaration order</summary>

 <remarks>Assumes <c>exceptionType</c> is an exception representation type. If not, <see cref="T:System.ArgumentException" /> is raised.</remarks>

 <param name="exceptionType">The exception type to read.</param>
 <param name="bindingFlags">Optional binding flags.</param>

 <exception cref="T:System.ArgumentException">Thrown if the given type is not an exception.</exception>

 <returns>An array containing the PropertyInfo of each field in the exception.</returns>

 <example-tbd></example-tbd>
</member>
<member name="T:Microsoft.FSharp.Reflection.FSharpType">
 <summary>Contains operations associated with constructing and analyzing F# types such as records, unions and tuples</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionTagReader(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Assumes the given type is a union type.
 If not, <see cref="T:System.ArgumentException" /> is raised during pre-computation.</summary>

 <remarks>Using the computed function is more efficient than calling GetUnionCase
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.</remarks>

 <param name="unionType">The type of union to optimize reading.</param>
 <param name="bindingFlags">Optional binding flags.</param>

 <returns>An optimized function to read the tags of the given union type.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionTagMemberInfo(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Precompute a property or static method for reading an integer representing the case tag of a union type.</summary>

 <param name="unionType">The type of union to read.</param>
 <param name="bindingFlags">Optional binding flags.</param>

 <returns>The description of the union case reader.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionReader(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Precompute a function for reading all the fields for a particular discriminator case of a union type</summary>

 <remarks>Using the computed function will typically be faster than executing a corresponding call to GetFields</remarks>

 <param name="unionCase">The description of the union case to read.</param>
 <param name="bindingFlags">Optional binding flags.</param>

 <returns>A function to for reading the fields of the given union case.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionConstructorInfo(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>A method that constructs objects of the given case</summary>

 <param name="unionCase">The description of the union case.</param>
 <param name="bindingFlags">Optional binding flags.</param>

 <returns>The description of the constructor of the given union case.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionConstructor(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Precompute a function for constructing a discriminated union value for a particular union case. </summary>

 <param name="unionCase">The description of the union case.</param>
 <param name="bindingFlags">Optional binding flags.</param>

 <returns>A function for constructing values of the given union case.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTupleReader(System.Type)">
 <summary>Precompute a function for reading the values of a particular tuple type</summary>

 <remarks>Assumes the given type is a TupleType.
 If not, <see cref="T:System.ArgumentException" /> is raised during pre-computation.</remarks>

 <param name="tupleType">The tuple type to read.</param>

 <exception cref="T:System.ArgumentException">Thrown when the given type is not a tuple type.</exception>

 <returns>A function to read values of the given tuple type.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTuplePropertyInfo(System.Type,System.Int32)">
 <summary>Gets information that indicates how to read a field of a tuple</summary>

 <param name="tupleType">The input tuple type.</param>
 <param name="index">The index of the tuple element to describe.</param>

 <returns>The description of the tuple element and an optional type and index if the tuple is big.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTupleConstructorInfo(System.Type)">
 <summary>Gets a method that constructs objects of the given tuple type.
 For small tuples, no additional type will be returned.</summary>

 <remarks>For large tuples, an additional type is returned indicating that
 a nested encoding has been used for the tuple type. In this case
 the suffix portion of the tuple type has the given type and an
 object of this type must be created and passed as the last argument
 to the ConstructorInfo. A recursive call to PreComputeTupleConstructorInfo
 can be used to determine the constructor for that the suffix type.</remarks>

 <param name="tupleType">The input tuple type.</param>

 <returns>The description of the tuple type constructor and an optional extra type
 for large tuples.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTupleConstructor(System.Type)">
 <summary>Precompute a function for reading the values of a particular tuple type</summary>

 <remarks>Assumes the given type is a TupleType.
 If not, <see cref="T:System.ArgumentException" /> is raised during pre-computation.</remarks>

 <param name="tupleType">The type of tuple to read.</param>

 <exception cref="T:System.ArgumentException">Thrown when the given type is not a tuple type.</exception>

 <returns>A function to read a particular tuple type.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordReader(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Precompute a function for reading all the fields from a record. The fields are returned in the
 same order as the fields reported by a call to Microsoft.FSharp.Reflection.Type.GetInfo for
 this type.</summary>

 <remarks>Assumes the given type is a RecordType.
 If not, <see cref="T:System.ArgumentException" /> is raised during pre-computation.

 Using the computed function will typically be faster than executing a corresponding call to Value.GetInfo
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.</remarks>

 <param name="recordType">The type of record to read.</param>
 <param name="bindingFlags">Optional binding flags.</param>

 <exception cref="T:System.ArgumentException">Thrown when the input type is not a record type.</exception>

 <returns>An optimized reader for the given record type.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordFieldReader(System.Reflection.PropertyInfo)">
 <summary>Precompute a function for reading a particular field from a record.
 Assumes the given type is a RecordType with a field of the given name.
 If not, <see cref="T:System.ArgumentException" /> is raised during pre-computation.</summary>

 <remarks>Using the computed function will typically be faster than executing a corresponding call to Value.GetInfo
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.</remarks>

 <param name="info">The PropertyInfo of the field to read.</param>

 <exception cref="T:System.ArgumentException">Thrown when the input type is not a record type.</exception>

 <returns>A function to read the specified field from the record.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordConstructorInfo(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Get a ConstructorInfo for a record type</summary>

 <param name="recordType">The record type.</param>
 <param name="bindingFlags">Optional binding flags.</param>

 <returns>A ConstructorInfo for the given record type.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordConstructor(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Precompute a function for constructing a record value. </summary>

 <remarks>Assumes the given type is a RecordType.
 If not, <see cref="T:System.ArgumentException" /> is raised during pre-computation.</remarks>

 <param name="recordType">The type of record to construct.</param>
 <param name="bindingFlags">Optional binding flags.</param>

 <exception cref="T:System.ArgumentException">Thrown when the input type is not a record type.</exception>

 <returns>A function to construct records of the given type.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeUnion(Microsoft.FSharp.Reflection.UnionCaseInfo,System.Object[],Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Create a union case value.</summary>

 <param name="unionCase">The description of the union case to create.</param>
 <param name="args">The array of arguments to construct the given case.</param>
 <param name="bindingFlags">Optional binding flags.</param>

 <returns>The constructed union case.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeTuple(System.Object[],System.Type)">
 <summary>Creates an instance of a tuple type</summary>

 <remarks>Assumes at least one element is given. If not, <see cref="T:System.ArgumentException" /> is raised.</remarks>

 <param name="tupleElements">The array of tuple fields.</param>
 <param name="tupleType">The tuple type to create.</param>

 <exception cref="T:System.ArgumentException">Thrown if no elements are given.</exception>

 <returns>An instance of the tuple type with the given elements.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeRecord(System.Type,System.Object[],Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Creates an instance of a record type.</summary>

 <remarks>Assumes the given input is a record type.</remarks>

 <param name="recordType">The type of record to make.</param>
 <param name="values">The array of values to initialize the record.</param>
 <param name="bindingFlags">Optional binding flags for the record.</param>

 <exception cref="T:System.ArgumentException">Thrown when the input type is not a record type.</exception>

 <returns>The created record.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeFunction(System.Type,Microsoft.FSharp.Core.FSharpFunc{System.Object,System.Object})">
 <summary>Builds a typed function from object from a dynamic function implementation</summary>

 <param name="functionType">The function type of the implementation.</param>
 <param name="implementation">The untyped lambda of the function implementation.</param>

 <returns>A typed function from the given dynamic implementation.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetUnionFields(System.Object,System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Identify the union case and its fields for an object</summary>

 <remarks>Assumes the given input is a union case value. If not, <see cref="T:System.ArgumentException" /> is raised.

 If the type is not given, then the runtime type of the input object is used to identify the
 relevant union type. The type should always be given if the input object may be null. For example,
 option values may be represented using the 'null'.</remarks>
 <param name="value">The input union case.</param>
 <param name="unionType">The union type containing the value.</param>
 <param name="bindingFlags">Optional binding flags.</param>

 <exception cref="T:System.ArgumentException">Thrown when the input type is not a union case value.</exception>

 <returns>The description of the union case and its fields.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetTupleFields(System.Object)">
 <summary>Reads all fields from a tuple.</summary>

 <remarks>Assumes the given input is a tuple value. If not, <see cref="T:System.ArgumentException" /> is raised.</remarks>

 <param name="tuple">The input tuple.</param>

 <exception cref="T:System.ArgumentException">Thrown when the input is not a tuple value.</exception>

 <returns>An array of the fields from the given tuple.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetTupleField(System.Object,System.Int32)">
 <summary>Reads a field from a tuple value.</summary>

 <remarks>Assumes the given input is a tuple value. If not, <see cref="T:System.ArgumentException" /> is raised.</remarks>

 <param name="tuple">The input tuple.</param>
 <param name="index">The index of the field to read.</param>

 <returns>The value of the field.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetRecordFields(System.Object,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Reads all the fields from a record value.</summary>

 <remarks>Assumes the given input is a record value. If not, <see cref="T:System.ArgumentException" /> is raised.</remarks>
 <param name="record">The record object.</param>
 <param name="bindingFlags">Optional binding flags for the record.</param>

 <exception cref="T:System.ArgumentException">Thrown when the input type is not a record type.</exception>

 <returns>The array of fields from the record.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetRecordField(System.Object,System.Reflection.PropertyInfo)">
 <summary>Reads a field from a record value.</summary>

 <remarks>Assumes the given input is a record value. If not, <see cref="T:System.ArgumentException" /> is raised.</remarks>

 <param name="record">The record object.</param>
 <param name="info">The PropertyInfo describing the field to read.</param>

 <exception cref="T:System.ArgumentException">Thrown when the input is not a record value.</exception>

 <returns>The field from the record.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetExceptionFields(System.Object,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
 <summary>Reads all the fields from a value built using an instance of an F# exception declaration</summary>

 <remarks>Assumes the given input is an F# exception value. If not, <see cref="T:System.ArgumentException" /> is raised.</remarks>

 <param name="exn">The exception instance.</param>
 <param name="bindingFlags">Optional binding flags.</param>

 <exception cref="T:System.ArgumentException">Thrown when the input type is not an F# exception.</exception>

 <returns>The fields from the given exception.</returns>

 <example-tbd></example-tbd>
</member>
<member name="T:Microsoft.FSharp.Reflection.FSharpValue">
 <summary>Contains operations associated with constructing and analyzing values associated with F# types
 such as records, unions and tuples.</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.UnionCaseInfo.Tag">
 <summary>The integer tag for the case.</summary>

 <example id="Tag-1">
 <code lang="fsharp">
 type CoinToss = Heads | Tails

 typeof&lt;CoinToss&gt;
 |> FSharpType.GetUnionCases
 |> Array.map (fun x -> $"{x.Name} has tag {x.Tag}")
 </code>
 Evaluates to <c>[|"Heads has tag 0"; "Tails has tag 1"|]</c>
 </example>
</member>
<member name="P:Microsoft.FSharp.Reflection.UnionCaseInfo.Name">
 <summary>The name of the case.</summary>

 <example id="Name-1">
 <code lang="fsharp">
 type Weather = Rainy | Sunny

 typeof&lt;Weather&gt;
 |> FSharpType.GetUnionCases
 |> Array.map (fun x -> x.Name)
 </code>
 Evaluates to <c>[|"Rainy", "Sunny"|]</c>
 </example>
</member>
<member name="P:Microsoft.FSharp.Reflection.UnionCaseInfo.DeclaringType">
 <summary>The type in which the case occurs.</summary>

 <example id="DeclaringType-1">
 <code lang="fsharp">
 type Weather = Rainy | Sunny

 let rainy =
     typeof&lt;Weather&gt;
     |> FSharpType.GetUnionCases
     |> Array.head

 rainy.DeclaringType
 </code>
 Evaluates to a value of type <c>System.Type</c>
 that holds type information for <c>Weather</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Reflection.UnionCaseInfo.GetFields">
 <summary>The fields associated with the case, represented by a PropertyInfo.</summary>
 <returns>The fields associated with the case.</returns>

 <example id="GetFields-1">
 <code lang="fsharp">
 type Shape =
     | Rectangle of width : float * length : float
     | Circle of radius : float
     | Prism of width : float * float * height : float

 typeof&lt;Shape&gt;
 |> FSharpType.GetUnionCases
 |> Array.map (fun unionCase ->
     unionCase.GetFields()
     |> Array.map (fun fieldInfo ->
         fieldInfo.Name,
         fieldInfo.PropertyType.Name))
 </code>
 Evaluates to
 <code lang="fsharp">
 [|[|("width", "Double"); ("length", "Double")|];
   [|("radius", "Double")|];
   [|("width", "Double"); ("Item2", "Double"); ("height", "Double")|]|]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Reflection.UnionCaseInfo.GetCustomAttributesData">
 <summary>Returns the custom attributes data associated with the case.</summary>
 <returns>An list of custom attribute data items.</returns>

 <example id="GetCustomAttributesData-1">
 <code lang="fsharp">
 type Signal(signal: string) =
   inherit System.Attribute()
   member this.Signal = signal

 type Answer =
     | [&lt;Signal("Thumbs up")&gt;] Yes
     | [&lt;Signal("Thumbs down")&gt;] No

 let answerYes =
     typeof&lt;Answer&gt;
     |> FSharpType.GetUnionCases
     |> Array.find (fun x -> x.Name = "Yes")

 answerYes.GetCustomAttributesData()
 </code>
 Evaluates to
 <code lang="fsharp">
  [|[FSI_0150+Signal("Thumbs up")]
      {AttributeType = FSI_0150+Signal;
       Constructor = Void .ctor(System.String);
       ConstructorArguments = seq ["Thumbs up"];
       NamedArguments = seq [];};
    [Microsoft.FSharp.Core.CompilationMappingAttribute((Microsoft.FSharp.Core.SourceConstructFlags)8, (Int32)0)]
      {AttributeType = Microsoft.FSharp.Core.CompilationMappingAttribute;
       Constructor = Void .ctor(Microsoft.FSharp.Core.SourceConstructFlags, Int32);
       ConstructorArguments = seq
                                [(Microsoft.FSharp.Core.SourceConstructFlags)8;
                                 (Int32)0];
       NamedArguments = seq [];}|]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Reflection.UnionCaseInfo.GetCustomAttributes(System.Type)">
 <summary>Returns the custom attributes associated with the case matching the given attribute type.</summary>
 <param name="attributeType">The type of attributes to return.</param>

 <returns>An array of custom attributes.</returns>

 <example id="GetCustomAttributes-2">
 <code lang="fsharp">
 type Signal(signal: string) =
    inherit System.Attribute()
    member this.Signal = signal

 type Answer =
     | [&lt;Signal("Thumbs up")&gt;] Yes
     | [&lt;Signal("Thumbs down")&gt;] No

 typeof&lt;Answer&gt;
 |> FSharpType.GetUnionCases
 |> Array.map (fun x -> x.GetCustomAttributes(typeof&lt;Signal&gt;))
 </code>
 Evaluates to
 <code lang="fsharp">
 [|[|FSI_0147+Signal {Signal = "Thumbs up";
                      TypeId = FSI_0147+Signal;}|];
   [|FSI_0147+Signal {Signal = "Thumbs down";
                      TypeId = FSI_0147+Signal;}|]|]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Reflection.UnionCaseInfo.GetCustomAttributes">
 <summary>Returns the custom attributes associated with the case.</summary>
 <returns>An array of custom attributes.</returns>

 <example id="GetCustomAttributes-1">
 <code lang="fsharp">
 type Weather =
     | Rainy
     | Sunny

 typeof&lt;Weather&gt;
 |> FSharpType.GetUnionCases
 |> Array.map (fun x -> x.GetCustomAttributes())
 </code>
 Evaluates to
 <code lang="fsharp">
 [|[|Microsoft.FSharp.Core.CompilationMappingAttribute
     {ResourceName = null;
      SequenceNumber = 0;
      SourceConstructFlags = UnionCase;
      TypeDefinitions = null;
      TypeId = Microsoft.FSharp.Core.CompilationMappingAttribute;
      VariantNumber = 0;}|];
 [|Microsoft.FSharp.Core.CompilationMappingAttribute
     {ResourceName = null;
      SequenceNumber = 1;
      SourceConstructFlags = UnionCase;
      TypeDefinitions = null;
      TypeId = Microsoft.FSharp.Core.CompilationMappingAttribute;
      VariantNumber = 0;}|]|]
 </code>
 </example>
</member>
<member name="T:Microsoft.FSharp.Reflection.UnionCaseInfo">
 <summary>Represents a case of a discriminated union type</summary>

 <namespacedoc><summary>
   Library functionality for accessing additional information about F# types and F# values at
   runtime, augmenting that available through <a href="https://docs.microsoft.com/dotnet/api/system.reflection">System.Reflection</a>.
 </summary></namespacedoc>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpReflectionExtensions.FSharpType.IsExceptionRepresentation.Static(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Returns true if the <c>exceptionType</c> is a representation of an F# exception declaration</summary>

 <param name="exceptionType">The type to check.</param>
 <param name="allowAccessToPrivateRepresentation">Optional flag that denotes accessibility of the private representation.</param>

 <returns>True if the type check is an F# exception.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpReflectionExtensions.FSharpType.GetExceptionFields.Static(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Reads all the fields from an F# exception declaration, in declaration order</summary>

 <remarks>Assumes <c>exceptionType</c> is an exception representation type. If not, <see cref="T:System.ArgumentException" /> is raised.</remarks>

 <param name="exceptionType">The exception type to read.</param>
 <param name="allowAccessToPrivateRepresentation">Optional flag that denotes accessibility of the private representation.</param>

 <exception cref="T:System.ArgumentException">Thrown if the given type is not an exception.</exception>

 <returns>An array containing the PropertyInfo of each field in the exception.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpReflectionExtensions.FSharpType.IsUnion.Static(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Returns true if the <c>typ</c> is a representation of an F# union type or the runtime type of a value of that type</summary>

 <param name="typ">The type to check.</param>
 <param name="allowAccessToPrivateRepresentation">Optional flag that denotes accessibility of the private representation.</param>

 <returns>True if the type check succeeds.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpReflectionExtensions.FSharpType.IsRecord.Static(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Return true if the <c>typ</c> is a representation of an F# record type </summary>

 <param name="typ">The type to check.</param>
 <param name="allowAccessToPrivateRepresentation">Optional flag that denotes accessibility of the private representation.</param>

 <returns>True if the type check succeeds.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpReflectionExtensions.FSharpType.GetUnionCases.Static(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Gets the cases of a union type.</summary>

 <remarks>Assumes the given type is a union type. If not, <see cref="T:System.ArgumentException" /> is raised during pre-computation.</remarks>

 <param name="unionType">The input union type.</param>
 <param name="allowAccessToPrivateRepresentation">Optional flag that denotes accessibility of the private representation.</param>

 <exception cref="T:System.ArgumentException">Thrown when the input type is not a union type.</exception>

 <returns>An array of descriptions of the cases of the given union type.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpReflectionExtensions.FSharpType.GetRecordFields.Static(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Reads all the fields from a record value, in declaration order</summary>

 <remarks>Assumes the given input is a record value. If not, <see cref="T:System.ArgumentException" /> is raised.</remarks>

 <param name="recordType">The input record type.</param>
 <param name="allowAccessToPrivateRepresentation">Optional flag that denotes accessibility of the private representation.</param>

 <returns>An array of descriptions of the properties of the record type.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpReflectionExtensions.FSharpValue.GetExceptionFields.Static(System.Object,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Reads all the fields from a value built using an instance of an F# exception declaration</summary>

 <remarks>Assumes the given input is an F# exception value. If not, <see cref="T:System.ArgumentException" /> is raised.</remarks>

 <param name="exn">The exception instance.</param>
 <param name="allowAccessToPrivateRepresentation">Optional flag that denotes accessibility of the private representation.</param>

 <exception cref="T:System.ArgumentException">Thrown when the input type is not an F# exception.</exception>

 <returns>The fields from the given exception.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpReflectionExtensions.FSharpValue.PreComputeUnionConstructorInfo.Static(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>A method that constructs objects of the given case</summary>

 <param name="unionCase">The description of the union case.</param>
 <param name="allowAccessToPrivateRepresentation">Optional flag that denotes accessibility of the private representation.</param>

 <returns>The description of the constructor of the given union case.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpReflectionExtensions.FSharpValue.PreComputeUnionConstructor.Static(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Precompute a function for constructing a discriminated union value for a particular union case. </summary>

 <param name="unionCase">The description of the union case.</param>
 <param name="allowAccessToPrivateRepresentation">Optional flag that denotes accessibility of the private representation.</param>

 <returns>A function for constructing values of the given union case.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpReflectionExtensions.FSharpValue.PreComputeUnionReader.Static(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Precompute a function for reading all the fields for a particular discriminator case of a union type</summary>

 <remarks>Using the computed function will typically be faster than executing a corresponding call to GetFields</remarks>

 <param name="unionCase">The description of the union case to read.</param>
 <param name="allowAccessToPrivateRepresentation">Optional flag that denotes accessibility of the private representation.</param>

 <returns>A function to for reading the fields of the given union case.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpReflectionExtensions.FSharpValue.PreComputeUnionTagMemberInfo.Static(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Precompute a property or static method for reading an integer representing the case tag of a union type.</summary>

 <param name="unionType">The type of union to read.</param>
 <param name="allowAccessToPrivateRepresentation">Optional flag that denotes accessibility of the private representation.</param>

 <returns>The description of the union case reader.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpReflectionExtensions.FSharpValue.PreComputeUnionTagReader.Static(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Assumes the given type is a union type.
 If not, <see cref="T:System.ArgumentException" /> is raised during pre-computation.</summary>

 <remarks>Using the computed function is more efficient than calling GetUnionCase
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.</remarks>

 <param name="unionType">The type of union to optimize reading.</param>
 <param name="allowAccessToPrivateRepresentation">Optional flag that denotes accessibility of the private representation.</param>

 <returns>An optimized function to read the tags of the given union type.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpReflectionExtensions.FSharpValue.GetUnionFields.Static(System.Object,System.Type,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Identify the union case and its fields for an object</summary>

 <remarks>Assumes the given input is a union case value. If not, <see cref="T:System.ArgumentException" /> is raised.

 If the type is not given, then the runtime type of the input object is used to identify the
 relevant union type. The type should always be given if the input object may be null. For example,
 option values may be represented using the 'null'.</remarks>

 <param name="value">The input union case.</param>
 <param name="unionType">The union type containing the value.</param>
 <param name="allowAccessToPrivateRepresentation">Optional flag that denotes accessibility of the private representation.</param>

 <exception cref="T:System.ArgumentException">Thrown when the input type is not a union case value.</exception>

 <returns>The description of the union case and its fields.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpReflectionExtensions.FSharpValue.MakeUnion.Static(Microsoft.FSharp.Reflection.UnionCaseInfo,System.Object[],Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Create a union case value.</summary>

 <param name="unionCase">The description of the union case to create.</param>
 <param name="args">The array of arguments to construct the given case.</param>
 <param name="allowAccessToPrivateRepresentation">Optional flag that denotes accessibility of the private representation.</param>

 <returns>The constructed union case.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpReflectionExtensions.FSharpValue.PreComputeRecordConstructorInfo.Static(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Get a ConstructorInfo for a record type</summary>

 <param name="recordType">The record type.</param>
 <param name="allowAccessToPrivateRepresentation">Optional flag that denotes accessibility of the private representation.</param>

 <returns>A ConstructorInfo for the given record type.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpReflectionExtensions.FSharpValue.PreComputeRecordConstructor.Static(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Precompute a function for constructing a record value. </summary>

 <remarks>Assumes the given type is a RecordType.
 If not, <see cref="T:System.ArgumentException" /> is raised during pre-computation.</remarks>

 <param name="recordType">The type of record to construct.</param>
 <param name="allowAccessToPrivateRepresentation">Optional flag that denotes accessibility of the private representation.</param>

 <exception cref="T:System.ArgumentException">Thrown when the input type is not a record type.</exception>

 <returns>A function to construct records of the given type.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpReflectionExtensions.FSharpValue.PreComputeRecordReader.Static(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Precompute a function for reading all the fields from a record. The fields are returned in the
 same order as the fields reported by a call to Microsoft.FSharp.Reflection.Type.GetInfo for
 this type.</summary>

 <remarks>Assumes the given type is a RecordType.
 If not, <see cref="T:System.ArgumentException" /> is raised during pre-computation.

 Using the computed function will typically be faster than executing a corresponding call to Value.GetInfo
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.</remarks>

 <param name="recordType">The type of record to read.</param>
 <param name="allowAccessToPrivateRepresentation">Optional flag that denotes accessibility of the private representation.</param>

 <exception cref="T:System.ArgumentException">Thrown when the input type is not a record type.</exception>

 <returns>An optimized reader for the given record type.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpReflectionExtensions.FSharpValue.GetRecordFields.Static(System.Object,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Reads all the fields from a record value.</summary>

 <remarks>Assumes the given input is a record value. If not, <see cref="T:System.ArgumentException" /> is raised.</remarks>

 <param name="record">The record object.</param>
 <param name="allowAccessToPrivateRepresentation">Optional flag that denotes accessibility of the private representation.</param>

 <exception cref="T:System.ArgumentException">Thrown when the input type is not a record type.</exception>

 <returns>The array of fields from the record.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpReflectionExtensions.FSharpValue.MakeRecord.Static(System.Type,System.Object[],Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Creates an instance of a record type.</summary>

 <remarks>Assumes the given input is a record type.</remarks>

 <param name="recordType">The type of record to make.</param>
 <param name="values">The array of values to initialize the record.</param>
 <param name="allowAccessToPrivateRepresentation">Optional flags that denotes accessibility of the private representation.</param>

 <exception cref="T:System.ArgumentException">Thrown when the input type is not a record type.</exception>

 <returns>The created record.</returns>

 <example-tbd></example-tbd>
</member>
<member name="T:Microsoft.FSharp.Reflection.FSharpReflectionExtensions">
 <summary>Defines further accessing additional information about F# types and F# values at runtime.</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredPrintfImpl.FormatOptions">
<summary>
 A record of options to control structural formatting.
 For F# Interactive properties matching those of this value can be accessed via the &apos;fsi&apos;
 value.

 Floating Point format given in the same format accepted by System.Double.ToString,
 e.g. f6 or g15.

 If ShowProperties is set the printing process will evaluate properties of the values being
 displayed.  This may cause additional computation.

 The ShowIEnumerable is set the printing process will force the evaluation of IEnumerable objects
 to a small, finite depth, as determined by the printing parameters.
 This may lead to additional computation being performed during printing.
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredPrintfImpl.Layout">
<summary>
 Data representing structured layouts of terms.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.Display.layout_to_string(Microsoft.FSharp.Text.StructuredPrintfImpl.FormatOptions,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Convert any value to a layout using the given formatting options.  The
 layout can then be processed using formatting display engines such as
 those in the Layout module.  any_to_string and output_any are
 built using any_to_layout with default format options.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.unfoldL``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``0,``1}}},``1,System.Int32)">
<summary>
 For limiting layout of list-like sequences (lists,arrays,etc).
 unfold a list of items using (project and z) making layout list via itemL.
 If reach maxLength (before exhausting) then truncate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.tagAttrL(System.String,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,System.String}},Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 See tagL
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.listL``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Layout like an F# list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.optionL``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Layout like an F# option.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.aboveListL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Layout list vertically.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.aboveL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Layout two vertically.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.tupleL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Form tuple of layouts.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.braceL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Wrap braces around layout.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.squareBracketL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Wrap square brackets around layout.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.bracketL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Wrap round brackets around Layout.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.sepListL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Join layouts into a list separated using the given Layout.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.semiListL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Join layouts into a semi-colon separated list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.spaceListL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Join layouts into a space separated list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.commaListL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Join layouts into a comma separated list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.op_AtAtMinusMinusMinusMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join broken with ident=4
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.op_AtAtMinusMinusMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join broken with ident=3
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.op_AtAtMinusMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join broken with ident=2
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.op_AtAtMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join broken with ident=1
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.op_AtAt(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join broken with ident=0
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.op_MinusMinusMinusMinusMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 optional break, indent=4
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.op_MinusMinusMinusMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 optional break, indent=3
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.op_MinusMinusMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join, possible break with indent=2
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.op_MinusMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join, possible break with indent=1
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.op_PlusPlus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join, possible break with indent=0
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.op_HatHat(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join, unbreakable.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.leftL(Microsoft.FSharp.Text.StructuredPrintfImpl.TaggedText)">
<summary>
 An string which is left  parenthesis (no space on the right).
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.rightL(Microsoft.FSharp.Text.StructuredPrintfImpl.TaggedText)">
<summary>
 An string which is right parenthesis (no space on the left).
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.sepL(Microsoft.FSharp.Text.StructuredPrintfImpl.TaggedText)">
<summary>
 An string which requires no spaces either side.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.wordL(Microsoft.FSharp.Text.StructuredPrintfImpl.TaggedText)">
<summary>
 An string leaf
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.objL(System.Object)">
<summary>
 An uninterpreted leaf, to be interpreted into a string
 by the layout engine. This allows leaf layouts for numbers, strings and
 other atoms to be customized according to culture.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.isEmptyL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Is it the empty layout?
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule.emptyL">
<summary>
 The empty layout
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutModule">
<summary>
 A layout is a sequence of strings which have been joined together.
 The strings are classified as words, separators and left and right parenthesis.
 This classification determines where spaces are inserted.
 A joint is either unbreakable, breakable or broken.
 If a joint is broken the RHS layout occurs on the next line with optional indentation.
 A layout can be squashed to for given width which forces breaks as required.
</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.FSharpExpr`1.Raw">
 <summary>Gets the raw expression associated with this type-carrying expression</summary>

 <example id="raw-1">
 <code lang="fsharp">
 open FSharp.Quotations

 let expr1 = &lt;@ 1 + 1 @&gt;

 expr1.Raw
 </code>
 Evaluates to the same quotation as <c>&lt;@ expr1 @&gt;</c> except with the weaker type <c>Expr</c> instead of <c>Expr&lt;int&gt;</c>.
 </example>
</member>
<member name="T:Microsoft.FSharp.Quotations.FSharpExpr`1">
 <summary>Type-carrying quoted expressions. Expressions are generated either
 by quotations in source text or programatically</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.FSharpExpr.Type">
 <summary>Returns type of an expression.</summary>

 <example id="type-1">
 <code lang="fsharp">
 open FSharp.Quotations
 open FSharp.Quotations.Patterns

 let sampleQuotation =  &lt;@ 1 + 1 @&gt;

 sampleQuotation.Type
 </code>
 Evaluates to <c>typeof&lt;int&gt;</c>.
 </example>
</member>
<member name="P:Microsoft.FSharp.Quotations.FSharpExpr.CustomAttributes">
 <summary>Returns the custom attributes of an expression. For quotations deriving from quotation literals this may include the source location of the literal.</summary>

 <example id="customattributes-1">
 <code lang="fsharp">
 open FSharp.Quotations
 open FSharp.Quotations.Patterns

 let sampleQuotation =  &lt;@ 1 + 1 @&gt;

 sampleQuotation.CustomAttributes
 </code>
 Evaluates to a list of expressions containing one custom attribute for the source location of the quotation literal.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.WithValue(System.Object,System.Type,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents a value and its associated reflected definition as a quotation</summary>

 <param name="value">The untyped object.</param>
 <param name="expressionType">The type of the object.</param>
 <param name="definition">The definition of the value being quoted.</param>

 <returns>The resulting expression.</returns>

 <example id="withvalue-2">
 <code lang="fsharp">
 open FSharp.Quotations

 Expr.WithValue(box 1, typeof&lt;int&gt;, &lt;@ 2 - 1 @&gt;)
 </code>
 Evaluates to a quotation that displays as <c>WithValue (1, Call (None, op_Subtraction, [Value (2), Value (1)]))</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.WithValue``1(``0,Microsoft.FSharp.Quotations.FSharpExpr{``0})">
 <summary>Builds an expression that represents a value and its associated reflected definition as a quotation</summary>

 <param name="value">The value being quoted.</param>
 <param name="definition">The definition of the value being quoted.</param>

 <returns>The resulting expression.</returns>

 <example id="withvalue-1">
 <code lang="fsharp">
 open FSharp.Quotations

 Expr.WithValue(1, &lt;@ 2 - 1 @&gt;)
 </code>
 Evaluates to a quotation that displays as <c>WithValue (1, Call (None, op_Subtraction, [Value (2), Value (1)]))</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.WhileLoop(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents a while loop</summary>

 <param name="guard">The predicate to control the loop iteration.</param>
 <param name="body">The body of the while loop.</param>

 <returns>The resulting expression.</returns>

 <example id="varset-1">
 <code lang="fsharp">
 open FSharp.Quotations

 let guardExpr = &lt;@ true @&gt;
 let bodyExpr = &lt;@ () @&gt;

 Expr.WhileLoop(guardExpr, bodyExpr)
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ while true do () @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.VarSet(Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents setting a mutable variable</summary>

 <param name="variable">The input variable.</param>
 <param name="value">The value to set.</param>

 <returns>The resulting expression.</returns>

 <example id="varset-1">
 <code lang="fsharp">
 open FSharp.Quotations

 let vVar = Var("v", typeof&lt;int&gt;, isMutable=true)

 Expr.VarSet(vVar, &lt;@ 5 @&gt;)
 </code>
 Evaluates to a quotation displayed as <c>VarSet (v, Value (5))</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Var(Microsoft.FSharp.Quotations.FSharpVar)">
 <summary>Builds an expression that represents a variable</summary>

 <param name="variable">The input variable.</param>

 <returns>The resulting expression.</returns>

 <example id="var-1">
 <code lang="fsharp">
 open FSharp.Quotations

 let vVar = Var("v", typeof&lt;int&gt;)

 Expr.Var(vVar)
 </code>
 Evaluates to a quotation displayed as <c>v</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.ValueWithName(System.Object,System.Type,System.String)">
 <summary>Builds an expression that represents a constant value of a particular type, arising from a variable of the given name </summary>

 <param name="value">The untyped object.</param>
 <param name="expressionType">The type of the object.</param>
 <param name="name">The name of the variable.</param>

 <returns>The resulting expression.</returns>

 <example id="valuewithname-1">
 <code lang="fsharp">
 open FSharp.Quotations

 Expr.ValueWithName(box 1, typeof&lt;int&gt;, "name")
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ 1 @&gt;</c> and associated information that the name of the value is <c>"name"</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.ValueWithName``1(``0,System.String)">
 <summary>Builds an expression that represents a constant value, arising from a variable of the given name </summary>

 <param name="value">The typed value.</param>
 <param name="name">The name of the variable.</param>

 <returns>The resulting expression.</returns>

 <example id="valuewithname-1">
 <code lang="fsharp">
 open FSharp.Quotations

 Expr.ValueWithName(1, "name")
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ 1 @&gt;</c> and associated information that the name of the value is <c>"name"</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Value``1(``0)">
 <summary>Builds an expression that represents a constant value </summary>

 <param name="value">The typed value.</param>

 <example id="value-2">
 <code lang="fsharp">
 open FSharp.Quotations

 Expr.Value(1)
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ 1 @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Value(System.Object,System.Type)">
 <summary>Builds an expression that represents a constant value of a particular type</summary>

 <param name="value">The untyped object.</param>
 <param name="expressionType">The type of the object.</param>

 <returns>The resulting expression.</returns>

 <example id="value-1">
 <code lang="fsharp">
 open FSharp.Quotations

 Expr.Value(box 1, typeof&lt;int&gt;)
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ 1 @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.UnionCaseTest(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Reflection.UnionCaseInfo)">
 <summary>Builds an expression that represents a test of a value is of a particular union case</summary>

 <param name="source">The expression to test.</param>
 <param name="unionCase">The description of the union case.</param>

 <returns>The resulting expression.</returns>

 <example id="unioncasetest-1">
 <code lang="fsharp">
 open System
 open FSharp.Quotations
 open FSharp.Reflection

 let ucCons = FSharpType.GetUnionCases(typeof&lt;int list&gt;)[1]

 Expr.UnionCaseTest(&lt;@ [11] @&gt;, ucCons)
 </code>
 Evaluates to a quotation that displays as <c>UnionCaseTest (NewUnionCase (Cons, Value (11), NewUnionCase (Empty)), Cons)</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.TypeTest(Microsoft.FSharp.Quotations.FSharpExpr,System.Type)">
 <summary>Builds an expression that represents a type test.</summary>

 <param name="source">The expression to test.</param>
 <param name="target">The target type.</param>

 <returns>The resulting expression.</returns>

 <example id="typetest-1">
 <code lang="fsharp">
 open FSharp.Quotations

 let obj = box 1

 Expr.TypeTest( &lt;@ obj @&gt;, typeof&lt;int&gt;)
 </code>
 Evaluates to quotation that displays as <c>TypeTest (Int32, PropertyGet (None, obj, []))</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.TupleGet(Microsoft.FSharp.Quotations.FSharpExpr,System.Int32)">
 <summary>Builds an expression that represents getting a field of a tuple</summary>

 <param name="tuple">The input tuple.</param>
 <param name="index">The index of the tuple element to get.</param>

 <returns>The resulting expression.</returns>

 <example id="tupleget-1">
 <code lang="fsharp">
 open FSharp.Quotations

 let tupExpr = &lt;@ (1, 2, 3) @&gt;

 Expr.TupleGet(tupExpr, 1)
 </code>
 Evaluates to quotation that displays as <c>TupleGet (NewTuple (Value (1), Value (2), Value (3)), 1)</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.TryWith(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents a try/with construct for exception filtering and catching.</summary>

 <param name="body">The body of the try expression.</param>
 <param name="filterVar"></param>
 <param name="filterBody"></param>
 <param name="catchVar">The variable to bind to a caught exception.</param>
 <param name="catchBody">The expression evaluated when an exception is caught.</param>

 <returns>The resulting expression.</returns>

 <example id="trywith-1">
 <code lang="fsharp">
 open System
 open FSharp.Quotations

 let exnVar = Var("exn", typeof&lt;exn&gt;)

 Expr.TryWith(&lt;@ 1+1 @&gt;, exnVar, &lt;@ 1 @&gt;, exnVar, &lt;@ 2+2 @&gt;)
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ try 1+1 with exn -> 2+2 @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.TryGetReflectedDefinition(System.Reflection.MethodBase)">
 <summary>Try and find a stored reflection definition for the given method. Stored reflection
 definitions are added to an F# assembly through the use of the [&lt;ReflectedDefinition&gt;] attribute.</summary>

 <param name="methodBase">The description of the method to find.</param>

 <returns>The reflection definition or None if a match could not be found.</returns>

 <example id="trygetreflecteddefinition-1">
 <code lang="fsharp">
 open FSharp.Quotations
 open FSharp.Quotations.Patterns

 [&lt;ReflectedDefinition&gt;]
 let f x = x + 1

 let methInfo =
     match &lt;@ f 1 @&gt; with
     | Call(_, mi, _) -> mi
     | _ -> failwith "call expected"

 Expr.TryGetReflectedDefinition(methInfo)
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ fun x -> x + 1 @&gt;</c>, which is the implementation of the
 method <c>f</c>.
 </example>

 <example id="trygetreflecteddefinition-2">
 <code lang="fsharp">
 open FSharp.Quotations
 open FSharp.Quotations.Patterns

 [&lt;ReflectedDefinition&gt;]
 module Methods =
    let f x = (x, x)

 let methInfoGeneric =
     match &lt;@ Methods.f (1, 2) @&gt; with
     | Call(_, mi, _) -> mi.GetGenericMethodDefinition()
     | _ -> failwith "call expected"

 let methInfoAtString = methInfoGeneric.MakeGenericMethod(typeof&lt;string&gt;)

 Expr.TryGetReflectedDefinition(methInfoAtString)
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ fun (x: string) -> (x, x) @&gt;</c>, which is the implementation of the
 generic method <c>f</c> instanatiated at type <c>string</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.TryFinally(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents a try/finally construct </summary>

 <param name="body">The body of the try expression.</param>
 <param name="compensation">The final part of the expression to be evaluated.</param>

 <returns>The resulting expression.</returns>

 <example id="tryfinally-1">
 <code lang="fsharp">
 open System
 open FSharp.Quotations

 Expr.TryFinally(&lt;@ 1+1 @&gt;, &lt;@ Console.WriteLine("finally") @&gt;)
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ try 1+1 finally Console.WriteLine("finally") @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.ToString(System.Boolean)">
 <summary>Format the expression as a string</summary>

 <param name="full">Indicates if method, property, constructor and type objects should be printed in detail. If false, these are abbreviated to their name.</param>

 <returns>The formatted string.</returns>

 <example id="globalvar-1">
 <code lang="fsharp">
 open FSharp.Quotations

 let expr1 = &lt;@ 1 + 1 @&gt;

 expr1.ToString(true)
 </code>
 Evaluates <c>"Call (None, Int32 op_Addition[Int32,Int32,Int32](Int32, Int32),[Value (1), Value (1)])"</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Substitute(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Quotations.FSharpExpr}})">
 <summary>Substitutes through the given expression using the given functions
 to map variables to new values. The functions must give consistent results
 at each application. Variable renaming may occur on the target expression
 if variable capture occurs.</summary>

 <param name="substitution">The function to map variables into expressions.</param>

 <returns>The expression with the given substitutions.</returns>

 <example id="substitute-1">
 <code lang="fsharp">
 open FSharp.Quotations
 open FSharp.Quotations.Patterns

 let sampleQuotation =  &lt;@ fun v -> v * v @&gt;

 let v, body =
     match sampleQuotation with
     | Lambda(v, body) -> (v, body)
     | _ -> failwith "unreachable"

 body.Substitute(function v2 when v = v2 -> Some &lt;@ 1 + 1 @&gt; | _ -> None)
 </code>
 Evaluates to <c>&lt;@ (1 + 1) * (1 + 1)&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Sequential(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents the sequential execution of one expression followed by another</summary>

 <param name="first">The first expression.</param>
 <param name="second">The second expression.</param>

 <returns>The resulting expression.</returns>

 <example id="sequential-1">
 <code lang="fsharp">
 open System
 open FSharp.Quotations

 Expr.Sequential(&lt;@ Console.WriteLine("a") @&gt;, &lt;@ Console.WriteLine("b") @&gt;)
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ Console.WriteLine("a"); Console.WriteLine("b") @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.RegisterReflectedDefinitions(System.Reflection.Assembly,System.String,System.Byte[],System.Type[])">
 <summary>Permits interactive environments such as F# Interactive
 to explicitly register new pickled resources that represent persisted
 top level definitions.</summary>

 <param name="assembly">The assembly associated with the resource.</param>
 <param name="resource">The unique name for the resources being added.</param>
 <param name="referencedTypes">The type definitions referenced.</param>
 <param name="serializedValue">The serialized resource to register with the environment.</param>

</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.RegisterReflectedDefinitions(System.Reflection.Assembly,System.String,System.Byte[])">
 <summary>Permits interactive environments such as F# Interactive
 to explicitly register new pickled resources that represent persisted
 top level definitions.</summary>

 <param name="assembly">The assembly associated with the resource.</param>
 <param name="resource">The unique name for the resources being added.</param>
 <param name="serializedValue">The serialized resource to register with the environment.</param>

</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.QuoteTyped(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents a nested typed quotation literal</summary>

 <param name="inner">The expression being quoted.</param>

 <returns>The resulting expression.</returns>

 <example id="quotetyped-1">
 <code lang="fsharp">
 open FSharp.Quotations

 Expr.QuoteTyped(&lt;@ 1 @&gt;)
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ &lt;@ 1 @&gt; @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.QuoteRaw(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents a nested raw quotation literal</summary>

 <param name="inner">The expression being quoted.</param>

 <returns>The resulting expression.</returns>

 <example id="quoteraw-1">
 <code lang="fsharp">
 open FSharp.Quotations

 Expr.QuoteRaw(&lt;@ 1 @&gt;)
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ &lt;@ 1 @&gt; @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Quote(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents a nested typed or raw quotation literal</summary>

 <param name="inner">The expression being quoted.</param>

 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.PropertySet(System.Reflection.PropertyInfo,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr}})">
 <summary>Builds an expression that represents writing to a static property </summary>

 <param name="property">The description of the property.</param>
 <param name="value">The value to set.</param>
 <param name="indexerArgs">List of indices for the property if it is an indexed property.</param>

 <returns>The resulting expression.</returns>

 <example id="propertyset-2">
 <code lang="fsharp">
 open System
 open System.Collections.Generic
 open FSharp.Quotations
 open FSharp.Quotations.Patterns

 let propInfo =
     match &lt;@ Console.BackgroundColor &lt;- ConsoleColor.Red  @&gt; with
     | PropertySet(None, pi, _, _) -> pi
     | _ -> failwith "property get expected"

 Expr.PropertySet(propInfo, &lt;@ ConsoleColor.Blue @&gt;)
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ Console.BackgroundColor &lt;- ConsoleColor.Blue @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.PropertySet(Microsoft.FSharp.Quotations.FSharpExpr,System.Reflection.PropertyInfo,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr}})">
 <summary>Builds an expression that represents writing to a property of an object</summary>

 <param name="obj">The input object.</param>
 <param name="property">The description of the property.</param>
 <param name="value">The value to set.</param>
 <param name="indexerArgs">List of indices for the property if it is an indexed property.</param>

 <returns>The resulting expression.</returns>

 <example id="propertyset-1">
 <code lang="fsharp">
 open System
 open System.Collections.Generic
 open FSharp.Quotations
 open FSharp.Quotations.Patterns

 let propInfo =
     match &lt;@ (new List&lt;int&gt;()).Capacity @&gt; with
     | PropertyGet(Some _, pi, _) -> pi
     | _ -> failwith "property get expected"

 let objExpr = &lt;@ (new List&lt;int&gt;()) @&gt;

 Expr.PropertySet(objExpr, propInfo, &lt;@ 6 @&gt;)
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ (new List&lt;int&gt;()).Capacity &lt;- 6 @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.PropertyGet(System.Reflection.PropertyInfo,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr}})">
 <summary>Builds an expression that represents reading a static property </summary>

 <param name="property">The description of the property.</param>
 <param name="indexerArgs">List of indices for the property if it is an indexed property.</param>

 <returns>The resulting expression.</returns>

 <example id="propertyget-2">
 <code lang="fsharp">
 open System
 open FSharp.Quotations
 open FSharp.Quotations.Patterns

 let propInfo =
     match &lt;@ Console.Out @&gt; with
     | PropertyGet(None, pi, _) -> pi
     | _ -> failwith "property get expected"

 Expr.PropertyGet(propInfo)
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ Console.Out @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.PropertyGet(Microsoft.FSharp.Quotations.FSharpExpr,System.Reflection.PropertyInfo,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr}})">
 <summary>Builds an expression that represents reading a property of an object</summary>

 <param name="obj">The input object.</param>
 <param name="property">The description of the property.</param>
 <param name="indexerArgs">List of indices for the property if it is an indexed property.</param>

 <returns>The resulting expression.</returns>

 <example id="propertyget-1">
 <code lang="fsharp">
 open System
 open FSharp.Quotations
 open FSharp.Quotations.Patterns

 let propInfo =
     match &lt;@ "a".Length @&gt; with
     | PropertyGet(Some _, pi, _) -> pi
     | _ -> failwith "property get expected"

 let objExpr = &lt;@ "bb" @&gt;

 Expr.PropertyGet(objExpr, propInfo)
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ "bb".Length @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.NewUnionCase(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Builds an expression that represents the creation of a union case value</summary>

 <param name="unionCase">The description of the union case.</param>
 <param name="arguments">The list of arguments for the case.</param>

 <returns>The resulting expression.</returns>

 <example id="newunioncase-1">
 <code lang="fsharp">
 open System
 open FSharp.Quotations
 open FSharp.Reflection

 let ucCons = FSharpType.GetUnionCases(typeof&lt;int list&gt;)[1]

 Expr.NewUnionCase(ucCons, [ &lt;@ 10 @&gt;; &lt;@ [11] @&gt; ])
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ 10 :: [11] @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.NewTuple(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Builds an expression that represents the creation of an F# tuple value</summary>

 <param name="elements">The list of elements of the tuple.</param>

 <returns>The resulting expression.</returns>

 <example id="defaultvalue-1">
 <code lang="fsharp">
 open FSharp.Quotations

 Expr.NewTuple([ &lt;@ 1 @&gt;; &lt;@ "a" @&gt; ])
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ (1, "a") @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.NewStructTuple(System.Reflection.Assembly,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Builds an expression that represents the creation of an F# tuple value</summary>

 <param name="asm">Runtime assembly containing System.ValueTuple definitions.</param>
 <param name="elements">The list of elements of the tuple.</param>

 <returns>The resulting expression.</returns>

 <example id="newstructtuple-1">
 <code lang="fsharp">
 open FSharp.Quotations

 Expr.NewStructTuple(typeof&lt;struct (int * int)&gt;.Assembly, [ &lt;@ 1 @&gt;; &lt;@ "a" @&gt; ])
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ struct (1, "a") @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.NewRecord(System.Type,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Builds record-construction expressions </summary>

 <param name="recordType">The type of record.</param>
 <param name="elements">The list of elements of the record.</param>

 <returns>The resulting expression.</returns>

 <example id="newrecord-1">
 <code lang="fsharp">
 open FSharp.Quotations

 type R = { Y: int; X: string }

 Expr.NewRecord(typeof&lt;R&gt;, [ &lt;@ 1 @&gt;; &lt;@ "a" @&gt; ])
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ { Y = 1; X = "a" } @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.NewObject(System.Reflection.ConstructorInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Builds an expression that represents the invocation of an object constructor</summary>

 <param name="constructorInfo">The description of the constructor.</param>
 <param name="arguments">The list of arguments to the constructor.</param>

 <returns>The resulting expression.</returns>

 <example id="newobject-1">
 <code lang="fsharp">
 open System
 open FSharp.Quotations
 open FSharp.Quotations.Patterns

 let ctorInfo =
     match &lt;@ new System.DateTime(100L) @&gt; with
     | NewObject(ci, _) -> ci
     | _ -> failwith "call expected"

 let argExpr = &lt;@ 100000L @&gt;

 Expr.NewObject(ctorInfo, [argExpr])
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ NewObject (DateTime, Value (100000L)) @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.NewDelegate(System.Type,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpVar},Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents the creation of a delegate value for the given type</summary>

 <param name="delegateType">The type of delegate.</param>
 <param name="parameters">The parameters for the delegate.</param>
 <param name="body">The body of the function.</param>

 <returns>The resulting expression.</returns>

 <example id="newdelegate-1">
 <code lang="fsharp">
 open System
 open FSharp.Quotations

 let vVar = Var("v", typeof&lt;int&gt;)
 let vExpr = Expr.Var(vVar)

 Expr.NewDelegate(typeof&lt;Func&lt;int,int&gt;&gt;, [vVar], vExpr)
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ new System.Func&lt;int, int&gt;(fun v -> v) @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.NewArray(System.Type,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Builds an expression that represents the creation of an array value initialized with the given elements</summary>

 <param name="elementType">The type for the elements of the array.</param>
 <param name="elements">The list of elements of the array.</param>

 <returns>The resulting expression.</returns>

 <example id="newarray-1">
 <code lang="fsharp">
 open FSharp.Quotations

 Expr.NewArray(typeof&lt;int&gt;, [ &lt;@ 1 @&gt;; &lt;@ 2 @&gt; ])
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ [| 1; 2 |] @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.LetRecursive(Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr}},Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds recursive expressions associated with 'let rec' constructs</summary>

 <param name="bindings">The list of bindings for the let expression.</param>
 <param name="body">The sub-expression where the bindings are in scope.</param>

 <returns>The resulting expression.</returns>


 <example id="letrecursive-1">
 <code lang="fsharp">
 open FSharp.Quotations
 open FSharp.Quotations.Patterns

 let fVar = Var("f", typeof&lt;int -&gt; int&gt;)
 let gVar = Var("v", typeof&lt;int -&gt; int&gt;)
 let fExpr = Expr.Var(fVar)
 let gExpr = Expr.Var(gVar)
 let fImplExpr = &lt;@ fun x -> (%%gExpr : int -> int) (x - 1) + 1 @&gt;
 let gImplExpr = &lt;@ fun x -> if x > 0 then (%%fExpr : int -> int) (x - 1) else 0 @&gt;
 let bodyExpr = &lt;@ (%%gExpr : int -> int) 10 @&gt;

 Expr.LetRecursive([(fVar, fImplExpr); (gVar, gImplExpr)], bodyExpr)
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ let rec f x = g (x-1) + 1 and g x = if x > 0 then f (x - 1) else 0 in g 10 @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Let(Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds expressions associated with 'let' constructs</summary>

 <param name="letVariable">The variable in the let expression.</param>
 <param name="letExpr">The expression bound to the variable.</param>
 <param name="body">The sub-expression where the binding is in scope.</param>

 <returns>The resulting expression.</returns>

 <example id="let-1">
 <code lang="fsharp">
 open FSharp.Quotations

 let vVar = Var("v", typeof&lt;int&gt;)
 let rhsExpr = &lt;@ 6 @&gt;
 let vExpr = Expr.Var(vVar)

 Expr.Let(vVar, rhsExpr, vExpr)
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ let v = 6 in v @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Lambda(Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents the construction of an F# function value</summary>

 <param name="parameter">The parameter to the function.</param>
 <param name="body">The body of the function.</param>

 <returns>The resulting expression.</returns>

 <example id="lambda-1">
 <code lang="fsharp">
 open FSharp.Quotations
 open FSharp.Quotations.Patterns

 let vVar = Var("v", typeof&lt;int&gt;)
 let vExpr = Expr.Var(vVar)

 Expr.Lambda(vVar, vExpr)
 </code>
 Evaluates to <c>Lambda (v, v)</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.IfThenElse(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds 'if ... then ... else' expressions.</summary>

 <param name="guard">The condition expression.</param>
 <param name="thenExpr">The <c>then</c> sub-expression.</param>
 <param name="elseExpr">The <c>else</c> sub-expression.</param>

 <returns>The resulting expression.</returns>

 <example id="coerce-1">
 <code lang="fsharp">
 open FSharp.Quotations

 let guardExpr = &lt;@ 1 > 3 @&gt;
 let thenExpr = &lt;@ 6 @&gt;
 let elseExpr = &lt;@ 7 @&gt;

 Expr.IfThenElse(guardExpr, thenExpr, elseExpr)
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ if 1 > 3 then 6 else 7 @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.GlobalVar``1(System.String)">
 <summary>Fetches or creates a new variable with the given name and type from a global pool of shared variables
 indexed by name and type. The type is given by the explicit or inferred type parameter</summary>

 <param name="name">The variable name.</param>

 <returns>The created of fetched typed global variable.</returns>

 <example id="globalvar-1">
 <code lang="fsharp">
 open FSharp.Quotations

 let expr1 = Expr.GlobalVar&lt;int&gt;("x")
 let expr2 = Expr.GlobalVar&lt;int&gt;("x")
 </code>
 Evaluates <c>expr1</c> and <c>expr2</c> to identical quotations.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.GetFreeVars">
 <summary>Gets the free expression variables of an expression as a list.</summary>
 <returns>A sequence of the free variables in the expression.</returns>

 <example id="getfreevars-1">
 <code lang="fsharp">
 open FSharp.Quotations
 open FSharp.Quotations.Patterns

 let sampleQuotation =  &lt;@ fun v -> v * v @&gt;

 let v, body =
     match sampleQuotation with
     | Lambda(v, body) -> (v, body)
     | _ -> failwith "unreachable"

 body.GetFreeVars()
 </code>
 Evaluates to a set containing the single variable for <c>v</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.ForIntegerRangeLoop(Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds a 'for i = ... to ... do ...' expression that represent loops over integer ranges</summary>

 <param name="loopVariable">The sub-expression declaring the loop variable.</param>
 <param name="start">The sub-expression setting the initial value of the loop variable.</param>
 <param name="endExpr">The sub-expression declaring the final value of the loop variable.</param>
 <param name="body">The sub-expression representing the body of the loop.</param>

 <returns>The resulting expression.</returns>

 <example id="coerce-1">
 <code lang="fsharp">
 open FSharp.Quotations

 let loopVariable = Var("x", typeof&lt;int&gt;)
 let startExpr = &lt;@ 6 @&gt;
 let endExpr = &lt;@ 7 @&gt;
 let body = &lt;@ System.Console.WriteLine("hello") @&gt;

 Expr.ForIntegerRangeLoop(loopVariable, startExpr, endExpr, body)
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ if 1 > 3 then 6 else 7 @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.FieldSet(Microsoft.FSharp.Quotations.FSharpExpr,System.Reflection.FieldInfo,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents writing to a field of an object</summary>

 <param name="obj">The input object.</param>
 <param name="fieldInfo">The description of the field to write to.</param>
 <param name="value">The value to set to the field.</param>

 <returns>The resulting expression.</returns>

 <example id="fieldset-1">Create an expression setting a reference cell via the public backing field:
 <code lang="fsharp">
 open FSharp.Quotations
 open FSharp.Quotations.Patterns

 let fieldInfo = typeof&lt;int ref&gt;.GetField("contents@")
 let refValue = ref 3
 let refExpr = &lt;@ refValue @&gt;
 let valueExpr = &lt;@ 6 @&gt;

 Expr.FieldSet(refExpr, fieldInfo, valueExpr)
 </code>
 Evaluates to <c>FieldSet (Some (PropertyGet (None, refValue, [])), contents@, Value (6))</c>.
 Note that for technical reasons the quotation <c>&lt;@ refValue.contents &lt;- 6 @&gt;</c> evaluates to a slightly different quotation
 accessing the contents field via a property.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.FieldSet(System.Reflection.FieldInfo,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents writing to a static field </summary>

 <param name="fieldInfo">The description of the field to write to.</param>
 <param name="value">The value to the set to the field.</param>

 <returns>The resulting expression.</returns>

 <remarks>Settable public static fields are rare in F# and .NET libraries, so examples of using this method are uncommon.</remarks>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.FieldGet(Microsoft.FSharp.Quotations.FSharpExpr,System.Reflection.FieldInfo)">
 <summary>Builds an expression that represents the access of a field of an object</summary>

 <param name="obj">The input object.</param>
 <param name="fieldInfo">The description of the field to access.</param>

 <returns>The resulting expression.</returns>

 <example id="fieldget-1">
 <code lang="fsharp">
 open FSharp.Quotations
 open FSharp.Quotations.Patterns

 let fieldInfo = typeof&lt;int ref&gt;.GetField("contents@")
 let refValue = ref 3
 let refExpr = &lt;@ refValue @&gt;

 Expr.FieldGet(refExpr, fieldInfo)
 </code>
 Evaluates to <c>FieldGet (Some (PropertyGet (None, refValue, [])), contents@)</c>.
 Note that for technical reasons the quotation <c>&lt;@ refValue.contents @&gt;</c> evaluates to a different quotation
 accessing the contents field via a property.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.FieldGet(System.Reflection.FieldInfo)">
 <summary>Builds an expression that represents the access of a static field</summary>

 <param name="fieldInfo">The description of the field to access.</param>

 <returns>The resulting expression.</returns>

 <example id="fieldget-1">
 <code lang="fsharp">
 open FSharp.Quotations
 open FSharp.Quotations.Patterns

 let fieldInfo = typeof&lt;System.DayOfWeek&gt;.GetField("Monday")

 Expr.FieldGet(fieldInfo)
 </code>
 Evaluates to <c>FieldGet (None, Monday)</c>. Note that for technical reasons the quotation <c>&lt;@ System.DayOfWeek.Monday @&gt;</c> evaluates to a different quotation containing a constant enum value <c>Value (Monday)</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Deserialize40(System.Type,System.Type[],System.Type[],Microsoft.FSharp.Quotations.FSharpExpr[],System.Byte[])">
 <summary>This function is called automatically when quotation syntax (&lt;@ @&gt;) and other sources of
 quotations are used. </summary>

 <param name="qualifyingType">A type in the assembly where the quotation occurs.</param>
 <param name="referencedTypes">The type definitions referenced.</param>
 <param name="spliceTypes">The spliced types, to replace references to type variables.</param>
 <param name="spliceExprs">The spliced expressions to replace references to spliced expressions.</param>
 <param name="bytes">The serialized form of the quoted expression.</param>

 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Deserialize(System.Type,Microsoft.FSharp.Collections.FSharpList{System.Type},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr},System.Byte[])">
 <summary>This function is called automatically when quotation syntax (&lt;@ @&gt;) and other sources of
 quotations are used. </summary>

 <param name="qualifyingType">A type in the assembly where the quotation occurs.</param>
 <param name="spliceTypes">The spliced types, to replace references to type variables.</param>
 <param name="spliceExprs">The spliced expressions to replace references to spliced expressions.</param>
 <param name="bytes">The serialized form of the quoted expression.</param>

 <returns>The resulting expression.</returns>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.DefaultValue(System.Type)">
 <summary>Builds an expression that represents the invocation of a default object constructor</summary>

 <param name="expressionType">The type on which the constructor is invoked.</param>

 <returns>The resulting expression.</returns>

 <example id="defaultvalue-1">
 <code lang="fsharp">
 open FSharp.Quotations

 Expr.DefaultValue(typeof&lt;int&gt;)
 </code>
 Evaluates to the quotation <c>DefaultValue (Int32)</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Coerce(Microsoft.FSharp.Quotations.FSharpExpr,System.Type)">
 <summary>Builds an expression that represents the coercion of an expression to a type</summary>

 <param name="source">The expression to coerce.</param>
 <param name="target">The target type.</param>

 <returns>The resulting expression.</returns>

 <example id="coerce-1">
 <code lang="fsharp">
 open FSharp.Quotations

 let expr = &lt;@ box "3" @&gt;

 Expr.Coerce(expr, typeof&lt;string&gt;)
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ (fun x -> x + 1) 3 @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Cast``1(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Returns a new typed expression given an underlying runtime-typed expression.
 A type annotation is usually required to use this function, and
 using an incorrect type annotation may result in a later runtime exception.</summary>

 <param name="source">The expression to cast.</param>

 <returns>The resulting typed expression.</returns>

 <example id="cast-1">
 <code lang="fsharp">
 open FSharp.Quotations

 let rawExpr = &lt;@ 1 @&gt;

 Expr.Cast&lt;int&gt;(rawExpr)
 </code>
 Evaluates with type <c>Expr&lt;int&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.CallWithWitnesses(Microsoft.FSharp.Quotations.FSharpExpr,System.Reflection.MethodInfo,System.Reflection.MethodInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Builds an expression that represents a call to an instance method associated with an object, potentially passing additional witness arguments</summary>

 <param name="obj">The input object.</param>
 <param name="methodInfo">The description of the method to call.</param>
 <param name="methodInfoWithWitnesses">The additional MethodInfo describing the method to call, accepting witnesses.</param>
 <param name="witnesses">The list of witnesses to the method.</param>
 <param name="arguments">The list of arguments to the method.</param>

 <returns>The resulting expression.</returns>

 <example id="callwithwitnesses-2">See examples for Call and CallWithWitnesses</example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.CallWithWitnesses(System.Reflection.MethodInfo,System.Reflection.MethodInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Builds an expression that represents a call to an static method or module-bound function, potentially passing additional witness arguments</summary>

 <param name="methodInfo">The MethodInfo describing the method to call.</param>
 <param name="methodInfoWithWitnesses">The additional MethodInfo describing the method to call, accepting witnesses.</param>
 <param name="witnesses">The list of witnesses to the method.</param>
 <param name="arguments">The list of arguments to the method.</param>

 <returns>The resulting expression.</returns>

 <example id="callwithwitnesses-1">In this example, we show how to use a witness to cosntruct an `op_Addition` call for a type that doesn't support addition directly:
 <code lang="fsharp">
 open FSharp.Quotations
 open FSharp.Quotations.Patterns

 // Get the entrypoint for inline addition that takes an explicit witness
 let addMethInfoG, addMethInfoGW =
     match &lt;@ 1+1 @&gt; with
     | CallWithWitnesses(None, mi, miW, _, _) ->
         mi.GetGenericMethodDefinition(), miW.GetGenericMethodDefinition()
     | _ ->
         failwith "call expected"

 // Make a non-standard witness for addition for a type C

 type C(value: int) =
     member x.Value = value

 let witnessExpr = &lt;@ (fun (x: C) (y: C) -> C(x.Value + y.Value)) @&gt;
 let argExpr1 = &lt;@ C(4) @&gt;
 let argExpr2 = &lt;@ C(5) @&gt;

 // Instantiate the generic method at the right type

 let addMethInfo = addMethInfoG.MakeGenericMethod(typeof&lt;C&gt;, typeof&lt;C&gt;, typeof&lt;C&gt;)
 let addMethInfoW = addMethInfoGW.MakeGenericMethod(typeof&lt;C&gt;, typeof&lt;C&gt;, typeof&lt;C&gt;)

 Expr.CallWithWitnesses(addMethInfo, addMethInfoW, [witnessExpr], [argExpr1; argExpr2])
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ Call (None, op_Addition, [NewObject (C, Value (4)), NewObject (C, Value (5))]) @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Call(Microsoft.FSharp.Quotations.FSharpExpr,System.Reflection.MethodInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Builds an expression that represents a call to an instance method associated with an object</summary>

 <param name="obj">The input object.</param>
 <param name="methodInfo">The description of the method to call.</param>
 <param name="arguments">The list of arguments to the method.</param>

 <returns>The resulting expression.</returns>

 <example id="call-2">
 <code lang="fsharp">
 open System
 open FSharp.Quotations
 open FSharp.Quotations.Patterns

 let objExpr, methInfo =
     match &lt;@ Console.Out.WriteLine("1") @&gt; with
     | Call(Some obj, mi, _) -> obj, mi
     | _ -> failwith "call expected"

 let argExpr = &lt;@ "Hello World" @&gt;

 Expr.Call(objExpr, methInfo, [argExpr])
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ Console.Out.WriteLine("Hello World") @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Call(System.Reflection.MethodInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Builds an expression that represents a call to an static method or module-bound function</summary>

 <param name="methodInfo">The MethodInfo describing the method to call.</param>
 <param name="arguments">The list of arguments to the method.</param>

 <returns>The resulting expression.</returns>

 <example id="call-1">
 <code lang="fsharp">
 open System
 open FSharp.Quotations
 open FSharp.Quotations.Patterns

 let methInfo =
     match &lt;@ Console.WriteLine("1") @&gt; with
     | Call(_, mi, _) -> mi
     | _ -> failwith "call expected"

 let argExpr = &lt;@ "Hello World" @&gt;

 Expr.Call(methInfo, [argExpr])
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ Console.WriteLine("Hello World") @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Applications(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr}})">
 <summary>Builds an expression that represents the application of a first class function value to multiple arguments</summary>

 <param name="functionExpr">The function to apply.</param>
 <param name="arguments">The list of lists of arguments to the function.</param>

 <returns>The resulting expression.</returns>

 <example id="applications-1">
 <code lang="fsharp">
 open FSharp.Quotations

 let funcExpr = &lt;@ (fun (x, y) z -> x + y + z) @&gt;
 let curriedArgExprs = [[ &lt;@ 1 @&gt;; &lt;@ 2 @&gt; ]; [ &lt;@ 3 @&gt; ]]

 Expr.Applications(funcExpr, curriedArgExprs)
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ (fun (x, y) z -> x + y + z) (1,2) 3 @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Application(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents the application of a first class function value to a single argument.</summary>

 <param name="functionExpr">The function to apply.</param>
 <param name="argument">The argument to the function.</param>

 <returns>The resulting expression.</returns>

 <example id="application-1">
 <code lang="fsharp">
 open FSharp.Quotations

 let funcExpr = &lt;@ (fun x -> x + 1) @&gt;
 let argExpr = &lt;@ 3 @&gt;

 Expr.Application(funcExpr, argExpr)
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ (fun x -> x + 1) 3 @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.AddressSet(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents setting the value held at a particular address.</summary>

 <param name="target">The target expression.</param>
 <param name="value">The value to set at the address.</param>

 <returns>The resulting expression.</returns>

 <example id="addresset-1">
 <code lang="fsharp">
 open FSharp.Quotations

 let array = [| 1; 2; 3 |]

 let addrExpr = Expr.AddressOf(&lt;@ array.[1] @&gt;)

 Expr.AddressSet(addrExpr, &lt;@ 4 @&gt;)
 </code>
 Evaluates to <c>AddressSet (AddressOf (Call (None, GetArray, [PropertyGet (None, array, []), Value (1)])), Value (4))</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.AddressOf(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Builds an expression that represents getting the address of a value.</summary>

 <param name="target">The target expression.</param>

 <returns>The resulting expression.</returns>

 <example id="addressof-1">
 <code lang="fsharp">
 open FSharp.Quotations

 let array = [| 1; 2; 3 |]

 Expr.AddressOf(&lt;@ array.[1] @&gt;)
 </code>
 Evaluates to <c>AddressOf (Call (None, GetArray, [PropertyGet (None, array, []), Value (1)]))</c>.
 </example>
</member>
<member name="T:Microsoft.FSharp.Quotations.FSharpExpr">
 <summary>Quoted expressions annotated with System.Type values. </summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.FSharpVar.Type">
 <summary>The type associated with the variable</summary>

 <example id="type-1">
 <code lang="fsharp">
 open FSharp.Quotations
 open FSharp.Quotations.Patterns

 match &lt;@ fun v -> v @&gt; with
 | Lambda(v, body) -> v.Type
 | _ -> failwith "unreachable"
 </code>
 Evaluates to <c>typeof&lt;int&gt;</c>
 </example>
</member>
<member name="P:Microsoft.FSharp.Quotations.FSharpVar.Name">
 <summary>The declared name of the variable</summary>

 <example id="name-1">
 <code lang="fsharp">
 open FSharp.Quotations
 open FSharp.Quotations.Patterns

 match &lt;@ fun v -> v @&gt; with
 | Lambda(v, body) -> v.Name
 | _ -> failwith "unreachable"
 </code>
 Evaluates to <c>"v"</c>
 </example>
</member>
<member name="P:Microsoft.FSharp.Quotations.FSharpVar.IsMutable">
 <summary>Indicates if the variable represents a mutable storage location</summary>

 <example id="ismutable-1">
 <code lang="fsharp">
 open FSharp.Quotations
 open FSharp.Quotations.Patterns

 match &lt;@ fun v -> v @&gt; with
 | Lambda(v, body) -> v.IsMutable
 | _ -> failwith "unreachable"
 </code>
 Evaluates to <c>false</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpVar.Global(System.String,System.Type)">
 <summary>Fetches or create a new variable with the given name and type from a global pool of shared variables
 indexed by name and type</summary>

 <param name="name">The name of the variable.</param>
 <param name="typ">The type associated with the variable.</param>

 <returns>The retrieved or created variable.</returns>

 <example id="global-1">
 <code lang="fsharp">
 open FSharp.Quotations
 open FSharp.Quotations.Patterns

 let valueVar1 = Var.Global("value", typeof&lt;int&gt;)
 let valueVar2 = Var.Global("value", typeof&lt;int&gt;)
 </code>
 Evaluates both to <c>valueVar1</c> and <c>valueVar2</c> to the same variable from a global pool of shared variables.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpVar.#ctor(System.String,System.Type,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Creates a new variable with the given name, type and mutability</summary>

 <param name="name">The declared name of the variable.</param>
 <param name="typ">The type associated with the variable.</param>
 <param name="isMutable">Indicates if the variable represents a mutable storage location. Default is false.</param>

 <returns>The created variable.</returns>

 <example id="ctor-1">
 <code lang="fsharp">
 open FSharp.Quotations
 open FSharp.Quotations.Patterns

 let valueVar = Var("value"), typeof&lt;int&gt;)
 </code>
 Evaluates to a new quotation variable with the given name and type<c></c>.
 </example>
</member>
<member name="T:Microsoft.FSharp.Quotations.FSharpVar">
 <summary>Information at the binding site of a variable</summary>

 <namespacedoc><summary>
   Library functionality for F# quotations.
    See also <a href="https: //docs.microsoft.com/dotnet/fsharp/language-reference/code-quotations">F# Code Quotations</a> in the F# Language Guide.
 </summary></namespacedoc>
</member>
<member name="M:Microsoft.FSharp.Quotations.ExprShapeModule.RebuildShapeCombination(System.Object,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
 <summary>Re-build combination expressions. The first parameter should be an object
 returned by the <c>ShapeCombination</c> case of the active pattern in this module.</summary>

 <param name="shape">The input shape.</param>
 <param name="arguments">The list of arguments.</param>

 <returns>The rebuilt expression.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.ExprShapeModule.ShapePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern that performs a complete decomposition viewing the expression tree as a binding structure</summary>

 <param name="input">The input expression.</param>

 <returns>The decomposed Var, Lambda, or ConstApp.</returns>

 <example-tbd></example-tbd>
</member>
<member name="T:Microsoft.FSharp.Quotations.ExprShapeModule">
 <summary>Active patterns for traversing, visiting, rebuilding and transforming expressions in a generic way</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.PropertySetterWithReflectedDefinitionPattern(System.Reflection.PropertyInfo)">
 <summary>An active pattern to recognize property setters that have an associated ReflectedDefinition</summary>

 <param name="propertyInfo">The description of the property.</param>

 <returns>The expression of the method definition if found, or None.</returns>

 <example id="propertysetterwithreflecteddefinition-1">
 <code lang="fsharp">
 open FSharp.Quotations
 open FSharp.Quotations.Patterns
 open FSharp.Quotations.DerivedPatterns

 [&lt;ReflectedDefinition&gt;]
 type C&lt;'T&gt;() =
    member x.Count with set (v: int) = ()

 let inpExpr = &lt;@ C&lt;int&gt;().Count &lt;- 3 @&gt;

 let implExpr =
     match inpExpr with
     | PropertySet(Some _, PropertySetterWithReflectedDefinition implExpr, [], _valueExpr) -> implExpr
     | _ -> failwith "unexpected"
 </code>
 Evaluates <c>implExpr</c> to a quotation with the same structure as <c>&lt;@ fun (x: C&lt;int&gt;) (v: int) -> () @&gt;</c>, which is the implementation of the
 setter for the property <c>Count</c>. Note that the correct generic instantaition has been applied to the implementation to reflect
 the the type at the callsite.
 </example>

</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.PropertyGetterWithReflectedDefinitionPattern(System.Reflection.PropertyInfo)">
 <summary>An active pattern to recognize property getters or values in modules that have an associated ReflectedDefinition</summary>

 <param name="propertyInfo">The description of the property.</param>

 <returns>The expression of the method definition if found, or None.</returns>

 <example id="propertywithreflecteddefinition-1">
 <code lang="fsharp">
 open FSharp.Quotations
 open FSharp.Quotations.Patterns
 open FSharp.Quotations.DerivedPatterns

 [&lt;ReflectedDefinition&gt;]
 type C&lt;'T&gt;() =
    member x.Identity = x

 let inpExpr = &lt;@ C&lt;int&gt;().Identity @&gt;

 let implExpr =
     match inpExpr with
     | PropertyGet(Some _, PropertyGetterWithReflectedDefinition implExpr, [ ]) -> implExpr
     | _ -> failwith "unexpected"
 </code>
 Evaluates <c>implExpr</c> to a quotation with the same structure as <c>&lt;@ fun (x: C&lt;int&gt;) () -> x @&gt;</c>, which is the implementation of the
 property <c>Identity</c>. Note that the correct generic instantaition has been applied to the implementation to reflect
 the the type at the callsite.
 </example>

</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.MethodWithReflectedDefinitionPattern(System.Reflection.MethodBase)">
 <summary>An active pattern to recognize methods that have an associated ReflectedDefinition</summary>

 <param name="methodBase">The description of the method.</param>

 <returns>The expression of the method definition if found, or None.</returns>

 <example id="methodwithreflecteddefinition-1">
 <code lang="fsharp">
 open FSharp.Quotations
 open FSharp.Quotations.Patterns
 open FSharp.Quotations.DerivedPatterns

 [&lt;ReflectedDefinition&gt;]
 let f x = (x, x)

 let inpExpr = &lt;@ f 4 @&gt;

 let implExpr =
     match inpExpr with
     | Call(None, MethodWithReflectedDefinition implExpr, [ _argExpr ]) -> implExpr
     | _ -> failwith "unexpected"
 </code>
 Evaluates <c>implExpr</c> to a quotation with the same structure as <c>&lt;@ fun (x: int) -> (x, x) @&gt;</c>, which is the implementation of the
 method <c>f</c>. Note that the correct generic instantaition has been applied to the implementation to reflect
 the the type at the callsite.
 </example>

</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.SpecificCallPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>A parameterized active pattern to recognize calls to a specified function or method.
 The returned elements are the optional target object (present if the target is an
 instance method), the generic type instantiation (non-empty if the target is a generic
 instantiation), and the arguments to the function or method.</summary>

 <param name="templateParameter">The input template expression to specify the method to call.</param>

 <returns>The optional target object (present if the target is an
 instance method), the generic type instantiation (non-empty if the target is a generic
 instantiation), and the arguments to the function or method.</returns>

 <example id="specificcall-1">Match a specific call to Console.WriteLine taking one string argument:
 <code lang="fsharp">
 open FSharp.Quotations
 open FSharp.Quotations.Patterns
 open FSharp.Quotations.DerivedPatterns

 let inpExpr = &lt;@ Console.WriteLine("hello") @&gt;

 match inpExpr with
 | SpecificCall &lt;@ Console.WriteLine("1") @&gt; (None, [], [ argExpr ]) -> argExpr
 | _ -> failwith "unexpected"
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ "hello" @&gt;</c>.
 </example>

 <example id="specificcall-2">Calls to this active pattern can be partially applied to pre-evaluate some aspects of the matching. For example:
 <code lang="fsharp">
 open FSharp.Quotations
 open FSharp.Quotations.Patterns
 open FSharp.Quotations.DerivedPatterns

 let (|ConsoleWriteLineOneArg|_|) = (|SpecificCall|_|) &lt;@ Console.WriteLine("1") @&gt;

 let inpExpr = &lt;@ Console.WriteLine("hello") @&gt;

 match inpExpr with
 | ConsoleWriteLineOneArg (None, [], [ argExpr ]) -> argExpr
 | _ -> failwith "unexpected"
 </code>
 Evaluates to a quotation with the same structure as <c>&lt;@ "hello" @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.DecimalPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant decimal expressions</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the constant value from the input expression</returns>

 <example id="decimal-1">
 <code lang="fsharp">
 open FSharp.Quotations.DerivedPatterns

 match &lt;@ 8.0M @&gt; with
 | Decimal v -> v
 | _ -> failwith "unexpected"
 </code>
 Evaluates to <c>8.0M</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.UInt64Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant unsigned int64 expressions</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the constant value from the input expression</returns>

 <example id="uint64-1">
 <code lang="fsharp">
 open FSharp.Quotations.DerivedPatterns

 match &lt;@ 8UL @&gt; with
 | UInt64 v -> v
 | _ -> failwith "unexpected"
 </code>
 Evaluates to <c>8UL</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.Int64Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant int64 expressions</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the constant value from the input expression</returns>

 <example id="int64-1">
 <code lang="fsharp">
 open FSharp.Quotations.DerivedPatterns

 match &lt;@ 8L @&gt; with
 | Int64 v -> v
 | _ -> failwith "unexpected"
 </code>
 Evaluates to <c>8L</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.UInt32Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant unsigned int32 expressions</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the constant value from the input expression</returns>

 <example id="uint32-1">
 <code lang="fsharp">
 open FSharp.Quotations.DerivedPatterns

 match &lt;@ 8u @&gt; with
 | UInt32 v -> v
 | _ -> failwith "unexpected"
 </code>
 Evaluates to <c>8u</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.Int32Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant int32 expressions</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the constant value from the input expression</returns>

 <example id="int32-1">
 <code lang="fsharp">
 open FSharp.Quotations.DerivedPatterns

 match &lt;@ 8 @&gt; with
 | Int32 v -> v
 | _ -> failwith "unexpected"
 </code>
 Evaluates to <c>8</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.UInt16Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant unsigned int16 expressions</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the constant value from the input expression</returns>

 <example id="uint16-1">
 <code lang="fsharp">
 open FSharp.Quotations.DerivedPatterns

 match &lt;@ 8us @&gt; with
 | UInt16 v -> v
 | _ -> failwith "unexpected"
 </code>
 Evaluates to <c>8us</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.Int16Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant int16 expressions</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the constant value from the input expression</returns>

 <example id="int16-1">
 <code lang="fsharp">
 open FSharp.Quotations.DerivedPatterns

 match &lt;@ 8s @&gt; with
 | Int16 v -> v
 | _ -> failwith "unexpected"
 </code>
 Evaluates to <c>8s</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.BytePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant byte expressions</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the constant value from the input expression</returns>

 <example id="byte-1">
 <code lang="fsharp">
 open FSharp.Quotations.DerivedPatterns

 match &lt;@ 8uy @&gt; with
 | Byte v -> v
 | _ -> failwith "unexpected"
 </code>
 Evaluates to <c>8uy</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.SBytePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant signed byte expressions</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the constant value from the input expression</returns>

 <example id="sbyte-1">
 <code lang="fsharp">
 open FSharp.Quotations.DerivedPatterns

 match &lt;@ 8y @&gt; with
 | SByte v -> v
 | _ -> failwith "unexpected"
 </code>
 Evaluates to <c>8y</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.CharPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant unicode character expressions</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the constant value from the input expression</returns>

 <example id="char-1">
 <code lang="fsharp">
 open FSharp.Quotations.DerivedPatterns

 match &lt;@ 'a' @&gt; with
 | Char v -> v
 | _ -> failwith "unexpected"
 </code>
 Evaluates to <c>'a'</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.DoublePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant 64-bit floating point number expressions</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the constant value from the input expression</returns>

 <example id="double-1">
 <code lang="fsharp">
 open FSharp.Quotations.DerivedPatterns

 match &lt;@ 1.0 @&gt; with
 | Double v -> v
 | _ -> failwith "unexpected"
 </code>
 Evaluates to <c>1.0</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.SinglePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant 32-bit floating point number expressions</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the constant value from the input expression</returns>

 <example id="single-1">
 <code lang="fsharp">
 open FSharp.Quotations.DerivedPatterns

 match &lt;@ 1.0f @&gt; with
 | Single v -> v
 | _ -> failwith "unexpected"
 </code>
 Evaluates to <c>1.0f</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.StringPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant string expressions</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the constant value from the input expression</returns>

 <example id="string-1">
 <code lang="fsharp">
 open FSharp.Quotations.DerivedPatterns

 match &lt;@ "a" @&gt; with
 | String v -> v
 | _ -> failwith "unexpected"
 </code>
 Evaluates to <c>"a"</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.BoolPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize constant boolean expressions</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the constant value from the input expression</returns>

 <example id="bool-1">
 <code lang="fsharp">
 open FSharp.Quotations.DerivedPatterns

 match &lt;@ true @&gt; with
 | Bool v -> v
 | _ -> failwith "unexpected"
 </code>
 Evaluates to <c>true</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.UnitPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize <c>()</c> constant expressions</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern does not bind any results</returns>

 <example id="unit-1">
 <code lang="fsharp">
 open FSharp.Quotations.DerivedPatterns

 match &lt;@ () @&gt; with
 | Unit v -> v
 | _ -> failwith "unexpected"
 </code>
 Evaluates to <c>true</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.OrElsePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions of the form <c>a || b</c> </summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the left and right parts of the input expression</returns>

 <example id="orelse-1">
 <code lang="fsharp">
 open FSharp.Quotations.DerivedPatterns

 match &lt;@ true || false @&gt; with
 | OrElse (a, b) -> (a, b)
 | _ -> failwith "unexpected"
 </code>
 Evaluates to <c>&lt;@ true @&gt;, &lt;@ false @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.AndAlsoPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions of the form <c>a &amp;&amp; b</c> </summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the left and right parts of the input expression</returns>

 <example id="andalso-1">
 <code lang="fsharp">
 open FSharp.Quotations.DerivedPatterns

 match &lt;@ true &amp;&amp; false @&gt; with
 | AndAlso (a, b) -> (a, b)
 | _ -> failwith "unexpected"
 </code>
 Evaluates to <c>&lt;@ true @&gt;, &lt;@ false @&gt;</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.ApplicationsPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent the application of a (possibly curried or tupled) first class function value</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the function and curried arguments of the input expression</returns>

 <example id="applications-1">
 <code lang="fsharp">
 open FSharp.Quotations.Patterns
 open FSharp.Quotations.DerivedPatterns

 match &lt;@ (fun f -> f (1, 2) 3) @&gt; with
 | Lambda(_, Applications (f, curriedArgs)) ->
     curriedArgs |> List.map (fun args -> args.Length)
 | _ -> failwith "unexpected"
 </code>
 Evaluates to <c>[2; 1]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.LambdasPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent a (possibly curried or tupled) first class function value</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the curried variables and body of the input expression</returns>

 <example id="lambdas-1">
 <code lang="fsharp">
 open FSharp.Quotations.Patterns
 open FSharp.Quotations.DerivedPatterns

 match &lt;@ (fun (a1, a2) b -> ()) @&gt; with
 | Lambdas(curriedVars, _) ->
     curriedVars |> List.map (List.map (fun arg -> arg.Name))
 | _ -> failwith "unexpected"
 </code>
 Evaluates to <c>[["a1"; "a2"]; ["b"]]</c>.
 </example>
</member>
<member name="T:Microsoft.FSharp.Quotations.DerivedPatternsModule">
 <summary>Contains a set of derived F# active patterns to analyze F# expression objects</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.VarSetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent setting a mutable variable</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the variable and value expression of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.VarPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent a variable</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the variable of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.WithValuePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that are a value with an associated definition</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the boxed value, its static type and its definition</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.ValueWithNamePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent a constant value</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the boxed value, its static type and its name</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.ValuePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent a constant value. This also matches expressions matched by ValueWithName.</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the boxed value and its static type</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.UnionCaseTestPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent a test if a value is of a particular union case</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the expression and union case being tested</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.TypeTestPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent a dynamic type test</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the expression and type being tested</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.TupleGetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent getting a tuple field</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the expression and tuple field being accessed</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.TryFinallyPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent a try/finally construct </summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the body and handler parts of the try/finally expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.TryWithPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent a try/with construct for exception filtering and catching </summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the body, exception variable, filter expression and catch expression of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.SequentialPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent sequential execution of one expression followed by another</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the two sub-expressions of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.QuoteTypedPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent a nested typed quotation literal</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the nested quotation expression of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.QuoteRawPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent a nested raw quotation literal</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the nested quotation expression of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.QuotePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent a nested quotation literal</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the nested quotation expression of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.PropertySetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent setting a static or instance property, or a non-function value declared in a module</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the object, property, indexer arguments and setter value of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.PropertyGetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent the read of a static or instance property, or a non-function value declared in a module</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the object, property and indexer arguments of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewStructTuplePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent construction of struct tuple values</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the element expressions of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewTuplePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent construction of tuple values</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the element expressions of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewUnionCasePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent construction of particular union case values</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the union case and field values of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewRecordPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent construction of record values</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the record type and field values of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewObjectPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent invocation of object constructors</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the constructor and arguments of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewDelegatePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent construction of delegate values</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the delegate type, argument parameters and body of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.DefaultValuePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent invocations of a default constructor of a struct</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the relevant type of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewArrayPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent the construction of arrays </summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the element type and values of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.LetRecursivePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent recursive let bindings of one or more variables</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the bindings and body of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.LetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent let bindings</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the variable, binding expression and body of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.LambdaPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent first class function values</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the variable and body of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.IfThenElsePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent conditionals</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the condition, then-branch and else-branch of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.WhileLoopPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent while loops </summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the guard and body of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.ForIntegerRangeLoopPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent loops over integer ranges</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the value, start, finish and body of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.FieldSetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent setting a static or instance field </summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the object, field and value of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.FieldGetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent getting a static or instance field </summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the object and field of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.CoercePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent coercions from one type to another</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the source expression and target type of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.CallWithWitnessesPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent calls to static and instance methods, and functions defined in modules, including witness arguments</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the object, method, witness-argument and argument sub-expressions of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.CallPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent calls to static and instance methods, and functions defined in modules</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the object, method and argument sub-expressions of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.ApplicationPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent applications of first class function values</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the function and argument of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.AddressSetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent setting the value held at an address </summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the target and value expressions of the input expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.AddressOfPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>An active pattern to recognize expressions that represent getting the address of a value</summary>

 <param name="input">The input expression to match against.</param>

 <returns>When successful, the pattern binds the sub-expression of the input AddressOf expression</returns>

 <example-tbd></example-tbd>
</member>
<member name="T:Microsoft.FSharp.Quotations.PatternsModule">
 <summary>Contains a set of primitive F# active patterns to analyze F# expression objects</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.CopyBlockInlined``1(``0*,``0*,System.Int32)">
 <summary>Copies a block of memory to a specified destination address starting from a specified source address until a specified byte count of (count * sizeof&lt;'T&gt;).</summary>

 <param name="destination">The destination pointer.</param>
 <param name="source">The source pointer.</param>
 <param name="count">The source pointer.</param>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.CopyPointerInlined``1(``0*,``0*)">
 <summary>Copies a value to a specified destination address from a specified source address.</summary>

 <param name="destination">The destination pointer.</param>
 <param name="source">The source pointer.</param>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.InitializeBlockInlined``1(``0*,System.Byte,System.UInt32)">
 <summary>Initializes a specified block of memory starting at a specific address to a given byte count and initial byte value.</summary>

 <param name="address">The input pointer.</param>
 <param name="value">The initial byte value.</param>
 <param name="count">The total repeat count of the byte value.</param>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.ClearPointerInlined``1(``0*)">
 <summary>Clears the value stored at the location of a given native pointer.</summary>

 <param name="address">The input pointer.</param>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.IsNullPointer``1(``0*)">
 <summary>Tests whether the given native pointer is null.</summary>

 <param name="address">The input pointer.</param>

 <returns>Whether the given native pointer is null.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.NullPointer``1">
 <summary>Gets the null native pointer.</summary>

 <returns>The null native pointer.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.StackAllocate``1(System.Int32)">
 <summary>Allocates a region of memory on the stack.</summary>

 <param name="count">The number of objects of type T to allocate.</param>

 <returns>A typed pointer to the allocated memory.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.SetPointerInlined``1(``0*,System.Int32,``0)">
 <summary>Assigns the <c>value</c> into the memory location referenced by the typed native
 pointer computed by adding index * sizeof&lt;'T&gt; to the given input pointer.</summary>

 <param name="address">The input pointer.</param>
 <param name="index">The index by which to offset the pointer.</param>
 <param name="value">The value to assign.</param>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.WritePointerInlined``1(``0*,``0)">
 <summary>Assigns the <c>value</c> into the memory location referenced by the given typed native pointer.</summary>

 <param name="address">The input pointer.</param>
 <param name="value">The value to assign.</param>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.ReadPointerInlined``1(``0*)">
 <summary>Dereferences the given typed native pointer.</summary>

 <param name="address">The input pointer.</param>

 <returns>The value at the pointer address.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.GetPointerInlined``1(``0*,System.Int32)">
 <summary>Dereferences the typed native pointer computed by adding index * sizeof&lt;'T&gt; to the
 given input pointer.</summary>

 <param name="address">The input pointer.</param>
 <param name="index">The index by which to offset the pointer.</param>

 <returns>The value at the pointer address.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.AddPointerInlined``1(``0*,System.Int32)">
 <summary>Returns a typed native pointer by adding index * sizeof&lt;'T&gt; to the
 given input pointer.</summary>

 <param name="address">The input pointer.</param>
 <param name="index">The index by which to offset the pointer.</param>

 <returns>A typed pointer.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.ToByRefInlined``1(``0*)">
 <summary>Converts a given typed native pointer to a managed pointer.</summary>

 <param name="address">The typed native pointer.</param>

 <returns>The managed pointer.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.ToILSigPtrInlined``1(``0*)">
 <summary>Returns a Common IL (Intermediate Language) signature pointer for a given typed native pointer.</summary>

 <param name="address">The typed native pointer.</param>

 <returns>A Common IL signature pointer.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.OfILSigPtrInlined``1(Microsoft.FSharp.Core.ilsigptr{``0})">
 <summary>Returns a typed native pointer for a Common IL (Intermediate Language) signature pointer.</summary>

 <param name="address">The Common IL signature pointer.</param>

 <returns>A typed native pointer.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.ToVoidPtrInlined``1(``0*)">
 <summary>Returns an untyped native pointer for a given typed native pointer.</summary>

 <param name="address">The typed native pointer.</param>

 <returns>An untyped native pointer.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.OfVoidPtrInlined``1(Microsoft.FSharp.Core.voidptr)">
 <summary>Returns a typed native pointer for a untyped native pointer.</summary>

 <param name="address">The untyped native pointer.</param>

 <returns>A typed native pointer.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.ToNativeIntInlined``1(``0*)">
 <summary>Returns a machine address for a given typed native pointer.</summary>

 <param name="address">The typed native pointer.</param>

 <returns>The machine address.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.OfNativeIntInlined``1(System.IntPtr)">
 <summary>Returns a typed native pointer for a given machine address.</summary>

 <param name="address">The machine address.</param>

 <returns>A typed native pointer.</returns>

 <example-tbd></example-tbd>
</member>
<member name="T:Microsoft.FSharp.NativeInterop.NativePtrModule">
 <summary>Contains operations on native pointers. Use of these operators may
 result in the generation of unverifiable code.</summary>

 <namespacedoc><summary>
   Library functionality for native interopability. See
   also <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/functions/external-functions">F# External Functions</a> in
   the F# Language Guide.
 </summary></namespacedoc>
</member>
<member name="T:Microsoft.FSharp.Control.IEvent`1">
 <summary>First-class listening points (i.e. objects that permit you to register a callback
 activated when the event is triggered). </summary>

 <category index="3">Events and Observables</category>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpHandler`1">
 <summary>A delegate type associated with the F# event type <c>IEvent&lt;_&gt;</c></summary>

 <param name="sender">The object that fired the event.</param>
 <param name="args">The event arguments.</param>

 <category index="3">Events and Observables</category>
</member>
<member name="T:Microsoft.FSharp.Control.IEvent`2">
 <summary>First class event values for CLI events conforming to CLI Framework standards.</summary>

 <category index="3">Events and Observables</category>
</member>
<member name="M:Microsoft.FSharp.Control.IDelegateEvent`1.RemoveHandler(`0)">
 <summary>Remove a listener delegate from an event listener store.</summary>

 <param name="handler">The delegate to be removed from the event listener store.</param>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.IDelegateEvent`1.AddHandler(`0)">
 <summary>Connect a handler delegate object to the event. A handler can
 be later removed using RemoveHandler. The listener will
 be invoked when the event is fired.</summary>

 <param name="handler">A delegate to be invoked when the event is fired.</param>

 <example-tbd></example-tbd>
</member>
<member name="T:Microsoft.FSharp.Control.IDelegateEvent`1">
 <summary>First class event values for arbitrary delegate types.</summary>

 <remarks>F# gives special status to member properties compatible with type IDelegateEvent and 
 tagged with the CLIEventAttribute. In this case the F# compiler generates appropriate 
 CLI metadata to make the member appear to other CLI languages as a CLI event.</remarks>

 <category index="3">Events and Observables</category>
</member>
<member name="T:Microsoft.FSharp.Control.Lazy`1">
 <summary>The type of delayed computations.</summary>
 
 <remarks>Use the values in the <c>Lazy</c> module to manipulate 
 values of this type, and the notation <c>lazy expr</c> to create values
 of type <see cref="T:System.Lazy`1" />.</remarks>

 <category index="3">Lazy Computation</category>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpEvent`1.Publish">
 <summary>Publishes the event as a first class value.</summary>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpEvent`1.Trigger(`0)">
 <summary>Triggers the event using the given parameters.</summary>

 <param name="arg">The event parameters.</param>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpEvent`1.#ctor">
 <summary>Creates an observable object.</summary>
 <returns>The created event.</returns>

 <example-tbd></example-tbd>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpEvent`1">
 <summary>Event implementations for the IEvent&lt;_&gt; type.</summary>

 <category index="3">Events and Observables</category>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpEvent`2.Publish">
 <summary>Publishes the event as a first class event value.</summary>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpEvent`2.Trigger(System.Object,`1)">
 <summary>Triggers the event using the given sender object and parameters. The sender object may be <c>null</c>.</summary>

 <param name="sender">The object triggering the event.</param>
 <param name="args">The parameters for the event.</param>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpEvent`2.#ctor">
 <summary>Creates an event object suitable for delegate types following the standard .NET Framework convention of a first 'sender' argument.</summary>
 <returns>The created event.</returns>

 <example-tbd></example-tbd>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpEvent`2">
 <summary>Event implementations for a delegate types following the standard .NET Framework convention of a first 'sender' argument.</summary>

 <category index="3">Events and Observables</category>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpDelegateEvent`1.Publish">
 <summary>Publishes the event as a first class event value.</summary>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpDelegateEvent`1.Trigger(System.Object[])">
 <summary>Triggers the event using the given parameters.</summary>
 <param name="args">The parameters for the event.</param>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpDelegateEvent`1.#ctor">
 <summary>Creates an event object suitable for implementing an arbitrary type of delegate.</summary>
 <returns>The event object.</returns>

 <example-tbd></example-tbd>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpDelegateEvent`1">
 <summary>Event implementations for an arbitrary type of delegate.</summary>

 <category index="3">Events and Observables</category>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.Zero">
 <summary>Creates an asynchronous computation that just returns <c>()</c>.</summary>

 <remarks>A cancellation check is performed when the computation is executed.

 The existence of this method permits the use of empty <c>else</c> branches in the 
 <c>async { ... }</c> computation expression syntax.</remarks>
 <returns>An asynchronous computation that returns <c>()</c>.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.While(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Boolean},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit})">
 <summary>Creates an asynchronous computation that runs <c>computation</c> repeatedly 
 until <c>guard()</c> becomes false.</summary>

 <remarks>A cancellation check is performed whenever the computation is executed.

 The existence of this method permits the use of <c>while</c> in the 
 <c>async { ... }</c> computation expression syntax.</remarks>

 <param name="guard">The function to determine when to stop executing <c>computation</c>.</param>
 <param name="computation">The function to be executed.  Equivalent to the body
 of a <c>while</c> expression.</param>

 <returns>An asynchronous computation that behaves similarly to a while loop when run.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.Using``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
 <summary>Creates an asynchronous computation that runs <c>binder(resource)</c>. 
 The action <c>resource.Dispose()</c> is executed as this computation yields its result
 or if the asynchronous computation exits by an exception or by cancellation.</summary>

 <remarks>A cancellation check is performed when the computation is executed.

 The existence of this method permits the use of <c>use</c> and <c>use!</c> in the 
 <c>async { ... }</c> computation expression syntax.</remarks>

 <param name="resource">The resource to be used and disposed.</param>
 <param name="binder">The function that takes the resource and returns an asynchronous
 computation.</param>

 <returns>An asynchronous computation that binds and eventually disposes <c>resource</c>.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.TryWith``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Control.FSharpAsync{``0}})">
 <summary>Creates an asynchronous computation that runs <c>computation</c> and returns its result.
 If an exception happens then <c>catchHandler(exn)</c> is called and the resulting computation executed instead.</summary>

 <remarks>A cancellation check is performed when the computation is executed.

 The existence of this method permits the use of <c>try/with</c> in the 
 <c>async { ... }</c> computation expression syntax.</remarks>

 <param name="computation">The input computation.</param>
 <param name="catchHandler">The function to run when <c>computation</c> throws an exception.</param>

 <returns>An asynchronous computation that executes <c>computation</c> and calls <c>catchHandler</c> if an
 exception is thrown.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.TryFinally``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Creates an asynchronous computation that runs <c>computation</c>. The action <c>compensation</c> is executed 
 after <c>computation</c> completes, whether <c>computation</c> exits normally or by an exception. If <c>compensation</c> raises an exception itself
 the original exception is discarded and the new exception becomes the overall result of the computation.</summary>

 <remarks>A cancellation check is performed when the computation is executed.

 The existence of this method permits the use of <c>try/finally</c> in the 
 <c>async { ... }</c> computation expression syntax.</remarks>

 <param name="computation">The input computation.</param>
 <param name="compensation">The action to be run after <c>computation</c> completes or raises an
 exception (including cancellation).</param>

 <returns>An asynchronous computation that executes computation and compensation afterwards or
 when an exception is raised.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.ReturnFrom``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
 <summary>Delegates to the input computation.</summary>

 <remarks>The existence of this method permits the use of <c>return!</c> in the 
 <c>async { ... }</c> computation expression syntax.</remarks>

 <param name="computation">The input computation.</param>

 <returns>The input computation.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.Return``1(``0)">
 <summary>Creates an asynchronous computation that returns the result <c>v</c>.</summary>

 <remarks>A cancellation check is performed when the computation is executed.

 The existence of this method permits the use of <c>return</c> in the 
 <c>async { ... }</c> computation expression syntax.</remarks>

 <param name="value">The value to return from the computation.</param>

 <returns>An asynchronous computation that returns <c>value</c> when executed.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.For``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}})">
 <summary>Creates an asynchronous computation that enumerates the sequence <c>seq</c>
 on demand and runs <c>body</c> for each element.</summary>

 <remarks>A cancellation check is performed on each iteration of the loop.

 The existence of this method permits the use of <c>for</c> in the 
 <c>async { ... }</c> computation expression syntax.</remarks>

 <param name="sequence">The sequence to enumerate.</param>
 <param name="body">A function to take an item from the sequence and create
 an asynchronous computation.  Can be seen as the body of the <c>for</c> expression.</param>

 <returns>An asynchronous computation that will enumerate the sequence and run <c>body</c>
 for each element.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.Delay``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Control.FSharpAsync{``0}})">
 <summary>Creates an asynchronous computation that runs <c>generator</c>.</summary>

 <remarks>A cancellation check is performed when the computation is executed.</remarks>

 <param name="generator">The function to run.</param>

 <returns>An asynchronous computation that runs <c>generator</c>.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.Combine``1(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Control.FSharpAsync{``0})">
 <summary>Creates an asynchronous computation that first runs <c>computation1</c>
 and then runs <c>computation2</c>, returning the result of <c>computation2</c>.</summary>

 <remarks>A cancellation check is performed when the computation is executed.

 The existence of this method permits the use of expression sequencing in the 
 <c>async { ... }</c> computation expression syntax.</remarks>

 <param name="computation1">The first part of the sequenced computation.</param>
 <param name="computation2">The second part of the sequenced computation.</param>

 <returns>An asynchronous computation that runs both of the computations sequentially.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.Bind``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
 <summary>Creates an asynchronous computation that runs <c>computation</c>, and when 
 <c>computation</c> generates a result <c>T</c>, runs <c>binder res</c>.</summary>

 <remarks>A cancellation check is performed when the computation is executed.

 The existence of this method permits the use of <c>let!</c> in the 
 <c>async { ... }</c> computation expression syntax.</remarks>

 <param name="computation">The computation to provide an unbound result.</param>
 <param name="binder">The function to bind the result of <c>computation</c>.</param>

 <returns>An asynchronous computation that performs a monadic bind on the result
 of <c>computation</c>.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.#ctor">
<summary>
 Generate an object used to build asynchronous computations using F# computation expressions. The value
 &apos;async&apos; is a pre-defined instance of this type.

 A cancellation check is performed when the computation is executed.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpAsyncBuilder">
 <summary>The type of the <c>async</c> operator, used to build workflows for asynchronous computations.</summary>

 <category index="1">Async Programming</category>
</member>
<member name="P:Microsoft.FSharp.Control.AsyncActivation`1.IsCancellationRequested">
 <summary>The F# compiler emits calls to this function to implement F# async expressions.</summary>

 <returns>A value indicating asynchronous execution.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncActivation`1.Success(Microsoft.FSharp.Control.AsyncActivation{`0},`0)">
 <summary>The F# compiler emits calls to this function to implement F# async expressions.</summary>

 <returns>A value indicating asynchronous execution.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncActivation`1.QueueContinuationWithTrampoline(`0)">
<summary>
 Used by MailboxProcessor
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncActivation`1.OnSuccess(`0)">
 <summary>The F# compiler emits calls to this function to implement F# async expressions.</summary>

 <returns>A value indicating asynchronous execution.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncActivation`1.OnExceptionRaised">
 <summary>The F# compiler emits calls to this function to implement F# async expressions.</summary>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncActivation`1.OnCancellation">
 <summary>The F# compiler emits calls to this function to implement F# async expressions.</summary>

 <returns>A value indicating asynchronous execution.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncActivation`1.CallContinuation(`0)">
<summary>
 Used by MailboxProcessor
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.AsyncActivation`1">
 <summary>The F# compiler emits references to this type to implement F# async expressions.</summary>

 <category index="5">Async Internals</category>
</member>
<member name="T:Microsoft.FSharp.Control.AsyncReturn">
 <summary>The F# compiler emits references to this type to implement F# async expressions.</summary>

 <category index="5">Async Internals</category>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpAsync.DefaultCancellationToken">
 <summary>Gets the default cancellation token for executing asynchronous computations.</summary>

 <returns>The default CancellationToken.</returns>

 <category index="3">Cancellation and Exceptions</category>

 <example id="default-cancellation-token-1">
 <code lang="fsharp">
 Async.DefaultCancellationToken.Register(fun () -> printfn "Computation Cancelled") |> ignore
 let primes = [ 2; 3; 5; 7; 11 ]

 for i in primes do
     async {
         do! Async.Sleep(i * 1000)
         printfn $"{i}"
     }
     |> Async.Start

 Thread.Sleep(6000)
 Async.CancelDefaultToken()
 printfn "Tasks Finished"
 </code>
 This will print "2" 2 seconds from start, "3" 3 seconds from start, "5" 5 seconds from start, cease computation and then
 print "Computation Cancelled", followed by "Tasks Finished".
 </example>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpAsync.CancellationToken">
 <summary>Creates an asynchronous computation that returns the CancellationToken governing the execution 
 of the computation.</summary>

 <remarks>In <c>async { let! token = Async.CancellationToken ...}</c> token can be used to initiate other 
 asynchronous operations that will cancel cooperatively with this workflow.</remarks>

 <returns>An asynchronous computation capable of retrieving the CancellationToken from a computation
 expression.</returns>

 <category index="3">Cancellation and Exceptions</category>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.TryCancelled``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc{System.OperationCanceledException,Microsoft.FSharp.Core.Unit})">
 <summary>Creates an asynchronous computation that executes <c>computation</c>.
 If this computation is cancelled before it completes then the computation generated by 
 running <c>compensation</c> is executed.</summary>

 <param name="computation">The input asynchronous computation.</param>
 <param name="compensation">The function to be run if the computation is cancelled.</param>

 <returns>An asynchronous computation that runs the compensation if the input computation
 is cancelled.</returns>

 <category index="3">Cancellation and Exceptions</category>

 <example id="try-cancelled-1">
 <code lang="fsharp">
 let primes = [ 2; 3; 5; 7; 11 ]
 for i in primes do
     Async.TryCancelled(
         async {
             do! Async.Sleep(i * 1000)
             printfn $"{i}"
         },
         fun oce -> printfn $"Computation Cancelled: {i}")
     |> Async.Start

 Thread.Sleep(6000)
 Async.CancelDefaultToken()
 printfn "Tasks Finished"
 </code>
 This will print "2" 2 seconds from start, "3" 3 seconds from start, "5" 5 seconds from start, cease computation
 and then print "Computation Cancelled: 7", "Computation Cancelled: 11" and "Tasks Finished" in any order.
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.SwitchToThreadPool">
 <summary>Creates an asynchronous computation that queues a work item that runs
 its continuation.</summary>

 <returns>A computation that generates a new work item in the thread pool.</returns>

 <category index="4">Threads and Contexts</category>

 <example id="switch-to-thread-pool-1">
 <code lang="fsharp">
 async {
     do! Async.SwitchToNewThread()
     do! someLongRunningComputation()
     do! Async.SwitchToThreadPool()

     for i in 1 .. 10 do
         do! someShortRunningComputation()
 } |> Async.StartImmediate
 </code>
 This will run someLongRunningComputation() without blocking the threads in the threadpool, and then switch to the
 threadpool for shorter computations.
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.SwitchToNewThread">
 <summary>Creates an asynchronous computation that creates a new thread and runs
 its continuation in that thread.</summary>

 <returns>A computation that will execute on a new thread.</returns>

 <category index="4">Threads and Contexts</category>

 <example id="switch-to-new-thread">
 <code lang="fsharp">
 async {
     do! Async.SwitchToNewThread()
     do! someLongRunningComputation()
 } |> Async.StartImmediate
 </code>
 This will run someLongRunningComputation() without blocking the threads in the threadpool.
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.SwitchToContext(System.Threading.SynchronizationContext)">
 <summary>Creates an asynchronous computation that runs
 its continuation using syncContext.Post. If syncContext is null 
 then the asynchronous computation is equivalent to SwitchToThreadPool().</summary>

 <param name="syncContext">The synchronization context to accept the posted computation.</param>

 <returns>An asynchronous computation that uses the syncContext context to execute.</returns>

 <category index="4">Threads and Contexts</category>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.StartWithContinuationsUsingDispatchInfo``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{System.Runtime.ExceptionServices.ExceptionDispatchInfo,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{System.OperationCanceledException,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.StartWithContinuations``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{System.OperationCanceledException,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
 <summary>Runs an asynchronous computation, starting immediately on the current operating system
 thread. Call one of the three continuations when the operation completes.</summary>

 <remarks>If no cancellation token is provided then the default cancellation token
 is used.</remarks>

 <param name="computation">The asynchronous computation to execute.</param>
 <param name="continuation">The function called on success.</param>
 <param name="exceptionContinuation">The function called on exception.</param>
 <param name="cancellationContinuation">The function called on cancellation.</param>
 <param name="cancellationToken">The <c>CancellationToken</c> to associate with the computation.
 The default is used if this parameter is not provided.</param>

 <category index="0">Starting Async Computations</category>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.StartImmediateAsTask``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
 <summary>Runs an asynchronous computation, starting immediately on the current operating system
 thread, but also returns the execution as <see cref="T:System.Threading.Tasks.Task`1"/>
 </summary>

 <remarks>If no cancellation token is provided then the default cancellation token is used.
 You may prefer using this method if you want to achive a similar behviour to async await in C# as 
 async computation starts on the current thread with an ability to return a result.
 </remarks>

 <param name="computation">The asynchronous computation to execute.</param>
 <param name="cancellationToken">The <c>CancellationToken</c> to associate with the computation.
 The default is used if this parameter is not provided.</param>

 <returns>A <see cref="T:System.Threading.Tasks.Task"/> that will be completed
 in the corresponding state once the computation terminates (produces the result, throws exception or gets canceled)</returns>

 <category index="0">Starting Async Computations</category>

 <example id="start-immediate-as-task-1">
 <code lang="fsharp">
 printfn "A"

 let t =
     async {
         printfn "B"
         do! Async.Sleep(1000)
         printfn "C"
     } |> Async.StartImmediateAsTask

 printfn "D"
 t.Wait()
 printfn "E"
 </code>
 Prints "A", "B", "D" immediately, then "C", "E" in 1 second.
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.StartImmediate(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
 <summary>Runs an asynchronous computation, starting immediately on the current operating system
 thread.</summary>

 <remarks>If no cancellation token is provided then the default cancellation token is used.</remarks>

 <param name="computation">The asynchronous computation to execute.</param>
 <param name="cancellationToken">The <c>CancellationToken</c> to associate with the computation.
 The default is used if this parameter is not provided.</param>

 <category index="0">Starting Async Computations</category>

 <example id="start-immediate-1">
 <code lang="fsharp">
 printfn "A"

 async {
     printfn "B"
     do! Async.Sleep(1000)
     printfn "C"
 } |> Async.StartImmediate

 printfn "D"
 </code>
 Prints "A", "B", "D" immediately, then "C" in 1 second
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.StartChildAsTask``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Threading.Tasks.TaskCreationOptions})">
 <summary>Creates an asynchronous computation which starts the given computation as a <see cref="T:System.Threading.Tasks.Task`1"/></summary>

 <category index="0">Starting Async Computations</category>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.StartChild``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Starts a child computation within an asynchronous workflow. 
 This allows multiple asynchronous computations to be executed simultaneously.</summary>

 <remarks>This method should normally be used as the immediate 
 right-hand-side of a <c>let!</c> binding in an F# asynchronous workflow, that is,
 <code lang="fsharp">
     async { ...
            let! completor1 = childComputation1 |> Async.StartChild  
            let! completor2 = childComputation2 |> Async.StartChild  
            ... 
            let! result1 = completor1 
            let! result2 = completor2 
            ... }
 </code>

 When used in this way, each use of <c>StartChild</c> starts an instance of <c>childComputation</c> 
 and returns a completor object representing a computation to wait for the completion of the operation.
 When executed, the completor awaits the completion of <c>childComputation</c>.</remarks>

 <param name="computation">The child computation.</param>
 <param name="millisecondsTimeout">The timeout value in milliseconds.  If one is not provided
 then the default value of -1 corresponding to <see cref="F:System.Threading.Timeout.Infinite"/>.</param>

 <returns>A new computation that waits for the input computation to finish.</returns>

 <category index="3">Cancellation and Exceptions</category>

 <example id="start-child-1">
 <code lang="fsharp">

 let computeWithTimeout timeout =
     async {
         let! completor1 =
             Async.StartChild(
                 (async {
                     do! Async.Sleep(1000)
                     return 1
                  }),
                 millisecondsTimeout = timeout)

         let! completor2 =
             Async.StartChild(
                 (async {
                     do! Async.Sleep(2000)
                     return 2
                  }),
                 millisecondsTimeout = timeout)

         let! v1 = completor1
         let! v2 = completor2
         printfn $"Result: {v1 + v2}"
     } |> Async.RunSynchronously
 </code>
 Will throw a System.TimeoutException if called with a timeout less than 2000, otherwise will print "Result: 3".
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.StartAsTask``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Threading.Tasks.TaskCreationOptions},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
 <summary>Executes a computation in the thread pool.</summary>

 <remarks>If no cancellation token is provided then the default cancellation token is used.</remarks>

 <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> that will be completed
 in the corresponding state once the computation terminates (produces the result, throws exception or gets canceled)</returns>

 <category index="0">Starting Async Computations</category>

 <example id="start-as-task-1">
 <code lang="fsharp">
 printfn "A"

 let t =
     async {
         printfn "B"
         do! Async.Sleep(1000)
         printfn "C"
     } |> Async.StartAsTask

 printfn "D"
 t.Wait()
 printfn "E"
 </code>
 Prints "A", then "D", "B" quickly in any order, then "C", "E" in 1 second.
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Start(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
 <summary>Starts the asynchronous computation in the thread pool. Do not await its result.</summary>

 <remarks>If no cancellation token is provided then the default cancellation token is used.</remarks>

 <param name="computation">The computation to run asynchronously.</param>
 <param name="cancellationToken">The cancellation token to be associated with the computation.
 If one is not supplied, the default cancellation token is used.</param>

 <category index="0">Starting Async Computations</category>

 <example id="start-1">
 <code lang="fsharp">
 printfn "A"

 async {
     printfn "B"
     do! Async.Sleep(1000)
     printfn "C"
 } |> Async.Start

 printfn "D"
 </code>
 Prints "A", then "D", "B" quickly in any order, and then "C" in 1 second.
 </example>
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Sleep(System.TimeSpan)">
 <summary>
  Creates an asynchronous computation that will sleep for the given time. This is scheduled
  using a System.Threading.Timer object. The operation will not block operating system threads
  for the duration of the wait.
 </summary>

 <param name="dueTime">The amount of time to sleep.</param>

 <returns>An asynchronous computation that will sleep for the given time.</returns>

 <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the due time is negative.</exception>

 <category index="2">Awaiting Results</category>

 <example id="sleep-2">
 <code lang="fsharp">
 async {
     printfn "A"
     do! Async.Sleep(TimeSpan(0, 0, 1))
     printfn "B"
 } |> Async.Start
 printfn "C"
 </code>
 Prints "C", then "A" quickly, and then "B" 1 second later.
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Sleep(System.Int32)">
 <summary>
  Creates an asynchronous computation that will sleep for the given time. This is scheduled
  using a System.Threading.Timer object. The operation will not block operating system threads
  for the duration of the wait.
 </summary>

 <param name="millisecondsDueTime">The number of milliseconds to sleep.</param>

 <returns>An asynchronous computation that will sleep for the given time.</returns>

 <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the due time is negative
 and not infinite.</exception>

 <category index="2">Awaiting Results</category>

 <example id="sleep-1">
 <code lang="fsharp">
 async {
     printfn "A"
     do! Async.Sleep(1000)
     printfn "B"
 } |> Async.Start

 printfn "C"
 </code>
 Prints "C", then "A" quickly, and then "B" 1 second later
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Sequential``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Control.FSharpAsync{``0}})">
 <summary>Creates an asynchronous computation that executes all the given asynchronous computations sequentially.</summary>

 <remarks>If all child computations succeed, an array of results is passed to the success continuation.

 If any child computation raises an exception, then the overall computation will trigger an
 exception, and cancel the others.

 The overall computation will respond to cancellation while executing the child computations.
 If cancelled, the computation will cancel any remaining child computations but will still wait
 for the other child computations to complete.</remarks>

 <param name="computations">A sequence of distinct computations to be run in sequence.</param>

 <returns>A computation that returns an array of values from the sequence of input computations.</returns>

 <category index="1">Composing Async Computations</category>

 <example id="sequential-1">
 <code lang="fsharp">
 let primes = [ 2; 3; 5; 7; 10; 11 ]
 let computations =
     [ for i in primes do
             async {
                 do! Async.Sleep(System.Random().Next(1000, 2000))

                 if i % 2 > 0 then
                     printfn $"{i}"
                     return true
                 else
                     return false
             }
    ]

 let t =
     Async.Sequential(computations)
     |> Async.StartAsTask

 t.Wait()
 printfn $"%A{t.Result}" 
 </code>
 This will print "3", "5", "7", "11" with ~1-2 seconds between them except for pauses where even numbers would be and then
 prints [| false; true; true; true; false; true |].
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.RunSynchronously``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
 <summary>Runs the asynchronous computation and await its result.</summary>

 <remarks>If an exception occurs in the asynchronous computation then an exception is re-raised by this
 function.

 If no cancellation token is provided then the default cancellation token is used.

 The computation is started on the current thread if <see cref="P:System.Threading.SynchronizationContext.Current"/> is null,
 <see cref="P:System.Threading.Thread.CurrentThread"/> has  <see cref="P:System.Threading.Thread.IsThreadPoolThread"/>
 of <c>true</c>, and no timeout is specified. Otherwise the computation is started by queueing a new work item in the thread pool,
 and the current thread is blocked awaiting the completion of the computation.

 The timeout parameter is given in milliseconds.  A value of -1 is equivalent to
 <see cref="F:System.Threading.Timeout.Infinite"/>.
 </remarks>

 <param name="computation">The computation to run.</param>
 <param name="timeout">The amount of time in milliseconds to wait for the result of the
 computation before raising a <see cref="T:System.TimeoutException"/>.  If no value is provided
 for timeout then a default of -1 is used to correspond to <see cref="F:System.Threading.Timeout.Infinite"/>.</param>
 <param name="cancellationToken">The cancellation token to be associated with the computation.
 If one is not supplied, the default cancellation token is used.</param>

 <returns>The result of the computation.</returns>

 <category index="0">Starting Async Computations</category>

 <example id="run-synchronously-1">
 <code lang="fsharp">
 printfn "A"

 let result = async {
     printfn "B"
     do! Async.Sleep(1000)
     printfn "C"
     17
 } |> Async.RunSynchronously

 printfn "D"
 </code>
 Prints "A", "B" immediately, then "C", "D" in 1 second. result is set to 17.
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Parallel``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Control.FSharpAsync{``0}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Creates an asynchronous computation that executes all the given asynchronous computations,
 initially queueing each as work items and using a fork/join pattern.</summary>

 <remarks>If all child computations succeed, an array of results is passed to the success continuation.

 If any child computation raises an exception, then the overall computation will trigger an
 exception, and cancel the others.

 The overall computation will respond to cancellation while executing the child computations.
 If cancelled, the computation will cancel any remaining child computations but will still wait
 for the other child computations to complete.</remarks>

 <param name="computations">A sequence of distinct computations to be parallelized.</param>
 <param name="maxDegreeOfParallelism">The maximum degree of parallelism in the parallel execution.</param>

 <returns>A computation that returns an array of values from the sequence of input computations.</returns>

 <category index="1">Composing Async Computations</category>

 <example id="parallel-2">
 <code lang="fsharp">
 let primes = [ 2; 3; 5; 7; 10; 11 ]
 let computations =
     [ for i in primes do
         async {
             do! Async.Sleep(System.Random().Next(1000, 2000))

             return
                 if i % 2 > 0 then
                     printfn $"{i}"
                     true
                 else
                     false
         } ]

 let t =
     Async.Parallel(computations, maxDegreeOfParallelism=3)
     |> Async.StartAsTask

 t.Wait()
 printfn $"%A{t.Result}"
 </code>
 This will print "3", "5" (in any order) in 1-2 seconds, and then "7", "11" (in any order) in 1-2 more seconds and then
 [| false; true; true; true; false; true |].
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Parallel``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Control.FSharpAsync{``0}})">
 <summary>Creates an asynchronous computation that executes all the given asynchronous computations, 
 initially queueing each as work items and using a fork/join pattern.</summary>

 <remarks>If all child computations succeed, an array of results is passed to the success continuation.

 If any child computation raises an exception, then the overall computation will trigger an 
 exception, and cancel the others. 

 The overall computation will respond to cancellation while executing the child computations.
 If cancelled, the computation will cancel any remaining child computations but will still wait
 for the other child computations to complete.</remarks>

 <param name="computations">A sequence of distinct computations to be parallelized.</param>

 <returns>A computation that returns an array of values from the sequence of input computations.</returns>

 <category index="1">Composing Async Computations</category>

 <example id="parallel-1">
 <code lang="fsharp">
 let primes = [ 2; 3; 5; 7; 10; 11 ]
 let t =
     [ for i in primes do
         async {
             do! Async.Sleep(System.Random().Next(1000, 2000))

             if i % 2 > 0 then
                 printfn $"{i}"
                 return true
             else
                 return false
         }
     ]
     |> Async.Parallel
     |> Async.StartAsTask

 t.Wait()
 printfn $"%A{t.Result}"
 </code>
 This will print "3", "5", "7", "11" (in any order) in 1-2 seconds and then [| false; true; true; true; false; true |].
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.OnCancel(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Generates a scoped, cooperative cancellation handler for use within an asynchronous workflow.</summary>

 <remarks>For example,
     <c>async { use! holder = Async.OnCancel interruption ... }</c> 
 generates an asynchronous computation where, if a cancellation happens any time during 
 the execution of the asynchronous computation in the scope of <c>holder</c>, then action 
 <c>interruption</c> is executed on the thread that is performing the cancellation. This can 
 be used to arrange for a computation to be asynchronously notified that a cancellation 
 has occurred, e.g. by setting a flag, or deregistering a pending I/O action.</remarks>

 <param name="interruption">The function that is executed on the thread performing the
 cancellation.</param>

 <returns>An asynchronous computation that triggers the interruption if it is cancelled
 before being disposed.</returns>

 <category index="3">Cancellation and Exceptions</category>

 <example id="on-cancel-1">
 <code lang="fsharp">
 let primes = [ 2; 3; 5; 7; 11 ]
 for i in primes do
     async {
         use! holder = Async.OnCancel(fun () -> printfn $"Computation Cancelled: {i}")
         do! Async.Sleep(i * 1000)
         printfn $"{i}"
     }
     |> Async.Start

 Thread.Sleep(6000)
 Async.CancelDefaultToken()
 printfn "Tasks Finished"
 </code>
 This will print "2" 2 seconds from start, "3" 3 seconds from start, "5" 5 seconds from start, cease computation
 and then print "Computation Cancelled: 7", "Computation Cancelled: 11" and "Tasks Finished" in any order.
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Ignore``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
 <summary>Creates an asynchronous computation that runs the given computation and ignores 
 its result.</summary>

 <param name="computation">The input computation.</param>

 <returns>A computation that is equivalent to the input computation, but disregards the result.</returns>

 <category index="1">Composing Async Computations</category>

 <example id="ignore-1">
 <code lang="fsharp">
 let readFile filename numBytes =
     async {
         use file = System.IO.File.OpenRead(filename)
         printfn "Reading from file %s." filename
         // Throw away the data being read.
         do! file.AsyncRead(numBytes) |> Async.Ignore
     }
 readFile "example.txt" 42 |> Async.Start
 </code>
 Reads bytes from a given file asynchronously and then ignores the result, allowing the do! to be used with functions
 that return an unwanted value.
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.FromContinuations``1(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{System.OperationCanceledException,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.Unit})">
 <summary>Creates an asynchronous computation that captures the current
 success, exception and cancellation continuations. The callback must 
 eventually call exactly one of the given continuations.</summary>

 <param name="callback">The function that accepts the current success, exception, and cancellation
 continuations.</param>

 <returns>An asynchronous computation that provides the callback with the current continuations.</returns>

 <category index="1">Composing Async Computations</category>

 <example id="from-continuations-1">
 <code lang="fsharp">
 let someRiskyBusiness() =
 match DateTime.Today with
 | dt when dt.DayOfWeek = DayOfWeek.Monday -> failwith "Not compatible with Mondays"
 | dt -> dt
 
 let computation =
     (fun (successCont, exceptionCont, cancellationCont) ->
         try
             someRiskyBusiness () |> successCont
         with
         | :? OperationCanceledException as oce -> cancellationCont oce
         | e -> exceptionCont e)
     |> Async.FromContinuations

 Async.StartWithContinuations(
     computation,
     (fun result -> printfn $"Result: {result}"),
     (fun e -> printfn $"Exception: {e}"),
     (fun oce -> printfn $"Cancelled: {oce}")
  )
 </code>
 This anonymous function will call someRiskyBusiness() and properly use the provided continuations
 defined to report the outcome.
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.FromBeginEnd``4(``0,``1,``2,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1,``2,System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc{System.IAsyncResult,``3},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">
 <summary>Creates an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in .NET 2.0 APIs.</summary>

 <remarks>The computation will respond to cancellation while waiting for the completion
 of the operation. If a cancellation occurs, and <c>cancelAction</c> is specified, then it is 
 executed, and the computation continues to wait for the completion of the operation.

 If <c>cancelAction</c> is not specified, then cancellation causes the computation
 to stop immediately, and subsequent invocations of the callback are ignored.</remarks>

 <param name="arg1">The first argument for the operation.</param>
 <param name="arg2">The second argument for the operation.</param>
 <param name="arg3">The third argument for the operation.</param>
 <param name="beginAction">The function initiating a traditional CLI asynchronous operation.</param>
 <param name="endAction">The function completing a traditional CLI asynchronous operation.</param>
 <param name="cancelAction">An optional function to be executed when a cancellation is requested.</param>

 <returns>An asynchronous computation wrapping the given Begin/End functions.</returns>

 <category index="5">Legacy .NET Async Interoperability</category>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.FromBeginEnd``3(``0,``1,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1,System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc{System.IAsyncResult,``2},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">
 <summary>
 Creates an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in .NET 2.0 APIs.</summary>

 <remarks>The computation will respond to cancellation while waiting for the completion
 of the operation. If a cancellation occurs, and <c>cancelAction</c> is specified, then it is 
 executed, and the computation continues to wait for the completion of the operation.

 If <c>cancelAction</c> is not specified, then cancellation causes the computation
 to stop immediately, and subsequent invocations of the callback are ignored.</remarks>

 <param name="arg1">The first argument for the operation.</param>
 <param name="arg2">The second argument for the operation.</param>
 <param name="beginAction">The function initiating a traditional CLI asynchronous operation.</param>
 <param name="endAction">The function completing a traditional CLI asynchronous operation.</param>
 <param name="cancelAction">An optional function to be executed when a cancellation is requested.</param>

 <returns>An asynchronous computation wrapping the given Begin/End functions.</returns>

 <category index="5">Legacy .NET Async Interoperability</category>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.FromBeginEnd``2(``0,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc{System.IAsyncResult,``1},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">
 <summary>
  Creates an asynchronous computation in terms of a Begin/End pair of actions in 
  the style used in .NET 2.0 APIs.
 </summary>

 <remarks>The computation will respond to cancellation while waiting for the completion
 of the operation. If a cancellation occurs, and <c>cancelAction</c> is specified, then it is 
 executed, and the computation continues to wait for the completion of the operation.

  If <c>cancelAction</c> is not specified, then cancellation causes the computation
  to stop immediately, and subsequent invocations of the callback are ignored.
</remarks>

 <param name="arg">The argument for the operation.</param>
 <param name="beginAction">The function initiating a traditional CLI asynchronous operation.</param>
 <param name="endAction">The function completing a traditional CLI asynchronous operation.</param>
 <param name="cancelAction">An optional function to be executed when a cancellation is requested.</param>

 <returns>An asynchronous computation wrapping the given Begin/End functions.</returns>

 <category index="5">Legacy .NET Async Interoperability</category>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.FromBeginEnd``1(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc{System.IAsyncResult,``0},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">
 <summary>
  Creates an asynchronous computation in terms of a Begin/End pair of actions in 
  the style used in CLI APIs.
 </summary>

 <remarks>
 The computation will respond to cancellation while waiting for the completion
 of the operation. If a cancellation occurs, and <c>cancelAction</c> is specified, then it is 
 executed, and the computation continues to wait for the completion of the operation.

 If <c>cancelAction</c> is not specified, then cancellation causes the computation
 to stop immediately, and subsequent invocations of the callback are ignored.</remarks>

 <param name="beginAction">The function initiating a traditional CLI asynchronous operation.</param>
 <param name="endAction">The function completing a traditional CLI asynchronous operation.</param>
 <param name="cancelAction">An optional function to be executed when a cancellation is requested.</param>

 <returns>An asynchronous computation wrapping the given Begin/End functions.</returns>

 <category index="5">Legacy .NET Async Interoperability</category>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Choice``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``0}}})">
 <summary>
 Creates an asynchronous computation that executes all given asynchronous computations in parallel, 
 returning the result of the first succeeding computation (one whose result is 'Some x').
 If all child computations complete with None, the parent computation also returns None.
 </summary>

 <remarks>
 If any child computation raises an exception, then the overall computation will trigger an 
 exception, and cancel the others. 

 The overall computation will respond to cancellation while executing the child computations.
 If cancelled, the computation will cancel any remaining child computations but will still wait
 for the other child computations to complete.
 </remarks>

 <param name="computations">A sequence of computations to be parallelized.</param>

 <returns>A computation that returns the first succeeding computation.</returns>

 <category index="1">Composing Async Computations</category>

 <example id="choice-example-1">
 <code lang="fsharp">
 printfn "Starting"
 let primes = [ 2; 3; 5; 7 ]
 let computations =
     [ for i in primes do
         async {
             do! Async.Sleep(System.Random().Next(1000, 2000))
             return if i % 2 > 0 then Some(i) else None
         }
     ]

 computations
 |> Async.Choice
 |> Async.RunSynchronously
 |> function
     | Some (i) -> printfn $"{i}"
     | None -> printfn "No Result"
 </code>
 Prints one randomly selected odd number in 1-2 seconds. If the list is changed to all even numbers, it will
 instead print "No Result".
 </example>

 <example id="choice-example-2">
 <code lang="fsharp">
 let primes = [ 2; 3; 5; 7 ]
 let computations =
     [ for i in primes do
         async {
             do! Async.Sleep(System.Random().Next(1000, 2000))

             return
                 if i % 2 > 0 then
                     Some(i)
                 else
                     failwith $"Even numbers not supported: {i}"
         }
     ]

 computations
 |> Async.Choice
 |> Async.RunSynchronously
 |> function
     | Some (i) -> printfn $"{i}"
     | None -> printfn "No Result"
 </code>
 Will sometimes print one randomly selected odd number, sometimes throw System.Exception("Even numbers not supported: 2").
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Catch``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
 <summary>Creates an asynchronous computation that executes <c>computation</c>.
 If this computation completes successfully then return <c>Choice1Of2</c> with the returned
 value. If this computation raises an exception before it completes then return <c>Choice2Of2</c>
 with the raised exception.</summary>

 <param name="computation">The input computation that returns the type T.</param>

 <returns>A computation that returns a choice of type T or exception.</returns>

 <category index="3">Cancellation and Exceptions</category>

 <example id="catch-example-1">
 <code lang="fsharp">
 let someRiskyBusiness() =
 match DateTime.Today with
 | dt when dt.DayOfWeek = DayOfWeek.Monday -> failwith "Not compatible with Mondays"
 | dt -> dt
 
 async { return someRiskyBusiness() }
 |> Async.Catch
 |> Async.RunSynchronously
 |> function
     | Choice1Of2 result -> printfn $"Result: {result}"
     | Choice2Of2 e -> printfn $"Exception: {e}"
 </code>
 Prints the returned value of someRiskyBusiness() or the exception if there is one.
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.CancelDefaultToken">
 <summary>Raises the cancellation condition for the most recent set of asynchronous computations started 
 without any specific CancellationToken. Replaces the global CancellationTokenSource with a new 
 global token source for any asynchronous computations created after this point without any 
 specific CancellationToken.</summary>

 <category index="3">Cancellation and Exceptions</category>

 <example id="cancel-default-token-1">
 <code lang="fsharp">
 let primes = [ 2; 3; 5; 7; 11 ]

 let computations =
     [ for i in primes do
             async {
                 do! Async.Sleep(i * 1000)
                 printfn $"{i}"
             }
     ]

 try
     let t =
         Async.Parallel(computations, 3) |> Async.StartAsTask

     Thread.Sleep(6000)
     Async.CancelDefaultToken()
     printfn $"Tasks Finished: %A{t.Result}"
 with
 | :? System.AggregateException as ae -> printfn $"Tasks Not Finished: {ae.Message}"
 </code>
 This will print "2" 2 seconds from start, "3" 3 seconds from start, "5" 5 seconds from start, cease computation and
 then print "Tasks Not Finished: One or more errors occurred. (A task was canceled.)".
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.AwaitWaitHandle(System.Threading.WaitHandle,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Creates an asynchronous computation that will wait on the given WaitHandle.</summary>

 <remarks>The computation returns true if the handle indicated a result within the given timeout.</remarks>

 <param name="waitHandle">The <c>WaitHandle</c> that can be signalled.</param>
 <param name="millisecondsTimeout">The timeout value in milliseconds.  If one is not provided
 then the default value of -1 corresponding to <see cref="F:System.Threading.Timeout.Infinite"/>.</param>

 <returns>An asynchronous computation that waits on the given <c>WaitHandle</c>.</returns>

 <category index="2">Awaiting Results</category>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.AwaitTask(System.Threading.Tasks.Task)">
 <summary>Return an asynchronous computation that will wait for the given task to complete and return
 its result.</summary>

 <param name="task">The task to await.</param>

 <remarks>If an exception occurs in the asynchronous computation then an exception is re-raised by this
 function.

 If the task is cancelled then <see cref="F:System.Threading.Tasks.TaskCanceledException"/> is raised. Note
 that the task may be governed by a different cancellation token to the overall async computation
 where the AwaitTask occurs. In practice you should normally start the task with the
 cancellation token returned by <c>let! ct = Async.CancellationToken</c>, and catch
 any <see cref="F:System.Threading.Tasks.TaskCanceledException"/> at the point where the
 overall async is started.
 </remarks>

 <category index="2">Awaiting Results</category>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.AwaitTask``1(System.Threading.Tasks.Task{``0})">
 <summary>Return an asynchronous computation that will wait for the given task to complete and return
 its result.</summary>

 <param name="task">The task to await.</param>

 <remarks>If an exception occurs in the asynchronous computation then an exception is re-raised by this
 function.

 If the task is cancelled then <see cref="F:System.Threading.Tasks.TaskCanceledException"/> is raised. Note
 that the task may be governed by a different cancellation token to the overall async computation
 where the AwaitTask occurs. In practice you should normally start the task with the
 cancellation token returned by <c>let! ct = Async.CancellationToken</c>, and catch
 any <see cref="F:System.Threading.Tasks.TaskCanceledException"/> at the point where the
 overall async is started.
 </remarks>

 <category index="2">Awaiting Results</category>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.AwaitIAsyncResult(System.IAsyncResult,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Creates an asynchronous computation that will wait on the IAsyncResult.</summary>

 <remarks>The computation returns true if the handle indicated a result within the given timeout.</remarks>

 <param name="iar">The IAsyncResult to wait on.</param>
 <param name="millisecondsTimeout">The timeout value in milliseconds.  If one is not provided
 then the default value of -1 corresponding to <see cref="F:System.Threading.Timeout.Infinite"/>.</param>

 <returns>An asynchronous computation that waits on the given <c>IAsyncResult</c>.</returns>

 <category index="2">Awaiting Results</category>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.AwaitEvent``2(Microsoft.FSharp.Control.IEvent{``0,``1},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">
 <summary>Creates an asynchronous computation that waits for a single invocation of a CLI 
 event by adding a handler to the event. Once the computation completes or is 
 cancelled, the handler is removed from the event.</summary>

 <remarks>The computation will respond to cancellation while waiting for the event. If a 
 cancellation occurs, and <c>cancelAction</c> is specified, then it is executed, and 
 the computation continues to wait for the event.

 If <c>cancelAction</c> is not specified, then cancellation causes the computation
 to cancel immediately.</remarks>

 <param name="event">The event to handle once.</param>
 <param name="cancelAction">An optional function to execute instead of cancelling when a
 cancellation is issued.</param>

 <returns>An asynchronous computation that waits for the event to be invoked.</returns>

 <category index="2">Awaiting Results</category>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.AsBeginEnd``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
 <summary>Creates three functions that can be used to implement the .NET 1.0 Asynchronous 
 Programming Model (APM) for a given asynchronous computation.</summary>

 <param name="computation">A function generating the asynchronous computation to split into the traditional
 .NET Asynchronous Programming Model.</param>

 <returns>A tuple of the begin, end, and cancel members.</returns>

 <category index="5">Legacy .NET Async Interoperability</category>

 <example-tbd></example-tbd>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpAsync">
 <summary>Holds static members for creating and manipulating asynchronous computations.</summary>

 <remarks>
  See also <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/asynchronous-workflows">F# Language Guide - Async Workflows</a>.
 </remarks>

 <category index="1">Async Programming</category>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpAsync`1">
 <summary>
 An asynchronous computation, which, when run, will eventually produce a value  of type T, or else raises an exception.
 </summary> 

 <remarks>
  This type has no members. Asynchronous computations are normally specified either by using an async expression
  or the static methods in the <see cref="T:Microsoft.FSharp.Control.FSharpAsync`1"/> type.

  See also <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/asynchronous-workflows">F# Language Guide - Async Workflows</a>.
 </remarks> 

 <namespacedoc><summary>
   Library functionality for asynchronous programming, events and agents. See also
   <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/asynchronous-workflows">Asynchronous Programming</a>, 
   <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/members/events">Events</a> and
   <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/lazy-expressions">Lazy Expressions</a> in the
   F# Language Guide.
 </summary></namespacedoc>

 <category index="1">Async Programming</category>
</member>
<member name="M:Microsoft.FSharp.Control.BackgroundTaskBuilder.RunDynamic``1(Microsoft.FSharp.Core.CompilerServices.ResumableCode{Microsoft.FSharp.Control.TaskStateMachineData{``0},``0})">
 <summary>
 The entry point for the dynamic implementation of the corresponding operation. Do not use directly, only used when executing quotations that involve tasks or other reflective execution of F# code.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Control.BackgroundTaskBuilder.Run``1(Microsoft.FSharp.Core.CompilerServices.ResumableCode{Microsoft.FSharp.Control.TaskStateMachineData{``0},``0})">
 <summary>
 Hosts the task code in a state machine and starts the task, executing in the threadpool using Task.Run
 </summary>
</member>
<member name="T:Microsoft.FSharp.Control.BackgroundTaskBuilder">
 <summary>
 Contains methods to build tasks using the F# computation expression syntax
 </summary>
</member>
<member name="M:Microsoft.FSharp.Control.TaskBuilder.RunDynamic``1(Microsoft.FSharp.Core.CompilerServices.ResumableCode{Microsoft.FSharp.Control.TaskStateMachineData{``0},``0})">
 <summary>
 The entry point for the dynamic implementation of the corresponding operation. Do not use directly, only used when executing quotations that involve tasks or other reflective execution of F# code.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Control.TaskBuilder.Run``1(Microsoft.FSharp.Core.CompilerServices.ResumableCode{Microsoft.FSharp.Control.TaskStateMachineData{``0},``0})">
<summary>
 Hosts the task code in a state machine and starts the task.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.TaskBuilder">
 <summary>
 Contains methods to build tasks using the F# computation expression syntax
 </summary>
</member>
<member name="M:Microsoft.FSharp.Control.TaskBuilderBase.Zero``1">
 <summary>
 Specifies a unit of task code which produces no result
 </summary>
</member>
<member name="M:Microsoft.FSharp.Control.TaskBuilderBase.While``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Boolean},Microsoft.FSharp.Core.CompilerServices.ResumableCode{Microsoft.FSharp.Control.TaskStateMachineData{``0},Microsoft.FSharp.Core.Unit})">
 <summary>
 Specifies the iterative execution of a unit of task code.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Control.TaskBuilderBase.TryWith``2(Microsoft.FSharp.Core.CompilerServices.ResumableCode{Microsoft.FSharp.Control.TaskStateMachineData{``0},``1},Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.CompilerServices.ResumableCode{Microsoft.FSharp.Control.TaskStateMachineData{``0},``1}})">
 <summary>
 Specifies a unit of task code which excuted using try/with semantics
 </summary>
</member>
<member name="M:Microsoft.FSharp.Control.TaskBuilderBase.TryFinally``2(Microsoft.FSharp.Core.CompilerServices.ResumableCode{Microsoft.FSharp.Control.TaskStateMachineData{``0},``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>
 Specifies a unit of task code which excuted using try/finally semantics
 </summary>
</member>
<member name="M:Microsoft.FSharp.Control.TaskBuilderBase.Return``1(``0)">
 <summary>
 Specifies a unit of task code which returns a value
 </summary>
</member>
<member name="M:Microsoft.FSharp.Control.TaskBuilderBase.For``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.CompilerServices.ResumableCode{Microsoft.FSharp.Control.TaskStateMachineData{``1},Microsoft.FSharp.Core.Unit}})">
 <summary>
 Specifies the iterative execution of a unit of task code.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Control.TaskBuilderBase.Delay``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.CompilerServices.ResumableCode{Microsoft.FSharp.Control.TaskStateMachineData{``0},``1}})">
 <summary>
 Specifies the delayed execution of a unit of task code.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Control.TaskBuilderBase.Combine``2(Microsoft.FSharp.Core.CompilerServices.ResumableCode{Microsoft.FSharp.Control.TaskStateMachineData{``0},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.CompilerServices.ResumableCode{Microsoft.FSharp.Control.TaskStateMachineData{``0},``1})">
 <summary>
 Specifies the sequential composition of two units of task code.
 </summary>
</member>
<member name="T:Microsoft.FSharp.Control.TaskBuilderBase">
 <summary>
 Contains methods to build tasks using the F# computation expression syntax
 </summary>
</member>
<member name="T:Microsoft.FSharp.Control.TaskCode`2">
 <summary>
 A special compiler-recognised delegate type for specifying blocks of task code
 with access to the state machine.
 </summary>
</member>
<member name="T:Microsoft.FSharp.Control.TaskResumptionFunc`1">
 <summary>
 Represents the runtime continuation of a task state machine created dynamically
 </summary>
</member>
<member name="T:Microsoft.FSharp.Control.TaskStateMachine`1">
 <summary>
 This is used by the compiler as a template for creating state machine structs
 </summary>
</member>
<member name="F:Microsoft.FSharp.Control.TaskStateMachineData`1.MethodBuilder">
 <summary>
 Holds the MethodBuilder for the state machine
 </summary>
</member>
<member name="F:Microsoft.FSharp.Control.TaskStateMachineData`1.Result">
 <summary>
 Holds the final result of the state machine
 </summary>
</member>
<member name="T:Microsoft.FSharp.Control.TaskStateMachineData`1">
 <summary>
 The extra data stored in ResumableStateMachine for tasks
 </summary>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.DefaultTimeout(System.Int32)">
 <summary>Raises a timeout exception if a message not received in this amount of time. By default
 no timeout is used.</summary>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.remove_Error(Microsoft.FSharp.Control.FSharpHandler{System.Exception})">
 <summary>Occurs when the execution of the agent results in an exception.</summary>

 <example-tbd></example-tbd>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.Error">
 <summary>Occurs when the execution of the agent results in an exception.</summary>

 <example-tbd></example-tbd>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.DefaultTimeout">
 <summary>Raises a timeout exception if a message not received in this amount of time. By default
 no timeout is used.</summary>

 <example-tbd></example-tbd>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.CurrentQueueLength">
 <summary>Returns the number of unprocessed messages in the message queue of the agent.</summary>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.add_Error(Microsoft.FSharp.Control.FSharpHandler{System.Exception})">
 <summary>Occurs when the execution of the agent results in an exception.</summary>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.TryScan``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Control.FSharpAsync{``0}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Scans for a message by looking through messages in arrival order until <c>scanner</c>
 returns a Some value. Other messages remain in the queue.</summary>

 <remarks>This method is for use within the body of the agent. For each agent, at most
 one concurrent reader may be active, so no more than one concurrent call to
 Receive, TryReceive, Scan and/or TryScan may be active.</remarks>

 <param name="scanner">The function to return None if the message is to be skipped
 or Some if the message is to be processed and removed from the queue.</param>
 <param name="timeout">An optional timeout in milliseconds. Defaults to -1 which corresponds
 to <see cref="F:System.Threading.Timeout.Infinite"/>.</param>

 <returns>An asynchronous computation that <c>scanner</c> built off the read message.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.TryReceive(Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Waits for a message. This will consume the first message in arrival order.</summary>

 <remarks>This method is for use within the body of the agent.

 Returns None if a timeout is given and the timeout is exceeded.

 This method is for use within the body of the agent. For each agent, at most
 one concurrent reader may be active, so no more than one concurrent call to
 Receive, TryReceive, Scan and/or TryScan may be active.</remarks>
 <param name="timeout">An optional timeout in milliseconds. Defaults to -1 which
 corresponds to <see cref="F:System.Threading.Timeout.Infinite"/>.</param>

 <returns>An asynchronous computation that returns the received message or
 None if the timeout is exceeded.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.TryPostAndReply``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Like PostAndReply, but returns None if no reply within the timeout period.</summary>

 <param name="buildMessage">The function to incorporate the AsyncReplyChannel into
 the message to be sent.</param>
 <param name="timeout">An optional timeout parameter (in milliseconds) to wait for a reply message.
 Defaults to -1 which corresponds to <see cref="F:System.Threading.Timeout.Infinite"/>.</param>

 <returns>The reply from the agent or None if the timeout expires.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.Start">
 <summary>Starts the agent.</summary>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.Start(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpMailboxProcessor{`0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
 <summary>Creates and starts an agent. The <c>body</c> function is used to generate the asynchronous
 computation executed by the agent.</summary>

 <param name="body">The function to produce an asynchronous computation that will be executed
 as the read loop for the MailboxProcessor when Start is called.</param>
 <param name="cancellationToken">An optional cancellation token for the <c>body</c>.
 Defaults to <c>Async.DefaultCancellationToken</c>.</param>

 <returns>The created MailboxProcessor.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.Scan``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Control.FSharpAsync{``0}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Scans for a message by looking through messages in arrival order until <c>scanner</c>
 returns a Some value. Other messages remain in the queue.</summary>

 <remarks>Returns None if a timeout is given and the timeout is exceeded.

 This method is for use within the body of the agent. For each agent, at most
 one concurrent reader may be active, so no more than one concurrent call to
 Receive, TryReceive, Scan and/or TryScan may be active.</remarks>

 <param name="scanner">The function to return None if the message is to be skipped
 or Some if the message is to be processed and removed from the queue.</param>
 <param name="timeout">An optional timeout in milliseconds. Defaults to -1 which corresponds
 to <see cref="F:System.Threading.Timeout.Infinite"/>.</param>

 <returns>An asynchronous computation that <c>scanner</c> built off the read message.</returns>

 <exception cref="T:System.TimeoutException">Thrown when the timeout is exceeded.</exception>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.Receive(Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Waits for a message. This will consume the first message in arrival order.</summary>

 <remarks>This method is for use within the body of the agent.

 This method is for use within the body of the agent. For each agent, at most
 one concurrent reader may be active, so no more than one concurrent call to
 Receive, TryReceive, Scan and/or TryScan may be active.</remarks>
 <param name="timeout">An optional timeout in milliseconds. Defaults to -1 which corresponds
 to <see cref="F:System.Threading.Timeout.Infinite"/>.</param>

 <returns>An asynchronous computation that returns the received message.</returns>
 <exception cref="T:System.TimeoutException">Thrown when the timeout is exceeded.</exception>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.PostAndTryAsyncReply``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Like AsyncPostAndReply, but returns None if no reply within the timeout period.</summary>

 <param name="buildMessage">The function to incorporate the AsyncReplyChannel into
 the message to be sent.</param>
 <param name="timeout">An optional timeout parameter (in milliseconds) to wait for a reply message.
 Defaults to -1 which corresponds to <see cref="F:System.Threading.Timeout.Infinite"/>.</param>

 <returns>An asynchronous computation that will return the reply or None if the timeout expires.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.PostAndReply``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Posts a message to an agent and await a reply on the channel, synchronously.</summary>

 <remarks>The message is generated by applying <c>buildMessage</c> to a new reply channel
 to be incorporated into the message. The receiving agent must process this
 message and invoke the Reply method on this reply channel precisely once.</remarks>
 <param name="buildMessage">The function to incorporate the AsyncReplyChannel into
 the message to be sent.</param>
 <param name="timeout">An optional timeout parameter (in milliseconds) to wait for a reply message.
 Defaults to -1 which corresponds to <see cref="F:System.Threading.Timeout.Infinite"/>.</param>

 <returns>The reply from the agent.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.PostAndAsyncReply``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Posts a message to an agent and await a reply on the channel, asynchronously.</summary>

 <remarks>The message is generated by applying <c>buildMessage</c> to a new reply channel
 to be incorporated into the message. The receiving agent must process this
 message and invoke the Reply method on this reply channel precisely once.</remarks>
 <param name="buildMessage">The function to incorporate the AsyncReplyChannel into
 the message to be sent.</param>
 <param name="timeout">An optional timeout parameter (in milliseconds) to wait for a reply message.
 Defaults to -1 which corresponds to <see cref="F:System.Threading.Timeout.Infinite"/>.</param>

 <returns>An asynchronous computation that will wait for the reply from the agent.</returns>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.Post(`0)">
 <summary>Posts a message to the message queue of the MailboxProcessor, asynchronously.</summary>

 <param name="message">The message to post.</param>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.#ctor(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpMailboxProcessor{`0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
 <summary>Creates an agent. The <c>body</c> function is used to generate the asynchronous
 computation executed by the agent. This function is not executed until
 <c>Start</c> is called.</summary>

 <param name="body">The function to produce an asynchronous computation that will be executed
 as the read loop for the MailboxProcessor when Start is called.</param>
 <param name="cancellationToken">An optional cancellation token for the <c>body</c>.
 Defaults to <c>Async.DefaultCancellationToken</c>.</param>

 <returns>The created MailboxProcessor.</returns>

 <example-tbd></example-tbd>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpMailboxProcessor`1">
 <summary>A message-processing agent which executes an asynchronous computation.</summary>

 <remarks>The agent encapsulates a message queue that supports multiple-writers and
 a single reader agent. Writers send messages to the agent by using the Post
 method and its variations.

 The agent may wait for messages using the Receive or TryReceive methods or
 scan through all available messages using the Scan or TryScan method.</remarks>

 <category index="4">Agents</category>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncReplyChannel`1.Reply(`0)">
 <summary>Sends a reply to a PostAndReply message.</summary>
 <param name="value">The value to send.</param>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpAsyncReplyChannel`1">
 <summary>A handle to a capability to reply to a PostAndReply message.</summary>

 <category index="4">Agents</category>
</member>
<member name="M:Microsoft.FSharp.Control.LazyExtensions.Force``1(System.Lazy{``0})">
 <summary>Forces the execution of this value and return its result. Same as Value. Mutual exclusion is used to 
 prevent other threads also computing the value.</summary>
 <returns>The value of the Lazy object.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.LazyExtensions.CreateFromValue``1(``0)">
 <summary>Creates a lazy computation that evaluates to the given value when forced.</summary>

 <param name="value">The input value.</param>

 <returns>The created Lazy object.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.LazyExtensions.Create``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
 <summary>Creates a lazy computation that evaluates to the result of the given function when forced.</summary>

 <param name="creator">The function to provide the value when needed.</param>

 <returns>The created Lazy object.</returns>
</member>
<member name="T:Microsoft.FSharp.Control.LazyExtensions">
 <summary>Extensions related to Lazy values.</summary>

 <category index="3">Lazy Computation</category>
</member>
<member name="M:Microsoft.FSharp.Control.WebExtensions.AsyncDownloadFile(System.Net.WebClient,System.Uri,System.String)">
 <summary>Returns an asynchronous computation that, when run, will wait for the download of the given URI to specified file.</summary>

 <param name="address">The URI to retrieve.</param>
 <param name="fileName">The file name to save download to.</param>

 <returns>An asynchronous computation that will wait for the download of the URI to specified file.</returns>
 
 <example id="async-download-file">
 <code lang="fsharp">
 open System.Net
 open System
 let client = new WebClient()
 Uri("https://www.w3.com") |> fun x -> client.AsyncDownloadFile(x, "output.html") |> Async.RunSynchronously
 </code>
 This will download the server response as a file and output it as output.html
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.WebExtensions.AsyncDownloadData(System.Net.WebClient,System.Uri)">
 <summary>Returns an asynchronous computation that, when run, will wait for the download of the given URI.</summary>

 <param name="address">The URI to retrieve.</param>

 <returns>An asynchronous computation that will wait for the download of the URI.</returns>
 
 <example id="async-download-data">
 <code lang="fsharp">
 open System.Net
 open System.Text
 open System
 let client = new WebClient()
 client.AsyncDownloadData(Uri("https://www.w3.org")) |> Async.RunSynchronously |> Encoding.ASCII.GetString 
 </code>
 </example>
 Downloads the data in bytes and decodes it to a string.
</member>
<member name="M:Microsoft.FSharp.Control.WebExtensions.AsyncDownloadString(System.Net.WebClient,System.Uri)">
 <summary>Returns an asynchronous computation that, when run, will wait for the download of the given URI.</summary>

 <param name="address">The URI to retrieve.</param>

 <returns>An asynchronous computation that will wait for the download of the URI.</returns>
 
 <example id="async-download-string">
 <code lang="fsharp">
 open System
 let client = new WebClient()
 Uri("https://www.w3.org") |> client.AsyncDownloadString |> Async.RunSynchronously
 </code>
 This will download the server response from https://www.w3.org
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.WebExtensions.AsyncGetResponse(System.Net.WebRequest)">
 <summary>Returns an asynchronous computation that, when run, will wait for a response to the given WebRequest.</summary>
 <returns>An asynchronous computation that waits for response to the <c>WebRequest</c>.</returns>
 
 <example id="get-response">
 <code lang="fsharp">
 open System.Net
 open System.IO
 let responseStreamToString = fun (responseStream : WebResponse) ->
     let reader = new StreamReader(responseStream.GetResponseStream())
     reader.ReadToEnd()
 let webRequest = WebRequest.Create("https://www.w3.org")
 let result = webRequest.AsyncGetResponse() |> Async.RunSynchronously |> responseStreamToString
 </code>
 </example>
 Gets the web response asynchronously and converts response stream to string
</member>
<member name="T:Microsoft.FSharp.Control.WebExtensions">
 <summary>A module of extension members providing asynchronous operations for some basic Web operations.</summary>

 <category index="1">Async Programming</category>
</member>
<member name="M:Microsoft.FSharp.Control.CommonExtensions.SubscribeToObservable``1(System.IObservable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit})">
 <summary>Connects a listener function to the observable. The listener will
 be invoked for each observation. The listener can be removed by
 calling Dispose on the returned IDisposable object.</summary>

 <param name="callback">The function to be called for each observation.</param>

 <returns>An object that will remove the listener if disposed.</returns>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.CommonExtensions.AddToObservable``1(System.IObservable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit})">
 <summary>Permanently connects a listener function to the observable. The listener will
 be invoked for each observation.</summary>

 <param name="callback">The function to be called for each observation.</param>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.CommonExtensions.AsyncWrite(System.IO.Stream,System.Byte[],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Returns an asynchronous computation that will write the given bytes to the stream.</summary>

 <param name="buffer">The buffer to write from.</param>
 <param name="offset">An optional offset as a number of bytes in the stream.</param>
 <param name="count">An optional number of bytes to write to the stream.</param>

 <returns>An asynchronous computation that will write the given bytes to the stream.</returns>

 <exception cref="T:System.ArgumentException">Thrown when the sum of offset and count is longer than
 the buffer length.</exception>
 <exception cref="T:System.ArgumentOutOfRangeException">Thrown when offset or count is negative.</exception>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.CommonExtensions.AsyncReadBytes(System.IO.Stream,System.Int32)">
 <summary>Returns an asynchronous computation that will read the given number of bytes from the stream.</summary>

 <param name="count">The number of bytes to read.</param>

 <returns>An asynchronous computation that returns the read byte[] when run.</returns> 
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Control.CommonExtensions.AsyncRead(System.IO.Stream,System.Byte[],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Returns an asynchronous computation that will read from the stream into the given buffer.</summary>
 <param name="buffer">The buffer to read into.</param>
 <param name="offset">An optional offset as a number of bytes in the stream.</param>
 <param name="count">An optional number of bytes to read from the stream.</param>

 <returns>An asynchronous computation that will read from the stream into the given buffer.</returns>

 <exception cref="T:System.ArgumentException">Thrown when the sum of offset and count is longer than
 the buffer length.</exception>
 <exception cref="T:System.ArgumentOutOfRangeException">Thrown when offset or count is negative.</exception>
 
 <example-tbd></example-tbd>
</member>
<member name="T:Microsoft.FSharp.Control.CommonExtensions">
 <summary>A module of extension members providing asynchronous operations for some basic CLI types related to concurrency and I/O.</summary>

 <category index="1">Async Programming</category>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncPrimitives.TryWith``1(Microsoft.FSharp.Control.AsyncActivation{``0},Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Control.FSharpAsync{``0}}})">
 <summary>The F# compiler emits calls to this function to implement the <c>try/with</c> construct for F# async expressions.</summary>

 <param name="ctxt">The async activation.</param>
 <param name="computation">The computation to protect.</param>
 <param name="catchFunction">The exception filter.</param>

 <returns>A value indicating asynchronous execution.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncPrimitives.TryFinally``1(Microsoft.FSharp.Control.AsyncActivation{``0},Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>The F# compiler emits calls to this function to implement the <c>try/finally</c> construct for F# async expressions.</summary>

 <param name="ctxt">The async activation.</param>
 <param name="computation">The computation to protect.</param>
 <param name="finallyFunction">The finally code.</param>

 <returns>A value indicating asynchronous execution.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncPrimitives.Bind``2(Microsoft.FSharp.Control.AsyncActivation{``0},Microsoft.FSharp.Control.FSharpAsync{``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``0}})">
 <summary>The F# compiler emits calls to this function to implement the <c>let!</c> construct for F# async expressions.</summary>

 <param name="ctxt">The async activation.</param>
 <param name="part1">The first part of the computation.</param>
 <param name="part2">A function returning the second part of the computation.</param>

 <returns>An async activation suitable for running part1 of the asynchronous execution.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncPrimitives.CallThenInvoke``2(Microsoft.FSharp.Control.AsyncActivation{``0},``1,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``0}})">
 <summary>The F# compiler emits calls to this function to implement constructs for F# async expressions.</summary>

 <param name="ctxt">The async activation.</param>
 <param name="result1">The result of the first part of the computation.</param>
 <param name="part2">A function returning the second part of the computation.</param>

 <returns>A value indicating asynchronous execution.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncPrimitives.Invoke``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.AsyncActivation{``0})">
 <summary>The F# compiler emits calls to this function to implement constructs for F# async expressions.</summary>

 <param name="computation">The async computation.</param>
 <param name="ctxt">The async activation.</param>

 <returns>A value indicating asynchronous execution.</returns>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncPrimitives.MakeAsync``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.AsyncActivation{``0},Microsoft.FSharp.Control.AsyncReturn})">
 <summary>The F# compiler emits calls to this function to implement F# async expressions.</summary>

 <param name="body">The body of the async computation.</param>

 <returns>The async computation.</returns>
</member>
<member name="T:Microsoft.FSharp.Control.AsyncPrimitives">
 <summary>Entry points for generated code</summary>

 <category index="5">Async Internals</category>
</member>
<member name="M:Microsoft.FSharp.Control.TaskBuilderExtensions.HighPriority.TaskBuilderBase.BindDynamic.Static``3(Microsoft.FSharp.Core.CompilerServices.ResumableStateMachine{Microsoft.FSharp.Control.TaskStateMachineData{``0}}@,System.Threading.Tasks.Task{``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.CompilerServices.ResumableCode{Microsoft.FSharp.Control.TaskStateMachineData{``0},``2}})">
 <summary>
 The entry point for the dynamic implementation of the corresponding operation. Do not use directly, only used when executing quotations that involve tasks or other reflective execution of F# code.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Control.TaskBuilderExtensions.HighPriority.TaskBuilderBase.ReturnFrom``1(Microsoft.FSharp.Control.TaskBuilderBase,System.Threading.Tasks.Task{``0})">
 <summary>
 Specifies a unit of task code which draws a result from a task.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Control.TaskBuilderExtensions.HighPriority.TaskBuilderBase.Bind``3(Microsoft.FSharp.Control.TaskBuilderBase,System.Threading.Tasks.Task{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.CompilerServices.ResumableCode{Microsoft.FSharp.Control.TaskStateMachineData{``1},``2}})">
 <summary>
 Specifies a unit of task code which draws a result from a task then calls a continuation.
 </summary>
</member>
<member name="T:Microsoft.FSharp.Control.TaskBuilderExtensions.HighPriority">
 <summary>
 Contains high-priority overloads for the `task` computation expression builder.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Control.TaskBuilderExtensions.MediumPriority.TaskBuilderBase.ReturnFrom``1(Microsoft.FSharp.Control.TaskBuilderBase,Microsoft.FSharp.Control.FSharpAsync{``0})">
 <summary>
 Specifies a unit of task code which draws a result from an F# async value.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Control.TaskBuilderExtensions.MediumPriority.TaskBuilderBase.Bind``3(Microsoft.FSharp.Control.TaskBuilderBase,Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.CompilerServices.ResumableCode{Microsoft.FSharp.Control.TaskStateMachineData{``1},``2}})">
 <summary>
 Specifies a unit of task code which draws a result from an F# async value then calls a continuation.
 </summary>
</member>
<member name="T:Microsoft.FSharp.Control.TaskBuilderExtensions.MediumPriority">
 <summary>
 Contains medium-priority overloads for the `task` computation expression builder.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Control.TaskBuilderExtensions.LowPriority.TaskBuilderBase.Using``3(Microsoft.FSharp.Control.TaskBuilderBase,``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.CompilerServices.ResumableCode{Microsoft.FSharp.Control.TaskStateMachineData{``1},``2}})">
 <summary>
 Specifies a unit of task code which binds to the resource implementing IDisposable and disposes it synchronously
 </summary>
</member>
<member name="M:Microsoft.FSharp.Control.TaskBuilderExtensions.LowPriority.TaskBuilderBase.BindDynamic.Static``5(Microsoft.FSharp.Core.FSharpFunc{``0,``3},Microsoft.FSharp.Core.FSharpFunc{``3,``1},Microsoft.FSharp.Core.FSharpFunc{``3,System.Boolean},Microsoft.FSharp.Core.CompilerServices.ResumableStateMachine{Microsoft.FSharp.Control.TaskStateMachineData{``4}}@,``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.CompilerServices.ResumableCode{Microsoft.FSharp.Control.TaskStateMachineData{``4},``2}})">
 <summary>
 The entry point for the dynamic implementation of the corresponding operation. Do not use directly, only used when executing quotations that involve tasks or other reflective execution of F# code.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Control.TaskBuilderExtensions.LowPriority.TaskBuilderBase.ReturnFrom``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``2},Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean},Microsoft.FSharp.Control.TaskBuilderBase,``0)">
 <summary>
 Specifies a unit of task code which draws its result from a task-like value
 satisfying the GetAwaiter pattern.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Control.TaskBuilderExtensions.LowPriority.TaskBuilderBase.Bind``5(Microsoft.FSharp.Core.FSharpFunc{``0,``3},Microsoft.FSharp.Core.FSharpFunc{``3,``1},Microsoft.FSharp.Core.FSharpFunc{``3,System.Boolean},Microsoft.FSharp.Control.TaskBuilderBase,``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.CompilerServices.ResumableCode{Microsoft.FSharp.Control.TaskStateMachineData{``4},``2}})">
 <summary>
 Specifies a unit of task code which draws a result from a task-like value
 satisfying the GetAwaiter pattern and calls a continuation.
 </summary>
</member>
<member name="T:Microsoft.FSharp.Control.TaskBuilderExtensions.LowPriority">
 <summary>
 Contains low-priority overloads for the `task` computation expression builder.
 </summary>
</member>
<member name="P:Microsoft.FSharp.Control.TaskBuilderModule.backgroundTask">
 <summary>
 Builds a task using computation expression syntax which switches to execute on a background thread if not
 already doing so.
 </summary>

 <remarks>
 If the task is created on a foreground thread (where <see cref="P:System.Threading.SynchronizationContext.Current"/> is non-null)
 its body is executed on a background thread using <see cref="M:System.Threading.Tasks.Task.Run"/>.
 If created on a background thread (where <see cref="P:System.Threading.SynchronizationContext.Current"/> is null) it is executed immeidately
 immediately on that thread.
 </remarks>
 
 <example-tbd></example-tbd>
</member>
<member name="P:Microsoft.FSharp.Control.TaskBuilderModule.task">
 <summary>
 Builds a task using computation expression syntax.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="T:Microsoft.FSharp.Control.TaskBuilderModule">
<summary>
 Contains the `task` computation expression builder.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Pairwise``2(Microsoft.FSharp.Control.IEvent{``0,``1})">
 <summary>Returns a new event that triggers on the second and subsequent triggerings of the input event.
 The Nth triggering of the input event passes the arguments from the N-1th and Nth triggering as
 a pair. The argument passed to the N-1th triggering is held in hidden internal state until the
 Nth triggering occurs.</summary>

 <param name="sourceEvent">The input event.</param>

 <returns>An event that triggers on pairs of consecutive values passed from the source event.</returns>
 <example>
 <code lang="fsharp">
 open System

 let createTimer interval =
     let timer = new Timers.Timer(interval)
     timer.AutoReset &lt;- true
     timer.Enabled &lt;- true
     timer.Elapsed

 let timer = createTimer 1000

 let pairWise = Event.pairwise timer

 let extractPair (pair: Timers.ElapsedEventArgs * Timers.ElapsedEventArgs) =
     let leftPair, rightPair = pair
     printfn $"(Left): {leftPair.SignalTime} (Right): {rightPair.SignalTime}"

 pairWise.Subscribe(extractPair) |> ignore

 Console.ReadLine() |> ignore
 </code>
 The sample will output the timer event every second: <c>
 (Left): 2/14/2022 11:58:46 PM (Right): 2/14/2022 11:58:46 PM
 (Left): 2/14/2022 11:58:46 PM (Right): 2/14/2022 11:58:47 PM
 (Left): 2/14/2022 11:58:47 PM (Right): 2/14/2022 11:58:48 PM </c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Add``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Control.IEvent{``1,``0})">
 <summary>Runs the given function each time the given event is triggered.</summary>

 <param name="callback">The function to call when the event is triggered.</param>
 <param name="sourceEvent">The input event.</param>

 <example>
 <code lang="fsharp">
 open System

 let createTimer interval =
     let timer = new Timers.Timer(interval)
     timer.AutoReset &lt;- true
     timer.Enabled &lt;- true
     timer.Elapsed

 let timer = createTimer 1000

 Event.add (fun (event: Timers.ElapsedEventArgs) -> printfn $"{event.SignalTime} ")  timer

 Console.ReadLine() |> ignore
 </code>
 The sample will output the timer event every second: <c>
 2/14/2022 11:52:05 PM
 2/14/2022 11:52:06 PM
 2/14/2022 11:52:07 PM
 2/14/2022 11:52:08 PM </c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Scan``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Microsoft.FSharp.Control.IEvent{``2,``1})">
 <summary>Returns a new event consisting of the results of applying the given accumulating function
 to successive values triggered on the input event.  An item of internal state
 records the current value of the state parameter.  The internal state is not locked during the
 execution of the accumulation function, so care should be taken that the
 input IEvent not triggered by multiple threads simultaneously.</summary>

 <param name="collector">The function to update the state with each event value.</param>
 <param name="state">The initial state.</param>
 <param name="sourceEvent">The input event.</param>

 <returns>An event that fires on the updated state values.</returns>
 <example>
 <code lang="fsharp">
 open System

 let createTimer interval =
     let timer = new Timers.Timer(interval)
     timer.AutoReset &lt;- true
     timer.Enabled &lt;- true
     timer.Elapsed

 let timer = createTimer 1000

 let multiplyBy number =
     fun (timerEvent: Timers.ElapsedEventArgs) -> number * timerEvent.SignalTime./// Second

 let initialState = 2

 let scan = Event.scan multiplyBy initialState timer

 scan.Subscribe(fun x -> printf "%A " x) |> ignore

 Console.ReadLine() |> ignore
 </code>
 The sample will output depending on your timestamp. It will multiply the seconds with an initial state of 2: <c>106 5724 314820 17629920 1004905440 -1845026624 -1482388416</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Choose``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Control.IEvent{``2,``0})">
 <summary>Returns a new event which fires on a selection of messages from the original event.
 The selection function takes an original message to an optional new message.</summary>

 <param name="chooser">The function to select and transform event values to pass on.</param>
 <param name="sourceEvent">The input event.</param>

 <returns>An event that fires only when the chooser returns Some.</returns>
 <example>
 <code lang="fsharp">
 open System

 let createTimer interval =
     let timer = new Timers.Timer(interval)
     timer.AutoReset &lt;- true
     timer.Enabled &lt;- true
     timer.Elapsed

 let timer = createTimer 1000

 let getEvenSeconds (number: Timers.ElapsedEventArgs) =
     match number with
     | _ when number.SignalTime.Second % 2 = 0 -> Some number.SignalTime
     | _ -> None

 let evenSecondsEvent = Event.choose getEvenSeconds timer

 evenSecondsEvent.Subscribe(fun x -> printfn $"{x} ")
 |> ignore

 Console.ReadLine() |> ignore
 </code>
 The sample will output: <c>2/15/2022 12:04:04 AM
 2/15/2022 12:04:06 AM
 2/15/2022 12:04:08 AM </c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Split``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Control.IEvent{``3,``0})">
 <summary>Returns a new event that listens to the original event and triggers the
 first resulting event if the application of the function to the event arguments
 returned a Choice1Of2, and the second event if it returns a Choice2Of2.</summary>

 <param name="splitter">The function to transform event values into one of two types.</param>
 <param name="sourceEvent">The input event.</param>

 <returns>A tuple of events.  The first fires whenever <c>splitter</c> evaluates to Choice1of1 and
 the second fires whenever <c>splitter</c> evaluates to Choice2of2.</returns>
 <example>
 <code lang="fsharp">
 open System

 let createTimer interval =
     let timer = new Timers.Timer(interval)
     timer.AutoReset &lt;- true
     timer.Enabled &lt;- true
     timer.Elapsed

 let timer = createTimer 1000

 let bySeconds (timerEvent: Timers.ElapsedEventArgs) =
     match timerEvent.SignalTime.Second % 2 = 0 with
     | true -> Choice1Of2 timerEvent.SignalTime.Second
     | false -> Choice2Of2 $"{timerEvent.SignalTime.Second} is not an even num ber"

 let evenSplit, printOddNumbers = Event.split bySeconds timer

 let printOutput event functionName =
     Event.add (fun output -> printfn $"{functionName} - Split output: {output}. /// Type: {output.GetType()}") event

 printOutput evenSplit (nameof evenSplit) |> ignore

 printOutput printOddNumbers (nameof printOddNumbers)
 |> ignore

 Console.ReadLine() |> ignore
 </code>
 The sample will split the events by even or odd seconds: <c>evenSplit - Split output: 44. Type: System.Int32
 printOddNumbers - Split output: 45 is not an even number. Type: System.String
 evenSplit - Split output: 46. Type: System.Int32
 printOddNumbers - Split output: 47 is not an even number. Type: System.String
 evenSplit - Split output: 48. Type: System.Int32
 printOddNumbers - Split output: 49 is not an even number. Type: System.String</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Partition``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Control.IEvent{``1,``0})">
 <summary>Returns a new event that listens to the original event and triggers the
 first resulting event if the application of the predicate to the event arguments
 returned true, and the second event if it returned false.</summary>

 <param name="predicate">The function to determine which output event to trigger.</param>
 <param name="sourceEvent">The input event.</param>

 <returns>A tuple of events.  The first is triggered when the predicate evaluates to true
 and the second when the predicate evaluates to false.</returns>
 <example>
 <code lang="fsharp">
 open System

 let createTimer interval =
     let timer = new Timers.Timer(interval)
     timer.AutoReset &lt;- true
     timer.Enabled &lt;- true
     timer.Elapsed

 let timer = createTimer 1000

 let getEvenSeconds (number: Timers.ElapsedEventArgs) =
     match number with
     | _ when number.SignalTime.Second % 2 = 0 -> true
     | _ -> false

 let leftPartition, rightPartition = Event.partition getEvenSeconds timer

 leftPartition.Subscribe(fun x -> printfn $"Left partition: {x.SignalTime}")
 |> ignore

 rightPartition.Subscribe(fun x -> printfn $"Right partition: {x.SignalTime}")
 |> ignore

 Console.ReadLine() |> ignore
 </code>
 The sample will partition into two events if it is even or odd seconds: <c>
 Right partition: 2/15/2022 12:00:27 AM
 Left partition: 2/15/2022 12:00:28 AM
 Right partition: 2/15/2022 12:00:29 AM
 Left partition: 2/15/2022 12:00:30 AM
 Right partition: 2/15/2022 12:00:31 AM</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Filter``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Control.IEvent{``1,``0})">
 <summary>Returns a new event that listens to the original event and triggers the resulting
 event only when the argument to the event passes the given function.</summary>

 <param name="predicate">The function to determine which triggers from the event to propagate.</param>
 <param name="sourceEvent">The input event.</param>

 <returns>An event that only passes values that pass the predicate.</returns>
 <example>
 <code lang="fsharp">
 open System

 let createTimer interval =
     let timer = new Timers.Timer(interval)
     timer.AutoReset &lt;- true
     timer.Enabled &lt;- true
     timer.Elapsed

 let timer = createTimer 1000

 let getEvenSeconds (number: Timers.ElapsedEventArgs) =
     match number with
     | _ when number.SignalTime.Second % 2 = 0 -> true
     | _ -> false

 let evenSecondsEvent = Event.filter getEvenSeconds timer

 evenSecondsEvent.Subscribe(fun x -> printfn $"{x} ")
 |> ignore

 Console.ReadLine() |> ignore
 </code>
 The sample will only output even seconds: <c>2/15/2022 12:03:08 AM
 2/15/2022 12:03:10 AM
 2/15/2022 12:03:12 AM
 2/15/2022 12:03:14 AM </c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Control.IEvent{``2,``0})">
 <summary>Returns a new event that passes values transformed by the given function.</summary>

 <param name="mapping">The function to transform event values.</param>
 <param name="sourceEvent">The input event.</param>

 <returns>An event that passes the transformed values.</returns>
 <example>
 <code lang="fsharp">
 open System

 let createTimer interval =
     let timer = new Timers.Timer(interval)
     timer.AutoReset &lt;- true
     timer.Enabled &lt;- true
     timer.Elapsed

 let timer = createTimer 1000

 let transformSeconds (number: Timers.ElapsedEventArgs) =
     match number with
     | _ when number.SignalTime.Second % 2 = 0 -> 100
     | _ -> -500

 let evenSecondsEvent = Event.map transformSeconds timer

 evenSecondsEvent.Subscribe(fun x -> printf $"{x} ")
 |> ignore

 Console.ReadLine() |> ignore
 </code>
 The sample will transform the seconds if it's even or odd number and the output is: <c>-500 100 -500 100 -500 100 </c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Merge``3(Microsoft.FSharp.Control.IEvent{``0,``1},Microsoft.FSharp.Control.IEvent{``2,``1})">
 <summary>Fires the output event when either of the input events fire.</summary>
 <param name="event1">The first input event.</param>
 <param name="event2">The second input event.</param>

 <returns>An event that fires when either of the input events fire.</returns>
 <example>
 <code lang="fsharp">
 open System.Reactive.Linq
 open System
 let createTimer interval =
     let timer = new Timers.Timer(interval)
     timer.AutoReset &lt;- true
     timer.Enabled &lt;- true
     timer.Elapsed

 let oneSecondTimer = createTimer 1000
 let fiveSecondsTimer = createTimer 5000

 let result = Event.merge oneSecondTimer fiveSecondsTimer

 result.Subscribe(fun output -> printfn $"Output - {output.SignalTime} ")
 |> ignore

 Console.ReadLine() |> ignore
 </code>
 The sample will output: <c>Output - 2/15/2022 12:10:40 AM
 Output - 2/15/2022 12:10:41 AM
 Output - 2/15/2022 12:10:41 AM
 Output - 2/15/2022 12:10:42 AM
 Output - 2/15/2022 12:10:43 AM </c>
 </example>
</member>
<member name="T:Microsoft.FSharp.Control.EventModule">
 <summary>Contains operations for working with values of type <see cref="T:Microsoft.FSharp.Control.IEvent`1"/>.</summary>

 <category index="3">Events and Observables</category>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Pairwise``1(System.IObservable{``0})">
 <summary>Returns a new observable that triggers on the second and subsequent triggerings of the input observable.
 The Nth triggering of the input observable passes the arguments from the N-1th and Nth triggering as
 a pair. The argument passed to the N-1th triggering is held in hidden internal state until the
 Nth triggering occurs.</summary>

 <remarks>For each observer, the registered intermediate observing object is not thread safe.
 That is, observations arising from the source must not be triggered concurrently
 on different threads.</remarks>
 <param name="source">The input Observable.</param>

 <returns>An Observable that triggers on successive pairs of observations from the input Observable.</returns>

 <example>
 <code lang="fsharp">
 /// open System.Reactive.Linq
 let numbers = seq { 1..5 }
 let observableNumbers = Observable.ToObservable numbers

 let pairWise = Observable.pairwise observableNumbers

 pairWise.Subscribe(fun pair -> printf $"{pair} ")
 |> ignore
 </code>
 The sample evaluates to: <c>(1, 2), (2, 3), (3, 4), (4, 5)</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Subscribe``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},System.IObservable{``0})">
 <summary>Creates an observer which subscribes to the given observable and which calls
 the given function for each observation.</summary>

 <param name="callback">The function to be called on each observation.</param>
 <param name="source">The input Observable.</param>

 <returns>An object that will remove the callback if disposed.</returns>

 <example>
 <code lang="fsharp">
 open System.Reactive.Linq
 let numbers = seq { 1..3 }
 let observableNumbers = Observable.ToObservable numbers
 let printOutput observable =
     use subscription = Observable.subscribe (fun x -> printfn "%A" x) observable
     subscription
 printOutput observableNumbers |> ignore
 </code>
 The sample evaluates to: <c>1, 2, 3</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Add``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},System.IObservable{``0})">
 <summary>Creates an observer which permanently subscribes to the given observable and which calls
 the given function for each observation.</summary>

 <param name="callback">The function to be called on each observation.</param>
 <param name="source">The input Observable.</param>

 <example>
 <code lang="fsharp">
 open System.Reactive.Linq
 let numbers = seq { 1..5 }
 let observableNumbers = Observable.ToObservable numbers
 let multiplyByTwo = fun number -> printf $"{number * 2} "
 Observable.add multiplyByTwo observableNumbers
 </code>
 The sample evaluates to: <c>2 4 6 8 10</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Scan``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.IObservable{``1})">
 <summary>Returns an observable which, for each observer, allocates an item of state
 and applies the given accumulating function to successive values arising from
 the input. The returned object will trigger observations for each computed
 state value, excluding the initial value. The returned object propagates
 all errors arising from the source and completes when the source completes.</summary>

 <remarks>For each observer, the registered intermediate observing object is not thread safe.
 That is, observations arising from the source must not be triggered concurrently
 on different threads.</remarks>
 <param name="collector">The function to update the state with each observation.</param>
 <param name="state">The initial state.</param>
 <param name="source">The input Observable.</param>

 <returns>An Observable that triggers on the updated state values.</returns>

 <example>
 <code lang="fsharp">
 open System.Reactive.Linq
 let numbers = seq { 1..5 }
 let observableNumbers = Observable.ToObservable numbers

 let multiplyBy number = fun y -> number * y
 let initialState = 2
 let scan = Observable.scan multiplyBy initialState observableNumbers

 scan.Subscribe(fun x -> printf "%A " x) |> ignore
 </code>
 The sample evaluates to: <c>2 4 12 48 240</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.IObservable{``0})">
 <summary>Returns an observable which chooses a projection of observations from the source
 using the given function. The returned object will trigger observations <c>x</c>
 for which the splitter returns <c>Some x</c>. The returned object also propagates
 all errors arising from the source and completes when the source completes.</summary>

 <param name="chooser">The function that returns Some for observations to be propagated
 and None for observations to ignore.</param>
 <param name="source">The input Observable.</param>

 <returns>An Observable that only propagates some of the observations from the source.</returns>

 <example>
 <code lang="fsharp">
 open System.Reactive.Linq
 let numbers = seq { 1..5 }
 let observableNumbers = Observable.ToObservable numbers

 let getOddNumbers number =
     match number with
     | _ when number % 2 = 0 -> None
     | _ -> Some number

 let map = Observable.choose getOddNumbers observableNumbers

 map.Subscribe(fun x -> printf $"{x} ") |> ignore
 </code>
 The sample will output: <c>1 3 5</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Split``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},System.IObservable{``0})">
 <summary>Returns two observables which split the observations of the source by the
 given function. The first will trigger observations <c>x</c> for which the
 splitter returns <c>Choice1Of2 x</c>. The second will trigger observations
 <c>y</c> for which the splitter returns <c>Choice2Of2 y</c> The splitter is
 executed once for each subscribed observer. Both also propagate error
 observations arising from the source and each completes when the source
 completes.</summary>

 <param name="splitter">The function that takes an observation an transforms
 it into one of the two output Choice types.</param>
 <param name="source">The input Observable.</param>

 <returns>A tuple of Observables.  The first triggers when <c>splitter</c> returns Choice1of2
 and the second triggers when <c>splitter</c> returns Choice2of2.</returns>

 <example>
 <code lang="fsharp">
 open System.Reactive.Linq
 let numbers = seq { 1..5 }
 let observableNumbers = Observable.ToObservable numbers

 let getEvenNumbers number =
     match number % 2 = 0 with
     | true -> Choice1Of2 number
     | false -> Choice2Of2 $"{number} is not an even number"

 let evenSplit, printOddNumbers = Observable.split getEvenNumbers observableNumbers

 let printOutput observable functionName =
     use subscription =
         Observable.subscribe
             (fun output -> printfn $"{functionName} - Split output: {output}. Type: {output.GetType()}")
             observable

     subscription

 printOutput evenSplit (nameof evenSplit) |> ignore
 printOutput printOddNumbers (nameof printOddNumbers) |> ignore
 </code>
 The sample evaluates to: <c>evenSplit - Split output: 2. Type: System.Int32
 evenSplit - Split output: 4. Type: System.Int32
 printOddNumbers - Split output: 1 is not an even number. Type: System.String
 printOddNumbers - Split output: 3 is not an even number. Type: System.String
 printOddNumbers - Split output: 5 is not an even number. Type: System.String</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.IObservable{``0})">
 <summary>Returns two observables which partition the observations of the source by
 the given function. The first will trigger observations for those values
 for which the predicate returns true. The second will trigger observations
 for those values where the predicate returns false. The predicate is
 executed once for each subscribed observer. Both also propagate all error
 observations arising from the source and each completes when the source
 completes.</summary>

 <param name="predicate">The function to determine which output Observable will trigger
 a particular observation.</param>
 <param name="source">The input Observable.</param>

 <returns>A tuple of Observables.  The first triggers when the predicate returns true, and
 the second triggers when the predicate returns false.</returns>

 <example>
 <code lang="fsharp">
 open System.Reactive.Linq
 let numbers = seq { 1..5 }
 let observableNumbers = Observable.ToObservable numbers

 let isEvenNumber = fun number -> number % 2 = 0

 let leftPartition, rightPartition =
     Observable.partition isEvenNumber observableNumbers

 leftPartition.Subscribe(fun x -> printfn $"Left partition: {x}") |> ignore

 rightPartition.Subscribe(fun x -> printfn $"Right partition: {x}") |> ignore
 </code>
 The sample evaluates to: <c>Left partition: 2, 4, Right partition: 1, 3, 5</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.IObservable{``0})">
 <summary>Returns an observable which filters the observations of the source
 by the given function. The observable will see only those observations
 for which the predicate returns true. The predicate is executed once for
 each subscribed observer. The returned object also propagates error
 observations arising from the source and completes when the source completes.</summary>

 <param name="predicate">The function to apply to observations to determine if it should
 be kept.</param>
 <param name="source">The input Observable.</param>

 <returns>An Observable that filters observations based on <c>filter</c>.</returns>

 <example>
 <code lang="fsharp">
 open System.Reactive.Linq
 let numbers = seq { 1..5 }
 let observableNumbers = Observable.ToObservable numbers

 let getEvenNumbers = fun number -> number % 2 = 0
 let map = Observable.filter multiplyByTwo observableNumbers

 map.Subscribe(fun x -> printf $"{x} ") |> ignore
 </code>
 The sample will output: <c>2 4</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.IObservable{``0})">
 <summary>Returns an observable which transforms the observations of the source by the
 given function. The transformation function is executed once for each
 subscribed observer. The returned object also propagates error observations
 arising from the source and completes when the source completes.</summary>
 <param name="mapping">The function applied to observations from the source.</param>
 <param name="source">The input Observable.</param>

 <returns>An Observable of the type specified by <c>mapping</c>.</returns>

 <example>
 <code lang="fsharp">
 open System.Reactive.Linq
 let numbers = seq { 1..5 }
 let observableNumbers = Observable.ToObservable numbers

 let multiplyByTwo = fun number -> number * 2
 let map = Observable.map multiplyByTwo observableNumbers

 map.Subscribe(fun x -> printf $"{x} ") |> ignore
 </code>
 The sample will output: <c>2 4 6 8 10</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Merge``1(System.IObservable{``0},System.IObservable{``0})">
 <summary>Returns an observable for the merged observations from the sources.
 The returned object propagates success and error values arising
 from either source and completes when both the sources have completed.</summary>

 <remarks>For each observer, the registered intermediate observing object is not
 thread safe. That is, observations arising from the sources must not
 be triggered concurrently on different threads.</remarks>

 <param name="source1">The first Observable.</param>
 <param name="source2">The second Observable.</param>

 <returns>An Observable that propagates information from both sources.</returns>

 <example>
 <code lang="fsharp">
 open System.Reactive.Linq
 open System

 let createTimer interval =
     let timer = new Timers.Timer(interval)
     timer.AutoReset &lt;- true
     timer.Enabled &lt;- true
     Observable.Create(fun observer -> timer.Elapsed.Subscribe(observer))

 let observableFirstTimer = createTimer 1000
 let observableSecondTimer = createTimer 3000

 let result = Observable.merge observableFirstTimer observableSecondTimer

 result.Subscribe(fun output -> printfn $"Output - {output.SignalTime} ")
 |> ignore

 Console.ReadLine() |> ignore
 </code>
 The sample will merge all events at a given interval and output it to the stream: <c>
 Output - 2/5/2022 3:49:37 AM
 Output - 2/5/2022 3:49:38 AM
 Output - 2/5/2022 3:49:39 AM
 Output - 2/5/2022 3:49:39 AM
 Output - 2/5/2022 3:49:40 AM
 Output - 2/5/2022 3:49:41 AM
 Output - 2/5/2022 3:49:42 AM
 Output - 2/5/2022 3:49:42 AM
 </c>
 </example>
</member>
<member name="T:Microsoft.FSharp.Control.ObservableModule">
 <summary>Contains operations for working with first class event and other observable objects.</summary>

 <category index="3">Events and Observables</category>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Zero``2">
 <summary>
 A method used to support the F# query syntax.  Returns an empty sequence that has the specified type argument.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.YieldFrom``2(Microsoft.FSharp.Linq.QuerySource{``0,``1})">
 <summary>
 A method used to support the F# query syntax.  Returns a sequence that contains the specified values.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Yield``2(``0)">
 <summary>
 A method used to support the F# query syntax.  Returns a sequence of length one that contains the specified value.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Where``2(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>A query operator that selects those elements based on a specified predicate. 
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.ThenByNullableDescending``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Nullable{``2}})">
 <summary>A query operator that performs a subsequent ordering of the elements selected so far in descending order by the given nullable sorting key.
 This operator may only be used immediately after a 'sortBy', 'sortByDescending', 'thenBy' or 'thenByDescending', or their nullable variants.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.ThenByNullable``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Nullable{``2}})">
 <summary>A query operator that performs a subsequent ordering of the elements selected so far in ascending order by the given nullable sorting key.
 This operator may only be used immediately after a 'sortBy', 'sortByDescending', 'thenBy' or 'thenByDescending', or their nullable variants.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.ThenByDescending``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
 <summary>A query operator that performs a subsequent ordering of the elements selected so far in descending order by the given sorting key.
 This operator may only be used immediately after a 'sortBy', 'sortByDescending', 'thenBy' or 'thenByDescending', or their nullable variants.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.ThenBy``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
 <summary>A query operator that performs a subsequent ordering of the elements selected so far in ascending order by the given sorting key.
 This operator may only be used immediately after a 'sortBy', 'sortByDescending', 'thenBy' or 'thenByDescending', or their nullable variants.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.TakeWhile``2(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>A query operator that selects elements from a sequence as long as a specified condition is true, and then skips the remaining elements.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Take``2(Microsoft.FSharp.Linq.QuerySource{``0,``1},System.Int32)">
 <summary>A query operator that selects a specified number of contiguous elements from those selected so far.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.SumByNullable``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``2},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``2,``2}},Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Nullable{``2}})">
 <summary>A query operator that selects a nullable value for each element selected so far and returns the sum of these values. 
 If any nullable does not have a value, it is ignored.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.SumBy``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``2},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``2,``2}},Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
 <summary>A query operator that selects a value for each element selected so far and returns the sum of these values. 
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Source``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 A method used to support the F# query syntax.  Inputs to queries are implicitly wrapped by a call to one of the overloads of this method.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Source``2(System.Linq.IQueryable{``0})">
 <summary>
 A method used to support the F# query syntax.  Inputs to queries are implicitly wrapped by a call to one of the overloads of this method.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.SortByNullableDescending``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Nullable{``2}})">
 <summary>A query operator that sorts the elements selected so far in descending order by the given nullable sorting key.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.SortByNullable``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Nullable{``2}})">
 <summary>A query operator that sorts the elements selected so far in ascending order by the given nullable sorting key.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.SortByDescending``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
 <summary>A query operator that sorts the elements selected so far in descending order by the given sorting key.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.SortBy``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
 <summary>A query operator that sorts the elements selected so far in ascending order by the given sorting key.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.SkipWhile``2(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>A query operator that bypasses elements in a sequence as long as a specified condition is true and then selects the remaining elements.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Skip``2(Microsoft.FSharp.Linq.QuerySource{``0,``1},System.Int32)">
 <summary>A query operator that bypasses a specified number of the elements selected so far and selects the remaining elements.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Select``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
 <summary>A query operator that projects each of the elements selected so far.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Run``1(Microsoft.FSharp.Quotations.FSharpExpr{Microsoft.FSharp.Linq.QuerySource{``0,System.Linq.IQueryable}})">
 <summary>
 A method used to support the F# query syntax.  Runs the given quotation as a query using LINQ IQueryable rules.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Quote``1(Microsoft.FSharp.Quotations.FSharpExpr{``0})">
 <summary>
 A method used to support the F# query syntax.  Indicates that the query should be passed as a quotation to the Run method.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Nth``2(Microsoft.FSharp.Linq.QuerySource{``0,``1},System.Int32)">
 <summary>A query operator that selects the element at a specified index amongst those selected so far.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.MinByNullable``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Nullable{``2}})">
 <summary>A query operator that selects a nullable value for each element selected so far and returns the minimum of these values. 
 If any nullable does not have a value, it is ignored.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.MinBy``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
 <summary>A query operator that selects a value for each element selected so far and returns the minimum resulting value. 
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.MaxByNullable``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Nullable{``2}})">
 <summary>A query operator that selects a nullable value for each element selected so far and returns the maximum of these values. 
 If any nullable does not have a value, it is ignored.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.MaxBy``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
 <summary>A query operator that selects a value for each element selected so far and returns the maximum resulting value. 
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.LeftOuterJoin``5(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Linq.QuerySource{``2,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``3},Microsoft.FSharp.Core.FSharpFunc{``2,``3},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{``2},``4}})">
 <summary>A query operator that correlates two sets of selected values based on matching keys and groups the results.
 If any group is empty, a group with a single default value is used instead. 
 Normal usage is 'leftOuterJoin y in elements2 on (key1 = key2) into group'. 
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.LastOrDefault``2(Microsoft.FSharp.Linq.QuerySource{``0,``1})">
 <summary>A query operator that selects the last element of those selected so far, or a default value if no element is found.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Last``2(Microsoft.FSharp.Linq.QuerySource{``0,``1})">
 <summary>A query operator that selects the last element of those selected so far.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Join``5(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Linq.QuerySource{``2,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``3},Microsoft.FSharp.Core.FSharpFunc{``2,``3},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,``4}})">
 <summary>A query operator that correlates two sets of selected values based on matching keys. 
 Normal usage is 'join y in elements2 on (key1 = key2)'. 
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.HeadOrDefault``2(Microsoft.FSharp.Linq.QuerySource{``0,``1})">
 <summary>A query operator that selects the first element of those selected so far, or a default value if the sequence contains no elements.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Head``2(Microsoft.FSharp.Linq.QuerySource{``0,``1})">
 <summary>A query operator that selects the first element from those selected so far.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.GroupValBy``4(Microsoft.FSharp.Linq.QuerySource{``0,``3},Microsoft.FSharp.Core.FSharpFunc{``0,``2},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>A query operator that selects a value for each element selected so far and groups the elements by the given key.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.GroupJoin``5(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Linq.QuerySource{``2,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``3},Microsoft.FSharp.Core.FSharpFunc{``2,``3},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{``2},``4}})">
 <summary>A query operator that correlates two sets of selected values based on matching keys and groups the results. 
 Normal usage is 'groupJoin y in elements2 on (key1 = key2) into group'. 
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.GroupBy``3(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
 <summary>A query operator that groups the elements selected so far according to a specified key selector.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.For``4(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Linq.QuerySource{``2,``3}})">
 <summary>
 A method used to support the F# query syntax.  Projects each element of a sequence to another sequence and combines the resulting sequences into one sequence.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Find``2(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>A query operator that selects the first element selected so far that satisfies a specified condition.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Exists``2(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>A query operator that determines whether any element selected so far satisfies a condition.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.ExactlyOneOrDefault``2(Microsoft.FSharp.Linq.QuerySource{``0,``1})">
 <summary>A query operator that selects the single, specific element of those selected so far, or a default value if that element is not found.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.ExactlyOne``2(Microsoft.FSharp.Linq.QuerySource{``0,``1})">
 <summary>A query operator that selects the single, specific element selected so far
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Distinct``2(Microsoft.FSharp.Linq.QuerySource{``0,``1})">
 <summary>A query operator that selects distinct elements from the elements selected so far. 
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Count``2(Microsoft.FSharp.Linq.QuerySource{``0,``1})">
 <summary>A query operator that returns the number of selected elements.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.Contains``2(Microsoft.FSharp.Linq.QuerySource{``0,``1},``0)">
 <summary>A query operator that determines whether the selected elements contains a specified element.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.AverageByNullable``3(Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``2}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``2},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``2,``2}},Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Nullable{``2}})">
 <summary>A query operator that selects a nullable value for each element selected so far and returns the average of these values. 
 If any nullable does not have a value, it is ignored.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.AverageBy``3(Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``2}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``2},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``2,``2}},Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
 <summary>A query operator that selects a value for each element selected so far and returns the average of these values. 
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.All``2(Microsoft.FSharp.Linq.QuerySource{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
 <summary>A query operator that determines whether all elements selected so far satisfies a condition.
 </summary>
 
 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryBuilder.#ctor">
 <summary>Create an instance of this builder. Use 'query { ... }' to use the query syntax.</summary>
</member>
<member name="T:Microsoft.FSharp.Linq.QueryBuilder">
<summary>
 The type used to support the F# query syntax. Use &apos;query { ... }&apos; to use the query syntax. See
 also &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/query-expressions&quot;&gt;F# Query Expressions&lt;/a&gt; in the F# Language Guide.
</summary>
</member>
<member name="P:Microsoft.FSharp.Linq.QuerySource`2.Source">
 <summary>
 A property used to support the F# query syntax.  
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QuerySource`2.#ctor(System.Collections.Generic.IEnumerable{`0})">
 <summary>
 A method used to support the F# query syntax.  
 </summary>
</member>
<member name="T:Microsoft.FSharp.Linq.QuerySource`2">
 <summary>
 A partial input or result in an F# query. This type is used to support the F# query syntax.
 </summary>

 <namespacedoc><summary>
   Library functionality for F# query syntax and interoperability with .NET LINQ Expressions. See
   also <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/query-expressions">F# Query Expressions</a> in the F# Language Guide.
 </summary></namespacedoc>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToChar``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Char},System.Nullable{``0})">
 <summary>Converts the argument to character. Numeric inputs are converted according to the UTF-16 
 encoding for characters. The operation requires an appropriate static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted char.</returns>
 
 <example id="char-1">
 <code lang="fsharp">
 open System
 open FSharp.Linq.NullableOperators

 Nullable.char (Nullable&lt;int>())  // evaluates to Nullable&lt;char>()
 Nullable.char (Nullable&lt;int>(64))  // evaluates to Nullable&lt;char>('@')
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToDecimal``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Decimal},System.Nullable{``0})">
 <summary>Converts the argument to System.Decimal using a direct conversion for all 
 primitive numeric types. The operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted decimal.</returns>
 
 <example id="decimal-1">
 <code lang="fsharp">
 open System
 open FSharp.Linq.NullableOperators

 Nullable.decimal (Nullable&lt;int>())  // evaluates to Nullable&lt;decimal>()
 Nullable.decimal (Nullable&lt;int>(3))  // evaluates to Nullable&lt;decimal>(3.0M)
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToUIntPtr``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.UIntPtr},System.Nullable{``0})">
 <summary>Converts the argument to unsigned native integer using a direct conversion for all 
 primitive numeric types. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted unativeint</returns>
 
 <example id="unativeint-1">
 <code lang="fsharp">
 open System
 open FSharp.Linq.NullableOperators

 Nullable.unativeint (Nullable&lt;int>())  // evaluates to Nullable&lt;unativeint>()
 Nullable.unativeint (Nullable&lt;int>(3))  // evaluates to Nullable&lt;unativeint>(3un)
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToIntPtr``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.IntPtr},System.Nullable{``0})">
 <summary>Converts the argument to signed native integer. This is a direct conversion for all 
 primitive numeric types. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted nativeint</returns>
 
 <example id="nativeint-1">
 <code lang="fsharp">
 open System
 open FSharp.Linq.NullableOperators

 Nullable.nativeint (Nullable&lt;int>())  // evaluates to Nullable&lt;nativeint>()
 Nullable.nativeint (Nullable&lt;int>(3))  // evaluates to Nullable&lt;nativeint>(3n)
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToDouble``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Double},System.Nullable{``0})">
 <summary>Converts the argument to 64-bit float. This is a direct conversion for all 
 primitive numeric types. The operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted float</returns>
 
 <example id="double-1">
 <code lang="fsharp">
 open System
 open FSharp.Linq.NullableOperators

 Nullable.double (Nullable&lt;int>())  // evaluates to Nullable&lt;double>()
 Nullable.double (Nullable&lt;int>(3))  // evaluates to Nullable&lt;double>(3.0)
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToSingle``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Single},System.Nullable{``0})">
 <summary>Converts the argument to 32-bit float. This is a direct conversion for all 
 primitive numeric types. The operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted float32</returns>
 
 <example id="single-1">
 <code lang="fsharp">
 open System
 open FSharp.Linq.NullableOperators

 Nullable.single (Nullable&lt;int>())  // evaluates to Nullable&lt;float32>()
 Nullable.single (Nullable&lt;int>(3))  // evaluates to Nullable&lt;float32>(3.0f)
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToFloat``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Double},System.Nullable{``0})">
 <summary>Converts the argument to 64-bit float. This is a direct conversion for all 
 primitive numeric types. The operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted float</returns>
 
 <example id="float-1">
 <code lang="fsharp">
 open System
 open FSharp.Linq.NullableOperators

 Nullable.float (Nullable&lt;int>())  // evaluates to Nullable&lt;float>()
 Nullable.float (Nullable&lt;int>(3))  // evaluates to Nullable&lt;float>(3.0)
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToFloat32``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Single},System.Nullable{``0})">
 <summary>Converts the argument to 32-bit float. This is a direct conversion for all 
 primitive numeric types. The operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted float32</returns>
 
 <example id="float32-1">
 <code lang="fsharp">
 open System
 open FSharp.Linq.NullableOperators

 Nullable.float32 (Nullable&lt;int>())  // evaluates to Nullable&lt;float32>()
 Nullable.float32 (Nullable&lt;int>(3))  // evaluates to Nullable&lt;float32>(3.0f)
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToUInt64``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.UInt64},System.Nullable{``0})">
 <summary>Converts the argument to unsigned 64-bit integer. This is a direct conversion for all 
 primitive numeric types. The operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted uint64</returns>
 
 <example id="uint64-1">
 <code lang="fsharp">
 open System
 open FSharp.Linq.NullableOperators

 Nullable.uint64 (Nullable&lt;int>())  // evaluates to Nullable&lt;uint64>()
 Nullable.uint64 (Nullable&lt;int>(3))  // evaluates to Nullable&lt;uint64>(3UL)
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToInt64``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Int64},System.Nullable{``0})">
 <summary>Converts the argument to signed 64-bit integer. This is a direct conversion for all 
 primitive numeric types. The operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted int64</returns>
 
 <example id="int64-1">
 <code lang="fsharp">
 open System
 open FSharp.Linq.NullableOperators

 Nullable.int64 (Nullable&lt;int>())  // evaluates to Nullable&lt;int64>()
 Nullable.int64 (Nullable&lt;int>(3))  // evaluates to Nullable&lt;int64>(3L)
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToUInt32``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.UInt32},System.Nullable{``0})">
 <summary>Converts the argument to unsigned 32-bit integer. This is a direct conversion for all 
 primitive numeric types. The operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted uint32</returns>
 
 <example id="uint32-1">
 <code lang="fsharp">
 open System
 open FSharp.Linq.NullableOperators

 Nullable.uint32 (Nullable&lt;int>())  // evaluates to Nullable&lt;uint32>()
 Nullable.uint32 (Nullable&lt;int>(3))  // evaluates to Nullable(3u)
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToInt32``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32},System.Nullable{``0})">
 <summary>Converts the argument to signed 32-bit integer. This is a direct conversion for all 
 primitive numeric types. The operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted int32</returns>
 
 <example id="int32-1">
 <code lang="fsharp">
 open System
 open FSharp.Linq.NullableOperators

 Nullable.int32 (Nullable&lt;int64>())  // evaluates to Nullable&lt;int32>()
 Nullable.int32 (Nullable&lt;int64>(3))  // evaluates to Nullable(3)
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToEnum``1(System.Nullable{System.Int32})">
 <summary>Converts the argument to a particular enum type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted enum type.</returns>
 
 <example id="enum-1">
 <code lang="fsharp">
 open System
 open FSharp.Linq.NullableOperators

 Nullable.enum&lt;DayOfWeek> (Nullable&lt;int>())  // evaluates to Nullable&lt;uint>()
 Nullable.enum&lt;DayOfWeek> (Nullable&lt;int>(3))  // evaluates to Nullable&lt;DayOfWeek>(Wednesday)
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToUInt``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.UInt32},System.Nullable{``0})">
 <summary>Converts the argument to an unsigned 32-bit integer. This is a direct conversion for all 
 primitive numeric types. The operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted unsigned integer</returns>
 
 <example id="uint-1">
 <code lang="fsharp">
 open System
 open FSharp.Linq.NullableOperators

 Nullable.uint (Nullable&lt;int>())  // evaluates to Nullable&lt;uint>()
 Nullable.uint (Nullable&lt;int>(3))  // evaluates to Nullable(3u)
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToInt``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32},System.Nullable{``0})">
 <summary>Converts the argument to signed 32-bit integer. This is a direct conversion for all 
 primitive numeric types. The operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted int</returns>
 
 <example id="int-1">
 <code lang="fsharp">
 open System
 open FSharp.Linq.NullableOperators

 Nullable.int (Nullable&lt;int64>())  // evaluates to Nullable&lt;int>()
 Nullable.int (Nullable&lt;int64>(3))  // evaluates to Nullable(3)
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToUInt16``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.UInt16},System.Nullable{``0})">
 <summary>Converts the argument to unsigned 16-bit integer. This is a direct conversion for all 
 primitive numeric types. The operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted uint16</returns>
 
 <example id="uint16-1">
 <code lang="fsharp">
 open System
 open FSharp.Linq.NullableOperators

 Nullable.uint16 (Nullable&lt;int>())  // evaluates to Nullable&lt;uint16>()
 Nullable.uint16 (Nullable&lt;int>(3))  // evaluates to Nullable(3us)
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToInt16``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Int16},System.Nullable{``0})">
 <summary>Converts the argument to signed 16-bit integer. This is a direct conversion for all 
 primitive numeric types. The operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted int16</returns>
 
 <example id="int16-1">
 <code lang="fsharp">
 open System
 open FSharp.Linq.NullableOperators

 Nullable.int16 (Nullable&lt;int>())  // evaluates to Nullable&lt;int16>()
 Nullable.int16 (Nullable&lt;int>(3))  // evaluates to Nullable(3s)
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToInt8``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.SByte},System.Nullable{``0})">
 <summary>Converts the argument to signed byte. This is a direct conversion for all 
 primitive numeric types. The operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted sbyte</returns>
 
 <example id="int8-1">
 <code lang="fsharp">
 open System
 open FSharp.Linq.NullableOperators

 Nullable.int8 (Nullable&lt;int>())  // evaluates to Nullable&lt;sbyte>()
 Nullable.int8 (Nullable&lt;int>(3))  // evaluates to Nullable(3y)
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToSByte``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.SByte},System.Nullable{``0})">
 <summary>Converts the argument to signed byte. This is a direct conversion for all 
 primitive numeric types. The operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted sbyte</returns>
 
 <example id="sbyte-1">
 <code lang="fsharp">
 open System
 open FSharp.Linq.NullableOperators

 Nullable.sbyte (Nullable&lt;int>())  // evaluates to Nullable&lt;sbyte>()
 Nullable.sbyte (Nullable&lt;int>(3))  // evaluates to Nullable(3y)
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToUInt8``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Byte},System.Nullable{``0})">
 <summary>Converts the argument to byte. This is a direct conversion for all 
 primitive numeric types. The operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted byte</returns>
 
 <example id="uint8-1">
 <code lang="fsharp">
 open System
 open FSharp.Linq.NullableOperators

 Nullable.uint8 (Nullable&lt;int>())  // evaluates to Nullable&lt;byte>()
 Nullable.uint8 (Nullable&lt;int>(3))  // evaluates to Nullable(3uy)
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableModule.ToByte``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Byte},System.Nullable{``0})">
 <summary>Converts the argument to byte. This is a direct conversion for all 
 primitive numeric types. The operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted byte</returns>
 
 <example id="byte-1">
 <code lang="fsharp">
 open System
 open FSharp.Linq.NullableOperators

 Nullable.byte (Nullable&lt;int>())  // evaluates to Nullable&lt;byte>()
 Nullable.byte (Nullable&lt;int>(3))  // evaluates to Nullable(3uy)
 </code>
 </example>

</member>
<member name="T:Microsoft.FSharp.Linq.NullableModule">
<summary>
 Functions for converting nullable values
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkDivideQmark``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Nullable{``0},System.Nullable{``1})">
 <summary>The division operator where a nullable value appears on both left and right sides</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example>See the other operators in this module for related examples.</example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_DivideQmark``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,System.Nullable{``1})">
 <summary>The division operator where a nullable value appears on the right</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example>See the other operators in this module for related examples.</example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkDivide``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Nullable{``0},``1)">
 <summary>The division operator where a nullable value appears on the left</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example>See the other operators in this module for related examples.</example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkPercentQmark``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Nullable{``0},System.Nullable{``1})">
 <summary>The modulus operator where a nullable value appears on both left and right sides</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example>See the other operators in this module for related examples.</example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_PercentQmark``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,System.Nullable{``1})">
 <summary>The modulus operator where a nullable value appears on the right</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example>See the other operators in this module for related examples.</example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkPercent``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Nullable{``0},``1)">
 <summary>The modulus operator where a nullable value appears on the left</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example>See the other operators in this module for related examples.</example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkMultiplyQmark``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Nullable{``0},System.Nullable{``1})">
 <summary>The multiplication operator where a nullable value appears on both left and right sides</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example>See the other operators in this module for related examples.</example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_MultiplyQmark``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,System.Nullable{``1})">
 <summary>The multiplication operator where a nullable value appears on the right</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example>See the other operators in this module for related examples.</example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkMultiply``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Nullable{``0},``1)">
 <summary>The multiplication operator where a nullable value appears on the left</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example>See the other operators in this module for related examples.</example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkMinusQmark``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Nullable{``0},System.Nullable{``1})">
 <summary>The subtraction operator where a nullable value appears on both left and right sides</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example>See the other operators in this module for related examples.</example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_MinusQmark``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,System.Nullable{``1})">
 <summary>The subtraction operator where a nullable value appears on the right</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example>See the other operators in this module for related examples.</example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkMinus``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Nullable{``0},``1)">
 <summary>The subtraction operator where a nullable value appears on the left</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example>See the other operators in this module for related examples.</example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkPlusQmark``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Nullable{``0},System.Nullable{``1})">
 <summary>The addition operator where a nullable value appears on both left and right sides</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example>See the other operators in this module for related examples.</example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_PlusQmark``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,System.Nullable{``1})">
 <summary>The addition operator where a nullable value appears on the right</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example>See the other operators in this module for related examples.</example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkPlus``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Nullable{``0},``1)">
 <summary>The addition operator where a nullable value appears on the left</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example>See the other operators in this module for related examples.</example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkLessGreaterQmark``1(System.Nullable{``0},System.Nullable{``0})">
 <summary>The '&lt;>' operator where a nullable value appears on both left and right sides</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example>See the other operators in this module for related examples.</example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkEqualsQmark``1(System.Nullable{``0},System.Nullable{``0})">
 <summary>The '=' operator where a nullable value appears on both left and right sides</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example>See the other operators in this module for related examples.</example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkLessQmark``1(System.Nullable{``0},System.Nullable{``0})">
 <summary>The '&lt;' operator where a nullable value appears on both left and right sides</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example>See the other operators in this module for related examples.</example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkLessEqualsQmark``1(System.Nullable{``0},System.Nullable{``0})">
 <summary>The '&lt;=' operator where a nullable value appears on both left and right sides</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example>See the other operators in this module for related examples.</example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkGreaterQmark``1(System.Nullable{``0},System.Nullable{``0})">
 <summary>The '&gt;' operator where a nullable value appears on both left and right sides</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example>See the other operators in this module for related examples.</example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkGreaterEqualsQmark``1(System.Nullable{``0},System.Nullable{``0})">
 <summary>The '&gt;=' operator where a nullable value appears on both left and right sides</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example>See the other operators in this module for related examples.</example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_LessGreaterQmark``1(``0,System.Nullable{``0})">
 <summary>The '&lt;>' operator where a nullable value appears on the right</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example>See the other operators in this module for related examples.</example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_EqualsQmark``1(``0,System.Nullable{``0})">
 <summary>The '=' operator where a nullable value appears on the right</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example>See the other operators in this module for related examples.</example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_LessQmark``1(``0,System.Nullable{``0})">
 <summary>The '&lt;' operator where a nullable value appears on the right</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example>See the other operators in this module for related examples.</example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_LessEqualsQmark``1(``0,System.Nullable{``0})">
 <summary>The '&lt;=' operator where a nullable value appears on the right</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example>See the other operators in this module for related examples.</example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_GreaterQmark``1(``0,System.Nullable{``0})">
 <summary>The '&gt;' operator where a nullable value appears on the right</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example>See the other operators in this module for related examples.</example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_GreaterEqualsQmark``1(``0,System.Nullable{``0})">
 <summary>The '&gt;=' operator where a nullable value appears on the right</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example>See the other operators in this module for related examples.</example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkLessGreater``1(System.Nullable{``0},``0)">
 <summary>The '&lt;>' operator where a nullable value appears on the left</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example id="nneq-1">
 <code lang="fsharp">
 open FSharp.Linq.NullableOperators

 Nullable(3) ?&lt;>= 4 // true
 Nullable(4) ?&lt;>= 4 // false
 Nullable() ?&lt;> 4 // true
 </code>
 </example>

</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkEquals``1(System.Nullable{``0},``0)">
 <summary>The '=' operator where a nullable value appears on the left</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example id="neq-1">
 <code lang="fsharp">
 open FSharp.Linq.NullableOperators

 Nullable(3) ?= 4 // false
 Nullable(4) ?= 4 // true
 Nullable() ?= 4 // false
 </code>
 </example>

</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkLess``1(System.Nullable{``0},``0)">
 <summary>The '&lt;' operator where a nullable value appears on the left</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example id="nlt-1">
 <code lang="fsharp">
 open FSharp.Linq.NullableOperators

 Nullable(3) ?&lt; 4 // true
 Nullable(4) ?&lt; 4 // false
 Nullable() ?&lt; 4 // false
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkLessEquals``1(System.Nullable{``0},``0)">
 <summary>The '&lt;=' operator where a nullable value appears on the left</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example id="nlte-1">
 <code lang="fsharp">
 open FSharp.Linq.NullableOperators

 Nullable(3) ?&lt;= 4 // true
 Nullable(5) ?&lt;= 4 // false
 Nullable() ?&lt;= 4 // false
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkGreater``1(System.Nullable{``0},``0)">
 <summary>The '&gt;' operator where a nullable value appears on the left</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example id="ngt-1">
 <code lang="fsharp">
 open FSharp.Linq.NullableOperators

 Nullable(3) ?> 4 // false
 Nullable(5) ?> 4 // true
 Nullable() ?> 4 // false
 </code>
 </example>

</member>
<member name="M:Microsoft.FSharp.Linq.NullableOperators.op_QmarkGreaterEquals``1(System.Nullable{``0},``0)">
 <summary>The '&gt;=' operator where a nullable value appears on the left</summary>
 
 <remarks>This operator is primarily for use in F# queries</remarks>

 <example id="nge-1">
 <code lang="fsharp">
 open FSharp.Linq.NullableOperators

 Nullable(3) ?>= 4 // false
 Nullable(4) ?>= 4 // true
 Nullable() ?>= 4 // false
 </code>
 </example>

</member>
<member name="T:Microsoft.FSharp.Linq.NullableOperators">
<summary>
 Operators for working with nullable values, primarily used on F# queries.
</summary>
</member>
<member name="T:Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`8">
 <summary>This type shouldn't be used directly from user code.</summary>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`7">
 <summary>This type shouldn't be used directly from user code.</summary>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`6">
 <summary>This type shouldn't be used directly from user code.</summary>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`5">
 <summary>This type shouldn't be used directly from user code.</summary>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`4">
 <summary>This type shouldn't be used directly from user code.</summary>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`3">
 <summary>This type shouldn't be used directly from user code.</summary>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`2">
 <summary>This type shouldn't be used directly from user code.</summary>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Linq.RuntimeHelpers.AnonymousObject`1">
 <summary>This type shouldn't be used directly from user code.</summary>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Linq.RuntimeHelpers.Grouping`2">
<summary>
 A type used to reconstruct a grouping after applying a mutable-&gt;immutable mapping transformation
 on a result of a query.
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.LeafExpressionConverter.SubstHelperRaw(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpVar[],System.Object[])">
 <summary>
 A runtime helper used to evaluate nested quotation literals.
 </summary>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.LeafExpressionConverter.SubstHelper``1(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpVar[],System.Object[])">
 <summary>
 A runtime helper used to evaluate nested quotation literals.
 </summary>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.LeafExpressionConverter.EvaluateQuotation(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>
 Evaluates a subset of F# quotations by first converting to a LINQ expression, for the subset of LINQ expressions represented by the
 expression syntax in the C# language.
 </summary>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.LeafExpressionConverter.QuotationToLambdaExpression``1(Microsoft.FSharp.Quotations.FSharpExpr{``0})">
 <summary>
 Converts a subset of F# quotations to a LINQ expression, for the subset of LINQ expressions represented by the
 expression syntax in the C# language.
 </summary>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.LeafExpressionConverter.QuotationToExpression(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>
 Converts a subset of F# quotations to a LINQ expression, for the subset of LINQ expressions represented by the
 expression syntax in the C# language.
 </summary>

 <example-tbd></example-tbd>
</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.LeafExpressionConverter.NewAnonymousObjectHelper``1(``0)">
 <summary>
 When used in a quotation, this function indicates a specific conversion
 should be performed when converting the quotation to a LINQ expression.

 This function should not be called directly.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.LeafExpressionConverter.MemberInitializationHelper``1(``0)">
 <summary>
 When used in a quotation, this function indicates a specific conversion
 should be performed when converting the quotation to a LINQ expression.

 This function should not be called directly.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.LeafExpressionConverter.ImplicitExpressionConversionHelper``1(``0)">
 <summary>
 When used in a quotation, this function indicates a specific conversion
 should be performed when converting the quotation to a LINQ expression.

 This function should not be called directly.
 </summary>
</member>
<member name="T:Microsoft.FSharp.Linq.RuntimeHelpers.LeafExpressionConverter">
 <summary>
 Contains functionality to convert F# quotations to LINQ expression trees.
 </summary>

 <namespacedoc><summary>
   Library functionality associated with converting F# quotations to .NET LINQ expression trees.
 </summary></namespacedoc>
</member>
<member name="T:Microsoft.FSharp.Linq.RuntimeHelpers.Adapters.ConversionDescription">
<summary>
 The generic MethodInfo for Select function
 Describes how we got from productions of immutable objects to productions of anonymous objects, with enough information
 that we can invert the process in final query results.
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.Adapters.ProduceMoreMutables(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Quotations.FSharpExpr,System.Tuple{Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Linq.RuntimeHelpers.Adapters.ConversionDescription}},Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Given the expression part of a &quot;yield&quot; or &quot;select&quot; which produces a result in terms of immutable tuples or immutable records,
 generate an equivalent expression yielding anonymous objects. Also return the conversion for the immutable-to-mutable correspondence
 so we can reverse this later.
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.Adapters.SimplifyConsumingExpr(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Simplify gets of tuples and gets of record fields.
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.Adapters.CleanupLeaf(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Cleanup the use of property-set object constructions in leaf expressions that form parts of F# queries.
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.Adapters.ConvImmutableTypeToMutableType(Microsoft.FSharp.Linq.RuntimeHelpers.Adapters.ConversionDescription,System.Type)">
<summary>
 Given an type involving immutable tuples and records, logically corresponding to the type produced at a
 &quot;yield&quot; or &quot;select&quot;, convert it to a type involving anonymous objects according to the conversion data.
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.Adapters.|NewAnonymousObject|_|(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Recognize anonymous type construction written using &apos;new AnonymousObject(&lt;e1&gt;, &lt;e2&gt;, ...)&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.Adapters.|ObjectConstruction|_|(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Recognize object construction written using &apos;new O(Prop1 = &lt;e&gt;, Prop2 = &lt;e&gt;, ...)&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.Adapters.|PropSetList|_|(Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
<summary>
 Tests whether a list consists only of assignments of properties of the
 given variable, null values (ignored) and ends by returning the given variable
 (pattern returns only property assignments)
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.RuntimeHelpers.Adapters.|LeftSequentialSeries|(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Recognize sequential series written as (... ((&lt;e&gt;; &lt;e&gt;); &lt;e&gt;); ...)
</summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryRunExtensions.HighPriority.RunQueryAsEnumerable``1(Microsoft.FSharp.Linq.QueryBuilder,Microsoft.FSharp.Quotations.FSharpExpr{Microsoft.FSharp.Linq.QuerySource{``0,System.Collections.IEnumerable}})">
 <summary>
 A method used to support the F# query syntax.  Runs the given quotation as a query using LINQ IEnumerable rules.
 </summary>
</member>
<member name="T:Microsoft.FSharp.Linq.QueryRunExtensions.HighPriority">
 <summary>
 A module used to support the F# query syntax.  
 </summary>
</member>
<member name="M:Microsoft.FSharp.Linq.QueryRunExtensions.LowPriority.RunQueryAsValue``1(Microsoft.FSharp.Linq.QueryBuilder,Microsoft.FSharp.Quotations.FSharpExpr{``0})">
 <summary>
 A method used to support the F# query syntax.  Runs the given quotation as a query using LINQ rules.
 </summary>
</member>
<member name="T:Microsoft.FSharp.Linq.QueryRunExtensions.LowPriority">
 <summary>
 A module used to support the F# query syntax.  
 </summary>

 <namespacedoc><summary>
    Contains modules used to support the F# query syntax.  
 </summary></namespacedoc>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.H">
<summary>
 A synonym for henry, the SI unit of inductance
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.kat">
<summary>
 A synonym for katal, the SI unit of catalytic activity
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.Sv">
<summary>
 A synonym for sievert, the SI unit of does equivalent
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.Gy">
<summary>
 A synonym for gray, the SI unit of absorbed dose
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.Bq">
<summary>
 A synonym for becquerel, the SI unit of activity referred to a radionuclide
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.lx">
<summary>
 A synonym for lux, the SI unit of illuminance
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.lm">
<summary>
 A synonym for lumen, the SI unit of luminous flux
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.T">
<summary>
 A synonym for tesla, the SI unit of magnetic flux density
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.Wb">
<summary>
 A synonym for weber, the SI unit of magnetic flux
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.ohm">
<summary>
 A synonym for UnitNames.ohm, the SI unit of electric resistance.
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.S">
<summary>
 A synonym for siemens, the SI unit of electric conductance
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.F">
<summary>
 A synonym for farad, the SI unit of capacitance
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.V">
<summary>
 A synonym for volt, the SI unit of electric potential difference, electromotive force
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.C">
<summary>
 A synonym for coulomb, the SI unit of electric charge, amount of electricity
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.W">
<summary>
 A synonym for watt, the SI unit of power, radiant flux
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.J">
<summary>
 A synonym for joule, the SI unit of energy, work, amount of heat
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.Pa">
<summary>
 A synonym for pascal, the SI unit of pressure, stress
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.N">
<summary>
 A synonym for newton, the SI unit of force
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.Hz">
<summary>
 A synonym for hertz, the SI unit of frequency
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.cd">
<summary>
 A synonym for candela, the SI unit of luminous intensity
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.mol">
<summary>
 A synonym for mole, the SI unit of amount of substance
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.K">
<summary>
 A synonym for kelvin, the SI unit of thermodynamic temperature
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.A">
<summary>
 A synonym for ampere, the SI unit of electric current
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.s">
<summary>
 A synonym for second, the SI unit of time
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.kg">
<summary>
 A synonym for kilogram, the SI unit of mass
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.m">
<summary>
 A synonym for Metre, the SI unit of length
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.katal">
<summary>
 The SI unit of catalytic activity
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.sievert">
<summary>
 The SI unit of does equivalent
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.gray">
<summary>
 The SI unit of absorbed dose
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.becquerel">
<summary>
 The SI unit of activity referred to a radionuclide
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.lux">
<summary>
 The SI unit of illuminance
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.lumen">
<summary>
 The SI unit of luminous flux
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.henry">
<summary>
 The SI unit of inductance
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.tesla">
<summary>
 The SI unit of magnetic flux density
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.weber">
<summary>
 The SI unit of magnetic flux
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.siemens">
<summary>
 The SI unit of electric conductance
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.ohm">
<summary>
 The SI unit of electric resistance
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.farad">
<summary>
 The SI unit of capacitance
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.volt">
<summary>
 The SI unit of electric potential difference, electromotive force
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.coulomb">
<summary>
 The SI unit of electric charge, amount of electricity
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.watt">
<summary>
 The SI unit of power, radiant flux
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.joule">
<summary>
 The SI unit of energy, work, amount of heat
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.pascal">
<summary>
 The SI unit of pressure, stress
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.newton">
<summary>
 The SI unit of force
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.hertz">
<summary>
 The SI unit of frequency
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.candela">
<summary>
 The SI unit of luminous intensity
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.mole">
<summary>
 The SI unit of amount of substance
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.kelvin">
<summary>
 The SI unit of thermodynamic temperature
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.ampere">
<summary>
 The SI unit of electric current
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.second">
<summary>
 The SI unit of time
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.kilogram">
<summary>
 The SI unit of mass
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.meter">
<summary>
 The SI unit of length
</summary>
</member>
<member name="T:Microsoft.FSharp.Data.UnitSystems.SI.UnitNames.metre">
<summary>
 The SI unit of length
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.ilsigptr`1">
 <summary>Represents an Common IL (Intermediate Language) Signature Pointer.</summary>

 <remarks>This type should only be used when writing F# code that interoperates
 with other .NET languages that use generic Common IL Signature Pointers.
 Use of this type in F# code may result in unverifiable code being generated.
 Because of the rules of Common IL Signature Pointers, you cannot use this type in generic type parameters,
 resulting in compiler errors. As a result, you should convert this type to <see cref="T:Microsoft.FSharp.Core.nativeptr{T}" />
 for use in F#. Note that Common IL Signature Pointers exposed by other .NET languages are converted to
 <see cref="T:Microsoft.FSharp.Core.nativeptr{T}" /> or <see cref="T:Microsoft.FSharp.Core.voidptr" /> automatically by F#,
 and F# also shows generic-specialized typed native pointers correctly to other .NET languages as Common IL Signature Pointers.
 However, generic typed native pointers are shown as <see cref="T:System.IntPtr"/> to other .NET languages.
 For other languages to interpret generic F# typed native pointers correctly, you should expose this type or
 <see cref="T:Microsoft.FSharp.Core.voidptr" /> instead of <see cref="T:Microsoft.FSharp.Core.nativeptr{T}" />.
 Values of this type can be generated by the functions in the <c>NativeInterop.NativePtr</c> module.</remarks>

 <category>ByRef and Pointer Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.voidptr">
 <summary>Represents an untyped unmanaged pointer in F# code.</summary>

 <remarks>This type should only be used when writing F# code that interoperates
 with native code. Use of this type in F# code may result in
 unverifiable code being generated. Conversions to and from the 
 <see cref="T:Microsoft.FSharp.Core.nativeint" /> type may be required. Values of this type can be generated
 by the functions in the <c>NativeInterop.NativePtr</c> module.</remarks>

 <category>ByRef and Pointer Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.nativeptr`1">
 <summary>Represents an unmanaged pointer in F# code.</summary>

 <remarks>This type should only be used when writing F# code that interoperates
 with native code. Use of this type in F# code may result in
 unverifiable code being generated. Conversions to and from the 
 <see cref="T:Microsoft.FSharp.Core.nativeint" /> type may be required. Values of this type can be generated
 by the functions in the <c>NativeInterop.NativePtr</c> module.</remarks>

 <category>ByRef and Pointer Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.array`1">
 <summary>Single dimensional, zero-based arrays, written <c>int[]</c>, <c>string[]</c> etc.</summary>
 
 <remarks>Use the values in the <see cref="T:Microsoft.FSharp.Collections.ArrayModule" /> module to manipulate values 
 of this type, or the notation <c>arr.[x]</c> to get/set array
 values.</remarks>   

 <category>Basic Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,]`1">
 <summary>Thirty-two dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,]`1">
 <summary>Thirty-one dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,]`1">
 <summary>Thirty dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,,,,,,,,,,,,,,,,,,,,,,,,,]`1">
 <summary>Twenty-nine dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,,,,,,,,,,,,,,,,,,,,,,,,]`1">
 <summary>Twenty-eight dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,,,,,,,,,,,,,,,,,,,,,,,]`1">
 <summary>Twenty-seven dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,,,,,,,,,,,,,,,,,,,,,,]`1">
 <summary>Twenty-six dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,,,,,,,,,,,,,,,,,,,,,]`1">
 <summary>Twenty-five dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,,,,,,,,,,,,,,,,,,,,]`1">
 <summary>Twenty-four dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,,,,,,,,,,,,,,,,,,,]`1">
 <summary>Twenty-three dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,,,,,,,,,,,,,,,,,,]`1">
 <summary>Twenty-two dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,,,,,,,,,,,,,,,,,]`1">
 <summary>Twenty-one dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,,,,,,,,,,,,,,,,]`1">
 <summary>Twenty dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,,,,,,,,,,,,,,,]`1">
 <summary>Nineteen dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,,,,,,,,,,,,,,]`1">
 <summary>Eighteen dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,,,,,,,,,,,,,]`1">
 <summary>Seventeen dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,,,,,,,,,,,,]`1">
 <summary>Sixteen dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,,,,,,,,,,,]`1">
 <summary>Fifteen dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,,,,,,,,,,]`1">
 <summary>Fourteen dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,,,,,,,,,]`1">
 <summary>Thirteen dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,,,,,,,,]`1">
 <summary>Twelve dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,,,,,,,]`1">
 <summary>Eleven dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,,,,,,]`1">
 <summary>Ten dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,,,,,]`1">
 <summary>Nine dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,,,,]`1">
 <summary>Eight dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,,,]`1">
 <summary>Seven dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,,]`1">
 <summary>Six dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,,]`1">
 <summary>Five dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,,]`1">
 <summary>Four dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <remarks>Use the values in the <c>Array4D</c> module
 to manipulate values of this type, or the notation <c>arr.[x1,x2,x3,x4]</c> to get and set array
 values.</remarks>  

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,,]`1">
 <summary>Three dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.</summary>

 <remarks>Use the values in the <c>Array3D</c> module
 to manipulate values of this type, or the notation <c>arr.[x1,x2,x3]</c> to get and set array
 values.</remarks>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[,]`1">
 <summary>Two dimensional arrays, typically zero-based.</summary> 

 <remarks>Use the values in the <c>Array2D</c> module
 to manipulate values of this type, or the notation <c>arr.[x,y]</c> to get/set array
 values.   

 Non-zero-based arrays can also be created using methods on the System.Array type.</remarks>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.[]`1">
 <summary>Single dimensional, zero-based arrays, written <c>int[]</c>, <c>string[]</c> etc.</summary>

 <remarks>Use the values in the <c>Array</c> module to manipulate values 
 of this type, or the notation <c>arr.[x]</c> to get/set array
 values.</remarks>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.uint">
 <summary>An abbreviation for the CLI type <see cref="T:System.UInt32"/>.</summary>

 <category>Basic Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.int">
 <summary>An abbreviation for the CLI type <see cref="T:System.Int32"/>.</summary>

 <category>Basic Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.decimal">
 <summary>An abbreviation for the CLI type <see cref="T:System.Decimal"/>.</summary>

 <category>Basic Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.bool">
 <summary>An abbreviation for the CLI type <see cref="T:System.Boolean"/>.</summary>

 <category>Basic Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.char">
 <summary>An abbreviation for the CLI type <see cref="T:System.Char"/>.</summary>

 <category>Basic Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.uint64">
 <summary>An abbreviation for the CLI type <see cref="T:System.UInt64"/>.</summary>

 <category>Basic Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.int64">
 <summary>An abbreviation for the CLI type <see cref="T:System.Int64"/>.</summary>

 <category>Basic Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.uint32">
 <summary>An abbreviation for the CLI type <see cref="T:System.UInt32"/>.</summary>

 <category>Basic Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.int32">
 <summary>An abbreviation for the CLI type <see cref="T:System.Int32"/>.</summary>

 <category>Basic Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.uint16">
 <summary>An abbreviation for the CLI type <see cref="T:System.UInt16"/>.</summary>

 <category>Basic Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.int16">
 <summary>An abbreviation for the CLI type <see cref="T:System.Int16"/>.</summary>

 <category>Basic Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.uint8">
 <summary>An abbreviation for the CLI type <see cref="T:System.Byte"/>.</summary>

 <category>Basic Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.int8">
 <summary>An abbreviation for the CLI type <see cref="T:System.SByte"/>.</summary>

 <category>Basic Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.byte">
 <summary>An abbreviation for the CLI type <see cref="T:System.Byte"/>.</summary>

 <category>Basic Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.sbyte">
 <summary>An abbreviation for the CLI type <see cref="T:System.SByte"/>.</summary>

 <category>Basic Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.double">
 <summary>An abbreviation for the CLI type <see cref="T:System.Double"/>. Identical to <see cref="T:Microsoft.FSharp.Core.float"/>.</summary>

 <category>Basic Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.single">
 <summary>An abbreviation for the CLI type <see cref="T:System.Single"/>. Identical to <see cref="T:Microsoft.FSharp.Core.float32"/>.</summary>

 <category>Basic Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.float">
 <summary>An abbreviation for the CLI type <see cref="T:System.Double"/>.</summary>

 <category>Basic Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.float32">
 <summary>An abbreviation for the CLI type <see cref="T:System.Single"/>.</summary>

 <category>Basic Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.string">
 <summary>An abbreviation for the CLI type <see cref="T:System.String"/>.</summary>

 <category>Basic Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.unativeint">
 <summary>An abbreviation for the CLI type <see cref="T:System.UIntPtr"/>.</summary>

 <category>Basic Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.nativeint">
 <summary>An abbreviation for the CLI type <see cref="T:System.IntPtr"/>.</summary>

 <category>Basic Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.exn">
 <summary>An abbreviation for the CLI type <see cref="T:System.Exception"/>.</summary>

 <category>Basic Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.obj">
 <summary>An abbreviation for the CLI type <see cref="T:System.Object"/>.</summary>

 <category>Basic Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpResult`2.Error">
<summary>
 Represents an Error or a Failure. The code failed with a value of &apos;TError representing what went wrong.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpResult`2.Ok">
<summary>
 Represents an OK or a Successful result. The code succeeded with a value of &apos;T.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpResult`2">
 <summary>Helper type for error handling without exceptions.</summary>

 <category>Choices and Results</category>
</member>
<member name="T:Microsoft.FSharp.Core.voption`1">
 <summary>The type of optional values, represented as structs.</summary>

 <remarks>Use the constructors <c>ValueSome</c> and <c>ValueNone</c> to create values of this type.
 Use the values in the <c>ValueOption</c> module to manipulate values of this type,
 or pattern match against the values directly.</remarks>

 <category>Options</category>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpValueOption`1.ValueSome">
 <summary>The representation of "Value of type 'T"</summary>

 <param name="Item">The input value.</param>

 <returns>An option representing the value.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpValueOption`1.ValueNone">
 <summary>The representation of "No value"</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpValueOption`1.op_Implicit(`0)">
 <summary>Implicitly converts a value into an optional that is a 'ValueSome' value.</summary>

 <param name="value">The input value</param>

 <remarks>The F# compiler ignored this method when determining possible type-directed conversions. Instead, use <c>Some</c> or <c>None</c> explicitly.</remarks>

 <returns>A voption representing the value.</returns>
 <exclude />
</member>
<member name="P:Microsoft.FSharp.Core.FSharpValueOption`1.Value">
 <summary>Get the value of a 'ValueSome' option. An InvalidOperationException is raised if the option is 'ValueNone'.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpValueOption`1.None">
 <summary>Create a value option value that is a 'ValueNone' value.</summary>
 <exclude />
</member>
<member name="P:Microsoft.FSharp.Core.FSharpValueOption`1.IsSome">
 <summary>Return 'true' if the value option is a 'ValueSome' value.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpValueOption`1.IsNone">
 <summary>Return 'true' if the value option is a 'ValueNone' value.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpValueOption`1.Some(`0)">
 <summary>Create a value option value that is a 'Some' value.</summary>

 <param name="value">The input value</param>

 <returns>A value option representing the value.</returns>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.FSharpValueOption`1">
 <summary>The type of optional values, represented as structs.</summary>

 <remarks>Use the constructors <c>ValueSome</c> and <c>ValueNone</c> to create values of this type.
 Use the values in the <c>ValueOption</c> module to manipulate values of this type,
 or pattern match against the values directly.</remarks>

 <category>Options</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.option`1">
 <summary>The type of optional values. When used from other CLI languages the
 empty option is the <c>null</c> value. </summary>

 <remarks>Use the constructors <c>Some</c> and <c>None</c> to create values of this type.
 Use the values in the <c>Option</c> module to manipulate values of this type,
 or pattern match against the values directly.

 'None' values will appear as the value <c>null</c> to other CLI languages.
 Instance methods on this type will appear as static methods to other CLI languages
 due to the use of <c>null</c> as a value representation.</remarks>

 <category index="3">Options</category>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpOption`1.Some">
 <summary>The representation of "Value of type 'T"</summary>

 <param name="Value">The input value.</param>

 <returns>An option representing the value.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpOption`1.None">
 <summary>The representation of "No value"</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpOption`1.op_Implicit(`0)">
 <summary>Implicitly converts a value into an optional that is a 'Some' value.</summary>

 <param name="value">The input value</param>

 <remarks>The F# compiler ignored this method when determining possible type-directed conversions. Instead, use <c>Some</c> or <c>None</c> explicitly.</remarks>

 <returns>An option representing the value.</returns>
 <exclude />
</member>
<member name="P:Microsoft.FSharp.Core.FSharpOption`1.Value">
 <summary>Get the value of a 'Some' option. A NullReferenceException is raised if the option is 'None'.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpOption`1.None">
 <summary>Create an option value that is a 'None' value.</summary>
 <exclude />
</member>
<member name="P:Microsoft.FSharp.Core.FSharpOption`1.IsSome">
 <summary>Return 'true' if the option is a 'Some' value.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpOption`1.IsNone">
 <summary>Return 'true' if the option is a 'None' value.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpOption`1.Some(`0)">
 <summary>Create an option value that is a 'Some' value.</summary>

 <param name="value">The input value</param>

 <returns>An option representing the value.</returns>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.FSharpOption`1">
 <summary>The type of optional values. When used from other CLI languages the
 empty option is the <c>null</c> value. </summary>

 <remarks>Use the constructors <c>Some</c> and <c>None</c> to create values of this type.
 Use the values in the <c>Option</c> module to manipulate values of this type,
 or pattern match against the values directly.

 <c>None</c> values will appear as the value <c>null</c> to other CLI languages.
 Instance methods on this type will appear as static methods to other CLI languages
 due to the use of <c>null</c> as a value representation.</remarks>

 <category>Options</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.ref`1">
 <summary>The type of mutable references. Use the functions [!] and [:=] to get and
 set values of this type.</summary>
 <category>Basic Types</category>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpRef`1.contents">
<summary>
 The current value of the reference cell
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpRef`1.Value(`0)">
 <summary>The current value of the reference cell</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpRef`1.Value">
 <summary>The current value of the reference cell</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpRef`1">
 <summary>The type of mutable references. Use the functions [!] and [:=] to get and
 set values of this type.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.ToFSharpFunc``2(System.Converter{``0,``1})">
 <summary>Convert the given Converter delegate object to an F# function value</summary>

 <param name="converter">The input Converter delegate.</param>

 <returns>The F# function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.ToFSharpFunc``1(System.Action{``0})">
 <summary>Convert the given Action delegate object to an F# function value</summary>

 <param name="action">The input Action delegate.</param>

 <returns>The F# function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``6(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1,``2,``3,``4},``5})">
 <summary>A utility function to convert function values from tupled to curried form</summary>

 <param name="func">The input tupled function.</param>

 <returns>The output curried function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``5(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1,``2,``3},``4})">
 <summary>A utility function to convert function values from tupled to curried form</summary>

 <param name="func">The input tupled function.</param>

 <returns>The output curried function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``4(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1,``2},``3})">
 <summary>A utility function to convert function values from tupled to curried form</summary>

 <param name="func">The input tupled function.</param>

 <returns>The output curried function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``3(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},``2})">
 <summary>A utility function to convert function values from tupled to curried form</summary>

 <param name="func">The input tupled function.</param>

 <returns>The output curried function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FromFunc``6(System.Func{``0,``1,``2,``3,``4,``5})">
 <summary>Convert the given Func delegate object to an F# function value</summary>

 <param name="func">The input Func delegate.</param>

 <returns>The F# function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FromFunc``5(System.Func{``0,``1,``2,``3,``4})">
 <summary>Convert the given Func delegate object to an F# function value</summary>

 <param name="func">The input Func delegate.</param>

 <returns>The F# function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FromFunc``4(System.Func{``0,``1,``2,``3})">
 <summary>Convert the given Func delegate object to an F# function value</summary>

 <param name="func">The input Func delegate.</param>

 <returns>The F# function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FromFunc``3(System.Func{``0,``1,``2})">
 <summary>Convert the given Func delegate object to an F# function value</summary>

 <param name="func">The input Func delegate.</param>

 <returns>The F#funcfunction.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FromFunc``2(System.Func{``0,``1})">
 <summary>Convert the given Func delegate object to an F# function value</summary>

 <param name="func">The input Func delegate.</param>

 <returns>The F# function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FromFunc``1(System.Func{``0})">
 <summary>Convert the given Func delegate object to an F# function value</summary>

 <param name="func">The input Func delegate.</param>

 <returns>The F# function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FromAction``5(System.Action{``0,``1,``2,``3,``4})">
 <summary>Convert the given Action delegate object to an F# function value</summary>

 <param name="action">The input Action delegate.</param>

 <returns>The F# function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FromAction``4(System.Action{``0,``1,``2,``3})">
 <summary>Convert the given Action delegate object to an F# function value</summary>

 <param name="action">The input Action delegate.</param>

 <returns>The F# function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FromAction``3(System.Action{``0,``1,``2})">
 <summary>Convert the given Action delegate object to an F# function value</summary>

 <param name="action">The input Action delegate.</param>

 <returns>The F# function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FromAction``2(System.Action{``0,``1})">
 <summary>Convert the given Action delegate object to an F# function value</summary>

 <param name="action">The input Action delegate.</param>

 <returns>The F#funcfunction.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FromAction``1(System.Action{``0})">
 <summary>Convert the given Action delegate object to an F# function value</summary>

 <param name="action">The input Action delegate.</param>

 <returns>The F# function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FromAction(System.Action)">
 <summary>Convert the given Action delegate object to an F# function value</summary>

 <param name="action">The input Action delegate.</param>

 <returns>The F# function.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.FuncConvert">
 <summary>Helper functions for converting F# first class function values to and from CLI representations
 of functions using delegates.</summary>
 <category>Language Primitives</category>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.op_Implicit(System.Converter{`0,`1})">
 <summary>Convert an value of type <see cref="T:System.Converter"/> to a F# first class function value </summary>

 <param name="converter">The input System.Converter.</param>

 <returns>An F# function of the same type.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.op_Implicit(Microsoft.FSharp.Core.FSharpFunc{`0,`1})">
 <summary>Convert an F# first class function value to a value of type <see cref="T:System.Converter"/></summary>

 <param name="func">The input function.</param>

 <returns>A System.Converter of the function type.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.ToConverter(Microsoft.FSharp.Core.FSharpFunc{`0,`1})">
 <summary>Convert an F# first class function value to a value of type <see cref="T:System.Converter"/></summary>

 <param name="func">The input function.</param>

 <returns>System.Converter&lt;'T,'U&gt;</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.InvokeFast``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,``0}},`0,`1)">
 <summary>Invoke an F# first class function value with two curried arguments. In some cases this
 will result in a more efficient application than applying the arguments successively.</summary>

 <param name="func">The input function.</param>
 <param name="arg1">The first arg.</param>
 <param name="arg2">The second arg.</param>

 <returns>The function result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.InvokeFast``2(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}}},`0,`1,``0)">
 <summary>Invoke an F# first class function value with three curried arguments. In some cases this
 will result in a more efficient application than applying the arguments successively.</summary>

 <param name="func">The input function.</param>
 <param name="arg1">The first arg.</param>
 <param name="arg2">The second arg.</param>
 <param name="arg3">The third arg.</param>

 <returns>The function result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.InvokeFast``3(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}}},`0,`1,``0,``1)">
 <summary>Invoke an F# first class function value with four curried arguments. In some cases this
 will result in a more efficient application than applying the arguments successively.</summary>

 <param name="func">The input function.</param>
 <param name="arg1">The first arg.</param>
 <param name="arg2">The second arg.</param>
 <param name="arg3">The third arg.</param>
 <param name="arg4">The fourth arg.</param>

 <returns>The function result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.InvokeFast``4(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}}}},`0,`1,``0,``1,``2)">
 <summary>Invoke an F# first class function value with five curried arguments. In some cases this
 will result in a more efficient application than applying the arguments successively.</summary>

 <param name="func">The input function.</param>
 <param name="arg1">The first arg.</param>
 <param name="arg2">The second arg.</param>
 <param name="arg3">The third arg.</param>
 <param name="arg4">The fourth arg.</param>
 <param name="arg5">The fifth arg.</param>

 <returns>The function result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.Invoke(`0)">
 <summary>Invoke an F# first class function value with one argument</summary>

 <param name="func"></param>

 <returns>'U</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.FromConverter(System.Converter{`0,`1})">
 <summary>Convert an value of type <see cref="T:System.Converter"/> to a F# first class function value </summary>

 <param name="converter">The input System.Converter.</param>

 <returns>An F# function of the same type.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.#ctor">
 <summary>Construct an instance of an F# first class function value </summary> 
 <returns>The created F# function.</returns> 
</member>
<member name="T:Microsoft.FSharp.Core.FSharpFunc`2">
 <summary>The CLI type used to represent F# function values. This type is not
 typically used directly, though may be used from other CLI languages.</summary>
 <category>Language Primitives</category>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpTypeFunc.Specialize``1">
 <summary>Specialize the type function at a given type</summary>
 <returns>The specialized type.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpTypeFunc.#ctor">
 <summary>Construct an instance of an F# first class type function value </summary>
 <returns>FSharpTypeFunc</returns>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpTypeFunc">
 <summary>The CLI type used to represent F# first-class type function values. This type is for use
 by compiled F# code.</summary>
 <category>Language Primitives</category>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`7.Choice7Of7">
 <summary>Choice 7 of 7 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`7.Choice6Of7">
 <summary>Choice 6 of 7 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`7.Choice5Of7">
 <summary>Choice 5 of 7 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`7.Choice4Of7">
 <summary>Choice 4 of 7 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`7.Choice3Of7">
 <summary>Choice 3 of 7 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`7.Choice2Of7">
 <summary>Choice 2 of 7 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`7.Choice1Of7">
 <summary>Choice 1 of 7 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`7">
 <summary>Helper types for active patterns with 7 choices.</summary>
 <category>Choices and Results</category>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`6.Choice6Of6">
 <summary>Choice 6 of 6 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`6.Choice5Of6">
 <summary>Choice 5 of 6 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`6.Choice4Of6">
 <summary>Choice 4 of 6 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`6.Choice3Of6">
 <summary>Choice 3 of 6 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`6.Choice2Of6">
 <summary>Choice 2 of 6 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`6.Choice1Of6">
 <summary>Choice 1 of 6 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`6">
 <summary>Helper types for active patterns with 6 choices.</summary>
 <category>Choices and Results</category>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`5.Choice5Of5">
 <summary>Choice 5 of 5 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`5.Choice4Of5">
 <summary>Choice 4 of 5 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`5.Choice3Of5">
 <summary>Choice 3 of 5 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`5.Choice2Of5">
 <summary>Choice 2 of 5 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`5.Choice1Of5">
 <summary>Choice 1 of 5 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`5">
 <summary>Helper types for active patterns with 5 choices.</summary>
 <category>Choices and Results</category>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`4.Choice4Of4">
 <summary>Choice 4 of 4 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`4.Choice3Of4">
 <summary>Choice 3 of 4 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`4.Choice2Of4">
 <summary>Choice 2 of 4 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`4.Choice1Of4">
 <summary>Choice 1 of 4 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`4">
 <summary>Helper types for active patterns with 4 choices.</summary>
 <category>Choices and Results</category>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`3.Choice3Of3">
 <summary>Choice 3 of 3 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`3.Choice2Of3">
 <summary>Choice 2 of 3 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`3.Choice1Of3">
 <summary>Choice 1 of 3 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`3">
 <summary>Helper types for active patterns with 3 choices.</summary>
 <category>Choices and Results</category>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`2.Choice2Of2">
 <summary>Choice 2 of 2 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`2.Choice1Of2">
 <summary>Choice 1 of 2 choices</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`2">
 <summary>Helper types for active patterns with 2 choices.</summary>
 <category index="5">Choices and Results</category>
</member>
<member name="T:Microsoft.FSharp.Core.outref`1">
 <summary>Represents a out-argument managed pointer in F# code. This type should only be used with F# 4.5+.</summary>
 <category>ByRef and Pointer Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.inref`1">
 <summary>Represents a in-argument or readonly managed pointer in F# code. This type should only be used with F# 4.5+.</summary>
 <category>ByRef and Pointer Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.byref`1">
 <summary>Represents a managed pointer in F# code. For F# 4.5+ this is considered equivalent to <c>byref&lt;'T, ByRefKinds.InOut&gt;</c></summary>
 <category>ByRef and Pointer Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.byref`2">
 <summary>Represents a managed pointer in F# code.</summary>
 <category index="7">ByRef and Pointer Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.uint32`1">
 <summary>The type of 32-bit unsigned integer numbers, annotated with a unit of measure.
 The unit of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to
 <see cref="T:System.UInt32"/>.</summary>

 <category>Basic Types with Units of Measure</category>
</member>
<member name="T:Microsoft.FSharp.Core.uint8`1">
 <summary>The type of 8-bit unsigned integer numbers, annotated with a unit of measure.
 The unit of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to
 <see cref="T:System.Byte"/>.</summary>

 <category>Basic Types with Units of Measure</category>
</member>
<member name="T:Microsoft.FSharp.Core.int32`1">
 <summary>The type of 32-bit signed integer numbers, annotated with a unit of measure.
 The unit of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to
 <see cref="T:System.Int32"/>.</summary>

 <category>Basic Types with Units of Measure</category>
</member>
<member name="T:Microsoft.FSharp.Core.int8`1">
 <summary>The type of 8-bit signed integer numbers, annotated with a unit of measure.
 The unit of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to
 <see cref="T:System.SByte"/>.</summary>

 <category>Basic Types with Units of Measure</category>
</member>
<member name="T:Microsoft.FSharp.Core.single`1">
 <summary>The type of single-precision floating point numbers, annotated with a unit of measure.
 The unit of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to
 <see cref="T:System.Single"/>.</summary>

 <category index="6">Basic Types with Units of Measure</category>
</member>
<member name="T:Microsoft.FSharp.Core.double`1">
 <summary>The type of double-precision floating point numbers, annotated with a unit of measure.
 The unit of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to
 <see cref="T:System.Double"/>.</summary>

 <category index="6">Basic Types with Units of Measure</category>
</member>
<member name="T:Microsoft.FSharp.Core.unativeint`1">
 <summary>The type of machine-sized unsigned integer numbers, annotated with a unit of measure.
 The unit of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to
 <see cref="T:System.UIntPtr"/>.</summary>

 <category>Basic Types with Units of Measure</category>
</member>
<member name="T:Microsoft.FSharp.Core.uint64`1">
 <summary>The type of 64-bit unsigned integer numbers, annotated with a unit of measure.
 The unit of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to
 <see cref="T:System.UInt64"/>.</summary>

 <category>Basic Types with Units of Measure</category>
</member>
<member name="T:Microsoft.FSharp.Core.uint16`1">
 <summary>The type of 16-bit unsigned integer numbers, annotated with a unit of measure.
 The unit of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to
 <see cref="T:System.UInt16"/>.</summary>

 <category>Basic Types with Units of Measure</category>
</member>
<member name="T:Microsoft.FSharp.Core.byte`1">
 <summary>The type of 8-bit unsigned integer numbers, annotated with a unit of measure. 
 The unit of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 <see cref="T:System.Byte"/>.</summary>

 <category>Basic Types with Units of Measure</category>
</member>
<member name="T:Microsoft.FSharp.Core.uint`1">
 <summary>The type of 32-bit unsigned integer numbers, annotated with a unit of measure. 
 The unit of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 <see cref="T:System.UInt32"/>.</summary>

 <category>Basic Types with Units of Measure</category>
</member>
<member name="T:Microsoft.FSharp.Core.nativeint`1">
 <summary>The type of machine-sized signed integer numbers, annotated with a unit of measure. 
 The unit of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 <see cref="T:System.IntPtr"/>.</summary>

 <category>Basic Types with Units of Measure</category>
</member>
<member name="T:Microsoft.FSharp.Core.int64`1">
 <summary>The type of 64-bit signed integer numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to
 <see cref="T:System.Int64"/>.</summary>

 <category>Basic Types with Units of Measure</category>
</member>
<member name="T:Microsoft.FSharp.Core.int16`1">
 <summary>The type of 16-bit signed integer numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to
 <see cref="T:System.Int16"/>.</summary>

 <category>Basic Types with Units of Measure</category>
</member>
<member name="T:Microsoft.FSharp.Core.sbyte`1">
 <summary>The type of 8-bit signed integer numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to
 <see cref="T:System.SByte"/>.</summary>

 <category>Basic Types with Units of Measure</category>
</member>
<member name="T:Microsoft.FSharp.Core.int`1">
 <summary>The type of 32-bit signed integer numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to
 <see cref="T:System.Int32"/>.</summary>

 <category>Basic Types with Units of Measure</category>
</member>
<member name="T:Microsoft.FSharp.Core.decimal`1">
 <summary>The type of decimal numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to
 <see cref="T:System.Decimal"/>.</summary>

 <category>Basic Types with Units of Measure</category>
</member>
<member name="T:Microsoft.FSharp.Core.float32`1">
 <summary>The type of single-precision floating point numbers, annotated with a unit of measure.
 The unit of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to
 <see cref="T:System.Single"/>.
 </summary>

 <category>Basic Types with Units of Measure</category>
</member>
<member name="T:Microsoft.FSharp.Core.float`1">
 <summary>The type of double-precision floating point numbers, annotated with a unit of measure.
 The unit of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to
 <see cref="T:System.Double"/>.</summary>

 <category index="6">Basic Types with Units of Measure</category>
</member>
<member name="M:Microsoft.FSharp.Core.NoCompilerInliningAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>NoCompilerInliningAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.NoCompilerInliningAttribute">
 <summary>Indicates a value or a function that must not be inlined by the F# compiler,
 but may be inlined by the JIT compiler.</summary>

 <category>Attributes</category>
</member>
<member name="P:Microsoft.FSharp.Core.AutoOpenAttribute.Path">
 <summary>Indicates the namespace or module to be automatically opened when an assembly is referenced
 or an enclosing module opened.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.AutoOpenAttribute.#ctor(System.String)">
 <summary>Creates an attribute used to mark a namespace or module path to be 'automatically opened' when an assembly is referenced</summary>

 <param name="path">The namespace or module to be automatically opened when an assembly is referenced
 or an enclosing module opened.</param>

 <returns>AutoOpenAttribute</returns>
</member>
<member name="M:Microsoft.FSharp.Core.AutoOpenAttribute.#ctor">
 <summary>Creates an attribute used to mark a module as 'automatically opened' when the enclosing namespace is opened</summary>
 <returns>AutoOpenAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.AutoOpenAttribute">
 <summary>Indicates a construct is automatically opened when brought into scope through
 an assembly reference or then opening of the containing namespace or module.</summary>

 <remarks>When applied to an assembly, this attribute must be given a string
 argument, and this indicates a valid module or namespace in that assembly. Source
 code files compiled with a reference to this assembly are processed in an environment
 where the given path is automatically opened.

 When applied to a type or module within an assembly, then the attribute must not be given any arguments, and
 the type or module is implicitly opened when its enclosing namespace or module is opened.
 </remarks>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.RequireQualifiedAccessAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>RequireQualifiedAccessAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.RequireQualifiedAccessAttribute">
 <summary>This attribute is used to indicate that references to the elements of a module, record or union 
 type require explicit qualified access.</summary>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.NoDynamicInvocationAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>NoDynamicInvocationAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.NoDynamicInvocationAttribute">
 <summary>This attribute is used to tag values that may not be dynamically invoked at runtime. This is
 typically added to inlined functions whose implementations include unverifiable code. It
 causes the method body emitted for the inlined function to raise an exception if 
 dynamically invoked, rather than including the unverifiable code in the generated
 assembly.</summary>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.UnverifiableAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>UnverifiableAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.UnverifiableAttribute">
 <summary>This attribute is used to tag values whose use will result in the generation
 of unverifiable code. These values are inevitably marked 'inline' to ensure that
 the unverifiable constructs are not present in the actual code for the F# library,
 but are rather copied to the source code of the caller.</summary>

 <category>Attributes</category>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerMessageAttribute.IsHidden(System.Boolean)">
 <summary>Indicates if the construct should always be hidden in an editing environment.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerMessageAttribute.IsError(System.Boolean)">
 <summary>Indicates if the message should indicate a compiler error. Error numbers less than
 10000 are considered reserved for use by the F# compiler and libraries.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerMessageAttribute.MessageNumber">
 <summary>Indicates the number associated with the message.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerMessageAttribute.Message">
 <summary>Indicates the warning message to be emitted when F# source code uses this construct</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerMessageAttribute.IsHidden">
 <summary>Indicates if the construct should always be hidden in an editing environment.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerMessageAttribute.IsError">
 <summary>Indicates if the message should indicate a compiler error. Error numbers less than
 10000 are considered reserved for use by the F# compiler and libraries.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerMessageAttribute.#ctor(System.String,System.Int32)">
 <summary>Creates an instance of the attribute.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerMessageAttribute">
 <summary>Indicates that a message should be emitted when F# source code uses this construct.</summary>

 <category>Attributes</category>
</member>
<member name="P:Microsoft.FSharp.Core.StructuredFormatDisplayAttribute.Value">
 <summary>Indicates the text to display by default when objects of this type are displayed 
 using '%A' printf formatting patterns and other two-dimensional text-based display 
 layouts. </summary>
</member>
<member name="M:Microsoft.FSharp.Core.StructuredFormatDisplayAttribute.#ctor(System.String)">
 <summary>Creates an instance of the attribute</summary>

 <param name="value">Indicates the text to display when using the '%A' printf formatting.</param>

 <returns>StructuredFormatDisplayAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.StructuredFormatDisplayAttribute">
 <summary>This attribute is used to mark how a type is displayed by default when using 
 '%A' printf formatting patterns and other two-dimensional text-based display layouts. 
 In this version of F# valid values are of the form <c>PreText {PropertyName1} PostText {PropertyName2} ... {PropertyNameX} PostText</c>.
 The property names indicate properties to evaluate and to display instead of the object itself. </summary>

 <category>Attributes</category>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationArgumentCountsAttribute.Counts">
 <summary>Indicates the number of arguments in each argument group </summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationArgumentCountsAttribute.#ctor(System.Int32[])">
 <summary>Creates an instance of the attribute</summary>

 <param name="counts">Indicates the number of arguments in each argument group.</param>

 <returns>CompilationArgumentCountsAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilationArgumentCountsAttribute">
 <summary>This attribute is generated automatically by the F# compiler to tag functions and members 
 that accept a partial application of some of their arguments and return a residual function.
 </summary>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.InlineIfLambdaAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>InlineIfLambdaAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.InlineIfLambdaAttribute">
 <summary>Adding this attribute to a parameter of function type indicates that, if the overall function or method is inlined and the parameter is
 determined to be a known lambda, then this function should be statically inlined throughout the body of the function of method.</summary>

 <remarks>If the function parameter is called multiple times in the implementation of the function or method this attribute may cause code explosion and slow compilation times.</remarks>

 <category>Attributes</category>
</member>
<member name="P:Microsoft.FSharp.Core.ExperimentalAttribute.Message">
 <summary>Indicates the warning message to be emitted when F# source code uses this construct</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExperimentalAttribute.#ctor(System.String)">
 <summary>Creates an instance of the attribute</summary>

 <param name="message">The warning message to be emitted when code uses this construct.</param>

 <returns>ExperimentalAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.ExperimentalAttribute">
 <summary>This attribute is used to tag values that are part of an experimental library
 feature.</summary>

 <category>Attributes</category>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationRepresentationAttribute.Flags">
 <summary>Indicates one or more adjustments to the compiled representation of an F# type or member</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationRepresentationAttribute.#ctor(Microsoft.FSharp.Core.CompilationRepresentationFlags)">
 <summary>Creates an instance of the attribute</summary>

 <param name="flags">Indicates adjustments to the compiled representation of the type or member.</param>

 <returns>CompilationRepresentationAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilationRepresentationAttribute">
 <summary>This attribute is used to adjust the runtime representation for a type. 
 For example, it may be used to note that the <c>null</c> representation
 may be used for a type. This affects how some constructs are compiled.
 </summary>

 <category>Attributes</category>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationSourceNameAttribute.SourceName">
 <summary>Indicates the name of the entity in F# source code</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationSourceNameAttribute.#ctor(System.String)">
 <summary>Creates an instance of the attribute</summary>

 <param name="sourceName">The name of the method in source.</param>

 <returns>CompilationSourceNameAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilationSourceNameAttribute">
 <summary>This attribute is inserted automatically by the F# compiler to tag 
 methods which are given the 'CompiledName' attribute.</summary>

 <remarks>This attribute is used by the functions in the 
 FSharp.Reflection namespace to reverse-map compiled constructs to 
 their original forms. It is not intended for use from user code.
 </remarks>

 <category>Attributes</category>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationMappingAttribute.VariantNumber">
 <summary>Indicates the variant number of the entity, if any, in a linear sequence of elements with F# source code</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationMappingAttribute.TypeDefinitions">
 <summary>Indicates the type definitions needed to resolve the source construct</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationMappingAttribute.SourceConstructFlags">
 <summary>Indicates the relationship between the compiled entity and F# source code</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationMappingAttribute.SequenceNumber">
 <summary>Indicates the sequence number of the entity, if any, in a linear sequence of elements with F# source code</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationMappingAttribute.ResourceName">
 <summary>Indicates the resource the source construct relates to</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationMappingAttribute.#ctor(System.String,System.Type[])">
 <summary>Creates an instance of the attribute</summary>

 <param name="typeDefinitions">Indicates the type definitions needed to resolve the source construct.</param>
 <param name="resourceName">The name of the resource needed to resolve the source construct.</param>

 <returns>CompilationMappingAttribute</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationMappingAttribute.#ctor(Microsoft.FSharp.Core.SourceConstructFlags,System.Int32,System.Int32)">
 <summary>Creates an instance of the attribute</summary>

 <param name="sourceConstructFlags">Indicates the type of source construct.</param>
 <param name="variantNumber">Indicates the index in the sequence of variants.</param>
 <param name="sequenceNumber">Indicates the index in the sequence of constructs.</param>

 <returns>CompilationMappingAttribute</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationMappingAttribute.#ctor(Microsoft.FSharp.Core.SourceConstructFlags,System.Int32)">
 <summary>Creates an instance of the attribute</summary>

 <param name="sourceConstructFlags">Indicates the type of source construct.</param>
 <param name="sequenceNumber">Indicates the index in the sequence of constructs.</param>

 <returns>CompilationMappingAttribute</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationMappingAttribute.#ctor(Microsoft.FSharp.Core.SourceConstructFlags)">
 <summary>Creates an instance of the attribute</summary>

 <param name="sourceConstructFlags">Indicates the type of source construct.</param>

 <returns>CompilationMappingAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilationMappingAttribute">
 <summary>This attribute is inserted automatically by the F# compiler to tag types 
 and methods in the generated CLI code with flags indicating the correspondence 
 with original source constructs.</summary>

 <remarks>This attribute is used by the functions in the 
 FSharp.Reflection namespace to reverse-map compiled constructs to 
 their original forms. It is not intended for use from user code.</remarks>

 <category>Attributes</category>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute.Release">
 <summary>The release number of the F# version associated with the attribute</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute.Minor">
 <summary>The minor version number of the F# version associated with the attribute</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute.Major">
 <summary>The major version number of the F# version associated with the attribute</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute.#ctor(System.Int32,System.Int32,System.Int32)">
 <summary>Creates an instance of the attribute</summary>

 <param name="major">The major version number.</param>
 <param name="minor">The minor version number.</param>
 <param name="release">The release number.</param>

 <returns>FSharpInterfaceDataVersionAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute">
 <summary>This attribute is added to generated assemblies to indicate the 
 version of the data schema used to encode additional F#
 specific information in the resource attached to compiled F# libraries.</summary>

 <category>Attributes</category>
</member>
<member name="P:Microsoft.FSharp.Core.AutoSerializableAttribute.Value">
 <summary>The value of the attribute, indicating whether the type is automatically marked serializable or not</summary>
</member>
<member name="M:Microsoft.FSharp.Core.AutoSerializableAttribute.#ctor(System.Boolean)">
 <summary>Creates an instance of the attribute</summary>

 <param name="value">Indicates whether the type should be serializable by default.</param>

 <returns>AutoSerializableAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.AutoSerializableAttribute">
 <summary>Adding this attribute to a type with value 'false' disables the behaviour where F# makes the
 type Serializable by default.</summary>

 <category>Attributes</category>
</member>
<member name="P:Microsoft.FSharp.Core.CompiledNameAttribute.CompiledName">
 <summary>The name of the value as it appears in compiled code</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompiledNameAttribute.#ctor(System.String)">
 <summary>Creates an instance of the attribute</summary>

 <param name="compiledName">The name to use in compiled code.</param>

 <returns>CompiledNameAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompiledNameAttribute">
 <summary>Adding this attribute to a value or function definition in an F# module changes the name used
 for the value in compiled CLI code.</summary>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.GeneralizableValueAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>GeneralizableValueAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.GeneralizableValueAttribute">
 <summary>Adding this attribute to a non-function value with generic parameters indicates that 
 uses of the construct can give rise to generic code through type inference. </summary>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.RequiresExplicitTypeArgumentsAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>RequiresExplicitTypeArgumentsAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.RequiresExplicitTypeArgumentsAttribute">
 <summary>Adding this attribute to a type, value or member requires that 
 uses of the construct must explicitly instantiate any generic type parameters.</summary>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.OptionalArgumentAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>OptionalArgumentAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.OptionalArgumentAttribute">
 <summary>This attribute is added automatically for all optional arguments.</summary>

 <category>Attributes</category>
</member>
<member name="P:Microsoft.FSharp.Core.DefaultValueAttribute.Check">
 <summary>Indicates if a constraint is asserted that the field type supports 'null'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.DefaultValueAttribute.#ctor(System.Boolean)">
 <summary>Creates an instance of the attribute</summary>

 <param name="check">Indicates whether to assert that the field type supports <c>null</c>.</param>

 <returns>DefaultValueAttribute</returns>
</member>
<member name="M:Microsoft.FSharp.Core.DefaultValueAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>DefaultValueAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.DefaultValueAttribute">
 <summary>Adding this attribute to a field declaration means that the field is 
 not initialized. During type checking a constraint is asserted that the field type supports 'null'. 
 If the 'check' value is false then the constraint is not asserted. 
 </summary>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.NoComparisonAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>NoComparisonAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.NoComparisonAttribute">
 <summary>Adding this attribute to a type indicates it is a type where comparison is an abnormal operation.
 This means that the type does not satisfy the F# 'comparison' constraint. Within the bounds of the 
 F# type system, this helps ensure that the F# generic comparison function is not instantiated directly
 at this type. The attribute and checking does not constrain the use of comparison with base or child 
 types of this type.
 </summary>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.CustomComparisonAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>CustomComparisonAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CustomComparisonAttribute">
 <summary>Adding this attribute to a type indicates it is a type with a user-defined implementation of comparison.</summary>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.CustomEqualityAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>CustomEqualityAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CustomEqualityAttribute">
 <summary>Adding this attribute to a type indicates it is a type with a user-defined implementation of equality.</summary>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.NoEqualityAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>NoEqualityAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.NoEqualityAttribute">
 <summary>Adding this attribute to a type indicates it is a type where equality is an abnormal operation.
 This means that the type does not satisfy the F# 'equality' constraint. Within the bounds of the 
 F# type system, this helps ensure that the F# generic equality function is not instantiated directly
 at this type. The attribute and checking does not constrain the use of comparison with base or child 
 types of this type.</summary>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.ProjectionParameterAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>ProjectionParameterAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.ProjectionParameterAttribute">
 <summary>Indicates that, when a custom operator is used in a computation expression,
 a parameter is automatically parameterized by the variable space of the computation expression</summary>

 <category>Attributes</category>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.MaintainsVariableSpaceUsingBind(System.Boolean)">
 <summary>Indicates if the custom operation maintains the variable space of the query of computation expression through the use of a bind operation</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.MaintainsVariableSpace(System.Boolean)">
 <summary>Indicates if the custom operation maintains the variable space of the query of computation expression</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.JoinConditionWord(System.String)">
 <summary>Indicates the name used for the 'on' part of the custom query operator for join-like operators</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.IsLikeZip(System.Boolean)">
 <summary>Indicates if the custom operation is an operation similar to a zip in a sequence computation, supporting two inputs</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.IsLikeJoin(System.Boolean)">
 <summary>Indicates if the custom operation is an operation similar to a join in a sequence computation, supporting two inputs and a correlation constraint</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.IsLikeGroupJoin(System.Boolean)">
 <summary>Indicates if the custom operation is an operation similar to a group join in a sequence computation, supporting two inputs and a correlation constraint, and generating a group</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.AllowIntoPattern(System.Boolean)">
 <summary>Indicates if the custom operation supports the use of 'into' immediately after the use of the operation in a query or other computation expression to consume the results of the operation</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.Name">
 <summary>Get the name of the custom operation when used in a query or other computation expression</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.MaintainsVariableSpaceUsingBind">
 <summary>Indicates if the custom operation maintains the variable space of the query of computation expression through the use of a bind operation</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.MaintainsVariableSpace">
 <summary>Indicates if the custom operation maintains the variable space of the query of computation expression</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.JoinConditionWord">
 <summary>Indicates the name used for the 'on' part of the custom query operator for join-like operators</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.IsLikeZip">
 <summary>Indicates if the custom operation is an operation similar to a zip in a sequence computation, supporting two inputs</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.IsLikeJoin">
 <summary>Indicates if the custom operation is an operation similar to a join in a sequence computation, supporting two inputs and a correlation constraint</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.IsLikeGroupJoin">
 <summary>Indicates if the custom operation is an operation similar to a group join in a sequence computation, supporting two inputs and a correlation constraint, and generating a group</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CustomOperationAttribute.AllowIntoPattern">
 <summary>Indicates if the custom operation supports the use of 'into' immediately after the use of the operation in a query or other computation expression to consume the results of the operation</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CustomOperationAttribute.#ctor(System.String)">
 <summary>Creates an instance of the attribute</summary>
 <returns>CustomOperationAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CustomOperationAttribute">
 <summary>Indicates that a member on a computation builder type is a custom query operator,
 and indicates the name of that operator.</summary>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.StructuralComparisonAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>StructuralComparisonAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.StructuralComparisonAttribute">
 <summary>Adding this attribute to a record, union, exception, or struct type confirms the 
 automatic generation of implementations for 'System.IComparable' for the type.</summary>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.StructuralEqualityAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>StructuralEqualityAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.StructuralEqualityAttribute">
 <summary>Adding this attribute to a record, union or struct type confirms the automatic 
 generation of overrides for 'System.Object.Equals(obj)' and 
 'System.Object.GetHashCode()' for the type. </summary>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.ReferenceEqualityAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>ReferenceEqualityAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.ReferenceEqualityAttribute">
 <summary>Adding this attribute to a record or union type disables the automatic generation
 of overrides for 'System.Object.Equals(obj)', 'System.Object.GetHashCode()' 
 and 'System.IComparable' for the type. The type will by default use reference equality.</summary>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.EntryPointAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>EntryPointAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.EntryPointAttribute">
 <summary>Adding this attribute to a function indicates it is the entrypoint for an application.
 If this attribute is not specified for an EXE then the initialization implicit in the
 module bindings in the last file in the compilation sequence are used as the entrypoint.</summary>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.VolatileFieldAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>VolatileFieldAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.VolatileFieldAttribute">
 <summary>Adding this attribute to an F# mutable binding causes the "volatile"
 prefix to be used for all accesses to the field.</summary>

 <category>Attributes</category>
</member>
<member name="P:Microsoft.FSharp.Core.DefaultAugmentationAttribute.Value">
 <summary>The value of the attribute, indicating whether the type has a default augmentation or not</summary>
</member>
<member name="M:Microsoft.FSharp.Core.DefaultAugmentationAttribute.#ctor(System.Boolean)">
 <summary>Creates an instance of the attribute</summary>

 <param name="value">Indicates whether to generate helper members on the CLI class representing a discriminated
 union.</param>

 <returns>DefaultAugmentationAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.DefaultAugmentationAttribute">
 <summary>Adding this attribute to a discriminated union with value false
 turns off the generation of standard helper member tester, constructor 
 and accessor members for the generated CLI class for that type.</summary>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.CLIMutableAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>CLIMutableAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CLIMutableAttribute">
 <summary>Adding this attribute to a record type causes it to be compiled to a CLI representation
 with a default constructor with property getters and setters.</summary>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.CLIEventAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>CLIEventAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CLIEventAttribute">
 <summary>Adding this attribute to a property with event type causes it to be compiled with as a CLI
 metadata event, through a syntactic translation to a pair of 'add_EventName' and 
 'remove_EventName' methods.</summary>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.LiteralAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>LiteralAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.LiteralAttribute">
 <summary>Adding this attribute to a value causes it to be compiled as a CLI constant literal.</summary>

 <category>Attributes</category>
</member>
<member name="P:Microsoft.FSharp.Core.AllowNullLiteralAttribute.Value">
 <summary>The value of the attribute, indicating whether the type allows the null literal or not</summary>
</member>
<member name="M:Microsoft.FSharp.Core.AllowNullLiteralAttribute.#ctor(System.Boolean)">
 <summary>Creates an instance of the attribute with the specified value</summary>
 <returns>AllowNullLiteralAttribute</returns>
</member>
<member name="M:Microsoft.FSharp.Core.AllowNullLiteralAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>AllowNullLiteralAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.AllowNullLiteralAttribute">
 <summary>Adding this attribute to a type lets the 'null' literal be used for the type 
 within F# code. This attribute may only be added to F#-defined class or 
 interface types.</summary>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.ClassAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>ClassAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.ClassAttribute">
 <summary>Adding this attribute to a type causes it to be represented using a CLI class.</summary>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.InterfaceAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>InterfaceAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.InterfaceAttribute">
 <summary>Adding this attribute to a type causes it to be represented using a CLI interface.</summary>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.MeasureAnnotatedAbbreviationAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>MeasureAnnotatedAbbreviationAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.MeasureAnnotatedAbbreviationAttribute">
 <summary>Adding this attribute to a type causes it to be interpreted as a refined type, currently limited to measure-parameterized types.
 This may only be used under very limited conditions.</summary>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.MeasureAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>MeasureAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.MeasureAttribute">
 <summary>Adding this attribute to a type causes it to be interpreted as a unit of measure.
 This may only be used under very limited conditions.</summary>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.StructAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>StructAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.StructAttribute">
 <summary>Adding this attribute to a type causes it to be represented using a CLI struct.</summary>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.ComparisonConditionalOnAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>ComparisonConditionalOnAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.ComparisonConditionalOnAttribute">
 <summary>This attribute is used to indicate a generic container type satisfies the F# 'comparison' 
 constraint only if a generic argument also satisfies this constraint.</summary>

 <remarks>For example, adding 
 this attribute to parameter 'T on a type definition C&lt;'T&gt; means that a type C&lt;X&gt; only supports 
 comparison if the type X also supports comparison and all other conditions for C&lt;X&gt; to support 
 comparison are also met. The type C&lt;'T&gt; can still be used with other type arguments, but a type such 
 as C&lt;(int -> int)&gt; will not support comparison because the type (int -> int) is an F# function type 
 and does not support comparison.

 This attribute will be ignored if it is used on the generic parameters of functions or methods.
 </remarks>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.EqualityConditionalOnAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>EqualityConditionalOnAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.EqualityConditionalOnAttribute">
 <summary>This attribute is used to indicate a generic container type satisfies the F# 'equality' 
 constraint only if a generic argument also satisfies this constraint.</summary>



 <remarks> For example, adding 
 this attribute to parameter 'T on a type definition C&lt;'T&gt; means that a type C&lt;X&gt; only supports 
 equality if the type X also supports equality and all other conditions for C&lt;X&gt; to support 
 equality are also met. The type C&lt;'T&gt; can still be used with other type arguments, but a type such 
 as C&lt;(int -> int)&gt; will not support equality because the type (int -> int) is an F# function type 
 and does not support equality.
 
 This attribute will be ignored if it is used on the generic parameters of functions or methods.
 </remarks>

 <category>Attributes</category>
</member>
<member name="P:Microsoft.FSharp.Core.ReflectedDefinitionAttribute.IncludeValue">
 <summary>The value of the attribute, indicating whether to include the evaluated value of the definition as the outer node of the quotation</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ReflectedDefinitionAttribute.#ctor(System.Boolean)">
 <summary>Creates an instance of the attribute</summary>

 <param name="includeValue">Indicates whether to include the evaluated value of the definition as the outer node of the quotation</param>

 <returns>ReflectedDefinitionAttribute</returns>
</member>
<member name="M:Microsoft.FSharp.Core.ReflectedDefinitionAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>ReflectedDefinitionAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.ReflectedDefinitionAttribute">
 <summary>Adding this attribute to the let-binding for the definition of a top-level 
 value makes the quotation expression that implements the value available
 for use at runtime.</summary>

 <category>Attributes</category>
</member>
<member name="M:Microsoft.FSharp.Core.AbstractClassAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>AbstractClassAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.AbstractClassAttribute">
 <summary>Adding this attribute to class definition makes it abstract, which means it need not
 implement all its methods. Instances of abstract classes may not be constructed directly.</summary>

 <category>Attributes</category>
</member>
<member name="P:Microsoft.FSharp.Core.SealedAttribute.Value">
 <summary>The value of the attribute, indicating whether the type is sealed or not.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.SealedAttribute.#ctor(System.Boolean)">
 <summary>Creates an instance of the attribute</summary>

 <param name="value">Indicates whether the class is sealed.</param>

 <returns>SealedAttribute</returns>
</member>
<member name="M:Microsoft.FSharp.Core.SealedAttribute.#ctor">
 <summary>Creates an instance of the attribute.</summary>
 <returns>The created attribute.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.SealedAttribute">
 <summary>Adding this attribute to class definition makes it sealed, which means it may not
 be extended or implemented.</summary>

 <category>Attributes</category>
</member>
<member name="F:Microsoft.FSharp.Core.CompilationRepresentationFlags.Event">
 <summary>Compile a property as a CLI event.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.CompilationRepresentationFlags.UseNullAsTrueValue">
 <summary>Permit the use of <c>null</c> as a representation for nullary discriminators in a discriminated union.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.CompilationRepresentationFlags.ModuleSuffix">
 <summary>append 'Module' to the end of a module whose name clashes with a type name in the same namespace.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.CompilationRepresentationFlags.Instance">
 <summary>Compile a member as 'instance' even if <c>null</c> is used as a representation for this type.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.CompilationRepresentationFlags.Static">
 <summary>Compile an instance member as 'static' .</summary>
</member>
<member name="F:Microsoft.FSharp.Core.CompilationRepresentationFlags.None">
 <summary>No special compilation representation.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilationRepresentationFlags">
 <summary>Indicates one or more adjustments to the compiled representation of an F# type or member.</summary>

 <category>Attributes</category>
</member>
<member name="F:Microsoft.FSharp.Core.SourceConstructFlags.NonPublicRepresentation">
 <summary>Indicates that the compiled entity had private or internal representation in F# source code.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.SourceConstructFlags.KindMask">
 <summary>The mask of values related to the kind of the compiled entity.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.SourceConstructFlags.Value">
 <summary>Indicates that the compiled entity is part of the representation of an F# value declaration.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.SourceConstructFlags.UnionCase">
 <summary>Indicates that the compiled entity is part of the representation of an F# union case declaration.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.SourceConstructFlags.Module">
 <summary>Indicates that the compiled entity is part of the representation of an F# module declaration.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.SourceConstructFlags.Closure">
 <summary>Indicates that the compiled entity is part of the representation of an F# closure.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.SourceConstructFlags.Exception">
 <summary>Indicates that the compiled entity is part of the representation of an F# exception declaration.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.SourceConstructFlags.Field">
 <summary>Indicates that the compiled entity is part of the representation of an F# record or union case field declaration.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.SourceConstructFlags.ObjectType">
 <summary>Indicates that the compiled entity is part of the representation of an F# class or other object type declaration.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.SourceConstructFlags.RecordType">
 <summary>Indicates that the compiled entity is part of the representation of an F# record type declaration.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.SourceConstructFlags.SumType">
 <summary>Indicates that the compiled entity is part of the representation of an F# union type declaration.</summary>
</member>
<member name="F:Microsoft.FSharp.Core.SourceConstructFlags.None">
 <summary>Indicates that the compiled entity has no relationship to an element in F# source code.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.SourceConstructFlags">
 <summary>Indicates the relationship between a compiled entity in a CLI binary and an element in F# source code.</summary>

 <category index="8">Attributes</category>
</member>
<member name="T:Microsoft.FSharp.Core.unit">
 <summary>The type 'unit', which has only one value "()". This value is special and
 always uses the representation 'null'.</summary>

 <category index="1">Basic Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.Unit">
 <namespacedoc><summary>
   Basic definitions of operators, options, functions, results, choices, attributes and plain text formatting.
 </summary></namespacedoc>

 <summary>The type 'unit', which has only one value "()". This value is special and
 always uses the representation 'null'.</summary>

 <category>Basic Types</category>
 <exclude />
</member>
<member name="T:Microsoft.FSharp.Core.bigint">
 <summary>An abbreviation for <see cref="T:System.Numerics.BigInteger"/>. </summary>

 <category>Basic Types</category>
</member>
<member name="T:Microsoft.FSharp.Core.Format`5">
 <summary>Type of a formatting expression.</summary>
 <typeparam name="Printer">Function type generated by printf.</typeparam>
 <typeparam name="State">Type argument passed to %a formatters</typeparam>
 <typeparam name="Residue">Value generated by the overall printf action (e.g. sprint generates a string)</typeparam>
 <typeparam name="Result">Value generated after post processing (e.g. failwithf generates a string internally then raises an exception)</typeparam>
 <typeparam name="Tuple">Tuple of values generated by scan or match.</typeparam>

 <category>Language Primitives</category>
</member>
<member name="T:Microsoft.FSharp.Core.Format`4">
 <summary>Type of a formatting expression.</summary>
 <typeparam name="Printer">Function type generated by printf.</typeparam>
 <typeparam name="State">Type argument passed to %a formatters</typeparam>
 <typeparam name="Residue">Value generated by the overall printf action (e.g. sprint generates a string)</typeparam>
 <typeparam name="Result">Value generated after post processing (e.g. failwithf generates a string internally then raises an exception)</typeparam>

 <category>Language Primitives</category>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfFormat`5.#ctor(System.String,System.Object[],System.Type[])">
 <summary>Construct a format string</summary>

 <param name="value">The input string.</param>
 <param name="captures">The captured expressions in an interpolated string.</param>
 <param name="captureTys">The types of expressions for %A holes in interpolated string.</param>

 <returns>The created format string.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfFormat`5.#ctor(System.String)">
 <summary>Construct a format string</summary>

 <param name="value">The input string.</param>

 <returns>The created format string.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfFormat`5">
 <summary>Type of a formatting expression.</summary>

 <typeparam name="Printer">Function type generated by printf.</typeparam>
 <typeparam name="State">Type argument passed to %a formatters</typeparam>
 <typeparam name="Residue">Value generated by the overall printf action (e.g. sprint generates a string)</typeparam>
 <typeparam name="Result">Value generated after post processing (e.g. failwithf generates a string internally then raises an exception)</typeparam>
 <typeparam name="Tuple">Tuple of values generated by scan or match.</typeparam>

 <category>Language Primitives</category>
</member>
<member name="P:Microsoft.FSharp.Core.PrintfFormat`4.Value">
 <summary>The raw text of the format string.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.PrintfFormat`4.Captures">
 <summary>The captures associated with an interpolated string.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.PrintfFormat`4.CaptureTypes">
 <summary>The capture types associated with an interpolated string.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfFormat`4.#ctor(System.String,System.Object[],System.Type[])">
 <summary>Construct a format string </summary>
 <param name="value">The input string.</param>
 <param name="captures">The captured expressions in an interpolated string.</param>
 <param name="captureTys">The types of expressions for %A holes in interpolated string.</param>
 <returns>The PrintfFormat containing the formatted result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfFormat`4.#ctor(System.String)">
 <summary>Construct a format string </summary>
 <param name="value">The input string.</param>

 <returns>The PrintfFormat containing the formatted result.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfFormat`4">
 <summary>Type of a formatting expression.</summary>

 <typeparam name="Printer">Function type generated by printf.</typeparam>
 <typeparam name="State">Type argument passed to %a formatters</typeparam>
 <typeparam name="Residue">Value generated by the overall printf action (e.g. sprint generates a string)</typeparam>
 <typeparam name="Result">Value generated after post processing (e.g. failwithf generates a string internally then raises an exception)</typeparam>

 <category>Language Primitives</category>
</member>
<member name="T:Microsoft.FSharp.Core.MatchFailureException">
 <summary>Non-exhaustive match failures will raise the MatchFailureException exception</summary>
 <category>Language Primitives</category>
</member>
<member name="P:Microsoft.FSharp.Core.SR.maxDegreeOfParallelismNotPositive">
 <summary>maxDegreeOfParallelism must be positive, was {0}</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.unsupportedQueryConstructKind">
 <summary>This is not a valid query expression. The construct '{0}' was used in a query but is not recognized by the F#-to-LINQ query translator. Check the specification of permitted queries and consider moving some of the operations out of the query expression.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.unsupportedQueryProperty">
 <summary>This is not a valid query expression. The property '{0}' was used in a query but is not recognized by the F#-to-LINQ query translator. Check the specification of permitted queries and consider moving some of the operations out of the query expression.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.unsupportedQueryCall">
 <summary>This is not a valid query expression. The method '{0}' was used in a query but is not recognized by the F#-to-LINQ query translator. Check the specification of permitted queries and consider moving some of the operations out of the query expression</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.unsupportedQueryConstruct">
 <summary>This is not a valid query expression. The following construct was used in a query but is not recognized by the F#-to-LINQ query translator:\n{0}\nCheck the specification of permitted queries and consider moving some of the operations out of the query expression.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.unsupportedIfThenElse">
 <summary>An if/then/else conditional or pattern matching expression with multiple branches is not permitted in a query. An if/then/else conditional may be used.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.failDueToUnsupportedInputTypeInSumByOrAverageBy">
 <summary>Unrecognized use of a 'sumBy' or 'averageBy' operator in a query. In queries whose original data is of static type IQueryable, these operators may only be used with result type int32, int64, single, double or decimal</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.thenByError">
 <summary>'thenBy' and 'thenByDescending' may only be used with an ordered input</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.inputSequenceTooLong">
 <summary>The input sequence contains more than one element.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.invalidTupleTypeConstructorNotDefined">
 <summary>The tuple type '{0}' is invalid. Required constructor is not defined.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.invalidRecordTypeConstructorNotDefined">
 <summary>The record type '{0}' is invalid. Required constructor is not defined.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.controlContinuationInvokedMultipleTimes">
 <summary>A continuation provided by Async.FromContinuations was invoked multiple times</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.optionValueWasNone">
 <summary>The option value was None</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.thisValueCannotBeMutated">
 <summary>This value cannot be mutated</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QtypeArgumentOutOfRange">
 <summary>type argument out of range</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QillFormedAppOrLet">
 <summary>ill formed expression: AppOp or LetOp</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QfailedToBindAssembly">
 <summary>Failed to bind assembly '{0}' while processing quotation data</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QcannotTakeAddress">
 <summary>Cannot take the address of this quotation</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QcannotBindToMethod">
 <summary>Could not bind to method</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QcannotBindProperty">
 <summary>Could not bind property {0} in type {1}</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QcannotBindFunction">
 <summary>Could not bind function {0} in type {1}</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.printfWidthSpecifierIllegal">
 <summary>Bad format specifier (width)</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.printfSpecifierAfterIllegal">
 <summary>Bad format specifier (after {0})</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.printfPrecisonSpecifierIllegal">
 <summary>Bad format specifier (precision)</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.printfNotAFunType">
 <summary>Not a function type</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.printfMissingFormatSpecifier">
 <summary>Missing format specifier</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.printfHashFormatSpecifierIllegal">
 <summary>The # formatting modifier is invalid in F#</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.printfExpectedWidth">
 <summary>Expected a width argument</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.printfExpectedPrecision">
 <summary>Expected a precision argument</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.printfBadIntegerForDynamicFomatter">
 <summary>Bad integer supplied to dynamic formatter</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.printfBadFormatSpecifier">
 <summary>Bad format specifier:{0}</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.printfBadFloatValue">
 <summary>Bad float value</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.multipleCompilationMappings">
 <summary>Multiple CompilationMappingAttributes, expected at most one</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.moveNextNotCalledOrFinished">
 <summary>MoveNext not called, or finished</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.firstClassUsesOfSplice">
 <summary>first class uses of '%' or '%%' are not permitted</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.constructorForUnionCaseNotFound">
 <summary>The constructor method '{0}' for the union case could not be found</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.keyNotFoundAlt">
 <summary>An index satisfying the predicate was not found in the collection.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QwrongNumOfTypeArgs">
 <summary>The method '{0}' expects {1} type arguments but {2} were provided</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QwritingGetOnly">
 <summary>Writing a get-only property</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QunionNeedsDiffNumArgs">
 <summary>F# union type requires different number of arguments</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QtupleLengthsDiffer">
 <summary>The tuple lengths are different</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QtupleAccessOutOfRange">
 <summary>Tuple access out of range</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmRaw">
 <summary>Type mismatch when splicing expression into quotation literal. The type of the expression tree being inserted doesn't match the type expected by the splicing operation. Expected '{0}', but received type '{1}'. Consider type-annotating with the expected expression type, e.g., (%% x : {0}) or (%x : {0}).</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmFunTypeNotMatchDelegate">
 <summary>Type mismatch when building '{0}': function type doesn't match delegate type. Expected '{1}', but received type '{2}'.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmExprHasWrongType">
 <summary>Type mismatch when building '{0}': the expression has the wrong type. Expected '{1}', but received type '{2}'.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QstaticWithReceiverObject">
 <summary>Receiver object was unexpected, as member is static</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QreadingSetOnly">
 <summary>Reading a set-only property</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QparentCannotBeNull">
 <summary>Parent type cannot be null</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QnonStaticNoReceiverObject">
 <summary>The member is non-static (instance), but no receiver object was supplied</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QinvalidFuncType">
 <summary>Invalid function type</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QincorrectType">
 <summary>Incorrect type</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QincorrectNumArgs">
 <summary>Incorrect number of arguments</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QincorrectInstanceType">
 <summary>Incorrect instance type</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QincompatibleRecordLength">
 <summary>Incompatible record length</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QfailedToBindTypeInAssembly">
 <summary>Failed to bind type '{0}' in assembly '{1}'</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QfailedToBindProperty">
 <summary>Failed to bind property '{0}'</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QfailedToBindField">
 <summary>Failed to bind field '{0}'</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QfailedToBindConstructor">
 <summary>Failed to bind constructor</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.tupleIndexOutOfRange">
 <summary>The tuple index '{1}' was out of range for tuple type '{0}'.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.syncContextNull">
 <summary>The System.Threading.SynchronizationContext.Current of the calling thread is null.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.stepCannotBeZero">
 <summary>The step of a range cannot be zero.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.stepCannotBeNaN">
 <summary>The step of a range cannot be NaN.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.startCannotBeNaN">
 <summary>The start of a range cannot be NaN.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.resetNotSupported">
 <summary>Reset is not supported on this enumerator.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QunrecognizedMethodCall">
 <summary>The parameter is not a recognized method name.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QunexpectedHole">
 <summary>Unexpected quotation hole in expression.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmVarTypeNotMatchRHS">
 <summary>Type mismatch when building '{0}': the variable type doesn't match the type of the right-hand-side of a let binding. Expected '{1}', but received type '{2}'.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmTuple">
 <summary>Type mismatch when building '{0}': mismatched type of argument and tuple element. Expected '{1}', but received type '{2}'.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmTrueAndFalseMustMatch">
 <summary>Type mismatch when building '{0}': types of true and false branches differ. Expected '{1}', but received type '{2}'.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmLowerUpperBoundMustBeInt">
 <summary>Type mismatch when building '{0}': lower and upper bounds must be integers. Expected '{1}', but received type '{2}'.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmLoopBodyMustBeLambdaTakingInteger">
 <summary>Type mismatch when building '{0}': body of the for loop must be lambda taking integer as an argument. Expected '{1}', but received type '{2}'.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmInvalidParam">
 <summary>Type mismatch when building '{0}': invalid parameter for a method or indexer property. Expected '{1}', but received type '{2}'.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmInitArray">
 <summary>Type mismatch when building '{0}': initializer doesn't match array type. Expected '{1}', but received type '{2}'.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmIncorrectArgForUnion">
 <summary>Type mismatch when building '{0}': incorrect argument type for an F# union. Expected '{1}', but received type '{2}'.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmIncorrectArgForRecord">
 <summary>Type mismatch when building '{0}': incorrect argument type for an F# record. Expected '{1}', but received type '{2}'.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmGuardMustBeBool">
 <summary>Type mismatch when building '{0}': guard must return boolean. Expected '{1}', but received type '{2}'.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmFunctionArgTypeMismatch">
 <summary>Type mismatch when building '{0}': function argument type doesn't match. Expected '{1}', but received type '{2}'.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmExprTypeMismatch">
 <summary>Type mismatch when building '{0}': types of expression does not match. Expected '{1}', but received type '{2}'.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmExprNotMatchTuple">
 <summary>Type mismatch when building '{0}': expression doesn't match the tuple type. Expected '{1}', but received type '{2}'.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmExpectedFunction">
 <summary>Type mismatch when building '{0}': expected function type in function application or let binding. Expected '{1}', but received type '{2}'.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmCondMustBeBool">
 <summary>Type mismatch when building '{0}': condition expression must be of type bool. Expected '{1}', but received type '{2}'.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmBodyMustBeUnit">
 <summary>Type mismatch when building '{0}': body must return unit. Expected '{1}', but received type '{2}'.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmBadFieldType">
 <summary>Type mismatch when building '{0}': the type of the field was incorrect. Expected '{1}', but received type '{2}'.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QmissingUnionCase">
 <summary>Type '{0}' did not have an F# union case named '{1}'.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QmissingRecordField">
 <summary>Type '{0}' did not have an F# record field named '{1}'.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QinvalidCaseIndex">
 <summary>Not a valid F# union case index.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QexpectedTwoTypes">
 <summary>Expected exactly two type arguments.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.QexpectedOneType">
 <summary>Expected exactly one type argument.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.privateUnionType">
 <summary>The type '{0}' is an F# union type but its representation is private. You must specify BindingFlags.NonPublic to access private type representations.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.privateRecordType">
 <summary>The type '{0}' is an F# record type but its representation is private. You must specify BindingFlags.NonPublic to access private type representations.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.privateExceptionType">
 <summary>The type '{0}' is the representation of an F# exception declaration but its representation is private. You must specify BindingFlags.NonPublic to access private type representations.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.outOfRange">
 <summary>The index is outside the legal range.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.objIsNullAndNoType">
 <summary>The object is null and no type was given.  Either pass a non-null object or a non-null type parameter.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.objIsNotARecord">
 <summary>The object is not an F# record value.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.nullsNotAllowedInArray">
 <summary>One of the elements in the array is null.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.notUsedForHashing">
 <summary>This object is for recursive equality calls and cannot be used for hashing.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.notEnoughElements">
 <summary>The input sequence has an insufficient number of elements.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.notComparable">
 <summary>The two objects have different types and are not comparable.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.notAUnionType">
 <summary>Type '{0}' is not an F# union type.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.notATupleType">
 <summary>Type '{0}' is not a tuple type.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.notARecordType">
 <summary>Type '{0}' is not an F# record type.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.notAPermutation">
 <summary>The function did not compute a permutation.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.notAnExceptionType">
 <summary>Type '{0}' is not the representation of an F# exception declaration.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.notAFunctionType">
 <summary>Type '{0}' is not a function type.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.nonZeroBasedDisallowed">
 <summary>Arrays with non-zero base cannot be created on this platform.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.checkStaticInit">
 <summary>The static initialization of a file or type resulted in static data being accessed recursively before it was fully initialized.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.checkInit">
 <summary>The initialization of an object or value resulted in an object or value being accessed recursively before it was fully initialized.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.noNegateMinValue">
 <summary>Negating the minimum value of a twos complement number is invalid.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.mismatchIAREnd">
 <summary>The IAsyncResult object provided does not match this 'End' operation.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.mismatchIARCancel">
 <summary>The IAsyncResult object provided does not match this 'Cancel' operation.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.mapCannotBeMutated">
 <summary>Map values cannot be mutated.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.mailboxScanTimedOut">
 <summary>Mailbox.Scan timed out.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.mailboxReceiveTimedOut">
 <summary>Mailbox.Receive timed out.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.mailboxProcessorPostAndReplyTimedOut">
 <summary>MailboxProcessor.PostAndReply timed out.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.mailboxProcessorPostAndAsyncReplyTimedOut">
 <summary>MailboxProcessor.PostAndAsyncReply timed out.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.mailboxProcessorAlreadyStarted">
 <summary>The MailboxProcessor has already been started.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.listsHadDifferentLengths">
 <summary>The lists had different lengths.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.keyNotFound">
 <summary>The item, key, or index was not found in the collection.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.invalidTupleTypes">
 <summary>This is not a valid tuple type for the F# reflection library.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.inputSequenceEmpty">
 <summary>The input sequence was empty.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.inputMustBePositive">
 <summary>The input must be positive.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.inputMustBeNonNegative">
 <summary>The input must be non-negative.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.inputListWasEmpty">
 <summary>The input list was empty.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.indexOutOfBounds">
 <summary>The index was outside the range of elements in the list.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.genericCompareFail1">
 <summary>Failure during generic comparison: the type '{0}' does not implement the System.IComparable interface. This error may be arise from the use of a function such as 'compare', 'max' or 'min' or a data structure such as 'Set' or 'Map' whose keys contain instances of this type.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.failedReadEnoughBytes">
 <summary>Failed to read enough bytes from the stream.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.enumerationPastIntMaxValue">
 <summary>Enumeration based on System.Int32 exceeded System.Int32.MaxValue.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.setContainsNoElements">
 <summary>Set contains no elements.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.enumerationNotStarted">
 <summary>Enumeration has not started. Call MoveNext.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.enumerationAlreadyFinished">
 <summary>Enumeration already finished.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.endCannotBeNaN">
 <summary>The end of a range cannot be NaN.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.dyInvOpMultOverload">
 <summary>Dynamic invocation of op_Multiply involving overloading is not supported.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.dyInvOpMultCoerce">
 <summary>Dynamic invocation of op_Multiply involving coercions is not supported.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.dyInvOpAddOverload">
 <summary>Dynamic invocation of op_Addition involving overloading is not supported.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.dyInvOpAddCoerce">
 <summary>Dynamic invocation of op_Addition involving coercions is not supported.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.dyInvDivByIntCoerce">
 <summary>Dynamic invocation of DivideByInt involving coercions is not supported.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.delegateExpected">
 <summary>Expecting delegate type.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.badFormatString">
 <summary>Input string was not in a correct format.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.arrayWasEmpty">
 <summary>The input array was empty.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.arraysHadDifferentLengths">
 <summary>The arrays have different lengths.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.addressOpNotFirstClass">
 <summary>First class uses of address-of operators are not permitted.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SR.matchCasesIncomplete">
 <summary>The match cases were incomplete</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.KeyValuePattern``2(System.Collections.Generic.KeyValuePair{``0,``1})">
 <summary>An active pattern to match values of type <see cref="T:System.Collections.Generic.KeyValuePair"/></summary>

 <param name="keyValuePair">The input key/value pair.</param>

 <returns>A tuple containing the key and value.</returns>
 
 <example id="keyvalue-example">
 <code lang="fsharp">
 let kv = System.Collections.Generic.KeyValuePair(42, "the answer")
 match kv with // evaluates to "found it"
 | KeyValue (42, v) -> "found it"
 | KeyValue (k, v) -> "keep waiting"
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToChar``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Char},``0)">
 <summary>Converts the argument to character. Numeric inputs are converted according to the UTF-16 
 encoding for characters. String inputs must be exactly one character long. For other
 input types the operation requires an appropriate static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted char.</returns>
 
 <example id="char-example">
 <code lang="fsharp">
 char "A"  // evaluates to 'A'
 char 0x41 // evaluates to 'A'
 char 65   // evaluates to 'A'
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToDecimal``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Decimal},``0)">
 <summary>Converts the argument to System.Decimal using a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>UInt64.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted decimal.</returns>
 
 <example id="decimal-example">
 <code lang="fsharp">
 decimal "42.23" // evaluates to 42.23M
 decimal 0xff    // evaluates to 255M
 decimal -10     // evaluates to -10M
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToString``1(``0)">
 <summary>Converts the argument to a string using <c>ToString</c>.</summary>

 <remarks>For standard integer and floating point values and any type that implements <c>IFormattable</c>
 <c>ToString</c> conversion uses <c>CultureInfo.InvariantCulture</c>. </remarks>
 <param name="value">The input value.</param>

 <returns>The converted string.</returns>
 
 <example id="string-example">
 <code lang="fsharp">
 string 'A'  // evaluates to "A"
 string 0xff // evaluates to "255"
 string -10  // evaluates to "-10"
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToUIntPtr``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.UIntPtr},``0)">
 <summary>Converts the argument to unsigned native integer using a direct conversion for all 
 primitive numeric types. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted unativeint</returns>
 
 <example id="unativeint-example">
 <code lang="fsharp">
 unativeint 'A'  // evaluates to 65un
 unativeint 0xff // evaluates to 255un
 unativeint -10  // evaluates to 18446744073709551606un
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToIntPtr``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.IntPtr},``0)">
 <summary>Converts the argument to signed native integer. This is a direct conversion for all 
 primitive numeric types. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted nativeint</returns>
 
 <example id="nativeint-example">
 <code lang="fsharp">
 nativeint 'A'  // evaluates to 65n
 nativeint 0xff // evaluates to 255n
 nativeint -10  // evaluates to -10n
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToDouble``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Double},``0)">
 <summary>Converts the argument to 64-bit float. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Double.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted float</returns>
 
 <example id="float-example">
 <code lang="fsharp">
 float 'A'  // evaluates to 65.0
 float 0xff // evaluates to 255.0
 float -10  // evaluates to -10.0
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToSingle``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Single},``0)">
 <summary>Converts the argument to 32-bit float. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Single.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted float32</returns>
 
 <example id="float32-example">
 <code lang="fsharp">
 float32 'A'  // evaluates to 65.0f
 float32 0xff // evaluates to 255.0f
 float32 -10  // evaluates to -10.0f
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToUInt64``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.UInt64},``0)">
 <summary>Converts the argument to unsigned 64-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>UInt64.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted uint64</returns>
 
 <example id="uint64-example">
 <code lang="fsharp">
 uint64 'A'  // evaluates to 65UL
 uint64 0xff // evaluates to 255UL
 uint64 -10  // evaluates to 18446744073709551606UL
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToInt64``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Int64},``0)">
 <summary>Converts the argument to signed 64-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Int64.Parse()</c> 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted int64</returns>
 
 <example id="int64-example">
 <code lang="fsharp">
 int64 'A'  // evaluates to 65L
 int64 0xff // evaluates to 255L
 int64 -10  // evaluates to -10L
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToUInt32``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.UInt32},``0)">
 <summary>Converts the argument to unsigned 32-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>UInt32.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted uint32</returns>
 
 <example id="uint32-example">
 <code lang="fsharp">
 uint32 'A'  // evaluates to 65u
 uint32 0xff // evaluates to 255u
 uint32 -10  // evaluates to 4294967286u
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToInt32``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32},``0)">
 <summary>Converts the argument to signed 32-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Int32.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted int32</returns>
 
 <example id="int32-example">
 <code lang="fsharp">
 int32 'A'  // evaluates to 65
 int32 0xff // evaluates to 255
 int32 -10  // evaluates to -10
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToEnum``1(System.Int32)">
 <summary>Converts the argument to a particular enum type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted enum type.</returns>
 
 <example id="enum-example">
 <code lang="fsharp">
 type Color =
 | Red = 1
 | Green = 2
 | Blue = 3
 let c: Color = enum 3 // c evaluates to Blue
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToUInt``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.UInt32},``0)">
 <summary>Converts the argument to an unsigned 32-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>UInt32.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted int</returns>
 
 <example id="uint-example">
 <code lang="fsharp">
 uint 'A'  // evaluates to 65u
 uint 0xff // evaluates to 255u
 uint -10  // evaluates to 4294967286u
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToInt``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32},``0)">
 <summary>Converts the argument to signed 32-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Int32.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted int</returns>
 
 <example id="int-example">
 <code lang="fsharp">
 int 'A'  // evaluates to 65
 int 0xff // evaluates to 255
 int -10  // evaluates to -10
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToUInt16``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.UInt16},``0)">
 <summary>Converts the argument to unsigned 16-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>UInt16.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted uint16</returns>
 
 <example id="uint16-example">
 <code lang="fsharp">
 uint16 'A'  // evaluates to 65us
 uint16 0xff // evaluates to 255s
 uint16 -10  // evaluates to 65526us
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToInt16``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Int16},``0)">
 <summary>Converts the argument to signed 16-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Int16.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted int16</returns>
 
 <example id="int16-example">
 <code lang="fsharp">
 int16 'A'  // evaluates to 65s
 int16 0xff // evaluates to 255s
 int16 -10  // evaluates to -10s
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToSByte``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.SByte},``0)">
 <summary>Converts the argument to signed byte. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>SByte.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted sbyte</returns>
 
 <example id="sbyte-example">
 <code lang="fsharp">
 sbyte 'A'  // evaluates to 65y
 sbyte 0xff // evaluates to -1y
 sbyte -10  // evaluates to -10y
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToByte``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Byte},``0)">
 <summary>Converts the argument to byte. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Byte.Parse()</c> 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted byte</returns>
 
 <example id="byte-example">
 <code lang="fsharp">
 byte 'A'  // evaluates to 65uy
 byte 0xff // evaluates to 255uy
 byte -10  // evaluates to 246uy
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.PowInteger``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0,System.Int32)">
 <summary>Overloaded power operator. If <c>n > 0</c> then equivalent to <c>x*...*x</c> for <c>n</c> occurrences of <c>x</c>. </summary>

 <param name="x">The input base.</param>
 <param name="n">The input exponent.</param>

 <returns>The base raised to the exponent.</returns>
 
 <example id="pown-example">
 <code lang="fsharp">
 pown 2.0 3 // evaluates to 8.0
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Exponentiation``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,``1)">
 <summary>Overloaded power operator.</summary>

 <param name="x">The input base.</param>
 <param name="y">The input exponent.</param>

 <returns>The base raised to the exponent.</returns>
 
 <example id="powop-example">
 <code lang="fsharp">
 2.0 ** 3 // evaluates to 8.0
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Truncate``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0)">
 <summary>Overloaded truncate operator.</summary>

 <param name="value">The input value.</param>

 <returns>The truncated value.</returns>
 
 <example id="truncate-example">
 <code lang="fsharp">
 truncate 23.92 // evaluates to 23.0
 truncate 23.92f // evaluates to 23.0f
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Tanh``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0)">
 <summary>Hyperbolic tangent of the given number</summary>

 <param name="value">The input value.</param>

 <returns>The hyperbolic tangent of the input.</returns>
 
 <example id="tanh-example">
 <code lang="fsharp">
 tanh -1.0 // evaluates to -0.761594156
 tanh 0.0  // evaluates to 0.0
 tanh 1.0  // evaluates to 0.761594156
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Tan``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0)">
 <summary>Tangent of the given number</summary>

 <param name="value">The input value.</param>

 <returns>The tangent of the input.</returns>
 
 <example id="tan-example">
 <code lang="fsharp">
 tan (-0.5 * System.Math.PI) // evaluates to -1.633123935e+16
 tan (0.0 * System.Math.PI)  // evaluates to 0.0
 tan (0.5 * System.Math.PI)  // evaluates to 1.633123935e+16
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Sinh``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0)">
 <summary>Hyperbolic sine of the given number</summary>

 <param name="value">The input value.</param>

 <returns>The hyperbolic sine of the input.</returns>
 
 <example id="sinh-example">
 <code lang="fsharp">
 sinh -1.0 // evaluates to -1.175201194
 sinh 0.0  // evaluates to 0.0
 sinh 1.0  // evaluates to 1.175201194
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Sin``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0)">
 <summary>Sine of the given number</summary>

 <param name="value">The input value.</param>

 <returns>The sine of the input.</returns>
 
 <example id="sin-example">
 <code lang="fsharp">
 sin (0.0 * System.Math.PI) // evaluates to 0.0
 sin (0.5 * System.Math.PI) // evaluates to 1.0
 sin (1.0 * System.Math.PI) // evaluates to 1.224646799e-16
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Cosh``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0)">
 <summary>Hyperbolic cosine  of the given number</summary>

 <param name="value">The input value.</param>

 <returns>The hyperbolic cosine of the input.</returns>
 
 <example id="cosh-example">
 <code lang="fsharp">
 cosh -1.0 // evaluates to 1.543080635
 cosh 0.0  // evaluates to 1.0
 cosh 1.0  // evaluates to 1.543080635
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Cos``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0)">
 <summary>Cosine of the given number</summary>

 <param name="value">The input value.</param>

 <returns>The cosine of the input.</returns>
 
 <example id="cos-example">
 <code lang="fsharp">
 cos (0.0 * System.Math.PI) // evaluates to 1.0
 cos (0.5 * System.Math.PI) // evaluates to 6.123233996e-17
 cos (1.0 * System.Math.PI) // evaluates to -1.0
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Sqrt``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
 <summary>Square root of the given number</summary>

 <param name="value">The input value.</param>

 <returns>The square root of the input.</returns>
 
 <example id="log-example">
 <code lang="fsharp">
 sqrt 2.0  //  Evaluates to 1.414213562
 sqrt 100.0  //  Evaluates to 10.0
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Log10``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0)">
 <summary>Logarithm to base 10 of the given number</summary>

 <param name="value">The input value.</param>

 <returns>The logarithm to base 10 of the input.</returns>
 
 <example id="log-example">
 <code lang="fsharp">
 log10 1000.0    //  Evaluates to 3.0
 log10 100000.0  //  Evaluates to 5.0
 log10 0.0001    //  Evaluates to -4.0
 log10 -20.0     //  Evaluates to nan
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Log``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0)">
 <summary>Natural logarithm of the given number</summary>

 <param name="value">The input value.</param>

 <returns>The natural logarithm of the input.</returns>
 
 <example id="log-example">
 <code lang="fsharp">
 let logBase baseNumber value = (log value) / (log baseNumber)
 logBase 2.0 32.0      //  Evaluates to 5.0
 logBase 10.0 1000.0   //  Evaluates to 3.0
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Round``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0)">
 <summary>Round the given number</summary>

 <param name="value">The input value.</param>

 <returns>The nearest integer to the input value.</returns>
 
 <example id="round-example">
 <code lang="fsharp">
 round 3.49    //  Evaluates to 3.0
 round -3.49   //  Evaluates to -3.0
 round 3.5     //  Evaluates to 4.0
 round -3.5    //  Evaluates to -4.0
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Sign``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32},``0)">
 <summary>Sign of the given number</summary>

 <param name="value">The input value.</param>

 <returns>-1, 0, or 1 depending on the sign of the input.</returns>
 
 <example id="sign-example">
 <code lang="fsharp">
 sign -12.0    //  Evaluates to -1
 sign 43       //  Evaluates to 1
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Floor``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0)">
 <summary>Floor of the given number</summary>

 <param name="value">The input value.</param>

 <returns>The floor of the input.</returns>
 
 <example id="floor-example">
 <code lang="fsharp">
 floor 12.1  //  Evaluates to 12.0
 floor -1.9  //  Evaluates to -2.0
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Exp``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0)">
 <summary>Exponential of the given number</summary>

 <param name="value">The input value.</param>

 <returns>The exponential of the input.</returns>
 
 <example id="exp-example">
 <code lang="fsharp">
 exp 0.0   //  Evaluates to 1.0
 exp 1.0   //  Evaluates to 2.718281828
 exp -1.0  //  Evaluates to 0.3678794412
 exp 2.0   //  Evaluates to 7.389056099
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Ceiling``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0)">
 <summary>Ceiling of the given number</summary>

 <param name="value">The input value.</param>

 <returns>The ceiling of the input.</returns>
 
 <example id="ceil-example">
 <code lang="fsharp">
 ceil 12.1  //  Evaluates to 13.0
 ceil -1.9  //  Evaluates to -1.0
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Atan2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``0,``0)">
 <summary>Inverse tangent of <c>x/y</c> where <c>x</c> and <c>y</c> are specified separately</summary>

 <param name="y">The y input value.</param>
 <param name="x">The x input value.</param>

 <returns>The inverse tangent of the input ratio.</returns>
 
 <example id="atan2-example">
 <code lang="fsharp">
 let angleFromPlaneAtXY x y = atan2 y x * 180.0 / System.Math.PI
 angleFromPlaneAtXY 0.0 -1.0   //  Evaluates to -90.0
 angleFromPlaneAtXY 1.0 1.0    //  Evaluates to 45.0
 angleFromPlaneAtXY -1.0 1.0   //  Evaluates to 135.0
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Atan``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0)">
 <summary>Inverse tangent of the given number</summary>

 <param name="value">The input value.</param>

 <returns>The inverse tangent of the input.</returns>
 
 <example id="atan-example">
 <code lang="fsharp">
 let angleFrom opposite adjacent = atan(opposite / adjacent)
 angleFrom 5.0 5.0   //  Evaluates to 0.7853981634
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Asin``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0)">
 <summary>Inverse sine of the given number</summary>

 <param name="value">The input value.</param>

 <returns>The inverse sine of the input.</returns>
 
 <example id="asin-example">
 <code lang="fsharp">
 let angleFromOpposite opposite hypotenuse = asin(opposite / hypotenuse)
 angleFromOpposite 6.0 10.0  //  Evaluates to 0.6435011088
 angleFromOpposite 5.0 3.0  //  Evaluates to nan
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Acos``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0)">
 <summary>Inverse cosine of the given number</summary>

 <param name="value">The input value.</param>

 <returns>The inverse cosine of the input.</returns>
 
 <example id="acos-example">
 <code lang="fsharp">
 let angleFromAdjacent adjacent hypotenuse = acos(adjacent / hypotenuse)
 angleFromAdjacent 8.0 10.0  //  Evaluates to 0.6435011088
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Abs``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0)">
 <summary>Absolute value of the given number.</summary>

 <param name="value">The input value.</param>

 <returns>The absolute value of the input.</returns>
 
 <example id="abs-example">
 <code lang="fsharp">
 abs -12    // Evaluates to 12
 abs -15.0  // Evaluates to 15.0
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.limitedHash``1(System.Int32,``0)">
 <summary>A generic hash function. This function has the same behaviour as 'hash', 
 however the default structural hashing for F# union, record and tuple 
 types stops when the given limit of nodes is reached. The exact behaviour of 
 the function can be adjusted on a type-by-type basis by implementing 
 GetHashCode for each type.</summary>

 <param name="limit">The limit of nodes.</param>
 <param name="obj">The input object.</param>

 <returns>The computed hash.</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Hash``1(``0)">
 <summary>A generic hash function, designed to return equal hash values for items that are 
 equal according to the "=" operator. By default it will use structural hashing
 for F# union, record and tuple types, hashing the complete contents of the 
 type. The exact behaviour of the function can be adjusted on a 
 type-by-type basis by implementing GetHashCode for each type.</summary>

 <param name="obj">The input object.</param>

 <returns>The computed hash.</returns>
 
 <example id="hash-example">
 <code lang="fsharp">
 hash "Bob Jones"  // Evaluates to -325251320
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.SizeOf``1">
 <summary>Returns the internal size of a type in bytes. For example, <c>sizeof&lt;int&gt;</c> returns 4.</summary>
 
 <example id="sizeof-example">
 <code lang="fsharp">
 sizeof&lt;bool&gt;                   //  Evaluates to 1
 sizeof&lt;byte&gt;                   //  Evaluates to 1
 sizeof&lt;int&gt;                    //  Evaluates to 4
 sizeof&lt;double&gt;                 //  Evaluates to 8
 sizeof&lt;struct(byte * byte)&gt;    //  Evaluates to 2
 sizeof&lt;nativeint&gt;              //  Evaluates to 4 or 8 (32-bit or 64-bit) depending on your platform
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.TypeDefOf``1">
 <summary>Generate a System.Type representation for a type definition. If the
 input type is a generic type instantiation then return the 
 generic type definition associated with all such instantiations.</summary>
 
 <example id="typedefof-example">
 <code lang="fsharp">
 typeof&lt;int list;&gt;     // Evaluates to Microsoft.FSharp.Collections.FSharpList`1[System.Int32]
 typedefof&lt;int list;&gt;  // Evaluates to Microsoft.FSharp.Collections.FSharpList`1[T]        /// 
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.MethodHandleOf``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>An internal, library-only compiler intrinsic for compile-time 
 generation of a RuntimeMethodHandle.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.NameOf``1(``0)">
 <summary>Returns the name of the given symbol.</summary>
 
 <example id="nameof-example">
 <code lang="fsharp">
 let myVariableName = "This value doesn't matter"
 nameof(myVariableName)   //  Evaluates to "myVariableName"
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.TypeOf``1">
 <summary>Generate a System.Type runtime representation of a static type.</summary>
 
 <example id="typeof-example">
 <code lang="fsharp">
 let t = typeof&lt;int&gt;  // Gets the System.Type
 t.FullName                 // Evaluates to "System.Int32"
 </code>
 </example>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Using``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Clean up resources associated with the input object after the completion of the given function.
 Cleanup occurs even when an exception is raised by the protected
 code. </summary>

 <param name="resource">The resource to be disposed after action is called.</param>
 <param name="action">The action that accepts the resource.</param>

 <returns>The resulting value.</returns>
 
 <example id="using-example">
 The following code appends 10 lines to test.txt, then closes the StreamWriter when finished.
 <code lang="fsharp">
 open System.IO
 
 using (File.AppendText "test.txt") (fun writer ->
     for i in 1 .. 10 do
         writer.WriteLine("Hello World {0}", i))
 
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Lock``2(``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1})">
 <summary>Execute the function as a mutual-exclusion region using the input value as a lock. </summary>

 <param name="lockObject">The object to be locked.</param>
 <param name="action">The action to perform during the lock.</param>

 <returns>The resulting value.</returns>
 
 <example id="lock-example">
 <code lang="fsharp">
 open System.Linq

 /// A counter object, supporting unlocked and locked increment
 type TestCounter () =
     let mutable count = 0
     
     /// Increment the counter, unlocked
     member this.IncrementWithoutLock() =
         count &lt;- count + 1

     /// Increment the counter, locked
     member this.IncrementWithLock() = 
         lock this (fun () -> count &lt;- count + 1)

     /// Get the count
     member this.Count = count
         
 let counter = TestCounter()

 // Create a parallel sequence to that uses all our CPUs
 (seq {1..100000}).AsParallel()
     .ForAll(fun _ -> counter.IncrementWithoutLock())
 
 // Evaluates to a number between 1-100000, non-deterministically because there is no locking
 counter.Count
 
 let counter2 = TestCounter()

 //  Create a parallel sequence to that uses all our CPUs
 (seq {1..100000}).AsParallel()
     .ForAll(fun _ -> counter2.IncrementWithLock())
 
 //  Evaluates to 100000 deterministically because the increment to the counter object is locked
 counter2.Count
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_RangeStep``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,``1,``0)">
 <summary>The standard overloaded skip range operator, e.g. <c>[n..skip..m]</c> for lists, <c>seq {n..skip..m}</c> for sequences</summary>

 <param name="start">The start value of the range.</param>
 <param name="step">The step value of the range.</param>
 <param name="finish">The end value of the range.</param>

 <returns>The sequence spanning the range using the specified step size.</returns>
 
 <example id="range-operator-example">
 <code lang="fsharp">
 [1..2..6]           //  Evaluates to [1; 3; 5]
 [1.1..0.2..1.5]     //  Evaluates to [1.1; 1.3; 1.5]
 ['a'..'e'] //  Evaluates to ['a'; 'b'; 'c'; 'd'; 'e']        
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Range``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0,``0)">
 <summary>The standard overloaded range operator, e.g. <c>[n..m]</c> for lists, <c>seq {n..m}</c> for sequences</summary>

 <param name="start">The start value of the range.</param>
 <param name="finish">The end value of the range.</param>

 <returns>The sequence spanning the range.</returns>
 
 <example id="range-operator-example">
 <code lang="fsharp">
 [1..4]      //  Evaluates to [1; 2; 3; 4]
 [1.5..4.4]  //  Evaluates to [1.5; 2.5; 3.5]
 ['a'..'d']  //  Evaluates to ['a'; 'b'; 'c'; 'd']
 
 [|1..4|]    //  Evaluates to an array [|1; 2; 3; 4|]
 { 1..4 }    //  Evaluates to a sequence [1; 2; 3; 4])
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ConsoleOut``1">
 <summary>Reads the value of the property <see cref="P:System.Console.Out"/>.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ConsoleError``1">
 <summary>Reads the value of the property <see cref="P:System.Console.Error"/>. </summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ConsoleIn``1">
 <summary>Reads the value of the property <see cref="P:System.Console.In"/>. </summary>
</member>
<member name="P:Microsoft.FSharp.Core.Operators.NaNSingle">
 <summary>Equivalent to <see cref="P:System.Single.NaN"/></summary>
</member>
<member name="P:Microsoft.FSharp.Core.Operators.InfinitySingle">
 <summary>Equivalent to <see cref="P:System.Single.PositiveInfinity"/></summary>
</member>
<member name="P:Microsoft.FSharp.Core.Operators.NaN">
 <summary>Equivalent to <see cref="P:System.Double.NaN"/></summary>
</member>
<member name="P:Microsoft.FSharp.Core.Operators.Infinity">
 <summary>Equivalent to <see cref="P:System.Double.PositiveInfinity"/></summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Exit``1(System.Int32)">
 <summary>Exit the current hardware isolated process, if security settings permit,
 otherwise raise an exception. Calls <see cref="M:System.Environment.Exit"/>.</summary>

 <param name="exitcode">The exit code to use.</param>
 
 <returns>Never returns.</returns>
 
 <example id="exit-example">
 <code lang="fsharp">
 [&lt;EntryPoint&gt;]
 let main argv = 
     if argv.Length = 0 then
         eprintfn "You must provide arguments"
         exit(-1)  // Causes program to quit with an error code
     printfn "Argument count: %i" argv.Length
     0 
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.CreateSequence``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a sequence using sequence expression syntax</summary>

 <param name="sequence">The input sequence.</param>

 <returns>The result sequence.</returns>
 
 <example id="seq-cast-example">
 <code lang="fsharp">
 seq { for i in 0..10 do yield (i, i*i) }
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Not(System.Boolean)">
 <summary>Negate a logical value. Not True equals False and not False equals True</summary>

 <param name="value">The value to negate.</param>

 <returns>The result of the negation.</returns>
 
 <example id="not-example">
 <code lang="fsharp">
 not (2 + 2 = 5)     // Evaluates to true 
 
 //  not is a function that can be compose with other functions
 let fileDoesNotExist = System.IO.File.Exists >> not
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Append``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Concatenate two lists.</summary>

 <param name="list1">The first list.</param>
 <param name="list2">The second list.</param>

 <returns>The concatenation of the lists.</returns>
 
 <example id="list-concat-example">
 <code lang="fsharp">
 let l1 = ['a'; 'b'; 'c']
 let l2 = ['d'; 'e'; 'f']
 l1 @ l2   //  Evalulates to ['a'; 'b'; 'c'; 'd'; 'e'; 'f']
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Increment(Microsoft.FSharp.Core.FSharpRef{System.Int32})">
 <summary>Increment a mutable reference cell containing an integer</summary>

 <param name="cell">The reference cell.</param>
 
 <example id="incr-example">
 <code lang="fsharp">
 let count = ref 99  // Creates a reference cell object with a mutable Value property
 incr count          // Increments our counter
 count.Value         // Evaluates to 100
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Decrement(Microsoft.FSharp.Core.FSharpRef{System.Int32})">
 <summary>Decrement a mutable reference cell containing an integer</summary>

 <param name="cell">The reference cell.</param>
 
 <example id="decr-example">
 <code lang="fsharp">
 let count = ref 99  // Creates a reference cell object with a mutable Value property
 decr count          // Decrements our counter
 count.Value         // Evaluates to 98
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Dereference``1(Microsoft.FSharp.Core.FSharpRef{``0})">
 <summary>Dereference a mutable reference cell</summary>

 <param name="cell">The cell to dereference.</param>

 <returns>The value contained in the cell.</returns>
 
 <example id="dereference-example">
 <code lang="fsharp">
 let count = ref 12  // Creates a reference cell object with a mutable Value property
 count.Value         // Evaluates to 12
 !count              // Also evaluates to 12 (with shorter syntax)
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ColonEquals``1(Microsoft.FSharp.Core.FSharpRef{``0},``0)">
 <summary>Assign to a mutable reference cell</summary>

 <param name="cell">The cell to mutate.</param>
 <param name="value">The value to set inside the cell.</param>
 
 <example id="ref-assign-example">
 <code lang="fsharp">
 let count = ref 0   // Creates a reference cell object with a mutable Value property
 count.Value &lt;- 1    // Updates the value
 count := 2          // Also updates the value, but with shorter syntax     
 count.Value         // Evaluates to 2              
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Ref``1(``0)">
 <summary>Create a mutable reference cell</summary>

 <param name="value">The value to contain in the cell.</param>

 <returns>The created reference cell.</returns>
 
 <example id="ref-example">
 <code lang="fsharp">
 let count = ref 0   // Creates a reference cell object with a mutable Value property
 count.Value         // Evaluates to 0
 count.Value &lt;- 1    // Updates the value
 count.Value         // Evaluates to 1        
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Identity``1(``0)">
 <summary>The identity function</summary>

 <param name="x">The input value.</param>

 <returns>The same value.</returns>
 
 <example id="id-example">
 <code lang="fsharp">
 id 12     //  Evaulates to 12
 id "abc"  //  Evaulates to "abc"
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.InvalidOp``1(System.String)">
 <summary>Throw a <see cref="T:System.InvalidOperationException"/> exception</summary>

 <param name="message">The exception message.</param>

 <returns>The result value.</returns>
 
 <example id="invalidop-example">
 <code lang="fsharp">
 type FileReader(fileName: string) = 
     let mutable isOpen = false
     member this.Open() = 
       if isOpen then invalidOp "File is already open"
       //  ... Here we may open the file ...
       isOpen &lt;- true
 
 let reader = FileReader("journal.txt")
 reader.Open()  //  Executes fine
 reader.Open()  //  Throws System.InvalidOperationException: File is already open
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.NullArg``1(System.String)">
 <summary>Throw a <see cref="T:System.ArgumentNullException"/> exception</summary>

 <param name="argumentName">The argument name.</param>

 <returns>Never returns.</returns>
 
 <example id="nullarg-example">
 <code lang="fsharp">
 let fullName firstName lastName = 
     nullArg (nameof(firstName))
     nullArg (nameof(lastName))
     firstName + " " + lastName
   
   fullName null "Jones"  // Throws System.ArgumentNullException: Value cannot be null. (Parameter 'firstName')
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.InvalidArg``1(System.String,System.String)">
 <summary>Throw a <see cref="T:System.ArgumentException"/> exception with
 the given argument name and message.</summary>

 <param name="argumentName">The argument name.</param>
 <param name="message">The exception message.</param>

 <returns>Never returns.</returns>

 <example id="invalidarg-example">
 <code lang="fsharp">
 let fullName firstName lastName = 
     if String.IsNullOrWhiteSpace(firstName) then
         invalidArg (nameof(firstName)) "First name can't be null or blank"
         if String.IsNullOrWhiteSpace(lastName) then
             invalidArg (nameof(lastName)) "Last name can't be null or blank"
     firstName + " " + lastName
   
 fullName null "Jones"
 </code>
 Throws <c>System.ArgumentException: First name can't be null or blank (Parameter 'firstName')</c>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.FailWith``1(System.String)">
 <summary>Throw a <see cref="T:System.Exception"/> exception.</summary>

 <param name="message">The exception message.</param>

 <returns>Never returns.</returns>

 <example id="failwith-example">
 <code lang="fsharp">
 let failingFunction() = 
     failwith "Oh no" // Throws an exception
     true  // Never reaches this
   
 failingFunction()  // Throws a System.Exception
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.IsNotNull``1(``0)">
 <summary>Determines whether the given value is not null.</summary>

 <param name="value">The value to check.</param>

 <returns>True when value is not null, false otherwise.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.IsNull``1(``0)">
 <summary>Determines whether the given value is null.</summary>

 <param name="value">The value to check.</param>

 <returns>True when value is null, false otherwise.</returns>
 
 <example id="isnull-example">
 <code lang="fsharp">
 isNull null        //  Evaluates to true
 isNull "Not null"  //  Evaluates to false
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.TryUnbox``1(System.Object)">
 <summary>Try to unbox a strongly typed value.</summary>

 <param name="value">The boxed value.</param>

 <returns>The unboxed result as an option.</returns>
 
 <example id="tryunbox-example">
 <code lang="fsharp">
 let x: int = 123
 let obj1 = box x    //  obj1 is a generic object type
 tryUnbox&lt;int&gt; obj1     //  Evaluates to Some(123)
 tryUnbox&lt;double&gt; obj1  //  Evaluates to None
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Box``1(``0)">
 <summary>Boxes a strongly typed value.</summary>

 <param name="value">The value to box.</param>

 <returns>The boxed object.</returns>
 
 <example id="box-example">
 <code lang="fsharp">
 let x: int = 123
 let obj1 = box x    //  obj1 is a generic object type
 unbox&lt;int&gt; obj1     //  Evaluates to 123 (int)
 unbox&lt;double&gt; obj1  //  Throws System.InvalidCastException
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Unbox``1(System.Object)">
 <summary>Unbox a strongly typed value.</summary>

 <param name="value">The boxed value.</param>

 <returns>The unboxed result.</returns>
 
 <example id="unbox-example">
 <code lang="fsharp">
 let x: int = 123
 let obj1 = box x    //  obj1 is a generic object type
 unbox&lt;int&gt; obj1     //  Evaluates to 123 (int)
 unbox&lt;double&gt; obj1  //  Throws System.InvalidCastException
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Ignore``1(``0)">
 <summary>Ignore the passed value. This is often used to throw away results of a computation.</summary>

 <param name="value">The value to ignore.</param>
 
 <example id="min-example">
 <code lang="fsharp">
  ignore 55555   //  Evaluates to ()
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Min``1(``0,``0)">
 <summary>Minimum based on generic comparison</summary>

 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>

 <returns>The minimum value.</returns>
 
 <example id="min-example">
 <code lang="fsharp">
  min 1 2             //  Evaluates to 1
  min [1;2;3] [1;2;4] //  Evaluates to [1;2;3]
  min "zoo" "alpha"   //  Evaluates to "alpha"
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Max``1(``0,``0)">
 <summary>Maximum based on generic comparison</summary>

 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>

 <returns>The maximum value.</returns>
 
 <example id="max-example">
 <code lang="fsharp">
  max 1 2             //  Evaluates to 2
  max [1;2;3] [1;2;4] //  Evaluates to [1;2;4]
  max "zoo" "alpha"   //  Evaluates to "zoo"
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Compare``1(``0,``0)">
 <summary>Generic comparison.</summary>

 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>

 <returns>The result of the comparison.</returns>
 
 <example id="compare-example">
 <code lang="fsharp">
 compare 1 2             //  Evaluates to -1
 compare [1;2;3] [1;2;4] //  Evaluates to -1
 compare 2 2             //  Evaluates to 0
 compare [1;2;3] [1;2;3] //  Evaluates to 0
 compare 2 1             //  Evaluates to 1
 compare [1;2;4] [1;2;3] //  Evaluates to 1
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Snd``2(System.Tuple{``0,``1})">
 <summary>Return the second element of a tuple, <c>snd (a,b) = b</c>.</summary>

 <param name="tuple">The input tuple.</param>

 <returns>The second value.</returns>
 
 <example id="snd-example">
 <code lang="fsharp">
 snd ("first", 2)  //  Evaluates to 2
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Fst``2(System.Tuple{``0,``1})">
 <summary>Return the first element of a tuple, <c>fst (a,b) = a</c>.</summary>

 <param name="tuple">The input tuple.</param>

 <returns>The first value.</returns>
 
 <example id="fst-example">
 <code lang="fsharp">
 fst ("first", 2)  //  Evaluates to "first"
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.FailurePattern(System.Exception)">
 <summary>Matches <see cref="T:System.Exception"/> objects whose runtime type is precisely <see cref="T:System.Exception"/></summary>

 <param name="error">The input exception.</param>

 <returns>A string option.</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Failure(System.String)">
 <summary>Builds a <see cref="T:System.Exception"/> object.</summary>

 <param name="message">The message for the Exception.</param>

 <returns>A System.Exception.</returns>
 
 <example id="failure-example">
 <code lang="fsharp">
 let throwException() = 
     raise(Failure("Oh no!!!")) 
     true  // Never gets here
   
   throwException() //  Throws a generic Exception class
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Reraise``1">
 <summary>Rethrows an exception. This should only be used when handling an exception</summary>
 <returns>The result value.</returns>
 
 <example id="reraise-example">
 <code lang="fsharp">
 let readFile (fileName: string) = 
   try
     File.ReadAllText(fileName)
   with ex ->
     eprintfn "Couldn't read %s" fileName
     reraise()
   
 readFile "/this-file-doest-exist"  
 //  Prints the message to stderr
 //  Throws a System.IO.FileNotFoundException
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Rethrow``1">
 <summary>Rethrows an exception. This should only be used when handling an exception</summary>
 <returns>The result value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Raise``1(System.Exception)">
 <summary>Raises an exception</summary>

 <param name="exn">The exception to raise.</param>

 <returns>The result value.</returns>
 
 <example id="raise-example">
 <code lang="fsharp">
 open System.IO
 exception FileNotFoundException of string
 
 let readFile (fileName: string) = 
     if not (File.Exists(fileName)) then
         raise(FileNotFoundException(fileName))
     File.ReadAllText(fileName)
 
 readFile "/this-file-doest-exist"
 </code>
 When executed, raises a <c>FileNotFoundException</c>.
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Concatenate(System.String,System.String)">
 <summary>Concatenate two strings. The operator '+' may also be used.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.DefaultValueArg``1(Microsoft.FSharp.Core.FSharpValueOption{``0},``0)">
 <summary>Used to specify a default value for an optional argument in the implementation of a function</summary>

 <param name="arg">A value option representing the argument.</param>
 <param name="defaultValue">The default value of the argument.</param>

 <returns>The argument value. If it is None, the defaultValue is returned.</returns>
 
 <example id="defaultValueArg-example">
 <code lang="fsharp">
 let arg1 = ValueSome(5)
 defaultValueArg arg1 6       //  Evaluates to 5
 defaultValueArg ValueNone 6  //  Evaluates to 6
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.DefaultArg``1(Microsoft.FSharp.Core.FSharpOption{``0},``0)">
 <summary>Used to specify a default value for an optional argument in the implementation of a function</summary>

 <param name="arg">An option representing the argument.</param>
 <param name="defaultValue">The default value of the argument.</param>

 <returns>The argument value. If it is None, the defaultValue is returned.</returns>
 
 <example id="defaultArg-example">
 <code lang="fsharp">
 type Vector(x: double, y: double, ?z: double) = 
     let z = defaultArg z 0.0
     member this.X = x
     member this.Y = y
     member this.Z = z
 
 let v1 = Vector(1.0, 2.0)
 v1.Z  // Evaluates to 0.
 let v2 = Vector(1.0, 2.0, 3.0)
 v2.Z  // Evaluates to 3.0
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeLeft3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},``0,``1,``2)">
 <summary>Apply a function to three values, the values being a triple on the right, the function on the left</summary>

 <param name="func">The function.</param>
 <param name="arg1">The first argument.</param>
 <param name="arg2">The second argument.</param>
 <param name="arg3">The third argument.</param>

 <returns>The function result.</returns>
 
 <example id="left-triple-pipeline-example">
 <code lang="fsharp">
 let sum3 x y z = x + y + z
 sum3 &lt;||| (3, 4, 5)   // Evaluates to 12
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeLeft2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,``1)">
 <summary>Apply a function to two values, the values being a pair on the right, the function on the left</summary>

 <param name="func">The function.</param>
 <param name="arg1">The first argument.</param>
 <param name="arg2">The second argument.</param>

 <returns>The function result.</returns>
 
 <example id="left-double-pipeline-example">
 <code lang="fsharp">
 let sum x y = x + y
 sum &lt;|| (3, 4)   // Evaluates to 7
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeLeft``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
 <summary>Apply a function to a value, the value being on the right, the function on the left</summary>

 <param name="func">The function.</param>
 <param name="arg1">The argument.</param>

 <returns>The function result.</returns>
 
 <example id="left-pipeline-example">
 <code lang="fsharp">
 let doubleIt x = x * 2
 doubleIt &lt;| 3  //  Evaluates to 6
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeRight3``4(``0,``1,``2,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}})">
 <summary>Apply a function to three values, the values being a triple on the left, the function on the right</summary>

 <param name="arg1">The first argument.</param>
 <param name="arg2">The second argument.</param>
 <param name="arg3">The third argument.</param>
 <param name="func">The function.</param>

 <returns>The function result.</returns>
 
 <example id="triple-pipeline-example">
 <code lang="fsharp">
 let sum3 x y z = x + y + z
 (3, 4, 5) |||> sum3   // Evaluates to 12
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeRight2``3(``0,``1,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
 <summary>Apply a function to two values, the values being a pair on the left, the function on the right</summary>

 <param name="arg1">The first argument.</param>
 <param name="arg2">The second argument.</param>
 <param name="func">The function.</param>

 <returns>The function result.</returns>
 
 <example id="double-pipeline-example">
 <code lang="fsharp">
 let sum x y = x + y
 (3, 4) ||> sum   // Evaluates to 7
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeRight``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Apply a function to a value, the value being on the left, the function on the right</summary>

 <param name="arg">The argument.</param>
 <param name="func">The function.</param>

 <returns>The function result.</returns>
 
 <example id="pipeline-example">
 <code lang="fsharp">
 let doubleIt x = x * 2
 3 |> doubleIt  //  Evaluates to 6
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ComposeLeft``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``0})">
 <summary>Compose two functions, the function on the right being applied first</summary>

 <param name="func2">The second function to apply.</param>
 <param name="func1">The first function to apply.</param>

 <returns>The composition of the input functions.</returns>
 
 <example id="right-compose-example">
 <code lang="fsharp">
 let addOne x = x + 1
 let doubleIt x = x * 2
 let doubleThenAdd = addOne &lt;&lt; doubleIt
 doubleThenAdd 3  
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ComposeRight``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``2})">
 <summary>Compose two functions, the function on the left being applied first</summary>

 <param name="func1">The first function to apply.</param>
 <param name="func2">The second function to apply.</param>

 <returns>The composition of the input functions.</returns>
 
 <example id="compose-example">
 <code lang="fsharp">
 let addOne x = x + 1
 let doubleIt x = x * 2
 let addThenDouble = addOne >> doubleIt
 addThenDouble 3  // Evaluates to 8
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Inequality``1(``0,``0)">
 <summary>Structural inequality</summary>

 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>

 <returns>The result of the comparison.</returns>
 
 <example id="compare-not-equal-example">
 <code lang="fsharp">
  5 &lt;&gt; 5              // Evaluates to false
  5 &lt;&gt; 6              // Evaluates to true
  [1; 2] &lt;&gt; [1; 2]    // Evaluates to false
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Equality``1(``0,``0)">
 <summary>Structural equality</summary>

 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>

 <returns>The result of the comparison.</returns>
 
 <example id="compare-equal-example">
 <code lang="fsharp">
  5 = 5              // Evaluates to true
  5 = 6              // Evaluates to false
  [1; 2] = [1; 2]    // Evaluates to true
  (1, 5) = (1, 6)    // Evaluates to false
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LessThanOrEqual``1(``0,``0)">
 <summary>Structural less-than-or-equal comparison</summary>

 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>

 <returns>The result of the comparison.</returns>
 
 <example id="compare-less-than-or-equal-example">
 <code lang="fsharp">
  5 &lt;= 1              // Evaluates to false
  5 &lt;= 5              // Evaluates to true
  [1; 5] &lt;= [1; 6]    // Evaluates to true
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_GreaterThanOrEqual``1(``0,``0)">
 <summary>Structural greater-than-or-equal</summary>

 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>

 <returns>The result of the comparison.</returns>
 
 <example id="compare-greater-than-or-equal-example">
 <code lang="fsharp">
  5 >= 1              // Evaluates to true
  5 >= 5              // Evaluates to true
  [1; 5] >= [1; 6]    // Evaluates to false
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_GreaterThan``1(``0,``0)">
 <summary>Structural greater-than</summary>

 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>

 <returns>The result of the comparison.</returns>
 
 <example id="compare-greather-than-example">
 <code lang="fsharp">
  5 &gt; 1               // Evaluates to true
  5 &gt; 5               // Evaluates to false
  (1, "a") &gt; (1, "z") // Evaluates to false
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LessThan``1(``0,``0)">
 <summary>Structural less-than comparison</summary>

 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>

 <returns>The result of the comparison.</returns>
 
 <example id="compare-less-than-example">
 <code lang="fsharp">
 1 &lt; 5               // Evaluates to true
 5 &lt; 5               // Evaluates to false
 (1, "a") &lt; (1, "z") // Evaluates to true
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_UnaryPlus``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0)">
 <summary>Overloaded prefix-plus operator</summary>

 <param name="value">The input value.</param>

 <returns>The result of the operation.</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LogicalNot``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0)">
 <summary>Overloaded bitwise-NOT operator</summary>

 <param name="value">The input value.</param>

 <returns>The result of the operation.</returns>
 
 <example id="bitwise-not-example-1">
 <code lang="fsharp">
 let byte1 = 60uy  //  00111100
 let byte2 = ~~~b1 //  11000011
 </code>
 Evaluates to 195
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_RightShift``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}},``0,System.Int32)">
 <summary>Overloaded byte-shift right operator by a specified number of bits</summary>

 <param name="value">The input value.</param>
 <param name="shift">The amount to shift.</param>

 <returns>The result of the operation.</returns>
 
 <example id="right-shift-example-1">
 <code lang="fsharp">
 let a = 206      // 00000000000000000000000011010000
 let c1 = a &gt;&gt;&gt; 2  // 00000000000000000000000000110100
 // Evaluates to 51
 let c2 = a &gt;&gt;&gt; 6  // 00000000000000000000000000000011
 Evaluates to 3
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LeftShift``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}},``0,System.Int32)">
 <summary>Overloaded byte-shift left operator by a specified number of bits</summary>

 <param name="value">The input value.</param>
 <param name="shift">The amount to shift.</param>

 <returns>The result of the operation.</returns>
 
 <example id="left-shift-example-1">
 <code lang="fsharp">
 let a = 13       // 00000000000000000000000000001101
 let c = a &lt;&lt;&lt; 4   // 00000000000000000000000011010000
 </code>
 Evaluates to 208
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ExclusiveOr``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0,``0)">
 <summary>Overloaded bitwise-XOR operator</summary>

 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>

 <returns>The result of the operation.</returns>
 
 <example id="bitwise-xor-example-1">
 <code lang="fsharp">
 let a = 13       // 00000000000000000000000000001101
 let b = 11       // 00000000000000000000000000001011
 let c = a ^^^ b  // 00000000000000000000000000000110
 </code>
 Evaluates to 6
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_BitwiseOr``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0,``0)">
 <summary>Overloaded bitwise-OR operator</summary>

 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>

 <returns>The result of the operation.</returns>
 
 <example id="bitwise-or-example-1">
 <code lang="fsharp">
 let a = 13       // 00000000000000000000000000001101
 let b = 11       // 00000000000000000000000000001011
 let c = a ||| b  // 00000000000000000000000000001111
 </code>
 Evaluates to 15
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_BitwiseAnd``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0,``0)">
 <summary>Overloaded bitwise-AND operator</summary>

 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>

 <returns>The result of the operation.</returns>
 
 <example id="bitwise-and-example-1">
 <code lang="fsharp">
 let a = 13       // 00000000000000000000000000001101
 let b = 11       // 00000000000000000000000000001011
 let c = a &amp;&amp;&amp; b  // 00000000000000000000000000001001
 </code>
 Evaluates to 9
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Modulus``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,``1)">
 <summary>Overloaded modulo operator</summary>

 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>

 <returns>The result of the operation.</returns>
 
 <example id="modulo-example-1">
 <code lang="fsharp">
 29 % 5 //  Evaluates to 4
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Division``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,``1)">
 <summary>Overloaded division operator</summary>

 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>

 <returns>The result of the operation.</returns>
 
 <example id="division-example-1">
 <code lang="fsharp">
 16 / 2 //  Evaluates to 8
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Multiply``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,``1)">
 <summary>Overloaded multiplication operator</summary>

 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>

 <returns>The result of the operation.</returns>
 
 <example id="multiplication-example-1">
 <code lang="fsharp">
 8 * 6 //  Evaluates to 48
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Subtraction``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,``1)">
 <summary>Overloaded subtraction operator</summary>

 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>

 <returns>The result of the operation.</returns>
 
 <example id="subtraction-example-1">
 <code lang="fsharp">
 10 - 2 //  Evaluates to 8
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Addition``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,``1)">
 <summary>Overloaded addition operator</summary>

 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>

 <returns>The result of the operation.</returns>
 
 <example id="addition-example-1">
 <code lang="fsharp">
 2 + 2 //  Evaluates to 4
 "Hello " + "Word" // Evaluates to "Hello World"
 </code>
 </example>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_UnaryNegation``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0)">
 <summary>Overloaded unary negation.</summary>

 <param name="n">The value to negate.</param>

 <returns>The result of the operation.</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToChar``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Char},``0)">
 <summary>Converts the argument to <c>char</c>. Numeric inputs are converted using a checked 
 conversion according to the UTF-16 encoding for characters. String inputs must 
 be exactly one character long. For other input types the operation requires an 
 appropriate static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted char</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToUIntPtr``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.UIntPtr},``0)">
 <summary>Converts the argument to <c>unativeint</c>. This is a direct, checked conversion for all 
 primitive numeric types. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted unativeint</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToIntPtr``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.IntPtr},``0)">
 <summary>Converts the argument to <see cref="T:Microsoft.FSharp.Core.nativeint" />. This is a direct, checked conversion for all 
 primitive numeric types. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted nativeint</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToUInt64``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.UInt64},``0)">
 <summary>Converts the argument to <c>uint64</c>. This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using <see cref="M:System.UInt64.Parse"/> 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted uint64</returns>
 
 <example-tbd></example-tbd>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToInt64``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Int64},``0)">
 <summary>Converts the argument to <c>int64</c>. This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using <see cref="M:System.Int64.Parse"/> 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted int64</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToUInt32``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.UInt32},``0)">
 <summary>Converts the argument to <c>uint32</c>. This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using <see cref="M:System.UInt32.Parse"/> 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted uint32</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToInt32``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32},``0)">
 <summary>Converts the argument to <c>int32</c>. This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using <see cref="M:System.Int32.Parse"/> 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted int32</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToInt``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32},``0)">
 <summary>Converts the argument to <c>int</c>. This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using <see cref="M:System.Int32.Parse"/> 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted int</returns>
 
 <example-tbd></example-tbd>
  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToUInt16``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.UInt16},``0)">
 <summary>Converts the argument to <c>uint16</c>. This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using <see cref="M:System.UInt16.Parse"/> 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted uint16</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToInt16``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Int16},``0)">
 <summary>Converts the argument to <c>int16</c>. This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using <see cref="M:System.Int16.Parse"/> 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted int16</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToSByte``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.SByte},``0)">
 <summary>Converts the argument to <c>sbyte</c>. This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using <see cref="M:System.SByte.Parse"/> 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted sbyte</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToByte``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Byte},``0)">
 <summary>Converts the argument to <c>byte</c>. This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using <see cref="M:System.Byte.Parse"/> 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>

 <param name="value">The input value.</param>

 <returns>The converted byte</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.op_Multiply``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,``1)">
 <summary>Overloaded multiplication operator (checks for overflow)</summary>

 <param name="x">The first value.</param>
 <param name="y">The second value.</param>

 <returns>The product of the two input values.</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.op_Addition``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,``1)">
 <summary>Overloaded addition operator (checks for overflow)</summary>

 <param name="x">The first value.</param>
 <param name="y">The second value.</param>

 <returns>The sum of the two input values.</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.op_Subtraction``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,``1)">
 <summary>Overloaded subtraction operator (checks for overflow)</summary>

 <param name="x">The first value.</param>
 <param name="y">The second value.</param>

 <returns>The first value minus the second value.</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.op_UnaryNegation``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0)">
 <summary>Overloaded unary negation (checks for overflow)</summary>

 <param name="value">The input value.</param>

 <returns>The negated value.</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="T:Microsoft.FSharp.Core.Operators.Checked">
 <summary>This module contains the basic arithmetic operations with overflow checks.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.NonStructuralComparison.Hash``1(``0)">
 <summary>Calls GetHashCode() on the value</summary>

 <param name="value">The value.</param>

 <returns>The hash code.</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.NonStructuralComparison.Min``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},``0,``0)">
 <summary>Minimum of the two values</summary>

 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>

 <returns>The minimum value.</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.NonStructuralComparison.Max``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},``0,``0)">
 <summary>Maximum of the two values</summary>

 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>

 <returns>The maximum value.</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.NonStructuralComparison.Compare``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},``0,``0)">
 <summary>Compares the two values</summary>

 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>

 <returns>The result of the comparison.</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.NonStructuralComparison.op_Inequality``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},``0,``0)">
 <summary>Compares the two values for inequality</summary>

 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>

 <returns>The result of the comparison.</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.NonStructuralComparison.op_Equality``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},``0,``0)">
 <summary>Compares the two values for equality</summary>

 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>

 <returns>The result of the comparison.</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.NonStructuralComparison.op_LessThanOrEqual``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},``0,``1)">
 <summary>Compares the two values for less-than-or-equal</summary>

 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>

 <returns>The result of the comparison.</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.NonStructuralComparison.op_GreaterThanOrEqual``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},``0,``1)">
 <summary>Compares the two values for greater-than-or-equal</summary>

 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>

 <returns>The result of the comparison.</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.NonStructuralComparison.op_GreaterThan``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},``0,``1)">
 <summary>Compares the two values for greater-than</summary>

 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>

 <returns>The result of the comparison.</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.NonStructuralComparison.op_LessThan``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},``0,``1)">
 <summary>Compares the two values for less-than</summary>

 <param name="x">The first parameter.</param>
 <param name="y">The second parameter.</param>

 <returns>The result of the comparison.</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="T:Microsoft.FSharp.Core.Operators.NonStructuralComparison">
 <summary>A module of comparison and equality operators that are statically resolved, but which are not fully generic and do not make structural comparison. Opening this
 module may make code that relies on structural or generic comparison no longer compile.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Unchecked.Hash``1(``0)">
 <summary>Perform generic hashing on a value where the type of the value is not
 statically required to satisfy the 'equality' constraint. </summary>
 <returns>The computed hash value.</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Unchecked.Equals``1(``0,``0)">
 <summary>Perform generic equality on two values where the type of the values is not
 statically required to satisfy the 'equality' constraint. </summary>
 <returns>The result of the comparison.</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Unchecked.Compare``1(``0,``0)">
 <summary>Perform generic comparison on two values where the type of the values is not
 statically required to have the 'comparison' constraint. </summary>
 <returns>The result of the comparison.</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Unchecked.DefaultOf``1">
 <summary>Generate a default value for any type. This is null for reference types, 
 For structs, this is struct value where all fields have the default value. 
 This function is unsafe in the sense that some F# values do not have proper <c>null</c> values.</summary>
 
 <example-tbd></example-tbd>
 
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Unchecked.Unbox``1(System.Object)">
 <summary>Unboxes a strongly typed value. This is the inverse of <c>box</c>, unbox&lt;t&gt;(box&lt;t&gt; a) equals a.</summary>

 <param name="value">The boxed value.</param>

 <returns>The unboxed result.</returns>
 
 <example-tbd></example-tbd>
 
</member>
<member name="T:Microsoft.FSharp.Core.Operators.Unchecked">
 <summary>This module contains basic operations which do not apply runtime and/or static checks</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowGeneric``1(``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowDecimal(System.Decimal,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'decimal'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowDouble(System.Double,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'float'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowSingle(System.Single,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'float32'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowUIntPtr(System.UIntPtr,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'unativeint'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowIntPtr(System.IntPtr,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'nativeint'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowUInt64(System.UInt64,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'uint64'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowInt64(System.Int64,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'int64'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowUInt32(System.UInt32,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'uint32'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowInt32(System.Int32,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'int32'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowUInt16(System.UInt16,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'uint16'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowInt16(System.Int16,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'int16'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowSByte(System.SByte,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'sbyte'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowByte(System.Byte,System.Int32)">
 <summary>This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'byte'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowDynamic``2(``0,``1)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.TanhDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.TanDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SinhDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SinDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.CoshDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.CosDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SqrtDynamic``2(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.Log10Dynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.LogDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SignDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RoundDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.TruncateDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.FloorDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.ExpDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.CeilingDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.Atan2Dynamic``2(``0,``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.AtanDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.AsinDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.AcosDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.AbsDynamic``1(``0)">
 <summary>This is a library intrinsic. Calls to this function may be generated by evaluating quotations.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeStepGeneric``2(``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1,``0,``1)">
 <summary>Generate a range of values using the given zero, add, start, step and stop values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeGeneric``1(``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0,``0)">
 <summary>Generate a range of values using the given zero, add, start, step and stop values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeChar(System.Char,System.Char)">
 <summary>Generate a range of char values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeByte(System.Byte,System.Byte,System.Byte)">
 <summary>Generate a range of byte values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeSByte(System.SByte,System.SByte,System.SByte)">
 <summary>Generate a range of sbyte values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeUInt16(System.UInt16,System.UInt16,System.UInt16)">
 <summary>Generate a range of uint16 values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeInt16(System.Int16,System.Int16,System.Int16)">
 <summary>Generate a range of int16 values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeUIntPtr(System.UIntPtr,System.UIntPtr,System.UIntPtr)">
 <summary>Generate a range of unativeint values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeIntPtr(System.IntPtr,System.IntPtr,System.IntPtr)">
 <summary>Generate a range of nativeint values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeUInt32(System.UInt32,System.UInt32,System.UInt32)">
 <summary>Generate a range of uint32 values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeUInt64(System.UInt64,System.UInt64,System.UInt64)">
 <summary>Generate a range of uint64 values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeInt64(System.Int64,System.Int64,System.Int64)">
 <summary>Generate a range of int64 values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeSingle(System.Single,System.Single,System.Single)">
 <summary>Generate a range of float32 values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeDouble(System.Double,System.Double,System.Double)">
 <summary>Generate a range of float values</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeInt32(System.Int32,System.Int32,System.Int32)">
 <summary>Generate a range of integers</summary>  
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetStringSlice(System.String,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Gets a slice from a string</summary>

 <param name="source">The source string.</param>
 <param name="start">The index of the first character of the slice.</param>
 <param name="finish">The index of the last character of the slice.</param>

 <returns>The substring from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice4D``1(``0[0:, 0:, 0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},``0[0:, 0:, 0:])">
 <summary>Sets a slice of an array</summary>

 <param name="target">The target array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>
 <param name="start4">The start index of the fourth dimension.</param>
 <param name="finish4">The end index of the fourth dimension.</param>
 <param name="source">The source array.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice4DFixedTriple1``1(``0[0:, 0:, 0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,System.Int32,System.Int32,``0[])">
 <summary>Sets a 1D slice of a 4D array</summary>

 <param name="target">The target array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="index2">The fixed index of the second dimension.</param>
 <param name="index3">The fixed index of the third dimension.</param>
 <param name="index4">The fixed index of the fourth dimension.</param>
 <param name="source">The source array.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice4DFixedTriple2``1(``0[0:, 0:, 0:],System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,System.Int32,``0[])">
 <summary>Sets a 1D slice of a 4D array</summary>

 <param name="target">The target array.</param>
 <param name="index1">The fixed index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="index3">The fixed index of the third dimension.</param>
 <param name="index4">The fixed index of the fourth dimension.</param>
 <param name="source">The source array.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice4DFixedTriple3``1(``0[0:, 0:, 0:],System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,``0[])">
 <summary>Sets a 1D slice of a 4D array</summary>

 <param name="target">The target array.</param>
 <param name="index1">The fixed index of the first dimension.</param>
 <param name="index2">The fixed index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>
 <param name="index4">The fixed index of the fourth dimension.</param>
 <param name="source">The source array.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice4DFixedTriple4``1(``0[0:, 0:, 0:],System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},``0[])">
 <summary>Sets a 1D slice of a 4D array</summary>

 <param name="target">The target array.</param>
 <param name="index1">The fixed index of the first dimension.</param>
 <param name="index2">The fixed index of the second dimension.</param>
 <param name="index3">The fixed index of the third dimension.</param>
 <param name="start4">The start index of the fourth dimension.</param>
 <param name="finish4">The end index of the fourth dimension.</param>
 <param name="source">The source array.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice4DFixedDouble6``1(``0[0:, 0:, 0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,System.Int32,``0[0:])">
 <summary>Sets a 2D slice of a 4D array</summary>

 <param name="target">The target array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="index3">The fixed index of the third dimension.</param>
 <param name="index4">The fixed index of the fourth dimension.</param>
 <param name="source">The source array.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice4DFixedDouble5``1(``0[0:, 0:, 0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,``0[0:])">
 <summary>Sets a 2D slice of a 4D array</summary>

 <param name="target">The target array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="index2">The fixed index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>
 <param name="index4">The fixed index of the fourth dimension.</param>
 <param name="source">The source array.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice4DFixedDouble4``1(``0[0:, 0:, 0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},``0[0:])">
 <summary>Sets a 2D slice of a 4D array</summary>

 <param name="target">The target array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="index2">The fixed index of the second dimension.</param>
 <param name="index3">The fixed index of the third dimension.</param>
 <param name="start4">The start index of the fourth dimension.</param>
 <param name="finish4">The end index of the fourth dimension.</param>
 <param name="source">The source array.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice4DFixedDouble3``1(``0[0:, 0:, 0:],System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,``0[0:])">
 <summary>Sets a 2D slice of a 4D array</summary>

 <param name="target">The target array.</param>
 <param name="index1">The fixed index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>
 <param name="index4">The fixed index of the fourth dimension.</param>
 <param name="source">The source array.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice4DFixedDouble2``1(``0[0:, 0:, 0:],System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},``0[0:])">
 <summary>Sets a 2D slice of a 4D array</summary>

 <param name="target">The target array.</param>
 <param name="index1">The fixed index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="index3">The fixed index of the third dimension.</param>
 <param name="start4">The start index of the fourth dimension.</param>
 <param name="finish4">The end index of the fourth dimension.</param>
 <param name="source">The source array.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice4DFixedDouble1``1(``0[0:, 0:, 0:],System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},``0[0:])">
 <summary>Sets a 2D slice of a 4D array</summary>

 <param name="target">The target array.</param>
 <param name="index1">The fixed index of the first dimension.</param>
 <param name="index2">The fixed index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>
 <param name="start4">The start index of the fourth dimension.</param>
 <param name="finish4">The end index of the fourth dimension.</param>
 <param name="source">The source array.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice4DFixedSingle4``1(``0[0:, 0:, 0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,``0[0:, 0:])">
 <summary>Sets a 3D slice of a 4D array</summary>

 <param name="target">The target array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>
 <param name="index4">The fixed index of the fourth dimension.</param>
 <param name="source">The source array.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice4DFixedSingle3``1(``0[0:, 0:, 0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},``0[0:, 0:])">
 <summary>Sets a 3D slice of a 4D array</summary>

 <param name="target">The target array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="index3">The fixed index of the third dimension.</param>
 <param name="start4">The start index of the fourth dimension.</param>
 <param name="finish4">The end index of the fourth dimension.</param>
 <param name="source">The source array.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice4DFixedSingle2``1(``0[0:, 0:, 0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},``0[0:, 0:])">
 <summary>Sets a 3D slice of a 4D array</summary>

 <param name="target">The target array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="index2">The fixed index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>
 <param name="start4">The start index of the fourth dimension.</param>
 <param name="finish4">The end index of the fourth dimension.</param>
 <param name="source">The source array.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice4DFixedSingle1``1(``0[0:, 0:, 0:],System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},``0[0:, 0:])">
 <summary>Sets a 3D slice of a 4D array</summary>

 <param name="target">The target array.</param>
 <param name="index1">The fixed index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>
 <param name="start4">The start index of the fourth dimension.</param>
 <param name="finish4">The end index of the fourth dimension.</param>
 <param name="source">The source array.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice4DFixedTriple1``1(``0[0:, 0:, 0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,System.Int32,System.Int32)">
 <summary>Gets a 1D slice of a 4D array</summary>

 <param name="source">The source array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="index2">The fixed index of the second dimension.</param>
 <param name="index3">The fixed index of the third dimension.</param>
 <param name="index4">The fixed index of the fourth dimension.</param>

 <returns>The one dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice4DFixedTriple2``1(``0[0:, 0:, 0:],System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,System.Int32)">
 <summary>Gets a 1D slice of a 4D array</summary>

 <param name="source">The source array.</param>
 <param name="index1">The fixed index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="index3">The fixed index of the third dimension.</param>
 <param name="index4">The fixed index of the fourth dimension.</param>

 <returns>The one dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice4DFixedTriple3``1(``0[0:, 0:, 0:],System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32)">
 <summary>Gets a 1D slice of a 4D array</summary>

 <param name="source">The source array.</param>
 <param name="index1">The fixed index of the first dimension.</param>
 <param name="index2">The fixed index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>
 <param name="index4">The fixed index of the fourth dimension.</param>

 <returns>The one dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice4DFixedTriple4``1(``0[0:, 0:, 0:],System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Gets a 1D slice of a 4D array</summary>

 <param name="source">The source array.</param>
 <param name="index1">The fixed index of the first dimension.</param>
 <param name="index2">The fixed index of the second dimension.</param>
 <param name="index3">The fixed index of the third dimension.</param>
 <param name="start4">The start index of the fourth dimension.</param>
 <param name="finish4">The end index of the fourth dimension.</param>

 <returns>The one dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice4DFixedDouble6``1(``0[0:, 0:, 0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,System.Int32)">
 <summary>Gets a 2D slice of a 4D array</summary>

 <param name="source">The source array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="index3">The fixed index of the third dimension.</param>
 <param name="index4">The fixed index of the fourth dimension.</param>

 <returns>The two dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice4DFixedDouble5``1(``0[0:, 0:, 0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32)">
 <summary>Gets a 2D slice of a 4D array</summary>

 <param name="source">The source array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="index2">The fixed index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>
 <param name="index4">The fixed index of the fourth dimension.</param>

 <returns>The two dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice4DFixedDouble4``1(``0[0:, 0:, 0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Gets a 2D slice of a 4D array</summary>

 <param name="source">The source array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="index2">The fixed index of the second dimension.</param>
 <param name="index3">The fixed index of the third dimension.</param>
 <param name="start4">The start index of the fourth dimension.</param>
 <param name="finish4">The end index of the fourth dimension.</param>

 <returns>The two dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice4DFixedDouble3``1(``0[0:, 0:, 0:],System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32)">
 <summary>Gets a 2D slice of a 4D array</summary>

 <param name="source">The source array.</param>
 <param name="index1">The fixed index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>
 <param name="index4">The fixed index of the fourth dimension.</param>

 <returns>The two dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice4DFixedDouble2``1(``0[0:, 0:, 0:],System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Gets a 2D slice of a 4D array</summary>

 <param name="source">The source array.</param>
 <param name="index1">The fixed index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="index3">The fixed index of the third dimension.</param>
 <param name="start4">The start index of the fourth dimension.</param>
 <param name="finish4">The end index of the fourth dimension.</param>

 <returns>The two dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice4DFixedDouble1``1(``0[0:, 0:, 0:],System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Gets a 2D slice of a 4D array</summary>

 <param name="source">The source array.</param>
 <param name="index1">The fixed index of the first dimension.</param>
 <param name="index2">The fixed index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>
 <param name="start4">The start index of the fourth dimension.</param>
 <param name="finish4">The end index of the fourth dimension.</param>

 <returns>The two dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice4DFixedSingle4``1(``0[0:, 0:, 0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32)">
 <summary>Gets a 3D slice of a 4D array</summary>

 <param name="source">The source array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>
 <param name="index4">The fixed index of the fourth dimension.</param>

 <returns>The three dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice4DFixedSingle3``1(``0[0:, 0:, 0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Gets a 3D slice of a 4D array</summary>

 <param name="source">The source array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="index3">The fixed index of the third dimension.</param>
 <param name="start4">The start index of the fourth dimension.</param>
 <param name="finish4">The end index of the fourth dimension.</param>

 <returns>The three dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice4DFixedSingle2``1(``0[0:, 0:, 0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Gets a 3D slice of a 4D array</summary>

 <param name="source">The source array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="index2">The fixed index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>
 <param name="start4">The start index of the fourth dimension.</param>
 <param name="finish4">The end index of the fourth dimension.</param>

 <returns>The three dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice4DFixedSingle1``1(``0[0:, 0:, 0:],System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Gets a 3D slice of a 4D array</summary>

 <param name="source">The source array.</param>
 <param name="index1">The fixed index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>
 <param name="start4">The start index of the fourth dimension.</param>
 <param name="finish4">The end index of the fourth dimension.</param>

 <returns>The three dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice4D``1(``0[0:, 0:, 0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Gets a slice of an array</summary>

 <param name="source">The source array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>
 <param name="start4">The start index of the fourth dimension.</param>
 <param name="finish4">The end index of the fourth dimension.</param>

 <returns>The four dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice3DFixedDouble3``1(``0[0:, 0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,System.Int32,``0[])">
 <summary>Sets a 1D slice of a 3D array.</summary>

 <param name="target">The target array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="index2">The fixed index of the second dimension.</param>
 <param name="index3">The fixed index of the third dimension.</param>
 <param name="source">The source array.</param>

 <returns>The one dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice3DFixedDouble2``1(``0[0:, 0:],System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,``0[])">
 <summary>Sets a 1D slice of a 3D array.</summary>

 <param name="target">The target array.</param>
 <param name="index1">The fixed index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="index3">The fixed index of the third dimension.</param>
 <param name="source">The source array.</param>

 <returns>The one dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice3DFixedDouble1``1(``0[0:, 0:],System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},``0[])">
 <summary>Sets a 1D slice of a 3D array.</summary>

 <param name="target">The target array.</param>
 <param name="index1">The fixed index of the first dimension.</param>
 <param name="index2">The fixed index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>
 <param name="source">The source array.</param>

 <returns>The one dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice3DFixedSingle3``1(``0[0:, 0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,``0[0:])">
 <summary>Sets a 2D slice of a 3D array</summary>

 <param name="target">The target array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="index3">The fixed index of the third dimension.</param>
 <param name="source">The source array.</param>

 <returns>The two dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice3DFixedSingle2``1(``0[0:, 0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},``0[0:])">
 <summary>Sets a 2D slice of a 3D array</summary>

 <param name="target">The target array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="index2">The fixed index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>
 <param name="source">The source array.</param>

 <returns>The two dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice3DFixedSingle1``1(``0[0:, 0:],System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},``0[0:])">
 <summary>Sets a 2D slice of a 3D array</summary>

 <param name="target">The target array.</param>
 <param name="index1">The fixed index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>
 <param name="source">The source array.</param>

 <returns>The two dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice3D``1(``0[0:, 0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},``0[0:, 0:])">
 <summary>Sets a slice of an array</summary>

 <param name="target">The target array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>
 <param name="source">The source array.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice3DFixedDouble3``1(``0[0:, 0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,System.Int32)">
 <summary>Gets a 1D slice of a 3D array.</summary>

 <param name="source">The source array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="index2">The fixed index of the second dimension.</param>
 <param name="index3">The fixed index of the third dimension.</param>

 <returns>The one dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice3DFixedDouble2``1(``0[0:, 0:],System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32)">
 <summary>Gets a 1D slice of a 3D array.</summary>

 <param name="source">The source array.</param>
 <param name="index1">The fixed index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="index3">The fixed index of the third dimension.</param>

 <returns>The one dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice3DFixedDouble1``1(``0[0:, 0:],System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Gets a 1D slice of a 3D array.</summary>

 <param name="source">The source array.</param>
 <param name="index1">The fixed index of the first dimension.</param>
 <param name="index2">The fixed index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>

 <returns>The one dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice3DFixedSingle3``1(``0[0:, 0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32)">
 <summary>Gets a 2D slice of a 3D array.</summary>

 <param name="source">The source array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="index3">The fixed index of the third dimension.</param>

 <returns>The two dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice3DFixedSingle2``1(``0[0:, 0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Gets a 2D slice of a 3D array.</summary>

 <param name="source">The source array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="index2">The fixed index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>

 <returns>The two dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice3DFixedSingle1``1(``0[0:, 0:],System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Gets a 2D slice of a 3D array.</summary>

 <param name="source">The source array.</param>
 <param name="index1">The fixed index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>

 <returns>The two dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice3D``1(``0[0:, 0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Gets a slice of an array</summary>

 <param name="source">The source array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="start3">The start index of the third dimension.</param>
 <param name="finish3">The end index of the third dimension.</param>

 <returns>The three dimensional sub array from the given indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice2DFixed2``1(``0[0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,``0[])">
 <summary>Sets a vector slice of a 2D array. The index of the second dimension is fixed.</summary>

 <param name="target">The target array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="index2">The index of the second dimension.</param>
 <param name="source">The source array.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice2DFixed1``1(``0[0:],System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},``0[])">
 <summary>Sets a vector slice of a 2D array. The index of the first dimension is fixed.</summary>

 <param name="target">The target array.</param>
 <param name="index1">The index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="source">The source array.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice2D``1(``0[0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},``0[0:])">
 <summary>Sets a region slice of an array</summary>

 <param name="target">The target array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>
 <param name="source">The source array.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice2DFixed2``1(``0[0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32)">
 <summary>Gets a vector slice of a 2D array. The index of the second dimension is fixed.</summary>

 <param name="source">The source array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="index2">The fixed index of the second dimension.</param>

 <returns>The sub array from the input indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice2DFixed1``1(``0[0:],System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Gets a vector slice of a 2D array. The index of the first dimension is fixed.</summary>

 <param name="source">The source array.</param>
 <param name="index1">The index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>

 <returns>The sub array from the input indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice2D``1(``0[0:],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Gets a region slice of an array</summary>

 <param name="source">The source array.</param>
 <param name="start1">The start index of the first dimension.</param>
 <param name="finish1">The end index of the first dimension.</param>
 <param name="start2">The start index of the second dimension.</param>
 <param name="finish2">The end index of the second dimension.</param>

 <returns>The two dimensional sub array from the input indices.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice``1(``0[],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},``0[])">
 <summary>Sets a slice of an array</summary>

 <param name="target">The target array.</param>
 <param name="start">The start index.</param>
 <param name="finish">The end index.</param>
 <param name="source">The source array.</param>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice``1(``0[],Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Gets a slice of an array</summary>

 <param name="source">The input array.</param>
 <param name="start">The start index.</param>
 <param name="finish">The end index.</param>

 <returns>The sub array from the input indices.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.Operators.OperatorIntrinsics">
 <summary>A module of compiler intrinsic functions for efficient implementations of F# integer ranges
 and dynamic invocations of other F# operators</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ArrayExtensions.String.GetReverseIndex(System.String,System.Int32,System.Int32)">
 <summary>Get the index for the element offset elements away from the end of the collection.</summary>

 <param name="rank">The rank of the index.</param>
 <param name="offset">The offset from the end.</param>

 <returns>The corresponding index from the start.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ArrayExtensions.[]`1.GetReverseIndex``1(``0[],System.Int32,System.Int32)">
 <summary>Get the index for the element offset elements away from the end of the collection.</summary>

 <param name="rank">The rank of the index.</param>
 <param name="offset">The offset from the end.</param>

 <returns>The corresponding index from the start.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ArrayExtensions.[,]`1.GetReverseIndex``1(``0[0:],System.Int32,System.Int32)">
 <summary>Get the index for the element offset elements away from the end of the collection.</summary>

 <param name="rank">The rank of the index. This refers to the dimension in the 2d array.</param>
 <param name="offset">The offset from the end.</param>

 <returns>The corresponding index from the start.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ArrayExtensions.[,,]`1.GetReverseIndex``1(``0[0:, 0:],System.Int32,System.Int32)">
 <summary>Get the index for the element offset elements away from the end of the collection.</summary>

 <param name="rank">The rank of the index. This refers to the dimension in the 3d array.</param>
 <param name="offset">The offset from the end.</param>

 <returns>The corresponding index from the start.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ArrayExtensions.[,,,]`1.GetReverseIndex``1(``0[0:, 0:, 0:],System.Int32,System.Int32)">
 <summary>Get the index for the element offset elements away from the end of the collection.</summary>

 <param name="rank">The rank of the index. This refers to the dimension in the 4d array.</param>
 <param name="offset">The offset from the end.</param>

 <returns>The corresponding index from the start.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.Operators.ArrayExtensions">
 <summary>Contains extension methods to allow the use of F# indexer notation with arrays.
 This module is automatically opened in all F# code.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Operators">
 <summary>Basic F# Operators. This module is automatically opened in all F# code.</summary>

 <category index="2">Basic Operators</category>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`6.Invoke(`0,`1,`2,`3,`4)">
 <summary>Invoke an F# first class function value that accepts five curried arguments 
 without intervening execution</summary>

 <param name="arg1">The first arg.</param>
 <param name="arg2">The second arg.</param>
 <param name="arg3">The third arg.</param>
 <param name="arg4">The fourth arg.</param>
 <param name="arg5">The fifth arg.</param>

 <returns>The function result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`6.Adapt(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{`2,Microsoft.FSharp.Core.FSharpFunc{`3,Microsoft.FSharp.Core.FSharpFunc{`4,`5}}}}})">
 <summary>Adapt an F# first class function value to be an optimized function value that can 
 accept five curried arguments without intervening execution. </summary>

 <param name="func">The input function.</param>

 <returns>The optimized function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`6.#ctor">
 <summary>Construct an optimized function value that can accept five curried 
 arguments without intervening execution.</summary>
 <returns>The optimized function.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`6">
 <summary>The CLI type used to represent F# function values that accept five curried arguments 
 without intervening execution. This type should not typically used directly from 
 either F# code or from other CLI languages.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`5.Invoke(`0,`1,`2,`3)">
 <summary>Invoke an F# first class function value that accepts four curried arguments 
 without intervening execution</summary>

 <param name="arg1">The first arg.</param>
 <param name="arg2">The second arg.</param>
 <param name="arg3">The third arg.</param>
 <param name="arg4">The fourth arg.</param>

 <returns>The function result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`5.Adapt(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{`2,Microsoft.FSharp.Core.FSharpFunc{`3,`4}}}})">
 <summary>Adapt an F# first class function value to be an optimized function value that can 
 accept four curried arguments without intervening execution. </summary>

 <param name="func">The input function.</param>

 <returns>The optimized function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`5.#ctor">
 <summary>Construct an optimized function value that can accept four curried 
 arguments without intervening execution.</summary>
 <returns>The optimized function.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`5">
 <summary>The CLI type used to represent F# function values that accept four curried arguments 
 without intervening execution. This type should not typically used directly from 
 either F# code or from other CLI languages.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`4.Invoke(`0,`1,`2)">
 <summary>Invoke an F# first class function value that accepts three curried arguments 
 without intervening execution</summary>

 <param name="arg1">The first arg.</param>
 <param name="arg2">The second arg.</param>
 <param name="arg3">The third arg.</param>

 <returns>The function result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`4.Adapt(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{`2,`3}}})">
 <summary>Adapt an F# first class function value to be an optimized function value that can 
 accept three curried arguments without intervening execution. </summary>

 <param name="func">The input function.</param>

 <returns>The adapted function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`4.#ctor">
 <summary>Construct an optimized function value that can accept three curried 
 arguments without intervening execution.</summary>
 <returns>The optimized function.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`4">
 <summary>The CLI type used to represent F# function values that accept
 three iterated (curried) arguments without intervening execution. This type should not
 typically used directly from either F# code or from other CLI languages.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`3.Invoke(`0,`1)">
 <summary>Invoke the optimized function value with two curried arguments </summary>

 <param name="arg1">The first arg.</param>
 <param name="arg2">The second arg.</param>

 <returns>The function result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`3.Adapt(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,`2}})">
 <summary>Adapt an F# first class function value to be an optimized function value that can 
 accept two curried arguments without intervening execution. </summary>

 <param name="func">The input function.</param>

 <returns>The adapted function.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`3.#ctor">
 <summary>Construct an optimized function value that can accept two curried 
 arguments without intervening execution.</summary>
 <returns>The optimized function.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`3">
 <summary>The CLI type used to represent F# function values that accept
 two iterated (curried) arguments without intervening execution. This type should not
 typically used directly from either F# code or from other CLI languages.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures">
 <summary>An implementation module used to hold some private implementations of function
 value invocation.</summary>
 <category>Language Primitives</category>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.DivideByInt``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}},``0,System.Int32)">
 <summary>Divides a value by an integer.</summary>

 <param name="x">The input value.</param>
 <param name="y">The input int.</param>

 <returns>The division result.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericOne``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
 <summary>Resolves to the value 'one' for any primitive numeric type or any type with a static member called 'One'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericZero``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
 <summary>Resolves to the zero value for any primitive numeric type or any type with a static member called 'Zero'</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.DivideByIntDynamic``1(``0,System.Int32)">
 <summary>A compiler intrinsic that implements dynamic invocations for the DivideByInt primitive.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.InequalityDynamic``3(``0,``1)">
 <summary>A compiler intrinsic that implements dynamic invocations related to the '=' operator.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.EqualityDynamic``3(``0,``1)">
 <summary>A compiler intrinsic that implements dynamic invocations related to the '=' operator.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GreaterThanOrEqualDynamic``3(``0,``1)">
 <summary>A compiler intrinsic that implements dynamic invocations related to the '&gt;=' operator.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.LessThanOrEqualDynamic``3(``0,``1)">
 <summary>A compiler intrinsic that implements dynamic invocations related to the '&lt;=' operator.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GreaterThanDynamic``3(``0,``1)">
 <summary>A compiler intrinsic that implements dynamic invocations related to the '&gt;' operator.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.LessThanDynamic``3(``0,``1)">
 <summary>A compiler intrinsic that implements dynamic invocations related to the '&lt;' operator.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.CheckedExplicitDynamic``2(``0)">
 <summary>A compiler intrinsic that implements dynamic invocations related to checked conversion operators.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ExplicitDynamic``2(``0)">
 <summary>A compiler intrinsic that implements dynamic invocations related to conversion operators.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.LogicalNotDynamic``2(``0)">
 <summary>A compiler intrinsic that implements dynamic invocations related to the '~~~' operator.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ExclusiveOrDynamic``3(``0,``1)">
 <summary>A compiler intrinsic that implements dynamic invocations related to the '^^^' operator.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.BitwiseOrDynamic``3(``0,``1)">
 <summary>A compiler intrinsic that implements dynamic invocations to the '|||' operator.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.BitwiseAndDynamic``3(``0,``1)">
 <summary>A compiler intrinsic that implements dynamic invocations to the '&amp;&amp;&amp;' operator.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.RightShiftDynamic``3(``0,``1)">
 <summary>A compiler intrinsic that implements dynamic invocations to the '&gt;&gt;&gt;' operator.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.LeftShiftDynamic``3(``0,``1)">
 <summary>A compiler intrinsic that implements dynamic invocations to the '&lt;&lt;&lt;' operator.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.CheckedUnaryNegationDynamic``2(``0)">
 <summary>A compiler intrinsic that implements dynamic invocations to the checked unary '-' operator.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.CheckedSubtractionDynamic``3(``0,``1)">
 <summary>A compiler intrinsic that implements dynamic invocations to the checked '-' operator.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ModulusDynamic``3(``0,``1)">
 <summary>A compiler intrinsic that implements dynamic invocations to the '%' operator.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.UnaryNegationDynamic``2(``0)">
 <summary>A compiler intrinsic that implements dynamic invocations to the unary '-' operator.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.DivisionDynamic``3(``0,``1)">
 <summary>A compiler intrinsic that implements dynamic invocations to the '/' operator.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.SubtractionDynamic``3(``0,``1)">
 <summary>A compiler intrinsic that implements dynamic invocations to the '-' operator.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.CheckedMultiplyDynamic``3(``0,``1)">
 <summary>A compiler intrinsic that implements dynamic invocations to the checked '*' operator.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.MultiplyDynamic``3(``0,``1)">
 <summary>A compiler intrinsic that implements dynamic invocations to the '*' operator.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.CheckedAdditionDynamic``3(``0,``1)">
 <summary>A compiler intrinsic that implements dynamic invocations to the checked '+' operator.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.AdditionDynamic``3(``0,``1)">
 <summary>A compiler intrinsic that implements dynamic invocations to the '+' operator.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericOneDynamic``1">
 <summary>Resolves to the value 'one' for any primitive numeric type or any type with a static member called 'One'.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericZeroDynamic``1">
 <summary>Resolves to the zero value for any primitive numeric type or any type with a static member called 'Zero'.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ParseUInt64(System.String)">
 <summary>Parse an uint64 according to the rules used by the overloaded 'uint64' conversion operator when applied to strings</summary>

 <param name="s">The input string.</param>

 <returns>The parsed value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ParseInt64(System.String)">
 <summary>Parse an int64 according to the rules used by the overloaded 'int64' conversion operator when applied to strings</summary>

 <param name="s">The input string.</param>

 <returns>The parsed value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ParseUInt32(System.String)">
 <summary>Parse an uint32 according to the rules used by the overloaded 'uint32' conversion operator when applied to strings</summary>

 <param name="s">The input string.</param>

 <returns>The parsed value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ParseInt32(System.String)">
 <summary>Parse an int32 according to the rules used by the overloaded 'int32' conversion operator when applied to strings</summary>

 <param name="s">The input string.</param>

 <returns>The parsed value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.UIntPtrWithMeasure``1(System.UIntPtr)">
 <summary>Creates a unativeint value with units-of-measure</summary>

 <param name="input">The input unativeint.</param>

 <returns>The unativeint with units-of-measure.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ByteWithMeasure``1(System.Byte)">
 <summary>Creates a byte value with units-of-measure</summary>

 <param name="input">The input byte.</param>

 <returns>The byte with units-of-measure.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.UInt16WithMeasure``1(System.UInt16)">
 <summary>Creates a uint16 value with units-of-measure</summary>

 <param name="input">The input uint16.</param>

 <returns>The uint16 with units-of-measure.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.UInt64WithMeasure``1(System.UInt64)">
 <summary>Creates a uint64 value with units-of-measure</summary>

 <param name="input">The input uint64.</param>

 <returns>The uint64 with units-of-measure.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.UInt32WithMeasure``1(System.UInt32)">
 <summary>Creates a uint value with units-of-measure</summary>

 <param name="input">The input uint.</param>

 <returns>The uint with units-of-measure.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntPtrWithMeasure``1(System.IntPtr)">
 <summary>Creates a nativeint value with units-of-measure</summary>

 <param name="input">The input nativeint.</param>

 <returns>The nativeint with units-of-measure.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.SByteWithMeasure``1(System.SByte)">
 <summary>Creates an sbyte value with units-of-measure</summary>

 <param name="input">The input sbyte.</param>

 <returns>The sbyte with units-of-measure.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.Int16WithMeasure``1(System.Int16)">
 <summary>Creates an int16 value with units-of-measure</summary>

 <param name="input">The input int16.</param>

 <returns>The int16 with units-of-measure.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.Int64WithMeasure``1(System.Int64)">
 <summary>Creates an int64 value with units-of-measure</summary>

 <param name="input">The input int64.</param>

 <returns>The int64 with units of measure.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.Int32WithMeasure``1(System.Int32)">
 <summary>Creates an int32 value with units-of-measure</summary>

 <param name="input">The input int.</param>

 <returns>The int with units of measure.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.DecimalWithMeasure``1(System.Decimal)">
 <summary>Creates a decimal value with units-of-measure</summary>

 <param name="input">The input decimal.</param>

 <returns>The decimal with units of measure.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.Float32WithMeasure``1(System.Single)">
 <summary>Creates a float32 value with units-of-measure</summary>

 <param name="input">The input float.</param>

 <returns>The float with units-of-measure.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.FloatWithMeasure``1(System.Double)">
 <summary>Creates a float value with units-of-measure</summary>

 <param name="input">The input float.</param>

 <returns>The float with units-of-measure.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.EnumToValue``2(``0)">
 <summary>Get the underlying value for an enum value</summary>

 <param name="enum">The input enum.</param>

 <returns>The enumeration as a value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.EnumOfValue``2(``0)">
 <summary>Build an enum value from an underlying value</summary>

 <param name="value">The input value.</param>

 <returns>The value as an enumeration.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericHashWithComparer``1(System.Collections.IEqualityComparer,``0)">
 <summary>Recursively hash a part of a value according to its structure. </summary>

 <param name="comparer">The comparison function.</param>
 <param name="obj">The input object.</param>

 <returns>The hashed value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericLimitedHash``1(System.Int32,``0)">
 <summary>Hash a value according to its structure. Use the given limit to restrict the hash when hashing F#
 records, lists and union types.</summary>

 <param name="limit">The limit on the number of nodes.</param>
 <param name="obj">The input object.</param>

 <returns>The hashed value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericHash``1(``0)">
 <summary>Hash a value according to its structure. This hash is not limited by an overall node count when hashing F#
 records, lists and union types.</summary>

 <param name="obj">The input object.</param>

 <returns>The hashed value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.FastGenericComparerFromTable``1">
 <summary>Make an F# comparer object for the given type</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.FastGenericEqualityComparerFromTable``1">
 <summary>Make an F# hash/equality object for the given type</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.FastLimitedGenericEqualityComparer``1(System.Int32)">
 <summary>Make an F# hash/equality object for the given type using node-limited hashing when hashing F#
 records, lists and union types.</summary>

 <param name="limit">The input limit on the number of nodes.</param>

 <returns>System.Collections.Generic.IEqualityComparer&lt;'T&gt;</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.FastGenericEqualityComparer``1">
 <summary>Make an F# hash/equality object for the given type</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.FastGenericComparerCanBeNull``1">
 <summary>Make an F# comparer object for the given type, where it can be null if System.Collections.Generic.Comparer&lt;'T&gt;.Default</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.FastGenericComparer``1">
 <summary>Make an F# comparer object for the given type</summary>
</member>
<member name="P:Microsoft.FSharp.Core.LanguagePrimitives.GenericComparer">
 <summary>A static F# comparer object</summary>
</member>
<member name="P:Microsoft.FSharp.Core.LanguagePrimitives.GenericEqualityERComparer">
 <summary>Return an F# comparer object suitable for hashing and equality. This hashing behaviour
 of the returned comparer is not limited by an overall node count when hashing F#
 records, lists and union types. This equality comparer has equivalence 
 relation semantics ([nan] = [nan]).</summary>
</member>
<member name="P:Microsoft.FSharp.Core.LanguagePrimitives.GenericEqualityComparer">
 <summary>Return an F# comparer object suitable for hashing and equality. This hashing behaviour
 of the returned comparer is not limited by an overall node count when hashing F#
 records, lists and union types.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.PhysicalHash``1(``0)">
 <summary>The physical hash. Hashes on the object identity.</summary>

 <param name="obj">The input object.</param>

 <returns>The hashed value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.PhysicalEquality``1(``0,``0)">
 <summary>Reference/physical equality. 
 True if the inputs are reference-equal, false otherwise.</summary>

 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>

 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericMaximum``1(``0,``0)">
 <summary>Take the maximum of two values structurally according to the order given by GenericComparison</summary>

 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>

 <returns>The maximum value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericMinimum``1(``0,``0)">
 <summary>Take the minimum of two values structurally according to the order given by GenericComparison</summary>

 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>

 <returns>The minimum value.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericGreaterOrEqual``1(``0,``0)">
 <summary>Compare two values   </summary>

 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>

 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericLessOrEqual``1(``0,``0)">
 <summary>Compare two values   </summary>

 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>

 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericGreaterThan``1(``0,``0)">
 <summary>Compare two values   </summary>

 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>

 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericLessThan``1(``0,``0)">
 <summary>Compare two values   </summary>

 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>

 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericComparisonWithComparer``1(System.Collections.IComparer,``0,``0)">
 <summary>Compare two values. May be called as a recursive case from an implementation of System.IComparable to
 ensure consistent NaN comparison semantics.</summary>

 <param name="comp">The function to compare the values.</param>
 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>

 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericComparison``1(``0,``0)">
 <summary>Compare two values </summary>

 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>

 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericEqualityWithComparer``1(System.Collections.IEqualityComparer,``0,``0)">
 <summary>Compare two values for equality</summary>

 <param name="comp"></param>
 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>

 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericEqualityER``1(``0,``0)">
 <summary>Compare two values for equality using equivalence relation semantics ([nan] = [nan])</summary>

 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>

 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericEquality``1(``0,``0)">
 <summary>Compare two values for equality using partial equivalence relation semantics ([nan] &lt;&gt; [nan])</summary>

 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>

 <returns>The result of the comparison.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastCompareTuple5``5(System.Collections.IComparer,System.Tuple{``0,``1,``2,``3,``4},System.Tuple{``0,``1,``2,``3,``4})">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastCompareTuple4``4(System.Collections.IComparer,System.Tuple{``0,``1,``2,``3},System.Tuple{``0,``1,``2,``3})">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastCompareTuple3``3(System.Collections.IComparer,System.Tuple{``0,``1,``2},System.Tuple{``0,``1,``2})">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastCompareTuple2``2(System.Collections.IComparer,System.Tuple{``0,``1},System.Tuple{``0,``1})">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastEqualsTuple5``5(System.Collections.IEqualityComparer,System.Tuple{``0,``1,``2,``3,``4},System.Tuple{``0,``1,``2,``3,``4})">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastEqualsTuple4``4(System.Collections.IEqualityComparer,System.Tuple{``0,``1,``2,``3},System.Tuple{``0,``1,``2,``3})">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastEqualsTuple3``3(System.Collections.IEqualityComparer,System.Tuple{``0,``1,``2},System.Tuple{``0,``1,``2})">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastEqualsTuple2``2(System.Collections.IEqualityComparer,System.Tuple{``0,``1},System.Tuple{``0,``1})">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastHashTuple5``5(System.Collections.IEqualityComparer,System.Tuple{``0,``1,``2,``3,``4})">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastHashTuple4``4(System.Collections.IEqualityComparer,System.Tuple{``0,``1,``2,``3})">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastHashTuple3``3(System.Collections.IEqualityComparer,System.Tuple{``0,``1,``2})">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastHashTuple2``2(System.Collections.IEqualityComparer,System.Tuple{``0,``1})">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericLessOrEqualIntrinsic``1(``0,``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericGreaterOrEqualIntrinsic``1(``0,``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericGreaterThanIntrinsic``1(``0,``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericLessThanIntrinsic``1(``0,``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericEqualityWithComparerIntrinsic``1(System.Collections.IEqualityComparer,``0,``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericEqualityERIntrinsic``1(``0,``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericEqualityIntrinsic``1(``0,``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericComparisonIntrinsic``1(``0,``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericComparisonWithComparerIntrinsic``1(System.Collections.IComparer,``0,``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericHashWithComparerIntrinsic``1(System.Collections.IEqualityComparer,``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.LimitedGenericHashIntrinsic``1(System.Int32,``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericHashIntrinsic``1(``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.PhysicalEqualityIntrinsic``1(``0,``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.PhysicalHashIntrinsic``1(``0)">
 <summary>A primitive entry point used by the F# compiler for optimization purposes.</summary> 
</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare">
 <summary>The F# compiler emits calls to some of the functions in this module as part of the compiled form of some language constructs</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.SetArray4D``1(``0[0:, 0:, 0:],System.Int32,System.Int32,System.Int32,System.Int32,``0)">
<summary>
 The standard overloaded associative (4-indexed) mutation operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.SetArray3D``1(``0[0:, 0:],System.Int32,System.Int32,System.Int32,``0)">
 <summary>The standard overloaded associative (3-indexed) mutation operator</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.SetArray2D``1(``0[0:],System.Int32,System.Int32,``0)">
 <summary>The standard overloaded associative (2-indexed) mutation operator</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.SetArray``1(``0[],System.Int32,``0)">
 <summary>The standard overloaded associative (indexed) mutation operator</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.GetArray4D``1(``0[0:, 0:, 0:],System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>The standard overloaded associative (4-indexed) lookup operator</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.GetArray3D``1(``0[0:, 0:],System.Int32,System.Int32,System.Int32)">
 <summary>The standard overloaded associative (3-indexed) lookup operator</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.GetArray2D``1(``0[0:],System.Int32,System.Int32)">
 <summary>The standard overloaded associative (2-indexed) lookup operator</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.GetArray``1(``0[],System.Int32)">
 <summary>The standard overloaded associative (indexed) lookup operator</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.CheckThis``1(``0)">
 <summary>A compiler intrinsic for checking initialization soundness of recursive bindings</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.FailStaticInit">
 <summary>A compiler intrinsic for checking initialization soundness of recursive static bindings</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.FailInit">
 <summary>A compiler intrinsic for checking initialization soundness of recursive bindings</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.Dispose``1(``0)">
 <summary>A compiler intrinsic for the efficient compilation of sequence expressions</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.MakeDecimal(System.Int32,System.Int32,System.Int32,System.Boolean,System.Byte)">
 <summary>This function implements parsing of decimal constants</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.CreateInstance``1">
 <summary>This function implements calls to default constructors
 accessed by 'new' constraints.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.GetString(System.String,System.Int32)">
 <summary>Primitive used by pattern match compilation</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.TypeTestFast``1(System.Object)">
 <summary>A compiler intrinsic that implements the ':?' operator</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.TypeTestGeneric``1(System.Object)">
 <summary>A compiler intrinsic that implements the ':?' operator</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.UnboxFast``1(System.Object)">
 <summary>A compiler intrinsic that implements the ':?>' operator</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.UnboxGeneric``1(System.Object)">
 <summary>A compiler intrinsic that implements the ':?>' operator</summary>
</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions">
 <summary>The F# compiler emits calls to some of the functions in this module as part of the compiled form of some language constructs</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_IntegerAddressOf``1(``0)">
 <summary>Address-of. Uses of this value may result in the generation of unverifiable code.</summary>

 <param name="obj">The input object.</param>

 <returns>The unmanaged pointer.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_AddressOf``1(``0)">
 <summary>Address-of. Uses of this value may result in the generation of unverifiable code.</summary>

 <param name="obj">The input object.</param>

 <returns>The managed pointer.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_BooleanOr(System.Boolean,System.Boolean)">
 <summary>Binary 'or'. When used as a binary operator the right hand value is evaluated only on demand</summary>

 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>

 <returns>The result of the operation.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.Or(System.Boolean,System.Boolean)">
 <summary>Binary 'or'. When used as a binary operator the right hand value is evaluated only on demand.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_BooleanAnd(System.Boolean,System.Boolean)">
 <summary>Binary 'and'. When used as a binary operator the right hand value is evaluated only on demand</summary>

 <param name="e1">The first value.</param>
 <param name="e2">The second value.</param>

 <returns>The result of the operation.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_Amp(System.Boolean,System.Boolean)">
 <summary>Binary 'and'. When used as a binary operator the right hand value is evaluated only on demand.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators">
 <summary>The F# compiler emits calls to some of the functions in this module as part of the compiled form of some language constructs</summary>
</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives.ErrorStrings">
 <summary>For compiler use only</summary>
</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives">
 <summary>Language primitives associated with the F# language</summary>

 <category index="9">Language Primitives</category>
</member>
<member name="T:Microsoft.FSharp.Core.ByRefKinds.InOut">
<summary>
 Represents a byref that can be both read and written
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.ByRefKinds.In">
<summary>
 Represents a byref that can be read
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.ByRefKinds.Out">
<summary>
 Represents a byref that can be written
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.ByRefKinds">
 <summary>Represents the types of byrefs in F# 4.5+</summary>
 <category>ByRef and Pointer Types</category>
</member>
<member name="M:Microsoft.FSharp.Core.ValueOption.ToObj``1(Microsoft.FSharp.Core.FSharpValueOption{``0})">
 <summary>Convert an option to a potentially null value.</summary>

 <param name="value">The input value.</param>

 <returns>The result value, which is null if the input was ValueNone.</returns>

 <example id="toObj-1">
 <code lang="fsharp">
 (ValueNone: string ValueOption) |> ValueOption.toObj // evaluates to null
 ValueSome "not a null string" |> ValueOption.toObj // evaluates to "not a null string"
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ValueOption.OfObj``1(``0)">
 <summary>Convert a potentially null value to a value option.</summary>

 <param name="value">The input value.</param>

 <returns>The result value option.</returns>

 <example id="ofObj-1">
 <code lang="fsharp">
 (null: string) |> ValueOption.ofObj // evaluates to ValueNone
 "not a null string" |> ValueOption.ofObj // evaluates to (ValueSome "not a null string")
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ValueOption.OfNullable``1(System.Nullable{``0})">
 <summary>Convert a Nullable value to a value option.</summary>

 <param name="value">The input nullable value.</param>

 <returns>The result value option.</returns>

 <example id="ofNullable-1">
 <code lang="fsharp">
 System.Nullable&lt;int&gt;() |> ValueOption.ofNullable // evaluates to ValueNone
 System.Nullable(42) |> ValueOption.ofNullable // evaluates to ValueSome 42
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ValueOption.ToNullable``1(Microsoft.FSharp.Core.FSharpValueOption{``0})">
 <summary>Convert the value option to a Nullable value.</summary>

 <param name="voption">The input value option.</param>

 <returns>The result value.</returns>

 <example id="toNullable-1">
 <code lang="fsharp">
 (ValueNone: int ValueOption) |> ValueOption.toNullable // evaluates to new System.Nullable&lt;int&gt;()
 ValueSome 42 |> ValueOption.toNullable // evaluates to new System.Nullable(42)
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ValueOption.ToList``1(Microsoft.FSharp.Core.FSharpValueOption{``0})">
 <summary>Convert the value option to a list of length 0 or 1.</summary>

 <param name="voption">The input value option.</param>

 <returns>The result list.</returns>

 <example id="toList-1">
 <code lang="fsharp">
 (ValueNone: int ValueOption) |> ValueOption.toList // evaluates to []
 ValueSome 42 |> ValueOption.toList // evaluates to [42]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ValueOption.ToArray``1(Microsoft.FSharp.Core.FSharpValueOption{``0})">
 <summary>Convert the value option to an array of length 0 or 1.</summary>

 <param name="voption">The input value option.</param>

 <returns>The result array.</returns>

 <example id="toArray-1">
 <code lang="fsharp">
 (ValueNone: int ValueOption) |> ValueOption.toArray // evaluates to [||]
 ValueSome 42 |> ValueOption.toArray // evaluates to [|42|]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ValueOption.Filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Core.FSharpValueOption{``0})">
 <summary><c>filter f inp</c> evaluates to <c>match inp with ValueNone -> ValueNone | ValueSome x -> if f x then ValueSome x else ValueNone</c>.</summary>

 <param name="predicate">A function that evaluates whether the value contained in the value option should remain, or be filtered out.</param>
 <param name="voption">The input value option.</param>

 <returns>The input if the predicate evaluates to true; otherwise, ValueNone.</returns>

 <example id="filter-1">
 <code lang="fsharp">
 ValueNone |> ValueOption.filter (fun x -> x >= 5) // evaluates to ValueNone
 ValueSome 42 |> ValueOption.filter (fun x -> x >= 5) // evaluates to ValueSome 42
 ValueSome 4 |> ValueOption.filter (fun x -> x >= 5) // evaluates to ValueNone
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ValueOption.Flatten``1(Microsoft.FSharp.Core.FSharpValueOption{Microsoft.FSharp.Core.FSharpValueOption{``0}})">
 <summary><c>flatten inp</c> evaluates to <c>match inp with ValueNone -> ValueNone | ValueSome x -> x</c></summary>

 <param name="voption">The input value option.</param>

 <returns>The input value if the value is Some; otherwise, ValueNone.</returns>
 <remarks><c>flatten</c> is equivalent to <c>bind id</c>.</remarks>

 <example id="flatten-1">
 <code lang="fsharp">
 (ValueNone: int ValueOption ValueOption) |> ValueOption.flatten // evaluates to ValueNone
 (ValueSome ((ValueNone: int ValueOption))) |> ValueOption.flatten // evaluates to ValueNone
 (ValueSome (ValueSome 42)) |> ValueOption.flatten // evaluates to ValueSome 42
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ValueOption.Bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpValueOption{``1}},Microsoft.FSharp.Core.FSharpValueOption{``0})">
 <summary><c>bind f inp</c> evaluates to <c>match inp with ValueNone -> ValueNone | ValueSome x -> f x</c></summary>

 <param name="binder">A function that takes the value of type T from a value option and transforms it into
 a value option containing a value of type U.</param>
 <param name="voption">The input value option.</param>

 <returns>An option of the output type of the binder.</returns>

 <example id="bind-1">
 <code lang="fsharp">
 let tryParse input =
     match System.Int32.TryParse (input: string) with
     | true, v -> ValueSome v
     | false, _ -> ValueNone
 ValueNone |> ValueOption.bind tryParse // evaluates to ValueNone
 ValueSome "42" |> ValueOption.bind tryParse // evaluates to ValueSome 42
 ValueSome "Forty-two" |> ValueOption.bind tryParse // evaluates to ValueNone
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ValueOption.Map3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},Microsoft.FSharp.Core.FSharpValueOption{``0},Microsoft.FSharp.Core.FSharpValueOption{``1},Microsoft.FSharp.Core.FSharpValueOption{``2})">
 <summary><c>map f voption1 voption2 voption3</c> evaluates to <c>match voption1, voption2, voption3 with ValueSome x, ValueSome y, ValueSome z -> ValueSome (f x y z) | _ -> ValueNone</c>.</summary>

 <param name="mapping">A function to apply to the value option values.</param>
 <param name="voption1">The first value option.</param>
 <param name="voption2">The second value option.</param>
 <param name="voption3">The third value option.</param>

 <returns>A value option of the input values after applying the mapping function, or ValueNone if any input is ValueNone.</returns>

 <example id="map3-1">
 <code lang="fsharp">
 (ValueNone, ValueNone, ValueNone) |||> ValueOption.map3 (fun x y z -> x + y + z) // evaluates to ValueNone
 (ValueSome 100, ValueNone, ValueNone) |||> ValueOption.map3 (fun x y z -> x + y + z) // evaluates to ValueNone
 (ValueNone, ValueSome 100, ValueNone) |||> ValueOption.map3 (fun x y z -> x + y + z) // evaluates to ValueNone
 (ValueNone, ValueNone, ValueSome 100) |||> ValueOption.map3 (fun x y z -> x + y + z) // evaluates to ValueNone
 (ValueSome 5, ValueSome 100, ValueSome 10) |||> ValueOption.map3 (fun x y z -> x + y + z) // evaluates to ValueSome 115
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ValueOption.Map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpValueOption{``0},Microsoft.FSharp.Core.FSharpValueOption{``1})">
 <summary><c>map f voption1 voption2</c> evaluates to <c>match voption1, voption2 with ValueSome x, ValueSome y -> ValueSome (f x y) | _ -> ValueNone</c>.</summary>

 <param name="mapping">A function to apply to the voption values.</param>
 <param name="voption1">The first value option.</param>
 <param name="voption2">The second value option.</param>

 <returns>A value option of the input values after applying the mapping function, or ValueNone if either input is ValueNone.</returns>

 <example id="map2-1">
 <code lang="fsharp">
 (ValueNone, ValueNone) ||> ValueOption.map2 (fun x y -> x + y) // evaluates to ValueNone
 (ValueSome 5, ValueNone) ||> ValueOption.map2 (fun x y -> x + y) // evaluates to ValueNone
 (ValueNone, ValueSome 10) ||> ValueOption.map2 (fun x y -> x + y) // evaluates to ValueNone
 (ValueSome 5, ValueSome 10) ||> ValueOption.map2 (fun x y -> x + y) // evaluates to ValueSome 15
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ValueOption.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpValueOption{``0})">
 <summary><c>map f inp</c> evaluates to <c>match inp with ValueNone -> ValueNone | ValueSome x -> ValueSome (f x)</c>.</summary>

 <param name="mapping">A function to apply to the voption value.</param>
 <param name="voption">The input value option.</param>

 <returns>A value option of the input value after applying the mapping function, or ValueNone if the input is ValueNone.</returns>

 <example id="map-1">
 <code lang="fsharp">
 ValueNone |> ValueOption.map (fun x -> x * 2) // evaluates to ValueNone
 ValueSome 42 |> ValueOption.map (fun x -> x * 2) // evaluates to ValueSome 84
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ValueOption.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpValueOption{``0})">
 <summary><c>iter f inp</c> executes <c>match inp with ValueNone -> () | ValueSome x -> f x</c>.</summary>

 <param name="action">A function to apply to the voption value.</param>
 <param name="voption">The input value option.</param>

 <example id="iter-1">
 <code lang="fsharp">
 ValueNone |> ValueOption.iter (printfn "%s") // does nothing
 ValueSome "Hello world" |> ValueOption.iter (printfn "%s") // prints "Hello world"
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ValueOption.Contains``1(``0,Microsoft.FSharp.Core.FSharpValueOption{``0})">
 <summary>Evaluates to true if <paramref name="voption"/> is <c>ValueSome</c> and its value is equal to <paramref name="value"/>.</summary>

 <param name="value">The value to test for equality.</param>
 <param name="voption">The input value option.</param>

 <returns>True if the option is <c>ValueSome</c> and contains a value equal to <paramref name="value"/>, otherwise false.</returns>

 <example id="contains-1">
 <code lang="fsharp">
 (99, ValueNone) ||> ValueOption.contains // evaluates to false
 (99, ValueSome 99) ||> ValueOption.contains // evaluates to true
 (99, ValueSome 100) ||> ValueOption.contains // evaluates to false
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ValueOption.ForAll``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Core.FSharpValueOption{``0})">
 <summary><c>forall p inp</c> evaluates to <c>match inp with ValueNone -> true | ValueSome x -> p x</c>.</summary>

 <param name="predicate">A function that evaluates to a boolean when given a value from the value option type.</param>
 <param name="voption">The input value option.</param>

 <returns>True if the option is None, otherwise it returns the result of applying the predicate
 to the option value.</returns>

 <example id="forall-1">
 <code lang="fsharp">
 ValueNone |> ValueOption.forall (fun x -> x >= 5) // evaluates to true
 ValueSome 42 |> ValueOption.forall (fun x -> x >= 5) // evaluates to true
 ValueSome 4 |> ValueOption.forall (fun x -> x >= 5) // evaluates to false
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ValueOption.Exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Core.FSharpValueOption{``0})">
 <summary><c>exists p inp</c> evaluates to <c>match inp with ValueNone -> false | ValueSome x -> p x</c>.</summary>

 <param name="predicate">A function that evaluates to a boolean when given a value from the option type.</param>
 <param name="voption">The input value option.</param>

 <returns>False if the option is ValueNone, otherwise it returns the result of applying the predicate
 to the option value.</returns>

 <example id="exists-1">
 <code lang="fsharp">
 ValueNone |> ValueOption.exists (fun x -> x >= 5) // evaluates to false
 ValueSome 42 |> ValueOption.exists (fun x -> x >= 5) // evaluates to true
 ValueSome 4 |> ValueOption.exists (fun x -> x >= 5) // evaluates to false
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ValueOption.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Microsoft.FSharp.Core.FSharpValueOption{``0},``1)">
 <summary><c>fold f inp s</c> evaluates to <c>match inp with ValueNone -> s | ValueSome x -> f x s</c>.</summary>

 <param name="folder">A function to update the state data when given a value from a value option.</param>
 <param name="voption">The input value option.</param>
 <param name="state">The initial state.</param>

 <returns>The original state if the option is ValueNone, otherwise it returns the updated state with the folder
 and the voption value.</returns>

 <example id="foldBack-1">
 <code lang="fsharp">
 (ValueNone, 0) ||> ValueOption.foldBack (fun x accum -> accum + x * 2) // evaluates to 0
 (ValueSome 1, 0) ||> ValueOption.foldBack (fun x accum -> accum + x * 2) // evaluates to 2
 (ValueSome 1, 10) ||> ValueOption.foldBack (fun x accum -> accum + x * 2) // evaluates to 12
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ValueOption.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1,Microsoft.FSharp.Core.FSharpValueOption{``0})">
 <summary><c>fold f s inp</c> evaluates to <c>match inp with ValueNone -> s | ValueSome x -> f s x</c>.</summary>

 <param name="folder">A function to update the state data when given a value from a value option.</param>
 <param name="state">The initial state.</param>
 <param name="voption">The input value option.</param>

 <returns>The original state if the option is ValueNone, otherwise it returns the updated state with the folder
 and the voption value.</returns>

 <example id="fold-1">
 <code lang="fsharp">
 (0, ValueNone) ||> ValueOption.fold (fun accum x -> accum + x * 2) // evaluates to 0
 (0, ValueSome 1) ||> ValueOption.fold (fun accum x -> accum + x * 2) // evaluates to 2
 (10, ValueSome 1) ||> ValueOption.fold (fun accum x -> accum + x * 2) // evaluates to 12
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ValueOption.Count``1(Microsoft.FSharp.Core.FSharpValueOption{``0})">
 <summary><c>count inp</c> evaluates to <c>match inp with ValueNone -> 0 | ValueSome _ -> 1</c>.</summary>

 <param name="voption">The input value option.</param>

 <returns>A zero if the option is ValueNone, a one otherwise.</returns>

 <example id="count-1">
 <code lang="fsharp">
 ValueNone |> ValueOption.count // evaluates to 0
 ValueSome 99 |> ValueOption.count // evaluates to 1
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ValueOption.GetValue``1(Microsoft.FSharp.Core.FSharpValueOption{``0})">
 <summary>Gets the value associated with the option.</summary>

 <param name="voption">The input value option.</param>

 <returns>The value within the option.</returns>
 <exception href="System.ArgumentException">Thrown when the option is ValueNone.</exception>

 <example id="get-1">
 <code lang="fsharp">
 ValueSome 42 |> ValueOption.get // evaluates to 42
 (ValueNone: int ValueOption) |> ValueOption.get // throws exception!
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ValueOption.OrElseWith``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.FSharpValueOption{``0}},Microsoft.FSharp.Core.FSharpValueOption{``0})">
 <summary>Returns <paramref name="voption"/> if it is <c>Some</c>, otherwise evaluates <paramref name="ifNoneThunk"/> and returns the result.</summary>

 <param name="ifNoneThunk">A thunk that provides an alternate value option when evaluated.</param>
 <param name="voption">The input value option.</param>

 <returns>The voption if the voption is ValueSome, else the result of evaluating <paramref name="ifNoneThunk"/>.</returns>
 <remarks><paramref name="ifNoneThunk"/> is not evaluated unless <paramref name="voption"/> is <c>ValueNone</c>.</remarks>

 <example id="orElseWith-1">
 <code lang="fsharp">
 (ValueNone: int ValueOption) |> ValueOption.orElseWith (fun () -> ValueNone) // evaluates to ValueNone
 ValueNone |> ValueOption.orElseWith (fun () -> (ValueSome 99)) // evaluates to ValueSome 99
 ValueSome 42 |> ValueOption.orElseWith (fun () -> ValueNone) // evaluates to ValueSome 42
 ValueSome 42 |> ValueOption.orElseWith (fun () -> (ValueSome 99)) // evaluates to ValueSome 42
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ValueOption.OrElse``1(Microsoft.FSharp.Core.FSharpValueOption{``0},Microsoft.FSharp.Core.FSharpValueOption{``0})">
 <summary>Returns <paramref name="voption"/> if it is <c>Some</c>, otherwise returns <paramref name="ifNone"/>.</summary>

 <param name="ifNone">The value to use if <paramref name="voption"/> is <c>None</c>.</param>
 <param name="voption">The input option.</param>

 <returns>The option if the option is Some, else the alternate option.</returns>

 <example id="orElse-1">
 <code lang="fsharp">
 ((ValueNone: int ValueOption), ValueNone) ||> ValueOption.orElse // evaluates to ValueNone
 (ValueSome 99, ValueNone) ||> ValueOption.orElse // evaluates to ValueSome 99
 (ValueNone, ValueSome 42) ||> ValueOption.orElse // evaluates to ValueSome 42
 (ValueSome 99, ValueSome 42) ||> ValueOption.orElse // evaluates to ValueSome 42
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ValueOption.DefaultWith``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpValueOption{``0})">
 <summary>Gets the value of the voption if the voption is <c>ValueSome</c>, otherwise evaluates <paramref name="defThunk"/> and returns the result.</summary>

 <param name="defThunk">A thunk that provides a default value when evaluated.</param>
 <param name="voption">The input voption.</param>

 <returns>The voption if the voption is ValueSome, else the result of evaluating <paramref name="defThunk"/>.</returns>
 <remarks><paramref name="defThunk"/> is not evaluated unless <paramref name="voption"/> is <c>ValueNone</c>.</remarks>

 <example id="defaultWith-1">
 <code lang="fsharp">
 ValueNone |> ValueOption.defaultWith (fun () -> 99) // evaluates to 99
 ValueSome 42 |> ValueOption.defaultWith (fun () -> 99) // evaluates to 42
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ValueOption.DefaultValue``1(``0,Microsoft.FSharp.Core.FSharpValueOption{``0})">
 <summary>Gets the value of the value option if the option is <c>ValueSome</c>, otherwise returns the specified default value.</summary>

 <param name="value">The specified default value.</param>
 <param name="voption">The input voption.</param>

 <returns>The voption if the voption is ValueSome, else the default value.</returns>
 <remarks>Identical to the built-in <see cref="defaultArg"/> operator, except with the arguments swapped.</remarks>

 <example id="defaultValue-1">
 <code lang="fsharp">
 (99, ValueNone) ||> ValueOption.defaultValue // evaluates to 99
 (99, ValueSome 42) ||> ValueOption.defaultValue // evaluates to 42
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ValueOption.IsNone``1(Microsoft.FSharp.Core.FSharpValueOption{``0})">
 <summary>Returns true if the value option is ValueNone.</summary>

 <param name="voption">The input value option.</param>

 <returns>True if the voption is ValueNone.</returns>

 <example id="isNone-1">
 <code lang="fsharp">
 ValueNone |> ValueOption.isNone // evaluates to true
 ValueSome 42 |> ValueOption.isNone // evaluates to false
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ValueOption.IsSome``1(Microsoft.FSharp.Core.FSharpValueOption{``0})">
 <summary>Returns true if the value option is not ValueNone.</summary>

 <param name="voption">The input value option.</param>

 <returns>True if the value option is not ValueNone.</returns>

 <example id="isSome-1">
 <code lang="fsharp">
 ValueNone |> ValueOption.isSome // evaluates to false
 ValueSome 42 |> ValueOption.isSome // evaluates to true
 </code>
 </example>
</member>
<member name="T:Microsoft.FSharp.Core.ValueOption">
 <summary>Contains operations for working with value options.</summary>

 <category>Options</category>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.ToObj``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Convert an option to a potentially null value.</summary>

 <param name="value">The input value.</param>

 <returns>The result value, which is null if the input was None.</returns>

 <example id="toObj-1">
 <code lang="fsharp">
 (None: string option) |> Option.toObj // evaluates to null
 Some "not a null string" |> Option.toObj // evaluates to "not a null string"
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.OfObj``1(``0)">
 <summary>Convert a potentially null value to an option.</summary>

 <param name="value">The input value.</param>

 <returns>The result option.</returns>

 <example id="ofObj-1">
 <code lang="fsharp">
 (null: string) |> Option.ofObj // evaluates to None
 "not a null string" |> Option.ofObj // evaluates to (Some "not a null string")
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.OfNullable``1(System.Nullable{``0})">
 <summary>Convert a Nullable value to an option.</summary>

 <param name="value">The input nullable value.</param>

 <returns>The result option.</returns>

 <example id="ofNullable-1">
 <code lang="fsharp">
 System.Nullable&lt;int&gt;() |> Option.ofNullable // evaluates to None
 System.Nullable(42) |> Option.ofNullable // evaluates to Some 42
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.ToNullable``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Convert the option to a Nullable value.</summary>

 <param name="option">The input option.</param>

 <returns>The result value.</returns>

 <example id="toNullable-1">
 <code lang="fsharp">
 (None: int option) |> Option.toNullable // evaluates to new System.Nullable&lt;int&gt;()
 Some 42 |> Option.toNullable // evaluates to new System.Nullable(42)
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.ToList``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Convert the option to a list of length 0 or 1.</summary>

 <param name="option">The input option.</param>

 <returns>The result list.</returns>

 <example id="toList-1">
 <code lang="fsharp">
 (None: int option) |> Option.toList // evaluates to []
 Some 42 |> Option.toList // evaluates to [42]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.ToArray``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Convert the option to an array of length 0 or 1.</summary>

 <param name="option">The input option.</param>

 <returns>The result array.</returns>

 <example id="toArray-1">
 <code lang="fsharp">
 (None: int option) |> Option.toArray // evaluates to [||]
 Some 42 |> Option.toArray // evaluates to [|42|]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary><c>filter f inp</c> evaluates to <c>match inp with None -> None | Some x -> if f x then Some x else None</c>.</summary>

 <param name="predicate">A function that evaluates whether the value contained in the option should remain, or be filtered out.</param>
 <param name="option">The input option.</param>

 <returns>The input if the predicate evaluates to true; otherwise, None.</returns>

 <example id="filter-1">
 <code lang="fsharp">
 None |> Option.filter (fun x -> x >= 5) // evaluates to None
 Some 42 |> Option.filter (fun x -> x >= 5) // evaluates to Some 42
 Some 4 |> Option.filter (fun x -> x >= 5) // evaluates to None
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Flatten``1(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{``0}})">
 <summary><c>flatten inp</c> evaluates to <c>match inp with None -> None | Some x -> x</c></summary>

 <param name="option">The input option.</param>

 <returns>The input value if the value is Some; otherwise, None.</returns>

 <remarks><c>flatten</c> is equivalent to <c>bind id</c>.</remarks>

 <example id="flatten-1">
 <code lang="fsharp">
 (None: int option option) |> Option.flatten // evaluates to None
 (Some ((None: int option))) |> Option.flatten // evaluates to None
 (Some (Some 42)) |> Option.flatten // evaluates to Some 42
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary><c>bind f inp</c> evaluates to <c>match inp with None -> None | Some x -> f x</c></summary>

 <param name="binder">A function that takes the value of type T from an option and transforms it into
 an option containing a value of type U.</param>
 <param name="option">The input option.</param>

 <returns>An option of the output type of the binder.</returns>

 <example id="bind-1">
 <code lang="fsharp">
 let tryParse (input: string) =
     match System.Int32.TryParse input with
     | true, v -> Some v
     | false, _ -> None
 None |> Option.bind tryParse // evaluates to None
 Some "42" |> Option.bind tryParse // evaluates to Some 42
 Some "Forty-two" |> Option.bind tryParse // evaluates to None
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Map3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1},Microsoft.FSharp.Core.FSharpOption{``2})">
 <summary><c>map f option1 option2 option3</c> evaluates to <c>match option1, option2, option3 with Some x, Some y, Some z -> Some (f x y z) | _ -> None</c>.</summary>

 <param name="mapping">A function to apply to the option values.</param>
 <param name="option1">The first option.</param>
 <param name="option2">The second option.</param>
 <param name="option3">The third option.</param>

 <returns>An option of the input values after applying the mapping function, or None if any input is None.</returns>

 <example id="map3-1">
 <code lang="fsharp">
 (None, None, None) |||> Option.map3 (fun x y z -> x + y + z) // evaluates to None
 (Some 100, None, None) |||> Option.map3 (fun x y z -> x + y + z) // evaluates to None
 (None, Some 100, None) |||> Option.map3 (fun x y z -> x + y + z) // evaluates to None
 (None, None, Some 100) |||> Option.map3 (fun x y z -> x + y + z) // evaluates to None
 (Some 5, Some 100, Some 10) |||> Option.map3 (fun x y z -> x + y + z) // evaluates to Some 115
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
 <summary><c>map f option1 option2</c> evaluates to <c>match option1, option2 with Some x, Some y -> Some (f x y) | _ -> None</c>.</summary>

 <param name="mapping">A function to apply to the option values.</param>
 <param name="option1">The first option.</param>
 <param name="option2">The second option.</param>

 <returns>An option of the input values after applying the mapping function, or None if either input is None.</returns>

 <example id="map2-1">
 <code lang="fsharp">
 (None, None) ||> Option.map2 (fun x y -> x + y) // evaluates to None
 (Some 5, None) ||> Option.map2 (fun x y -> x + y) // evaluates to None
 (None, Some 10) ||> Option.map2 (fun x y -> x + y) // evaluates to None
 (Some 5, Some 10) ||> Option.map2 (fun x y -> x + y) // evaluates to Some 15
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary><c>map f inp</c> evaluates to <c>match inp with None -> None | Some x -> Some (f x)</c>.</summary>

 <param name="mapping">A function to apply to the option value.</param>
 <param name="option">The input option.</param>

 <returns>An option of the input value after applying the mapping function, or None if the input is None.</returns>

 <example id="map-1">
 <code lang="fsharp">
 None |> Option.map (fun x -> x * 2) // evaluates to None
 Some 42 |> Option.map (fun x -> x * 2) // evaluates to Some 84
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary><c>iter f inp</c> executes <c>match inp with None -> () | Some x -> f x</c>.</summary>

 <param name="action">A function to apply to the option value.</param>
 <param name="option">The input option.</param>

 <example id="iter-1">
 <code lang="fsharp">
 None |> Option.iter (printfn "%s") // does nothing
 Some "Hello world" |> Option.iter (printfn "%s") // prints "Hello world"
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Contains``1(``0,Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Evaluates to true if <paramref name="option"/> is <c>Some</c> and its value is equal to <paramref name="value"/>.</summary>

 <param name="value">The value to test for equality.</param>
 <param name="option">The input option.</param>

 <returns>True if the option is <c>Some</c> and contains a value equal to <paramref name="value"/>, otherwise false.</returns>

 <example id="contains-1">
 <code lang="fsharp">
 (99, None) ||> Option.contains // evaluates to false
 (99, Some 99) ||> Option.contains // evaluates to true
 (99, Some 100) ||> Option.contains // evaluates to false
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.ForAll``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary><c>forall p inp</c> evaluates to <c>match inp with None -> true | Some x -> p x</c>.</summary>

 <param name="predicate">A function that evaluates to a boolean when given a value from the option type.</param>
 <param name="option">The input option.</param>

 <returns>True if the option is None, otherwise it returns the result of applying the predicate
 to the option value.</returns>

 <example id="forall-1">
 <code lang="fsharp">
 None |> Option.forall (fun x -> x >= 5) // evaluates to true
 Some 42 |> Option.forall (fun x -> x >= 5) // evaluates to true
 Some 4 |> Option.forall (fun x -> x >= 5) // evaluates to false
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary><c>exists p inp</c> evaluates to <c>match inp with None -> false | Some x -> p x</c>.</summary>

 <param name="predicate">A function that evaluates to a boolean when given a value from the option type.</param>
 <param name="option">The input option.</param>

 <returns>False if the option is None, otherwise it returns the result of applying the predicate
 to the option value.</returns>

 <example id="exists-1">
 <code lang="fsharp">
 None |> Option.exists (fun x -> x >= 5) // evaluates to false
 Some 42 |> Option.exists (fun x -> x >= 5) // evaluates to true
 Some 4 |> Option.exists (fun x -> x >= 5) // evaluates to false
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Microsoft.FSharp.Core.FSharpOption{``0},``1)">
 <summary><c>fold f inp s</c> evaluates to <c>match inp with None -> s | Some x -> f x s</c>.</summary>

 <param name="folder">A function to update the state data when given a value from an option.</param>
 <param name="option">The input option.</param>
 <param name="state">The initial state.</param>

 <returns>The original state if the option is None, otherwise it returns the updated state with the folder
 and the option value.</returns>

 <example id="foldBack-1">
 <code lang="fsharp">
 (None, 0) ||> Option.foldBack (fun x accum -> accum + x * 2) // evaluates to 0
 (Some 1, 0) ||> Option.foldBack (fun x accum -> accum + x * 2) // evaluates to 2
 (Some 1, 10) ||> Option.foldBack (fun x accum -> accum + x * 2) // evaluates to 12
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1,Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary><c>fold f s inp</c> evaluates to <c>match inp with None -> s | Some x -> f s x</c>.</summary>

 <param name="folder">A function to update the state data when given a value from an option.</param>
 <param name="state">The initial state.</param>
 <param name="option">The input option.</param>

 <returns>The original state if the option is None, otherwise it returns the updated state with the folder
 and the option value.</returns>

 <example id="fold-1">
 <code lang="fsharp">
 (0, None) ||> Option.fold (fun accum x -> accum + x * 2) // evaluates to 0
 (0, Some 1) ||> Option.fold (fun accum x -> accum + x * 2) // evaluates to 2
 (10, Some 1) ||> Option.fold (fun accum x -> accum + x * 2) // evaluates to 12
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Count``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary><c>count inp</c> evaluates to <c>match inp with None -> 0 | Some _ -> 1</c>.</summary>

 <param name="option">The input option.</param>

 <returns>A zero if the option is None, a one otherwise.</returns>

 <example id="count-1">
 <code lang="fsharp">
 None |> Option.count // evaluates to 0
 Some 99 |> Option.count // evaluates to 1
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.GetValue``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Gets the value associated with the option.</summary>

 <param name="option">The input option.</param>

 <returns>The value within the option.</returns>

 <exception href="System.ArgumentException">Thrown when the option is None.</exception>

 <example id="get-1">
 <code lang="fsharp">
 Some 42 |> Option.get // evaluates to 42
 (None: int option) |> Option.get // throws exception!
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.OrElseWith``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.FSharpOption{``0}},Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Returns <paramref name="option"/> if it is <c>Some</c>, otherwise evaluates <paramref name="ifNoneThunk"/> and returns the result.</summary>

 <param name="ifNoneThunk">A thunk that provides an alternate option when evaluated.</param>
 <param name="option">The input option.</param>

 <returns>The option if the option is Some, else the result of evaluating <paramref name="ifNoneThunk"/>.</returns>
 <remarks><paramref name="ifNoneThunk"/> is not evaluated unless <paramref name="option"/> is <c>None</c>.</remarks>

 <example id="orElseWith-1">
 <code lang="fsharp">
 (None: int Option) |> Option.orElseWith (fun () -> None) // evaluates to None
 None |> Option.orElseWith (fun () -> (Some 99)) // evaluates to Some 99
 Some 42 |> Option.orElseWith (fun () -> None) // evaluates to Some 42
 Some 42 |> Option.orElseWith (fun () -> (Some 99)) // evaluates to Some 42
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.OrElse``1(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Returns <paramref name="option"/> if it is <c>Some</c>, otherwise returns <paramref name="ifNone"/>.</summary>

 <param name="ifNone">The value to use if <paramref name="option"/> is <c>None</c>.</param>
 <param name="option">The input option.</param>

 <returns>The option if the option is Some, else the alternate option.</returns>

 <example id="orElse-1">
 <code lang="fsharp">
 ((None: int Option), None) ||> Option.orElse // evaluates to None
 (Some 99, None) ||> Option.orElse // evaluates to Some 99
 (None, Some 42) ||> Option.orElse // evaluates to Some 42
 (Some 99, Some 42) ||> Option.orElse // evaluates to Some 42
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.DefaultWith``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Gets the value of the option if the option is <c>Some</c>, otherwise evaluates <paramref name="defThunk"/> and returns the result.</summary>

 <param name="defThunk">A thunk that provides a default value when evaluated.</param>
 <param name="option">The input option.</param>

 <returns>The option if the option is Some, else the result of evaluating <paramref name="defThunk"/>.</returns>
 <remarks><paramref name="defThunk"/> is not evaluated unless <paramref name="option"/> is <c>None</c>.</remarks>

 <example id="defaultWith-1">
 <code lang="fsharp">
 None |> Option.defaultWith (fun () -> 99) // evaluates to 99
 Some 42 |> Option.defaultWith (fun () -> 99) // evaluates to 42
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.DefaultValue``1(``0,Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Gets the value of the option if the option is <c>Some</c>, otherwise returns the specified default value.</summary>

 <param name="value">The specified default value.</param>
 <param name="option">The input option.</param>

 <returns>The option if the option is Some, else the default value.</returns>

 <remarks>Identical to the built-in <see cref="defaultArg"/> operator, except with the arguments swapped.</remarks>

 <example id="defaultValue-1">
 <code lang="fsharp">
 (99, None) ||> Option.defaultValue // evaluates to 99
 (99, Some 42) ||> Option.defaultValue // evaluates to 42
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.IsNone``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Returns true if the option is None.</summary>

 <param name="option">The input option.</param>

 <returns>True if the option is None.</returns>

 <example id="isNone-1">
 <code lang="fsharp">
 None |> Option.isNone // evaluates to true
 Some 42 |> Option.isNone // evaluates to false
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.IsSome``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Returns true if the option is not None.</summary>
 <param name="option">The input option.</param>

 <returns>True if the option is not None.</returns>

 <example id="isSome-1">
 <code lang="fsharp">
 None |> Option.isSome // evaluates to false
 Some 42 |> Option.isSome // evaluates to true
 </code>
 </example>
</member>
<member name="T:Microsoft.FSharp.Core.OptionModule">
 <summary>Contains operations for working with options.</summary>

 <category>Options</category>
</member>
<member name="M:Microsoft.FSharp.Core.ResultModule.ToValueOption``2(Microsoft.FSharp.Core.FSharpResult{``0,``1})">
 <summary>Convert the result to an Option value.</summary>

 <param name="result">The input result.</param>

 <returns>The result value.</returns>

 <example id="toValueOption-1">
 <code lang="fsharp">
 Error 42 |> Result.toOption // evaluates to ValueNone
 Ok 42 |> Result.toOption // evaluates to ValueSome 42
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ResultModule.ToOption``2(Microsoft.FSharp.Core.FSharpResult{``0,``1})">
 <summary>Convert the result to an Option value.</summary>

 <param name="result">The input result.</param>

 <returns>The option value.</returns>

 <example id="toOption-1">
 <code lang="fsharp">
 Error 42 |> Result.toOption // evaluates to None
 Ok 42 |> Result.toOption // evaluates to Some 42
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ResultModule.ToList``2(Microsoft.FSharp.Core.FSharpResult{``0,``1})">
 <summary>Convert the result to a list of length 0 or 1.</summary>

 <param name="result">The input result.</param>

 <returns>The result list.</returns>

 <example id="toList-1">
 <code lang="fsharp">
 Error 42 |> Result.toList // evaluates to []
 Ok 42 |> Result.toList // evaluates to [ 42 ]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ResultModule.ToArray``2(Microsoft.FSharp.Core.FSharpResult{``0,``1})">
 <summary>Convert the result to an array of length 0 or 1.</summary>

 <param name="result">The input result.</param>

 <returns>The result array.</returns>

 <example id="toArray-1">
 <code lang="fsharp">
 Error 42 |> Result.toArray // evaluates to [||]
 Ok 42 |> Result.toArray // evaluates to [| 42 |]
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ResultModule.Iterate``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpResult{``0,``1})">
 <summary><c>iter f inp</c> executes <c>match inp with Error _ -> () | Ok x -> f x</c>.</summary>

 <param name="action">A function to apply to the result value.</param>
 <param name="result">The input result.</param>

 <example id="iter-1">
 <code lang="fsharp">
 Error "Hello world" |> Result.iter (printfn "%s") // does nothing
 Ok "Hello world" |> Result.iter (printfn "%s") // prints "Hello world"
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ResultModule.Contains``2(``0,Microsoft.FSharp.Core.FSharpResult{``0,``1})">
 <summary>Evaluates to true if <paramref name="result"/> is <c>Ok</c> and its value is equal to <paramref name="value"/>.</summary>

 <param name="value">The value to test for equality.</param>
 <param name="result">The input result.</param>

 <returns>True if the result is <c>Ok</c> and contains a value equal to <paramref name="value"/>, otherwise false.</returns>

 <example id="contains-1">
 <code lang="fsharp">
 (99, Error 99) ||> Result.contains // evaluates to false
 (99, Ok 99) ||> Result.contains // evaluates to true
 (99, Ok 100) ||> Result.contains // evaluates to false
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ResultModule.ForAll``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Core.FSharpResult{``0,``1})">
 <summary><c>forall p inp</c> evaluates to <c>match inp with Error _ -> true | Ok x -> p x</c>.</summary>

 <param name="predicate">A function that evaluates to a boolean when given a value from the result type.</param>
 <param name="result">The input result.</param>

 <returns>True if the result is Error, otherwise it returns the result of applying the predicate
 to the result value.</returns>

 <example id="forall-1">
 <code lang="fsharp">
 Error 1 |> Result.forall (fun x -> x >= 5) // evaluates to true
 Ok 42 |> Result.forall (fun x -> x >= 5) // evaluates to true
 Ok 4 |> Result.forall (fun x -> x >= 5) // evaluates to false
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ResultModule.Exists``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Core.FSharpResult{``0,``1})">
 <summary><c>exists p inp</c> evaluates to <c>match inp with Error _ -> false | Ok x -> p x</c>.</summary>

 <param name="predicate">A function that evaluates to a boolean when given a value from the result type.</param>
 <param name="result">The input result.</param>

 <returns>False if the result is Error, otherwise it returns the result of applying the predicate
 to the result value.</returns>

 <example id="exists-1">
 <code lang="fsharp">
 Error 6 |> Result.exists (fun x -> x >= 5) // evaluates to false
 Ok 42 |> Result.exists (fun x -> x >= 5) // evaluates to true
 Ok 4 |> Result.exists (fun x -> x >= 5) // evaluates to false
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ResultModule.FoldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,``2}},Microsoft.FSharp.Core.FSharpResult{``0,``1},``2)">
 <summary><c>fold f inp s</c> evaluates to <c>match inp with Error _ -> s | Ok x -> f x s</c>.</summary>

 <param name="folder">A function to update the state data when given a value from an result.</param>
 <param name="result">The input result.</param>
 <param name="state">The initial state.</param>

 <returns>The original state if the result is Error, otherwise it returns the updated state with the folder
 and the result value.</returns>

 <example id="foldBack-1">
 <code lang="fsharp">
 (Error 2, 0) ||> Result.foldBack (fun x accum -> accum + x * 2) // evaluates to 0
 (Ok 1, 0) ||> Result.foldBack (fun x accum -> accum + x * 2) // evaluates to 2
 (Ok 1, 10) ||> Result.foldBack (fun x accum -> accum + x * 2) // evaluates to 12
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ResultModule.Fold``3(Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``0,``2}},``2,Microsoft.FSharp.Core.FSharpResult{``0,``1})">
 <summary><c>fold f s inp</c> evaluates to <c>match inp with Error _ -> s | Ok x -> f s x</c>.</summary>

 <param name="folder">A function to update the state data when given a value from an result.</param>
 <param name="state">The initial state.</param>
 <param name="result">The input result.</param>

 <returns>The original state if the result is Error, otherwise it returns the updated state with the folder
 and the result value.</returns>

 <example id="fold-1">
 <code lang="fsharp">
 (0, Error 2) ||> Result.fold (fun accum x -> accum + x * 2) // evaluates to 0
 (0, Ok 1) ||> Result.fold (fun accum x -> accum + x * 2) // evaluates to 2
 (10, Ok 1) ||> Result.fold (fun accum x -> accum + x * 2) // evaluates to 12
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ResultModule.Count``2(Microsoft.FSharp.Core.FSharpResult{``0,``1})">
 <summary><c>count inp</c> evaluates to <c>match inp with Error _ -> 0 | Ok _ -> 1</c>.</summary>

 <param name="result">The input result.</param>

 <returns>A zero if the result is Error, a one otherwise.</returns>

 <example id="count-1">
 <code lang="fsharp">
 Error 99 |> Result.count // evaluates to 0
 Ok 99 |> Result.count // evaluates to 1
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ResultModule.DefaultWith``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpResult{``1,``0})">
 <summary>Gets the value of the result if the result is <c>Ok</c>, otherwise evaluates <paramref name="defThunk"/> and returns the result.</summary>

 <param name="defThunk">A thunk that provides a default value when evaluated.</param>
 <param name="result">The input result.</param>

 <returns>The result if the result is Ok, else the result of evaluating <paramref name="defThunk"/>.</returns>
 <remarks><paramref name="defThunk"/> is not evaluated unless <paramref name="result"/> is <c>Error</c>.</remarks>

 <example id="defaultWith-1">
 <code lang="fsharp">
 Ok 1 |> Result.defaultWith (fun error -> 99) // evaluates to 1
 Error 2 |> Result.defaultWith (fun error -> 99) // evaluates to 99
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ResultModule.DefaultValue``2(``0,Microsoft.FSharp.Core.FSharpResult{``0,``1})">
 <summary>Gets the value of the result if the result is <c>Ok</c>, otherwise returns the specified default value.</summary>

 <param name="value">The specified default value.</param>
 <param name="result">The input result.</param>

 <returns>The result if the result is Ok, else the default value.</returns>

 <example id="defaultValue-1">
 <code lang="fsharp">
 Result.defaultValue 2 (Error 3) // evaluates to 2
 Result.defaultValue 2 (Ok 1) // evaluates to 1
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ResultModule.IsError``2(Microsoft.FSharp.Core.FSharpResult{``0,``1})">
 <summary>Returns true if the result is Error.</summary>

 <param name="result">The input result.</param>

 <returns>True if the result is Error.</returns>

 <example id="isError-1">
 <code lang="fsharp">
 Ok 42 |> Result.isError // evaluates to false
 Error 42 |> Result.isError // evaluates to true
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ResultModule.IsOk``2(Microsoft.FSharp.Core.FSharpResult{``0,``1})">
 <summary>Returns true if the result is Ok.</summary>
 <param name="result">The input result.</param>

 <returns>True if the result is OK.</returns>

 <example id="isOk-1">
 <code lang="fsharp">
 Ok 42 |> Result.isOk // evaluates to true
 Error 42 |> Result.isOk // evaluates to false
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ResultModule.Bind``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpResult{``1,``2}},Microsoft.FSharp.Core.FSharpResult{``0,``2})">
 <summary><c>bind f inp</c> evaluates to <c>match inp with Error e -> Error e | Ok x -> f x</c></summary>

 <param name="binder">A function that takes the value of type T from a result and transforms it into
 a result containing a value of type U.</param>
 <param name="result">The input result.</param>

 <returns>A result of the output type of the binder.</returns>

 <example>
 <code lang="fsharp">
 let tryParse (input: string) =
     match System.Int32.TryParse input with
     | true, v -> Ok v
     | false, _ -> Error "couldn't parse"

 Error "message" |> Result.bind tryParse // evaluates to Error "message"

 Ok "42" |> Result.bind tryParse // evaluates to Ok 42

 Ok "Forty-two" |> Result.bind tryParse // evaluates to Error "couldn't parse"
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ResultModule.MapError``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpResult{``2,``0})">
 <summary><c>map f inp</c> evaluates to <c>match inp with Error x -> Error (f x) | Ok v -> Ok v</c>.</summary>

 <param name="mapping">A function to apply to the Error result value.</param>
 <param name="result">The input result.</param>

 <returns>A result of the error value after applying the mapping function, or Ok if the input is Ok.</returns>

 <example>
 <code lang="fsharp">
 Ok 1 |> Result.mapError (fun x -> "bar") // evaluates to Ok 1

 Error "foo" |> Result.mapError (fun x -> "bar") // evaluates to Error "bar"
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ResultModule.Map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpResult{``0,``2})">
 <summary><c>map f inp</c> evaluates to <c>match inp with Error e -> Error e | Ok x -> Ok (f x)</c>.</summary>

 <param name="mapping">A function to apply to the OK result value.</param>
 <param name="result">The input result.</param>

 <returns>A result of the input value after applying the mapping function, or Error if the input is Error.</returns>

 <example>
 <code lang="fsharp">
 Ok 1 |> Result.map (fun x -> "perfect") // evaluates to Ok "perfect"

 Error "message" |> Result.map (fun x -> "perfect") // evaluates to Error "message"
 </code>
 </example>
</member>
<member name="T:Microsoft.FSharp.Core.ResultModule">
 <summary>Contains operations for working with values of type <see cref="T:Microsoft.FSharp.Core.FSharpResult`2"/>.</summary>

 <category>Choices and Results</category>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Replicate(System.Int32,System.String)">
 <summary>Returns a string by concatenating <c>count</c> instances of <c>str</c>.</summary>

 <param name="count">The number of copies of the input string will be copied.</param>
 <param name="str">The input string.</param>

 <returns>The concatenated string.</returns>
 <exception cref="T:System.ArgumentException">Thrown when <c>count</c> is negative.</exception>

 <example id="replicate-1">
 <code lang="fsharp">
 "Do it!" |> String.replicate 3
 </code>
 Evaluates to <c>"Do it!Do it!Do it!"</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.MapIndexed(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Char}},System.String)">
 <summary>Builds a new string whose characters are the results of applying the function <c>mapping</c>
 to each character and index of the input string.</summary>

 <param name="mapping">The function to apply to each character and index of the string.</param>
 <param name="str">The input string.</param>

 <returns>The resulting string.</returns>

 <example id="mapi-1">
 <code lang="fsharp">
 input |> String.mapi (fun i c -> (i, c))
 </code>
 Evaluates to <c>[ (0, 'O'); (1, 'K'); (2, '!') ]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Map(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Char},System.String)">
 <summary>Builds a new string whose characters are the results of applying the function <c>mapping</c>
 to each of the characters of the input string.</summary>

 <param name="mapping">The function to apply to the characters of the string.</param>
 <param name="str">The input string.</param>

 <returns>The resulting string.</returns>

 <example id="map-1"> Changing case to upper for all characters in the input string
 <code lang="fsharp">
 open System

 let input = "Hello there!"

 input |> String.map Char.ToUpper  // evaluates "HELLO THERE!"
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Length(System.String)">
 <summary>Returns the length of the string.</summary>

 <param name="str">The input string.</param>

 <returns>The number of characters in the string.</returns>

 <example id="length-1"> Getting the length of different strings
 <code lang="fsharp">
 String.length null   // evaluates 0
 String.length ""     // evaluates 0
 String.length "123"  // evaluates 3
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.IterateIndexed(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.Unit}},System.String)">
 <summary>Applies the function <c>action</c> to the index of each character in the string and the
 character itself.</summary>

 <param name="action">The function to apply to each character and index of the string.</param>
 <param name="str">The input string.</param>

 <example id="iteri-1"> Numbering the characters and printing the associated ASCII code
 for each characater in the input string
 <code lang="fsharp">
 let input = "Hello"
 input |> String.iteri (fun i c -> printfn "%d. %c %d" (i + 1) c (int c))
 </code>
 The sample evaluates as <c>unit</c>, but prints:
 <code>
 1. H 72
 2. e 101
 3. l 108
 4. l 108
 5. o 111
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Iterate(Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.Unit},System.String)">
 <summary>Applies the function <c>action</c> to each character in the string.</summary>

 <param name="action">The function to be applied to each character of the string.</param>
 <param name="str">The input string.</param>

 <example id="iter-1"> Printing the ASCII code for each characater in the string
 <code lang="fsharp">
 let input = "Hello"
 input |> String.iter (fun c -> printfn "%c %d" c (int c))
 </code>
 The sample evaluates as <c>unit</c>, but prints:
 <code>
 H 72
 e 101
 l 108
 l 108
 o 111
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Initialize(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.String})">
 <summary>Builds a new string whose characters are the results of applying the function <c>mapping</c>
 to each index from <c>0</c> to <c>count-1</c> and concatenating the resulting
 strings.</summary>

 <param name="count">The number of strings to initialize.</param>
 <param name="initializer">The function to take an index and produce a string to
 be concatenated with the others.</param>

 <returns>The constructed string.</returns>

 <exception cref="T:System.ArgumentException">Thrown when <c>count</c> is negative.</exception>

 <example id="init-1"> Enumerate digits ASCII codes
 <code lang="fsharp">
 String.init 10 (fun i -> int '0' + i |> sprintf "%d ")
 </code>
 The sample evaluates to: <c>"48 49 50 51 52 53 54 55 56 57 "</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.ForAll(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
 <summary>Tests if all characters in the string satisfy the given predicate.</summary>

 <param name="predicate">The function to test each character of the string.</param>
 <param name="str">The input string.</param>

 <returns>True if all characters return true for the predicate and false otherwise.</returns>

 <example id="forall-1"> Looking for lowercase characters
 <code lang="fsharp">
 open System

 "all are lower" |> String.forall Char.IsLower  // evaluates false

 "allarelower" |> String.forall Char.IsLower    // evaluates true
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Filter(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
 <summary>Builds a new string containing only the characters of the input string
 for which the given predicate returns "true".</summary>

 <remarks>Returns an empty string if the input string is null</remarks>

 <param name="predicate">A function to test whether each character in the input sequence should be included in the output string.</param>
 <param name="str">The input string.</param>

 <returns>The resulting string.</returns>

 <example id="filter-1"> Filtering out just alphanumeric characters
 <code lang="fsharp">
 open System

 let input = "0 1 2 3 4 5 6 7 8 9 a A m M"

 input |> String.filter Uri.IsHexDigit  // evaluates "123456789aA"
 </code>
 </example>
 <example id="filter-2"> Filtering out just digits
 <code lang="fsharp">
 open System

 "hello" |> String.filter Char.IsDigit  // evaluates ""
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Exists(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
 <summary>Tests if any character of the string satisfies the given predicate.</summary>

 <param name="predicate">The function to test each character of the string.</param>
 <param name="str">The input string.</param>

 <returns>True if any character returns true for the predicate and false otherwise.</returns>

 <example id="exists-1"> Looking for uppercase characters
 <code lang="fsharp">
 open System

 "Yoda" |> String.exists Char.IsUpper  // evaluates true

 "nope" |> String.exists Char.IsUpper  // evaluates false
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Concat(System.String,System.Collections.Generic.IEnumerable{System.String})">
 <summary>Returns a new string made by concatenating the given strings
 with separator <c>sep</c>, that is <c>a1 + sep + ... + sep + aN</c>.</summary>
 <param name="sep">The separator string to be inserted between the strings
 of the input sequence.</param>
 <param name="strings">The sequence of strings to be concatenated.</param>

 <returns>A new string consisting of the concatenated strings separated by
 the separation string.</returns>
 <exception cref="T:System.ArgumentNullException">Thrown when <c>strings</c> is null.</exception>

 <example id="concat-1">
 <code lang="fsharp">
 let input1 = ["Stefan"; "says:"; "Hello"; "there!"]

 input1 |> String.concat " "  // evaluates "Stefan says: Hello there!"

 let input2 = [0..9] |> List.map string

 input2 |> String.concat ""    // evaluates "0123456789"
 input2 |> String.concat ", "  // evaluates "0, 1, 2, 3, 4, 5, 6, 7, 8, 9"

 let input3 = ["No comma"]

 input3 |> String.concat ","   // evaluates "No comma"
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Collect(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.String},System.String)">
 <summary>Builds a new string whose characters are the results of applying the function <c>mapping</c>
 to each of the characters of the input string and concatenating the resulting
 strings.</summary>

 <param name="mapping">The function to produce a string from each character of the input string.</param>
 <param name="str">The input string.</param>

 <returns>The concatenated string.</returns>

 <example id="collect-1"> The following samples shows how to interspace spaces in a text
 <code lang="fsharp">
 let input = "Stefan says: Hi!"

 input |> String.collect (sprintf "%c ")
 </code>
 The sample evaluates to <c>"S t e f a n   s a y s :   H i ! "</c>
 </example>

 <example id="collect-2"> How to show the ASCII representation of a very secret text
 <code lang="fsharp">
 "Secret" |> String.collect (fun chr -> int chr |> sprintf "%d ")
 </code>
 The sample evaluates to <c>"83 101 99 114 101 116 "</c>
 </example>
</member>
<member name="T:Microsoft.FSharp.Core.StringModule">
 <summary>Functional programming operators for string processing.  Further string operations
 are available via the member functions on strings and other functionality in
  <a href="http://msdn2.microsoft.com/en-us/library/system.string.aspx">System.String</a>
 and <a href="http://msdn2.microsoft.com/library/system.text.regularexpressions.aspx">System.Text.RegularExpressions</a> types.
 </summary>

 <category>Strings and Text</category>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromStringDynamic(System.String)">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals of the form &apos;dddI&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromInt64Dynamic(System.Int64)">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals of the form &apos;dddI&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromString``1(System.String)">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals of the form &apos;dddI&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromInt64``1(System.Int64)">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals of the form &apos;dddI&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromInt32``1(System.Int32)">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals of the form &apos;dddI&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromOne``1">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals of the form &apos;dddI&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromZero``1">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals of the form &apos;dddI&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals of the form &apos;dddI&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.NumericLiterals">
 <summary>Provides a default implementations of F# numeric literal syntax  for literals of the form 'dddI' </summary>

 <category>Language Primitives</category>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule.TextWriterFormat`1">
 <summary>Represents a statically-analyzed format associated with writing to a <see cref="T:System.IO.TextWriter"/>. The type parameter indicates the
 arguments and return type of the format operation.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule.StringFormat`1">
 <summary>Represents a statically-analyzed format when formatting builds a string. The type parameter indicates the
 arguments and return type of the format operation.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule.BuilderFormat`1">
 <summary>Represents a statically-analyzed format associated with writing to a <see cref="T:System.Text.StringBuilder"/>. The type parameter indicates the
 arguments and return type of the format operation.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule.TextWriterFormat`2">
 <summary>Represents a statically-analyzed format associated with writing to a <see cref="T:System.IO.TextWriter"/>. The first type parameter indicates the
 arguments of the format operation and the last the overall return type.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule.StringFormat`2">
 <summary>Represents a statically-analyzed format when formatting builds a string. The first type parameter indicates the
 arguments of the format operation and the last the overall return type.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule.BuilderFormat`2">
 <summary>Represents a statically-analyzed format associated with writing to a <see cref="T:System.Text.StringBuilder"/>. The first type parameter indicates the
 arguments of the format operation and the last the overall return type.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToStringThenFail``2(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,``1})">
 <summary>Print to a string buffer and raise an exception with the given
 result. Helper printers must return strings.</summary>

 <param name="format">The input formatter.</param>

 <returns>The arguments of the formatter.</returns>

 <example id="failwithff-1">
 <code lang="fsharp">
 failwithf "That's wrong. Five = %d and six = %d" (3+2) (3+3)
 </code>
 Throws <c>Exception</c> with message <c>"That's wrong. Five = 5 and six = 6"</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToStringThen``2(Microsoft.FSharp.Core.FSharpFunc{System.String,``0},Microsoft.FSharp.Core.PrintfFormat{``1,Microsoft.FSharp.Core.Unit,System.String,``0})">
 <summary>sprintf, but call the given 'final' function to generate the result.
 See <c>kprintf</c>.</summary>

 <param name="continuation">The function called to generate a result from the formatted string.</param>
 <param name="format">The input formatter.</param>

 <returns>The arguments of the formatter.</returns>

 <example id="ksprintf-1">Using <c>%</c> format patterns:
 <code lang="fsharp">
 open Printf

 ksprintf (fun s -> s + ", done!") $"Write three = {1+2}"
 </code>
 Evaluates to <c>"Write five = 5, done!"</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatThen``2(Microsoft.FSharp.Core.FSharpFunc{System.String,``0},Microsoft.FSharp.Core.PrintfFormat{``1,Microsoft.FSharp.Core.Unit,System.String,``0})">
 <summary>printf, but call the given 'final' function to generate the result.
 For example, these let the printing force a flush after all output has
 been entered onto the channel, but not before. </summary>

 <param name="continuation">The function called after formatting to generate the format result.</param>
 <param name="format">The input formatter.</param>

 <returns>The arguments of the formatter.</returns>

 <example id="kprintf-1">Using <c>%</c> format patterns:
 <code lang="fsharp">
 open Printf

 kprintf (fun s -> s + ", done!") $"Write three = {1+2}"
 </code>
 Evaluates to <c>"Write five = 5, done!"</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToTextWriterThen``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},System.IO.TextWriter,Microsoft.FSharp.Core.PrintfFormat{``1,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,``0})">
 <summary>fprintf, but call the given 'final' function to generate the result.
 See <c>kprintf</c>.</summary>

 <param name="continuation">The function called after formatting to generate the format result.</param>
 <param name="textWriter">The input TextWriter.</param>
 <param name="format">The input formatter.</param>

 <returns>The arguments of the formatter.</returns>

 <example id="kfprintf-1">Using <c>%</c> format patterns:
 <code lang="fsharp">
 open Printf
 open System.IO

 let file = File.CreateText("out.txt")

 kfprintf (fun () -> file.Close()) $"Write three = {1+2}"
 </code>
 Writes <c>"Write five = 5"</c> to <c>out.txt</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToStringBuilderThen``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},System.Text.StringBuilder,Microsoft.FSharp.Core.PrintfFormat{``1,System.Text.StringBuilder,Microsoft.FSharp.Core.Unit,``0})">
 <summary>bprintf, but call the given 'final' function to generate the result.
 See <c>kprintf</c>.</summary>

 <param name="continuation">The function called after formatting to generate the format result.</param>
 <param name="builder">The input StringBuilder.</param>
 <param name="format">The input formatter.</param>

 <returns>The arguments of the formatter.</returns>

 <example id="kbprintf-1">Using <c>%</c> format patterns:
 <code lang="fsharp">
 open Printf
 open System.Text

 let buffer = new StringBuilder()

 kbprintf (fun () -> buffer.ToString()) buffer "Write five = %d" (3+2)
 </code>
 Evaluates to <c>"Write five = 5"</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToStringThen``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,System.String})">
 <summary>Print to a string via an internal string buffer and return
 the result as a string. Helper printers must return strings.</summary>

 <param name="format">The input formatter.</param>

 <returns>The formatted string.</returns>

 <example id="sprintf-1">
 <code lang="fsharp">
 sprintf "Write five = %d and six = %d" (3+2) (3+3)
 </code>
 Evaluates to <c>"Write five = 5 and six = 6"</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatLine``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Formatted printing to stdout, adding a newline.</summary>

 <param name="format">The input formatter.</param>

 <returns>The return type and arguments of the formatter.</returns>

 <example id="printfn-1">Using interpolated strings:
 <code lang="fsharp">
 printfn $"Write three = {1+2}"
 printfn $"Write four = {2+2}"
 </code>
 After evaluation the two lines are written to <c>stdout</c>.
 </example>

 <example id="printfn-2">Using <c>%</c> format patterns:
 <code lang="fsharp">
 printfn "Write five = %d" (3+2)
 printfn "Write six = %d" (3+3)
 </code>
 After evaluation the two lines are written to <c>stdout</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormat``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Formatted printing to stdout</summary>

 <param name="format">The input formatter.</param>

 <returns>The return type and arguments of the formatter.</returns>

 <example id="printf-1">Using interpolated strings:
 <code lang="fsharp">
 printf $"Write three = {1+2}"
 </code>
 After evaluation the text <c>"Write three = 3"</c> is written to <c>stdout</c>.
 </example>

 <example id="printf-2">Using <c>%</c> format patterns:
 <code lang="fsharp">
 printf "Write five = %d" (3+2)
 </code>
 After evaluation the text <c>"Write five = 5"</c> is written to <c>stdout</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatLineToError``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Formatted printing to stderr, adding a newline </summary>

 <param name="format">The input formatter.</param>

 <returns>The return type and arguments of the formatter.</returns>

 <example id="eprintfn-1">Using interpolated strings:
 <code lang="fsharp">
 eprintfn $"Write three = {1+2}"
 eprintfn $"Write four = {2+2}"
 </code>
 After evaluation two lines are written to <c>stderr</c>.
 </example>

 <example id="eprintf-2">Using <c>%</c> format patterns:
 <code lang="fsharp">
 eprintfn "Write five = %d" (3+2)
 eprintfn "Write six = %d" (3+3)
 </code>
 After evaluation two lines are written to <c>stderr</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToError``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Formatted printing to stderr</summary>

 <param name="format">The input formatter.</param>

 <returns>The return type and arguments of the formatter.</returns>

 <example id="eprintf-1">Using interpolated strings:
 <code lang="fsharp">
 eprintf $"Write three = {1+2}"
 </code>
 After evaluation the text <c>"Write three = 3"</c> is written to <c>stderr</c>.
 </example>

 <example id="eprintf-2">Using <c>%</c> format patterns:
 <code lang="fsharp">
 eprintf "Write five = %d" (3+2)
 </code>
 After evaluation the text <c>"Write five = 5"</c> is written to <c>stderr</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatLineToTextWriter``1(System.IO.TextWriter,Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Print to a text writer, adding a newline</summary>

 <param name="textWriter">The TextWriter to print to.</param>
 <param name="format">The input formatter.</param>

 <returns>The return type and arguments of the formatter.</returns>


 <example id="fprintfn-1">Using interpolated strings:
 <code lang="fsharp">
 open Printf
 open System.IO

 let file = File.CreateText("out.txt")

 fprintfn file $"Write three = {1+2}"
 fprintfn file $"Write four = {2+2}"
 file.Close()
 </code>
 After evaluation the file contains two lines.
 </example>

 <example id="fprintfn-2">Using <c>%</c> format patterns:
 <code lang="fsharp">
 open Printf
 open System.IO

 let file = File.CreateText("out.txt")

 fprintfn file "Write five = %d" (3+2)
 fprintfn file "Write six = %d" (3+3)
 file.Close()
 </code>
 After evaluation the file contains two lines.
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToTextWriter``1(System.IO.TextWriter,Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Print to a text writer.</summary>

 <param name="textWriter">The TextWriter to print to.</param>
 <param name="format">The input formatter.</param>

 <returns>The return type and arguments of the formatter.</returns>

 <example id="fprintf-1">Using interpolated strings:
 <code lang="fsharp">
 open Printf
 open System.IO

 let file = File.CreateText("out.txt")

 fprintf file $"Write three = {1+2}"
 file.Close()
 </code>
 After evaluation the file contains the text <c>"Write three = 3"</c>.
 </example>

 <example id="fprintf-2">Using <c>%</c> format patterns:
 <code lang="fsharp">
 open Printf
 open System.IO

 let file = File.CreateText("out.txt")

 fprintf file "Write five = %d" (3+2)
 file.Close()
 </code>
 After evaluation the file contains the text <c>"Write five = 5"</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToStringBuilder``1(System.Text.StringBuilder,Microsoft.FSharp.Core.PrintfFormat{``0,System.Text.StringBuilder,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Print to a <see cref="T:System.Text.StringBuilder"/></summary>

 <param name="builder">The StringBuilder to print to.</param>
 <param name="format">The input format or interpolated string.</param>

 <returns>The return type and arguments of the formatter.</returns>

 <example id="bprintf-1">Using interpolated strings:
 <code lang="fsharp">
 open Printf
 open System.Text

 let buffer = new StringBuilder()

 bprintf buffer $"Write three = {1+2}"
 buffer.ToString()
 </code>
 Evaluates to <c>"Write three = 3"</c>.
 </example>

 <example id="bprintf-2">Using <c>%</c> format patterns:
 <code lang="fsharp">
 open Printf
 open System.Text

 let buffer = new StringBuilder()

 bprintf buffer "Write five = %d" (3+2)
 buffer.ToString()
 </code>
 Evaluates to <c>"Write five = 5"</c>.
 </example>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule">
 <summary>Extensible printf-style formatting for numbers and other datatypes</summary>

 <remarks>Format specifications are strings with "%" markers indicating format
 placeholders. Format placeholders consist of <c>%[flags][width][.precision][type]</c>.</remarks>

 <category index="4">Strings and Text</category>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ArrayCollector`1.Close">
<summary>
 Return the resulting list
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ArrayCollector`1.AddManyAndClose(System.Collections.Generic.IEnumerable{`0})">
<summary>
 Add multiple elements to the collector and return the resulting array
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ArrayCollector`1.AddMany(System.Collections.Generic.IEnumerable{`0})">
<summary>
 Add multiple elements to the collector
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ArrayCollector`1.Add(`0)">
<summary>
 Add an element to the collector
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.ArrayCollector`1">
<summary>
 Collects elements and builds an array
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ListCollector`1.Close">
<summary>
 Return the resulting list
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ListCollector`1.AddManyAndClose(System.Collections.Generic.IEnumerable{`0})">
<summary>
 Add multiple elements to the collector and return the resulting list
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ListCollector`1.AddMany(System.Collections.Generic.IEnumerable{`0})">
<summary>
 Add multiple elements to the collector
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ListCollector`1.Add(`0)">
<summary>
 Add an element to the collector
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.ListCollector`1">
<summary>
 Collects elements and builds a list
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1.LastGenerated">
 <summary>The F# compiler emits implementations of this type for compiled sequence expressions.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1.CheckClose">
 <summary>The F# compiler emits implementations of this type for compiled sequence expressions.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1.GetFreshEnumerator">
 <summary>The F# compiler emits implementations of this type for compiled sequence expressions.</summary>

 <returns>A new enumerator for the sequence.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1.GenerateNext(System.Collections.Generic.IEnumerable{`0}@)">
 <summary>The F# compiler emits implementations of this type for compiled sequence expressions.</summary>

 <param name="result">A reference to the sequence.</param>

 <returns>A 0, 1, and 2 respectively indicate Stop, Yield, and Goto conditions for the sequence generator.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1.Close">
 <summary>The F# compiler emits implementations of this type for compiled sequence expressions.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1.#ctor">
 <summary>The F# compiler emits implementations of this type for compiled sequence expressions.</summary>

 <returns>A new sequence generator for the expression.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1">
 <summary>The F# compiler emits implementations of this type for compiled sequence expressions.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.NoEagerConstraintApplicationAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>NoEagerConstraintApplicationAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.NoEagerConstraintApplicationAttribute">
 <summary>Adding this attribute to the method adjusts the processing of some generic methods
 during overload resolution.</summary>

 <remarks>During overload resolution, caller arguments are matched with called arguments
 to extract type information. By default, when the caller argument type is unconstrained (for example
 a simple value <c>x</c> without known type information), and a method qualifies for
 lambda constraint propagation, then member trait constraints from a method overload
 are eagerly applied to the caller argument type. This causes that overload to be preferred,
 regardless of other method overload resolution rules. Using this attribute suppresses this behaviour. 
 </remarks>

 <example>
 Consider the following overloads:
 <code>
 type OverloadsWithSrtp() =
     [&lt;NoEagerConstraintApplicationAttribute&gt;]
     static member inline SomeMethod&lt; ^T when ^T : (member Number: int) &gt; (x: ^T, f: ^T -> int) = 1
     static member SomeMethod(x: 'T list, f: 'T list -> int) = 2
 
 let inline f x = 
     OverloadsWithSrtp.SomeMethod (x, (fun a -> 1)) 
 </code>
 With the attribute, the overload resolution fails, because both members are applicable.
 Without the attribute, the overload resolution succeeds, because the member constraint is
 eagerly applied, making the second member non-applicable.  
 </example>
 <category>Attributes</category>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.AfterCode`2">
<summary>
 Defines the implementation of the code run after the creation of a struct state machine.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.SetStateMachineMethodImpl`1">
<summary>
 Defines the implementation of the SetStateMachine method for a struct state machine.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.MoveNextMethodImpl`1">
<summary>
 Defines the implementation of the MoveNext method for a struct state machine.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.ResumableCode`2">
<summary>
 A special compiler-recognised delegate type for specifying blocks of resumable code
 with access to the state machine.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.ResumptionFunc`1">
<summary>
 Represents the runtime continuation of a resumable state machine created dynamically
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.ResumptionDynamicInfo`1.ResumptionFunc(Microsoft.FSharp.Core.CompilerServices.ResumptionFunc{`0})">
<summary>
 The continuation of the state machine
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.ResumptionDynamicInfo`1.ResumptionData(System.Object)">
<summary>
 Additional data associated with the state machine
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.ResumptionDynamicInfo`1.ResumptionFunc">
<summary>
 The continuation of the state machine
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.ResumptionDynamicInfo`1.ResumptionData">
<summary>
 Additional data associated with the state machine
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ResumptionDynamicInfo`1.SetStateMachine(Microsoft.FSharp.Core.CompilerServices.ResumableStateMachine{`0}@,System.Runtime.CompilerServices.IAsyncStateMachine)">
<summary>
 Executes the SetStateMachine implementation of the state machine
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ResumptionDynamicInfo`1.MoveNext(Microsoft.FSharp.Core.CompilerServices.ResumableStateMachine{`0}@)">
<summary>
 Executes the MoveNext implementation of the state machine
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ResumptionDynamicInfo`1.#ctor(Microsoft.FSharp.Core.CompilerServices.ResumptionFunc{`0})">
<summary>
 Create dynamic information for a state machine
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.ResumptionDynamicInfo`1">
<summary>
 Represents the delegated runtime continuation of a resumable state machine created dynamically
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.IResumableStateMachine`1.Data(`0)">
<summary>
 Copy-out or copy-in the data of the state machine
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.IResumableStateMachine`1.ResumptionPoint">
<summary>
 Get the resumption point of the state machine
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.IResumableStateMachine`1.Data">
<summary>
 Copy-out or copy-in the data of the state machine
</summary>
</member>
<member name="F:Microsoft.FSharp.Core.CompilerServices.ResumableStateMachine`1.ResumptionDynamicInfo">
 <summary>Represents the delegated runtime continuation for a resumable state machine created dynamically</summary>
 <remarks>This field is removed from state machines generated using '__stateMachine'. Resumable code
 used in state machines which accesses this field will raise a runtime exception.</remarks>
</member>
<member name="F:Microsoft.FSharp.Core.CompilerServices.ResumableStateMachine`1.ResumptionPoint">
<summary>
 When statically compiled, holds the continuation goto-label further execution of the state machine
</summary>
</member>
<member name="F:Microsoft.FSharp.Core.CompilerServices.ResumableStateMachine`1.Data">
<summary>
 When statically compiled, holds the data for the state machine
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.ResumableStateMachine`1">
<summary>
 Acts as a template for struct state machines introduced by __stateMachine, and also as a reflective implementation
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ITypeProvider2.GetStaticParametersForMethod(System.Reflection.MethodBase)">
 <summary>
 Get the static parameters for a provided method. 
 </summary>

 <param name="methodWithoutArguments">A method returned by GetMethod on a provided type</param>

 <returns>The static parameters of the provided method, if any</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ITypeProvider2.ApplyStaticArgumentsForMethod(System.Reflection.MethodBase,System.String,System.Object[])">
 <summary>
 Apply static arguments to a provided method that accepts static arguments. 
 </summary>
 <remarks>The provider must return a provided method with the given mangled name.</remarks>
 <param name="methodWithoutArguments">the provided method definition which has static parameters</param>
 <param name="methodNameWithArguments">the full name of the method that must be returned, including encoded representations of static parameters</param>
 <param name="staticArguments">the values of the static parameters, indexed by name</param>

 <returns>The provided method definition corresponding to the given static parameter values</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.ITypeProvider2">
<summary>
 Represents additional, optional information for a type provider component
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ITypeProvider.remove_Invalidate(System.EventHandler)">
 <summary>
 Triggered when an assumption changes that invalidates the resolutions so far reported by the provider
 </summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.ITypeProvider.Invalidate">
 <summary>
 Triggered when an assumption changes that invalidates the resolutions so far reported by the provider
 </summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ITypeProvider.add_Invalidate(System.EventHandler)">
 <summary>
 Triggered when an assumption changes that invalidates the resolutions so far reported by the provider
 </summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ITypeProvider.GetStaticParameters(System.Type)">
 <summary>
 Get the static parameters for a provided type. 
 </summary>

 <param name="typeWithoutArguments">A type returned by GetTypes or ResolveTypeName</param>

 <returns></returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ITypeProvider.GetNamespaces">
 <summary>
 Gets the namespaces provided by the type provider.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ITypeProvider.GetInvokerExpression(System.Reflection.MethodBase,Microsoft.FSharp.Quotations.FSharpExpr[])">
 <summary>
 Called by the compiler to ask for an Expression tree to replace the given MethodBase with.
 </summary>

 <param name="syntheticMethodBase">MethodBase that was given to the compiler by a type returned by a GetType(s) call.</param>
 <param name="parameters">Expressions that represent the parameters to this call.</param>

 <returns>An expression that the compiler will use in place of the given method base.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ITypeProvider.GetGeneratedAssemblyContents(System.Reflection.Assembly)">
 <summary>
 Get the physical contents of the given logical provided assembly.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ITypeProvider.ApplyStaticArguments(System.Type,System.String[],System.Object[])">
 <summary>
 Apply static arguments to a provided type that accepts static arguments. 
 </summary>

 <remarks>The provider must return a type with the given mangled name.</remarks>

 <param name="typeWithoutArguments">the provided type definition which has static parameters</param>
 <param name="typePathWithArguments">the full path of the type, including encoded representations of static parameters</param>
 <param name="staticArguments">the static parameters, indexed by name</param>

 <returns></returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.ITypeProvider">
 <summary>
 Represents an instantiation of a type provider component.
 </summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.IProvidedNamespace.NamespaceName">
<summary>
 Namespace name the provider injects types into.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.IProvidedNamespace.ResolveTypeName(System.String)">
 <summary>
 Compilers call this method to query a type provider for a type <c>name</c>.
 </summary>
 <remarks>Resolver should return a type called <c>name</c> in namespace <c>NamespaceName</c> or <c>null</c> if the type is unknown.
 </remarks>
 <returns></returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.IProvidedNamespace.GetTypes">
 <summary>
 The top-level types
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.IProvidedNamespace.GetNestedNamespaces">
<summary>
 The sub-namespaces in this namespace. An optional member to prevent generation of namespaces until an outer namespace is explored.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.IProvidedNamespace">
 <summary>
 Represents a namespace provided by a type provider component.
 </summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.TemporaryFolder(System.String)">
<summary>
 Get the full path to use for temporary files for the type provider instance.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.SystemRuntimeAssemblyVersion(System.Version)">
<summary>
 version of referenced system runtime assembly
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.RuntimeAssembly(System.String)">
<summary>
 Get the full path to referenced assembly that caused this type provider instance to be created.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.ResolutionFolder(System.String)">
<summary>
 Get the full path to use to resolve relative paths in any file name arguments given to the type provider instance.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.ReferencedAssemblies(System.String[])">
<summary>
 Get the referenced assemblies for the type provider instance.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.IsInvalidationSupported(System.Boolean)">
<summary>
 Indicates if the type provider host responds to invalidation events for type provider instances. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.IsHostedExecution(System.Boolean)">
<summary>
 Indicates if the type provider instance is used in an environment which executes provided code such as F# Interactive.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.TemporaryFolder">
<summary>
 Get the full path to use for temporary files for the type provider instance.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.SystemRuntimeAssemblyVersion">
<summary>
 version of referenced system runtime assembly
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.RuntimeAssembly">
<summary>
 Get the full path to referenced assembly that caused this type provider instance to be created.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.ResolutionFolder">
<summary>
 Get the full path to use to resolve relative paths in any file name arguments given to the type provider instance.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.ReferencedAssemblies">
<summary>
 Get the referenced assemblies for the type provider instance.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.IsInvalidationSupported">
<summary>
 Indicates if the type provider host responds to invalidation events for type provider instances. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.IsHostedExecution">
<summary>
 Indicates if the type provider instance is used in an environment which executes provided code such as F# Interactive.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.SystemRuntimeContainsType(System.String)">
<summary>
 Checks if given type exists in target system runtime library
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.#ctor(Microsoft.FSharp.Core.FSharpFunc{System.String,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.String[]})">
<summary>
 Create a configuration which calls the given functions for the corresponding operation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig.#ctor(Microsoft.FSharp.Core.FSharpFunc{System.String,System.Boolean})">
<summary>
 Create a configuration which calls the given function for the corresponding operation.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.TypeProviderConfig">
<summary>
 If the class that implements ITypeProvider has a constructor that accepts TypeProviderConfig
 then it will be constructed with an instance of TypeProviderConfig.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.TypeProviderEditorHideMethodsAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>TypeProviderEditorHideMethodsAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.TypeProviderEditorHideMethodsAttribute">
 <summary>Indicates that a code editor should hide all System.Object methods from the intellisense menus for instances of a provided type</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderDefinitionLocationAttribute.Line(System.Int32)">
 <summary>Gets or sets the line for the location.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderDefinitionLocationAttribute.FilePath(System.String)">
 <summary>Gets or sets the file path for the definition location.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderDefinitionLocationAttribute.Column(System.Int32)">
 <summary>Gets or sets the column for the location.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderDefinitionLocationAttribute.Line">
 <summary>Gets or sets the line for the location.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderDefinitionLocationAttribute.FilePath">
 <summary>Gets or sets the file path for the definition location.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderDefinitionLocationAttribute.Column">
 <summary>Gets or sets the column for the location.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.TypeProviderDefinitionLocationAttribute">
 <summary>A type provider may provide an instance of this attribute to indicate the definition location for a provided type or member.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderXmlDocAttribute.CommentText">
 <summary>Gets the comment text.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.TypeProviderXmlDocAttribute.#ctor(System.String)">
 <summary>Creates an instance of the attribute</summary>
 <returns>TypeProviderXmlDocAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.TypeProviderXmlDocAttribute">
 <summary>A type provider may provide an instance of this attribute to indicate the documentation to show for 
 a provided type or member.</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.TypeProviderAssemblyAttribute.AssemblyName">
 <summary>Gets the assembly name.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.TypeProviderAssemblyAttribute.#ctor(System.String)">
 <summary>Creates an instance of the attribute</summary>
 <returns>TypeProviderAssemblyAttribute</returns>
 <param name="assemblyName">The name of the design-time assembly for this type provider.</param>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.TypeProviderAssemblyAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>TypeProviderAssemblyAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.TypeProviderAssemblyAttribute">
 <summary>Place this attribute on a runtime assembly to indicate that there is a corresponding design-time 
 assembly that contains a type provider. Runtime and design-time assembly may be the same. </summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.TypeProviderTypeAttributes">
 <summary>Additional type attribute flags related to provided types</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.TypeProviderAttribute.#ctor">
 <summary>Creates an instance of the attribute</summary>
 <returns>TypeProviderAttribute</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.TypeProviderAttribute">
 <summary>Place on a class that implements ITypeProvider to extend the compiler</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.MeasureOne">
 <summary>Represents the '1' measure expression when returned as a generic argument of a provided type.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.MeasureInverse`1">
 <summary>Represents the inverse of a measure expressions when returned as a generic argument of a provided type.</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.MeasureProduct`2">
 <summary>Represents the product of two measure expressions when returned as a generic argument of a provided type.</summary>

 <namespacedoc><summary>
   Library functionality for supporting type providers and code generated by the F# compiler. See
   also <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/tutorials/type-providers/">F# Type Providers</a> in the F# Language Guide.
 </summary></namespacedoc>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers.CreateEvent``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},``0})">
 <summary>Creates an anonymous event with the given handlers.</summary>

 <param name="addHandler">A function to handle adding a delegate for the event to trigger.</param>
 <param name="removeHandler">A function to handle removing a delegate that the event triggers.</param>
 <param name="createHandler">A function to produce the delegate type the event can trigger.</param>

 <returns>The initialized event.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers.EnumerateUsing``3(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>The F# compiler emits calls to this function to implement the <c>use</c> operator for F# sequence
 expressions.</summary>

 <param name="resource">The resource to be used and disposed.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers.EnumerateFromFunctions``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>The F# compiler emits calls to this function to implement the compiler-intrinsic
 conversions from untyped IEnumerable sequences to typed sequences.</summary>

 <param name="create">An initializer function.</param>
 <param name="moveNext">A function to iterate and test if end of sequence is reached.</param>
 <param name="current">A function to retrieve the current element.</param>

 <returns>The resulting typed sequence.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers.EnumerateThenFinally``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>The F# compiler emits calls to this function to
 implement the <c>try/finally</c> operator for F# sequence expressions.</summary>

 <param name="source">The input sequence.</param>
 <param name="compensation">A computation to be included in an enumerator's Dispose method.</param>

 <returns>The result sequence.</returns>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers.EnumerateWhile``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>The F# compiler emits calls to this function to
 implement the <c>while</c> operator for F# sequence expressions.</summary>

 <param name="guard">A function that indicates whether iteration should continue.</param>
 <param name="source">The input sequence.</param>

 <returns>The result sequence.</returns>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers">
 <summary>A group of functions used as part of the compiled representation of F# sequence expressions.</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.StateMachineHelpers.__stateMachine``2(Microsoft.FSharp.Core.CompilerServices.MoveNextMethodImpl{``0},Microsoft.FSharp.Core.CompilerServices.SetStateMachineMethodImpl{``0},Microsoft.FSharp.Core.CompilerServices.AfterCode{``0,``1})">
 <summary>
 Statically generates a closure struct type based on ResumableStateMachine,
 At runtime an instance of the new struct type is populated and 'afterMethod' is called
 to consume it.
 </summary>

 <remarks>
 At compile-time, the ResumableStateMachine type guides the generation of a new struct type by the F# compiler
 with closure-capture fields in a way similar to an object expression. 
 Any mention of the ResumableStateMachine type in any the 'methods' is rewritten to this
 fresh struct type.  The 'methods' are used to implement the interfaces on ResumableStateMachine and are also rewritten.
 The 'after' method is then executed and must eliminate the ResumableStateMachine. For example,
 its return type must not include ResumableStateMachine.
 </remarks>
 <param name="moveNextMethod">Gives the implementation of the MoveNext method on IAsyncStateMachine.</param>
 <param name="setStateMachineMethod">Gives the implementation of the SetStateMachine method on IAsyncStateMachine.</param>
 <param name="afterCode">Gives code to execute after the generation of the state machine and to produce the final result.</param>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.StateMachineHelpers.__resumeAt``1(System.Int32)">
 <summary>
 Indicates to jump to a resumption point within resumable code.
 This may be the first statement in a MoveNextMethodImpl.
 The integer must be a valid resumption point within this resumable code.
 </summary>
 <param name="programLabel"></param>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.StateMachineHelpers.__resumableEntry">
 <summary>
 Indicates a resumption point within resumable code
 </summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.StateMachineHelpers.__useResumableCode``1">
 <summary>
 When used in a conditional, statically determines whether the 'then' branch
 represents valid resumable code and provides an alternative implementation
 if not.
 </summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.StateMachineHelpers.__debugPoint(System.String)">
 <summary>
 Indicates a named debug point arising from the context of inlined code.
 </summary>
 <remarks>
 Only a limited range of debug point names are supported.

 If the debug point name is the empty string then the range used for the debug point will be
 the range of the outermost expression prior to inlining.

 If the debug point name is <c>ForLoop.InOrToKeyword</c> and the code was ultimately
 from a <c>for .. in .. do</c> or <c>for .. = .. to .. do</c> construct in a computation expression,
 de-sugared to an inlined <c>builder.For</c> call, then the name "ForLoop.InOrToKeyword" can be used.
 The range of the debug point will be precisely the range of the <c>in</c> or <c>to</c> keyword.

 If the name doesn't correspond to a known debug point arising from the original source context, then
 an opt-in warning 3514 is emitted, and the range used for the debug point will be
 the range of the root expression prior to inlining.
 </remarks>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.StateMachineHelpers">
<summary>
 Contains compiler intrinsics related to the definition of state machines.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ResumableCode.YieldDynamic``1(Microsoft.FSharp.Core.CompilerServices.ResumableStateMachine{``0}@)">
<summary>
 The dynamic implementation of the corresponding operation. This operation should not be used directly.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ResumableCode.TryWithDynamic``2(Microsoft.FSharp.Core.CompilerServices.ResumableStateMachine{``0}@,Microsoft.FSharp.Core.CompilerServices.ResumableCode{``0,``1},Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.CompilerServices.ResumableCode{``0,``1}})">
<summary>
 The dynamic implementation of the corresponding operation. This operation should not be used directly.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ResumableCode.TryFinallyAsyncDynamic``2(Microsoft.FSharp.Core.CompilerServices.ResumableStateMachine{``0}@,Microsoft.FSharp.Core.CompilerServices.ResumableCode{``0,``1},Microsoft.FSharp.Core.CompilerServices.ResumableCode{``0,Microsoft.FSharp.Core.Unit})">
<summary>
 The dynamic implementation of the corresponding operation. This operation should not be used directly.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ResumableCode.WhileDynamic``1(Microsoft.FSharp.Core.CompilerServices.ResumableStateMachine{``0}@,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Boolean},Microsoft.FSharp.Core.CompilerServices.ResumableCode{``0,Microsoft.FSharp.Core.Unit})">
<summary>
 The dynamic implementation of the corresponding operation. This operation should not be used directly.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ResumableCode.CombineDynamic``2(Microsoft.FSharp.Core.CompilerServices.ResumableStateMachine{``0}@,Microsoft.FSharp.Core.CompilerServices.ResumableCode{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.CompilerServices.ResumableCode{``0,``1})">
<summary>
 The dynamic implementation of the corresponding operation. This operation should not be used directly.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ResumableCode.Zero``1">
<summary>
 Specifies resumable code which does nothing
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ResumableCode.While``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Boolean},Microsoft.FSharp.Core.CompilerServices.ResumableCode{``0,Microsoft.FSharp.Core.Unit})">
<summary>
 Specifies resumable code which executes a loop
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ResumableCode.Using``3(``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.CompilerServices.ResumableCode{``1,``2}})">
<summary>
 Specifies resumable code which executes with &apos;use&apos; semantics
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ResumableCode.TryWith``2(Microsoft.FSharp.Core.CompilerServices.ResumableCode{``0,``1},Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.CompilerServices.ResumableCode{``0,``1}})">
<summary>
 Specifies resumable code which executes with try/with semantics
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ResumableCode.TryFinallyAsync``2(Microsoft.FSharp.Core.CompilerServices.ResumableCode{``0,``1},Microsoft.FSharp.Core.CompilerServices.ResumableCode{``0,Microsoft.FSharp.Core.Unit})">
<summary>
 Specifies resumable code which executes with try/finally semantics
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ResumableCode.TryFinally``2(Microsoft.FSharp.Core.CompilerServices.ResumableCode{``0,``1},Microsoft.FSharp.Core.CompilerServices.ResumableCode{``0,Microsoft.FSharp.Core.Unit})">
<summary>
 Specifies resumable code which executes with try/finally semantics
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ResumableCode.Yield``1">
<summary>
 Specifies resumable code which iterates yields
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ResumableCode.For``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.CompilerServices.ResumableCode{``1,Microsoft.FSharp.Core.Unit}})">
<summary>
 Specifies resumable code which iterates an input sequence
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ResumableCode.Delay``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.CompilerServices.ResumableCode{``0,``1}})">
<summary>
 Creates resumable code whose definition is a delayed function
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.ResumableCode.Combine``2(Microsoft.FSharp.Core.CompilerServices.ResumableCode{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.CompilerServices.ResumableCode{``0,``1})">
<summary>
 Sequences one section of resumable code after another
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.ResumableCode">
<summary>
 Contains functions for composing resumable code blocks
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.ExtraTopLevelOperators.query">
 <summary>Builds a query using query syntax and operators.</summary>
 
 <example id="query-1">
 <code lang="fsharp">
 let findEvensAndSortAndDouble(xs: System.Linq.IQueryable&lt;int>) =
     query {
         for x in xs do
         where (x % 2 = 0)
         sortBy x
         select (x+x)
      }

 let data = [1; 2; 6; 7; 3; 6; 2; 1]

 findEvensAndSortAndDouble (data.AsQueryable()) |> Seq.toList
 </code>
 Evaluates to <c>[4; 4; 12; 12]</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.LazyPattern``1(System.Lazy{``0})">
 <summary>An active pattern to force the execution of values of type <c>Lazy&lt;_&gt;</c>.</summary>
 
 <example id="lazy-1">
 <code lang="fsharp">
 let f (Lazy v) = v + v

 let v = lazy (printf "eval!"; 5+5)

 f v
 f v
 </code>
 Evaluates to <c>10</c>. The text <c>eval!</c> is printed once on the first invocation of <c>f</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.SpliceUntypedExpression``1(Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>Special prefix operator for splicing untyped expressions into quotation holes.</summary>
 
 <example id="rawsplice-1">
 <code lang="fsharp">
 let f v = &lt;@@ (%%v: int) + (%%v: int) @@>

 f &lt;@@ 5 + 5 @@>;;
 </code>
 Evaluates to an untyped quotation equivalent to <c>&lt;@@ (5 + 5) + (5 + 5) @@> </c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.SpliceExpression``1(Microsoft.FSharp.Quotations.FSharpExpr{``0})">
 <summary>Special prefix operator for splicing typed expressions into quotation holes.</summary>
 
 <example id="splice-1">
 <code lang="fsharp">
 let f v = &lt;@ %v + %v @>

 f &lt;@ 5 + 5 @>;;
 </code>
 Evaluates to a quotation equivalent to <c>&lt;@ (5 + 5) + (5 + 5) @> </c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateArray2D``2(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a 2D array from a sequence of sequences of elements.</summary>
 
 <example id="array2d-1">
 <code lang="fsharp">
 array2D [ [ 1.0; 2.0 ]; [ 3.0; 4.0 ] ]
 </code>
 Evaluates to a 2x2 zero-based array with contents <c>[[1.0; 2.0]; [3.0; 4.0]]</c>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateReadOnlyDictionary``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
 <summary>Builds a read-only lookup table from a sequence of key/value pairs. The key objects are indexed using generic hashing and equality.</summary>
 
 <example id="readonlydict-1">
 <code lang="fsharp">
 let table = readOnlyDict [ (1, 100); (2, 200) ]

 table[1]
 </code>
 Evaluates to <c>100</c>.
 </example>
 
 <example id="readonlydict-2">
 <code lang="fsharp">
 let table = readOnlyDict [ (1, 100); (2, 200) ]

 table[3]
 </code>
 Throws <c>System.Collections.Generic.KeyNotFoundException</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateDictionary``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
 <summary>Builds a read-only lookup table from a sequence of key/value pairs. The key objects are indexed using generic hashing and equality.</summary>
 
 <example id="dict-1">
 <code lang="fsharp">
 let table = dict [ (1, 100); (2, 200) ]

 table[1]
 </code>
 Evaluates to <c>100</c>.
 </example>
 
 <example id="dict-2">
 <code lang="fsharp">
 let table = dict [ (1, 100); (2, 200) ]

 table[3]
 </code>
 Throws <c>System.Collections.Generic.KeyNotFoundException</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.ToSByte``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.SByte},``0)">
 <summary>Converts the argument to signed byte.</summary>
 <remarks>This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>SByte.Parse()</c>  with InvariantCulture settings.
 Otherwise the operation requires and invokes a <c>ToSByte</c> method on the input type.</remarks>
 
 <example id="int8-1">
 <code lang="fsharp">
 int8 -12
 </code>
 Evaluates to <c>-12y</c>.
 </example>
 
 <example id="int8-2">
 <code lang="fsharp">
 int8 "3"
 </code>
 Evaluates to <c>3y</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.ToByte``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Byte},``0)">
 <summary>Converts the argument to byte.</summary>
 <remarks>This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Byte.Parse()</c> on strings and otherwise requires a <c>ToByte</c> method on the input type.</remarks>
 
 <example id="uint8-1">
 <code lang="fsharp">
 uint8 12
 </code>
 Evaluates to <c>12uy</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.ToDouble``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Double},``0)">
 <summary>Converts the argument to 64-bit float.</summary>

 <remarks>This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Double.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToDouble</c> method on the input type.</remarks>
 
 <example id="double-1">
 <code lang="fsharp">
 double 45
 </code>
 Evaluates to <c>45.0</c>.
 </example>
 
 <example id="double-2">
 <code lang="fsharp">
 double 12.3f
 </code>
 Evaluates to <c>12.30000019</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.ToSingle``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Single},``0)">
 <summary>Converts the argument to 32-bit float.</summary>

 <remarks>This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Single.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToSingle</c> method on the input type.</remarks>
 
 <example id="single-1">
 <code lang="fsharp">
 single 45
 </code>
 Evaluates to <c>45.0f</c>.
 </example>
</member>
<member name="P:Microsoft.FSharp.Core.ExtraTopLevelOperators.DefaultAsyncBuilder">
 <summary>Builds an asynchronous workflow using computation expression syntax.</summary>
 
 <example id="async-1">
 <code lang="fsharp">
 let sleepExample() =
     async {
         printfn "sleeping"
         do! Async.Sleep 10
         printfn "waking up"
         return 6
      }

 sleepExample() |> Async.RunSynchronously
 </code>
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateSet``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Builds a set from a sequence of objects. The objects are indexed using generic comparison.</summary>

 <param name="elements">The input sequence of elements.</param>

 <returns>The created set.</returns>
 
 <example id="set-1">
 <code lang="fsharp">
 let values = set [ 1; 2; 3; 5; 7; 11 ]
 </code>
 Evaluates to a set containing the given numbers.
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatLineToTextWriter``1(System.IO.TextWriter,Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Print to a file using the given format, and add a newline.</summary>

 <param name="textWriter">The file TextWriter.</param>
 <param name="format">The formatter.</param>

 <returns>The formatted result.</returns>
 
 <example>See <c>Printf.fprintfn</c> (link: <see cref='M:Microsoft.FSharp.Core.PrintfModule.PrintFormatLineToTextWriter``1'/>) for examples.</example>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatToTextWriter``1(System.IO.TextWriter,Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Print to a file using the given format.</summary>

 <param name="textWriter">The file TextWriter.</param>
 <param name="format">The formatter.</param>

 <returns>The formatted result.</returns>
 
 <example>See <c>Printf.fprintf</c> (link: <see cref='M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToTextWriter``1'/>) for examples.</example>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatToStringThenFail``2(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,``1})">
 <summary>Print to a string buffer and raise an exception with the given
 result. Helper printers must return strings.</summary>

 <param name="format">The formatter.</param>

 <returns>The formatted result.</returns>
 
 <example>See <c>Printf.failwithf</c> (link: <see cref='M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToStringThenFail``2'/>) for examples.</example>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatToString``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,System.String})">
 <summary>Print to a string using the given format.</summary>

 <param name="format">The formatter.</param>

 <returns>The formatted result.</returns>
 
 <example>See <c>Printf.sprintf</c> (link: <see cref='M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToStringThen``1'/>) for examples.</example>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatLineToError``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Print to <c>stderr</c> using the given format, and add a newline.</summary>

 <param name="format">The formatter.</param>

 <returns>The formatted result.</returns>
 
 <example>See <c>Printf.eprintfn</c> (link: <see cref='M:Microsoft.FSharp.Core.PrintfModule.PrintFormatLineToError``1'/>) for examples.</example>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatToError``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Print to <c>stderr</c> using the given format.</summary>

 <param name="format">The formatter.</param>

 <returns>The formatted result.</returns>
 
 <example>See <c>Printf.eprintf</c> (link: <see cref='M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToError``1'/>) for examples.</example>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatLine``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Print to <c>stdout</c> using the given format, and add a newline.</summary>

 <param name="format">The formatter.</param>

 <returns>The formatted result.</returns>
 
 <example>See <c>Printf.printfn</c> (link: <see cref='M:Microsoft.FSharp.Core.PrintfModule.PrintFormatLine``1'/>) for examples.</example>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormat``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
 <summary>Print to <c>stdout</c> using the given format.</summary>

 <param name="format">The formatter.</param>

 <returns>The formatted result.</returns>
 
 <example>See <c>Printf.printf</c> (link: <see cref='M:Microsoft.FSharp.Core.PrintfModule.PrintFormat``1'/>) for examples.</example>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.Checked.ToSByte``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.SByte},``0)">
 <summary>Converts the argument to signed byte.</summary>
 <remarks>This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using <c>SByte.Parse()</c>  with InvariantCulture settings.
 Otherwise the operation requires and invokes a <c>ToSByte</c> method on the input type.</remarks>
 
 <example id="int8-1">
 <code lang="fsharp">
 Checked.int8 -12
 </code>
 Evaluates to <c>-12y</c>.
 </example>
 
 <example id="int8-2">
 <code lang="fsharp">
 Checked.int8 "129"
 </code>
 Throws <c>System.OverflowException</c>.
 </example>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.Checked.ToByte``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Byte},``0)">
 <summary>Converts the argument to byte.</summary>
 <remarks>This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Byte.Parse()</c> on strings and otherwise requires a <c>ToByte</c> method on the input type.</remarks>
 
 <example id="uint8-1">
 <code lang="fsharp">
 Checked.uint8 12
 </code>
 Evaluates to <c>-12y</c>.
 </example>
 
 <example id="uint8-2">
 <code lang="fsharp">
 Checked.uint8 -12
 </code>
 Throws <c>System.OverflowException</c>.
 </example>
</member>
<member name="T:Microsoft.FSharp.Core.ExtraTopLevelOperators">
 <summary>A set of extra operators and functions. This module is automatically opened in all F# code.</summary>

 <category>Basic Operators</category>
</member>
</members>
</doc>
