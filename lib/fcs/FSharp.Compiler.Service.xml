<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharp.Compiler.Service</name></assembly>
<members>
<member name="M:FSComp.SR.yieldUsedInsteadOfYieldBang">
<summary>
 Consider using &apos;yield!&apos; instead of &apos;yield&apos;.
 (Originally from FSComp.txt:38)
</summary>
</member>
<member name="M:FSComp.SR.xmlDocUnresolvedCrossReference(System.String)">
<summary>
 This XML comment is invalid: unresolved cross-reference &apos;%s&apos;
 (Originally from FSComp.txt:1676)
</summary>
</member>
<member name="M:FSComp.SR.xmlDocMissingParameterName">
<summary>
 This XML comment is invalid: missing &apos;name&apos; attribute for parameter or parameter reference
 (Originally from FSComp.txt:1672)
</summary>
</member>
<member name="M:FSComp.SR.xmlDocMissingParameter(System.String)">
<summary>
 This XML comment is incomplete: no documentation for parameter &apos;%s&apos;
 (Originally from FSComp.txt:1677)
</summary>
</member>
<member name="M:FSComp.SR.xmlDocMissingCrossReference">
<summary>
 This XML comment is invalid: missing &apos;cref&apos; attribute for cross-reference
 (Originally from FSComp.txt:1673)
</summary>
</member>
<member name="M:FSComp.SR.xmlDocInvalidParameterName(System.String)">
<summary>
 This XML comment is invalid: unknown parameter &apos;%s&apos;
 (Originally from FSComp.txt:1674)
</summary>
</member>
<member name="M:FSComp.SR.xmlDocDuplicateParameter(System.String)">
<summary>
 This XML comment is invalid: multiple documentation entries for parameter &apos;%s&apos;
 (Originally from FSComp.txt:1675)
</summary>
</member>
<member name="M:FSComp.SR.xmlDocBadlyFormed(System.String)">
<summary>
 This XML comment is invalid: &apos;%s&apos;
 (Originally from FSComp.txt:1671)
</summary>
</member>
<member name="M:FSComp.SR.writeToReadOnlyByref">
<summary>
 The byref pointer is readonly, so this write is not permitted.
 (Originally from FSComp.txt:1503)
</summary>
</member>
<member name="M:FSComp.SR.valueIsNotAccessible(System.String)">
<summary>
 The value &apos;%s&apos; is not accessible from this code location
 (Originally from FSComp.txt:976)
</summary>
</member>
<member name="M:FSComp.SR.useSdkRefs">
<summary>
 Use reference assemblies for .NET framework references when available (Enabled by default).
 (Originally from FSComp.txt:1559)
</summary>
</member>
<member name="M:FSComp.SR.unsupportedAttribute">
<summary>
 This attribute is currently unsupported by the F# compiler. Applying it will not achieve its intended effect.
 (Originally from FSComp.txt:42)
</summary>
</member>
<member name="M:FSComp.SR.unnecessaryParentheses">
<summary>
 Parentheses can be removed.
 (Originally from FSComp.txt:1762)
</summary>
</member>
<member name="M:FSComp.SR.unionCasesAreNotAccessible(System.String)">
<summary>
 The union cases or fields of the type &apos;%s&apos; are not accessible from this code location
 (Originally from FSComp.txt:975)
</summary>
</member>
<member name="M:FSComp.SR.unionCaseIsNotAccessible(System.String)">
<summary>
 The union case &apos;%s&apos; is not accessible from this code location
 (Originally from FSComp.txt:977)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameValueOfConstructor(System.String)">
<summary>
 The value or constructor &apos;%s&apos; is not defined.
 (Originally from FSComp.txt:10)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameValueNamespaceTypeOrModule(System.String)">
<summary>
 The value, namespace, type or module &apos;%s&apos; is not defined.
 (Originally from FSComp.txt:11)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameValueConstructorNamespaceOrType(System.String)">
<summary>
 The value, constructor, namespace or type &apos;%s&apos; is not defined.
 (Originally from FSComp.txt:9)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameTypeParameter(System.String)">
<summary>
 The type parameter %s is not defined.
 (Originally from FSComp.txt:18)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameTypeIn(System.String,System.String)">
<summary>
 The type &apos;%s&apos; is not defined in &apos;%s&apos;.
 (Originally from FSComp.txt:14)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameType(System.String)">
<summary>
 The type &apos;%s&apos; is not defined.
 (Originally from FSComp.txt:13)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameSuggestionsIntro">
<summary>
 Maybe you want one of the following:
 (Originally from FSComp.txt:17)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameRecordLabelOrNamespace(System.String)">
<summary>
 The record label or namespace &apos;%s&apos; is not defined.
 (Originally from FSComp.txt:15)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameRecordLabel(System.String)">
<summary>
 The record label &apos;%s&apos; is not defined.
 (Originally from FSComp.txt:16)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNamePatternDiscriminator(System.String)">
<summary>
 The pattern discriminator &apos;%s&apos; is not defined.
 (Originally from FSComp.txt:19)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameNamespaceOrModule(System.String)">
<summary>
 The namespace or module &apos;%s&apos; is not defined.
 (Originally from FSComp.txt:6)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameNamespace(System.String)">
<summary>
 The namespace &apos;%s&apos; is not defined.
 (Originally from FSComp.txt:5)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameFieldConstructorOrMemberWhenTypeIsKnown(System.String,System.String)">
<summary>
 The type &apos;%s&apos; does not define the field, constructor or member &apos;%s&apos;.
 (Originally from FSComp.txt:8)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameFieldConstructorOrMember(System.String)">
<summary>
 The field, constructor or member &apos;%s&apos; is not defined.
 (Originally from FSComp.txt:7)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameConstructorModuleOrNamespace(System.String)">
<summary>
 The constructor, module or namespace &apos;%s&apos; is not defined.
 (Originally from FSComp.txt:12)
</summary>
</member>
<member name="M:FSComp.SR.typrelTypeImplementsIComparableShouldOverrideObjectEquals(System.String)">
<summary>
 The type &apos;%s&apos; implements &apos;System.IComparable&apos;. Consider also adding an explicit override for &apos;Object.Equals&apos;
 (Originally from FSComp.txt:179)
</summary>
</member>
<member name="M:FSComp.SR.typrelTypeImplementsIComparableDefaultObjectEqualsProvided(System.String)">
<summary>
 The type &apos;%s&apos; implements &apos;System.IComparable&apos; explicitly but provides no corresponding override for &apos;Object.Equals&apos;. An implementation of &apos;Object.Equals&apos; has been automatically provided, implemented via &apos;System.IComparable&apos;. Consider implementing the override &apos;Object.Equals&apos; explicitly
 (Originally from FSComp.txt:180)
</summary>
</member>
<member name="M:FSComp.SR.typrelSigImplNotCompatibleParamCountsDiffer">
<summary>
 The signature and implementation are not compatible because the respective type parameter counts differ
 (Originally from FSComp.txt:175)
</summary>
</member>
<member name="M:FSComp.SR.typrelSigImplNotCompatibleConstraintsDifferRemove(System.String,System.String)">
<summary>
 The signature and implementation are not compatible because the type parameter &apos;%s&apos; has a constraint of the form %s but the implementation does not. Either remove this constraint from the signature or add it to the implementation.
 (Originally from FSComp.txt:178)
</summary>
</member>
<member name="M:FSComp.SR.typrelSigImplNotCompatibleConstraintsDiffer(System.String,System.String)">
<summary>
 The signature and implementation are not compatible because the declaration of the type parameter &apos;%s&apos; requires a constraint of the form %s
 (Originally from FSComp.txt:177)
</summary>
</member>
<member name="M:FSComp.SR.typrelSigImplNotCompatibleCompileTimeRequirementsDiffer">
<summary>
 The signature and implementation are not compatible because the type parameter in the class/signature has a different compile-time requirement to the one in the member/implementation
 (Originally from FSComp.txt:176)
</summary>
</member>
<member name="M:FSComp.SR.typrelOverrideWasAmbiguous(System.String)">
<summary>
 The override for &apos;%s&apos; was ambiguous
 (Originally from FSComp.txt:195)
</summary>
</member>
<member name="M:FSComp.SR.typrelOverrideImplementsMoreThenOneSlot(System.String,System.String,System.String)">
<summary>
 The override &apos;%s&apos; implements more than one abstract slot, e.g. &apos;%s&apos; and &apos;%s&apos;
 (Originally from FSComp.txt:198)
</summary>
</member>
<member name="M:FSComp.SR.typrelOverloadNotFound(System.String,System.String)">
<summary>
 No implementations of &apos;%s&apos; had the correct number of arguments and type parameters. The required signature is &apos;%s&apos;.
 (Originally from FSComp.txt:194)
</summary>
</member>
<member name="M:FSComp.SR.typrelNoImplementationGivenWithSuggestion(System.String)">
<summary>
 No implementation was given for &apos;%s&apos;. Note that all interface members must be implemented and listed under an appropriate &apos;interface&apos; declaration, e.g. &apos;interface ... with member ...&apos;.
 (Originally from FSComp.txt:205)
</summary>
</member>
<member name="M:FSComp.SR.typrelNoImplementationGivenSeveralWithSuggestion(System.String)">
<summary>
 No implementation was given for those members: %sNote that all interface members must be implemented and listed under an appropriate &apos;interface&apos; declaration, e.g. &apos;interface ... with member ...&apos;.
 (Originally from FSComp.txt:206)
</summary>
</member>
<member name="M:FSComp.SR.typrelNoImplementationGivenSeveralTruncatedWithSuggestion(System.String)">
<summary>
 No implementation was given for those members (some results omitted): %sNote that all interface members must be implemented and listed under an appropriate &apos;interface&apos; declaration, e.g. &apos;interface ... with member ...&apos;.
 (Originally from FSComp.txt:207)
</summary>
</member>
<member name="M:FSComp.SR.typrelNoImplementationGivenSeveralTruncated(System.String)">
<summary>
 No implementation was given for those members (some results omitted): %s
 (Originally from FSComp.txt:204)
</summary>
</member>
<member name="M:FSComp.SR.typrelNoImplementationGivenSeveral(System.String)">
<summary>
 No implementation was given for those members: %s
 (Originally from FSComp.txt:203)
</summary>
</member>
<member name="M:FSComp.SR.typrelNoImplementationGiven(System.String)">
<summary>
 No implementation was given for &apos;%s&apos;
 (Originally from FSComp.txt:202)
</summary>
</member>
<member name="M:FSComp.SR.typrelNeverRefinedAwayFromTop">
<summary>
 A type has been implicitly inferred as &apos;obj&apos;, which may be unintended. Consider adding explicit type annotations. You can disable this warning by using &apos;#nowarn \&quot;3559\&quot;&apos; or &apos;--nowarn:3559&apos;.
 (Originally from FSComp.txt:1737)
</summary>
</member>
<member name="M:FSComp.SR.typrelNeedExplicitImplementation(System.String)">
<summary>
 The interface &apos;%s&apos; is included in multiple explicitly implemented interface types. Add an explicit implementation of this interface.
 (Originally from FSComp.txt:200)
</summary>
</member>
<member name="M:FSComp.SR.typrelNamedArgumentHasBeenAssignedMoreThenOnce(System.String)">
<summary>
 The named argument &apos;%s&apos; has been assigned more than one value
 (Originally from FSComp.txt:201)
</summary>
</member>
<member name="M:FSComp.SR.typrelMoreThenOneOverride(System.String)">
<summary>
 More than one override implements &apos;%s&apos;
 (Originally from FSComp.txt:196)
</summary>
</member>
<member name="M:FSComp.SR.typrelModuleNamespaceAttributesDifferInSigAndImpl">
<summary>
 The namespace or module attributes differ between signature and implementation
 (Originally from FSComp.txt:192)
</summary>
</member>
<member name="M:FSComp.SR.typrelMethodIsSealed(System.String)">
<summary>
 The method &apos;%s&apos; is sealed and cannot be overridden
 (Originally from FSComp.txt:197)
</summary>
</member>
<member name="M:FSComp.SR.typrelMethodIsOverconstrained">
<summary>
 This method is over-constrained in its type parameters
 (Originally from FSComp.txt:193)
</summary>
</member>
<member name="M:FSComp.SR.typrelMemberHasMultiplePossibleDispatchSlots(System.String,System.String)">
<summary>
 The member &apos;%s&apos; matches multiple overloads of the same method.\nPlease restrict it to one of the following:%s.
 (Originally from FSComp.txt:1396)
</summary>
</member>
<member name="M:FSComp.SR.typrelMemberDoesNotHaveCorrectNumberOfTypeParameters(System.String,System.String)">
<summary>
 The member &apos;%s&apos; does not have the correct number of method type parameters. The required signature is &apos;%s&apos;.
 (Originally from FSComp.txt:209)
</summary>
</member>
<member name="M:FSComp.SR.typrelMemberDoesNotHaveCorrectNumberOfArguments(System.String,System.String)">
<summary>
 The member &apos;%s&apos; does not have the correct number of arguments. The required signature is &apos;%s&apos;.
 (Originally from FSComp.txt:208)
</summary>
</member>
<member name="M:FSComp.SR.typrelMemberDoesNotHaveCorrectKindsOfGenericParameters(System.String,System.String)">
<summary>
 The member &apos;%s&apos; does not have the correct kinds of generic parameters. The required signature is &apos;%s&apos;.
 (Originally from FSComp.txt:210)
</summary>
</member>
<member name="M:FSComp.SR.typrelMemberCannotImplement(System.String,System.String,System.String)">
<summary>
 The member &apos;%s&apos; cannot be used to implement &apos;%s&apos;. The required signature is &apos;%s&apos;.
 (Originally from FSComp.txt:211)
</summary>
</member>
<member name="M:FSComp.SR.typrelInvalidValue">
<summary>
 Invalid value
 (Originally from FSComp.txt:174)
</summary>
</member>
<member name="M:FSComp.SR.typrelInterfaceWithConcreteAndVariableObjectExpression(System.String,System.String,System.String)">
<summary>
 You cannot implement the interface &apos;%s&apos; with the two instantiations &apos;%s&apos; and &apos;%s&apos; because they may unify.
 (Originally from FSComp.txt:1630)
</summary>
</member>
<member name="M:FSComp.SR.typrelInterfaceWithConcreteAndVariable(System.String,System.String,System.String,System.String)">
<summary>
 &apos;%s&apos; cannot implement the interface &apos;%s&apos; with the two instantiations &apos;%s&apos; and &apos;%s&apos; because they may unify.
 (Originally from FSComp.txt:1629)
</summary>
</member>
<member name="M:FSComp.SR.typrelInterfaceMemberNoMostSpecificImplementation(System.String)">
<summary>
 Interface member &apos;%s&apos; does not have a most specific implementation.
 (Originally from FSComp.txt:1557)
</summary>
</member>
<member name="M:FSComp.SR.typrelExplicitImplementationOfGetHashCodeOrEquals(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has an explicit implementation of &apos;Object.GetHashCode&apos; or &apos;Object.Equals&apos;. You must apply the &apos;CustomEquality&apos; attribute to the type
 (Originally from FSComp.txt:181)
</summary>
</member>
<member name="M:FSComp.SR.typrelExplicitImplementationOfGetHashCode(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has an explicit implementation of &apos;Object.GetHashCode&apos;. Consider implementing a matching override for &apos;Object.Equals(obj)&apos;
 (Originally from FSComp.txt:182)
</summary>
</member>
<member name="M:FSComp.SR.typrelExplicitImplementationOfEquals(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has an explicit implementation of &apos;Object.Equals&apos;. Consider implementing a matching override for &apos;Object.GetHashCode()&apos;
 (Originally from FSComp.txt:183)
</summary>
</member>
<member name="M:FSComp.SR.typrelDuplicateInterface">
<summary>
 Duplicate or redundant interface
 (Originally from FSComp.txt:199)
</summary>
</member>
<member name="M:FSComp.SR.typrelCannotResolveImplicitGenericInstantiation(System.String,System.String)">
<summary>
 The implicit instantiation of a generic construct at or near this point could not be resolved because it could resolve to multiple unrelated types, e.g. &apos;%s&apos; and &apos;%s&apos;. Consider using type annotations to resolve the ambiguity
 (Originally from FSComp.txt:170)
</summary>
</member>
<member name="M:FSComp.SR.typrelCannotResolveAmbiguityInUnmanaged">
<summary>
 Could not resolve the ambiguity in the use of a generic construct with an &apos;unmanaged&apos; constraint at or near this position
 (Originally from FSComp.txt:1088)
</summary>
</member>
<member name="M:FSComp.SR.typrelCannotResolveAmbiguityInPrintf">
<summary>
 Could not resolve the ambiguity inherent in the use of a &apos;printf&apos;-style format string
 (Originally from FSComp.txt:171)
</summary>
</member>
<member name="M:FSComp.SR.typrelCannotResolveAmbiguityInEnum">
<summary>
 Could not resolve the ambiguity in the use of a generic construct with an &apos;enum&apos; constraint at or near this position
 (Originally from FSComp.txt:172)
</summary>
</member>
<member name="M:FSComp.SR.typrelCannotResolveAmbiguityInDelegate">
<summary>
 Could not resolve the ambiguity in the use of a generic construct with a &apos;delegate&apos; constraint at or near this position
 (Originally from FSComp.txt:173)
</summary>
</member>
<member name="M:FSComp.SR.typeIsNotAccessible(System.String)">
<summary>
 The type &apos;%s&apos; is not accessible from this code location
 (Originally from FSComp.txt:974)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoUnionCase">
<summary>
 union case
 (Originally from FSComp.txt:952)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoProperty">
<summary>
 property
 (Originally from FSComp.txt:957)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoPatternVariable">
<summary>
 patvar
 (Originally from FSComp.txt:962)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoOtherOverloads(System.Int32)">
<summary>
 and %d other overloads
 (Originally from FSComp.txt:951)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoNamespaceOrModule">
<summary>
 namespace/module
 (Originally from FSComp.txt:965)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoNamespace">
<summary>
 namespace
 (Originally from FSComp.txt:963)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoModule">
<summary>
 module
 (Originally from FSComp.txt:964)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoGeneratedType">
<summary>
 generated type
 (Originally from FSComp.txt:969)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoGeneratedProperty">
<summary>
 generated property
 (Originally from FSComp.txt:968)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoFullName">
<summary>
 Full name
 (Originally from FSComp.txt:947)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoFromNext(System.String)">
<summary>
 also from %s
 (Originally from FSComp.txt:967)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoFromFirst(System.String)">
<summary>
 from %s
 (Originally from FSComp.txt:966)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoField">
<summary>
 field
 (Originally from FSComp.txt:955)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoExtension">
<summary>
 extension
 (Originally from FSComp.txt:958)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoEvent">
<summary>
 event
 (Originally from FSComp.txt:956)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoCustomOperation">
<summary>
 custom operation
 (Originally from FSComp.txt:959)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoCallsWord">
<summary>
 Calls
 (Originally from FSComp.txt:1300)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoArgument">
<summary>
 argument
 (Originally from FSComp.txt:960)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoAnonRecdField">
<summary>
 anonymous record field
 (Originally from FSComp.txt:961)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoActiveRecognizer">
<summary>
 active recognizer
 (Originally from FSComp.txt:954)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoActivePatternResult">
<summary>
 active pattern result
 (Originally from FSComp.txt:953)
</summary>
</member>
<member name="M:FSComp.SR.tupleRequiredInAbstractMethod">
<summary>
 \nA tuple type is required for one or more arguments. Consider wrapping the given arguments in additional parentheses or review the definition of the interface.
 (Originally from FSComp.txt:39)
</summary>
</member>
<member name="M:FSComp.SR.toolLocationHelperUnsupportedFrameworkVersion(System.String)">
<summary>
 The specified .NET Framework version &apos;%s&apos; is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.
 (Originally from FSComp.txt:1138)
</summary>
</member>
<member name="M:FSComp.SR.tooManyMethodsInDotNetTypeWritingAssembly(System.String,System.Int32,System.Int32)">
<summary>
 The type &apos;%s&apos; has too many methods. Found: &apos;%d&apos;, maximum: &apos;%d&apos;
 (Originally from FSComp.txt:1772)
</summary>
</member>
<member name="M:FSComp.SR.tlrUnexpectedTExpr">
<summary>
 Unexpected Expr.TyChoose
 (Originally from FSComp.txt:984)
</summary>
</member>
<member name="M:FSComp.SR.tlrLambdaLiftingOptimizationsNotApplied">
<summary>
 Note: Lambda-lifting optimizations have not been applied because of the use of this local constrained generic function as a first class value. Adding type constraints may resolve this condition.
 (Originally from FSComp.txt:985)
</summary>
</member>
<member name="M:FSComp.SR.tcVolatileOnlyOnClassLetBindings">
<summary>
 The &apos;VolatileField&apos; attribute may only be used on &apos;let&apos; bindings in classes
 (Originally from FSComp.txt:678)
</summary>
</member>
<member name="M:FSComp.SR.tcVolatileFieldsMustBeMutable">
<summary>
 Volatile fields must be marked &apos;mutable&apos; and cannot be thread-static
 (Originally from FSComp.txt:733)
</summary>
</member>
<member name="M:FSComp.SR.tcValueInSignatureRequiresLiteralAttribute">
<summary>
 A declaration may only be given a value in a signature if the declaration has the [&lt;Literal&gt;] attribute
 (Originally from FSComp.txt:731)
</summary>
</member>
<member name="M:FSComp.SR.tcUsingInterfacesWithStaticAbstractMethods">
<summary>
 Declaring \&quot;interfaces with static abstract methods\&quot; is an advanced feature. See https://aka.ms/fsharp-iwsams for guidance. You can disable this warning by using &apos;#nowarn \&quot;3535\&quot;&apos; or &apos;--nowarn:3535&apos;.
 (Originally from FSComp.txt:1719)
</summary>
</member>
<member name="M:FSComp.SR.tcUsingInterfaceWithStaticAbstractMethodAsType(System.String)">
<summary>
 &apos;%s&apos; is normally used as a type constraint in generic code, e.g. \&quot;&apos;T when ISomeInterface&lt;&apos;T&gt;\&quot; or \&quot;let f (x: #ISomeInterface&lt;_&gt;)\&quot;. See https://aka.ms/fsharp-iwsams for guidance. You can disable this warning by using &apos;#nowarn \&quot;3536\&quot;&apos; or &apos;--nowarn:3536&apos;.
 (Originally from FSComp.txt:1720)
</summary>
</member>
<member name="M:FSComp.SR.tcUseYieldBangForMultipleResults">
<summary>
 In sequence expressions, multiple results are generated using &apos;yield!&apos;
 (Originally from FSComp.txt:653)
</summary>
</member>
<member name="M:FSComp.SR.tcUseMayNotBeUsedInQueries">
<summary>
 &apos;use&apos; expressions may not be used in queries
 (Originally from FSComp.txt:1317)
</summary>
</member>
<member name="M:FSComp.SR.tcUseForInSequenceExpression">
<summary>
 The use of &apos;let! x = coll&apos; in sequence expressions is not permitted. Use &apos;for x in coll&apos; instead.
 (Originally from FSComp.txt:651)
</summary>
</member>
<member name="M:FSComp.SR.tcUnsupportedMutRecDecl">
<summary>
 This declaration is not supported in recursive declaration groups
 (Originally from FSComp.txt:1386)
</summary>
</member>
<member name="M:FSComp.SR.tcUnsupportedAttribute">
<summary>
 This attribute cannot be used in this version of F#
 (Originally from FSComp.txt:705)
</summary>
</member>
<member name="M:FSComp.SR.tcUnrecognizedQueryOperator">
<summary>
 This is not a known query operator. Query operators are identifiers such as &apos;select&apos;, &apos;where&apos;, &apos;sortBy&apos;, &apos;thenBy&apos;, &apos;groupBy&apos;, &apos;groupValBy&apos;, &apos;join&apos;, &apos;groupJoin&apos;, &apos;sumBy&apos; and &apos;averageBy&apos;, defined using corresponding methods on the &apos;QueryBuilder&apos; type.
 (Originally from FSComp.txt:1320)
</summary>
</member>
<member name="M:FSComp.SR.tcUnrecognizedQueryBinaryOperator">
<summary>
 Arguments to query operators may require parentheses, e.g. &apos;where (x &gt; y)&apos; or &apos;groupBy (x.Length / 10)&apos;
 (Originally from FSComp.txt:1328)
</summary>
</member>
<member name="M:FSComp.SR.tcUnrecognizedAttributeTarget">
<summary>
 Unrecognized attribute target. Valid attribute targets are &apos;assembly&apos;, &apos;module&apos;, &apos;type&apos;, &apos;method&apos;, &apos;property&apos;, &apos;return&apos;, &apos;param&apos;, &apos;field&apos;, &apos;event&apos;, &apos;constructor&apos;.
 (Originally from FSComp.txt:695)
</summary>
</member>
<member name="M:FSComp.SR.tcUnnamedArgumentsDoNotFormPrefix">
<summary>
 The unnamed arguments do not form a prefix of the arguments of the method called
 (Originally from FSComp.txt:672)
</summary>
</member>
<member name="M:FSComp.SR.tcUnknownUnion">
<summary>
 Unknown union case
 (Originally from FSComp.txt:525)
</summary>
</member>
<member name="M:FSComp.SR.tcUnitsOfMeasureInvalidInTypeConstructor">
<summary>
 Unit-of-measure cannot be used in type constructor application
 (Originally from FSComp.txt:562)
</summary>
</member>
<member name="M:FSComp.SR.tcUnionCaseRequiresOneArgument">
<summary>
 This union case takes one argument
 (Originally from FSComp.txt:581)
</summary>
</member>
<member name="M:FSComp.SR.tcUnionCaseNameConflictsWithGeneratedType(System.String,System.String)">
<summary>
 The union case named &apos;%s&apos; conflicts with the generated type &apos;%s&apos;
 (Originally from FSComp.txt:1112)
</summary>
</member>
<member name="M:FSComp.SR.tcUnionCaseFieldCannotBeUsedMoreThanOnce(System.String)">
<summary>
 Union case/exception field &apos;%s&apos; cannot be used more than once.
 (Originally from FSComp.txt:1355)
</summary>
</member>
<member name="M:FSComp.SR.tcUnionCaseExpectsTupledArguments(System.Int32,System.Int32,System.String)">
<summary>
 This union case expects %d arguments in tupled form, but was given %d. The missing field arguments may be any of:%s
 (Originally from FSComp.txt:582)
</summary>
</member>
<member name="M:FSComp.SR.tcUnionCaseDoesNotTakeArguments">
<summary>
 This union case does not take arguments
 (Originally from FSComp.txt:580)
</summary>
</member>
<member name="M:FSComp.SR.tcUnionCaseConstructorDoesNotHaveFieldWithGivenName(System.String,System.String)">
<summary>
 The union case &apos;%s&apos; does not have a field named &apos;%s&apos;.
 (Originally from FSComp.txt:1351)
</summary>
</member>
<member name="M:FSComp.SR.tcUninitializedValFieldsMustBeMutable">
<summary>
 Uninitialized &apos;val&apos; fields must be mutable and marked with the &apos;[&lt;DefaultValue&gt;]&apos; attribute. Consider using a &apos;let&apos; binding instead of a &apos;val&apos; field.
 (Originally from FSComp.txt:734)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedTypeArguments">
<summary>
 Unexpected type arguments
 (Originally from FSComp.txt:572)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedSymbolInTypeExpression(System.String)">
<summary>
 Unexpected %s in type expression
 (Originally from FSComp.txt:566)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedSlashInType">
<summary>
 Unexpected / in type
 (Originally from FSComp.txt:571)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedPropertySpec">
<summary>
 Unexpected source-level property specification
 (Originally from FSComp.txt:536)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedPropertyInSyntaxTree">
<summary>
 Unexpected source-level property specification in syntax tree
 (Originally from FSComp.txt:530)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedMeasureAnon">
<summary>
 Unexpected SynMeasure.Anon
 (Originally from FSComp.txt:487)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedFunTypeInUnionCaseField">
<summary>
 Unexpected function type in union case field definition. If you intend the field to be a function, consider wrapping the function signature with parens, e.g. | Case of a -&gt; b into | Case of (a -&gt; b).
 (Originally from FSComp.txt:1759)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedExprAtRecInfPoint">
<summary>
 Unexpected expression at recursive inference point
 (Originally from FSComp.txt:515)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedConstUint16Array">
<summary>
 Unexpected Const_uint16array
 (Originally from FSComp.txt:492)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedConstByteArray">
<summary>
 Unexpected Const_bytearray
 (Originally from FSComp.txt:493)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedConditionInImportedAssembly">
<summary>
 Unexpected condition in imported assembly: failed to decode AttributeUsage attribute
 (Originally from FSComp.txt:694)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedBigRationalConstant">
<summary>
 Unexpected big rational constant
 (Originally from FSComp.txt:490)
</summary>
</member>
<member name="M:FSComp.SR.tcUndefinedField(System.String,System.String)">
<summary>
 The field &apos;%s&apos; has been given a value, but is not present in the type &apos;%s&apos;
 (Originally from FSComp.txt:618)
</summary>
</member>
<member name="M:FSComp.SR.tcUnableToParseInterpolatedString(System.String)">
<summary>
 Invalid interpolated string. %s
 (Originally from FSComp.txt:1656)
</summary>
</member>
<member name="M:FSComp.SR.tcUnableToParseFormatString(System.String)">
<summary>
 Unable to parse format string &apos;%s&apos;
 (Originally from FSComp.txt:596)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesCannotInheritFromMultipleConcreteTypes">
<summary>
 Types cannot inherit from multiple concrete types
 (Originally from FSComp.txt:783)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesCannotContainNestedTypes">
<summary>
 Types cannot contain nested type definitions
 (Originally from FSComp.txt:764)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesAreAlwaysSealedStruct">
<summary>
 Struct types are always sealed
 (Originally from FSComp.txt:795)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesAreAlwaysSealedRecord">
<summary>
 Record types are always sealed
 (Originally from FSComp.txt:793)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesAreAlwaysSealedEnum">
<summary>
 Enum types are always sealed
 (Originally from FSComp.txt:797)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesAreAlwaysSealedDelegate">
<summary>
 Delegate types are always sealed
 (Originally from FSComp.txt:796)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesAreAlwaysSealedDU">
<summary>
 Discriminated union types are always sealed
 (Originally from FSComp.txt:792)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesAreAlwaysSealedAssemblyCode">
<summary>
 Assembly code types are always sealed
 (Originally from FSComp.txt:794)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeUsedInInvalidWay(System.String,System.String,System.String)">
<summary>
 The type &apos;%s&apos; is used in an invalid way. A value prior to &apos;%s&apos; has an inferred type involving &apos;%s&apos;, which is an invalid forward reference.
 (Originally from FSComp.txt:819)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeTestLossy(System.String,System.String)">
<summary>
 This type test or downcast will erase the provided type &apos;%s&apos; to the type &apos;%s&apos;
 (Originally from FSComp.txt:1228)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeTestLosesMeasures(System.String)">
<summary>
 This type test or downcast will ignore the unit-of-measure &apos;%s&apos;
 (Originally from FSComp.txt:1123)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeTestErased(System.String,System.String)">
<summary>
 This type test with a provided type &apos;%s&apos; is not allowed because this provided type will be erased to &apos;%s&apos; at runtime.
 (Originally from FSComp.txt:1230)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeRequiresDefinition">
<summary>
 This type requires a definition
 (Originally from FSComp.txt:780)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeParametersInferredAreNotStable">
<summary>
 The type parameters inferred for this value are not stable under the erasure of type abbreviations. This is due to the use of type abbreviations which drop or reorder type parameters, e.g. \n\ttype taggedInt&lt;&apos;a&gt; = int or\n\ttype swap&lt;&apos;a,&apos;b&gt; = &apos;b * &apos;a.\nConsider declaring the type parameters for this value explicitly, e.g.\n\tlet f&lt;&apos;a,&apos;b&gt; ((x,y) : swap&lt;&apos;b,&apos;a&gt;) : swap&lt;&apos;a,&apos;b&gt; = (y,x).
 (Originally from FSComp.txt:520)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeParameterInvalidAsTypeConstructor">
<summary>
 Type parameter cannot be used as type constructor
 (Originally from FSComp.txt:567)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeParameterHasBeenConstrained(System.String)">
<summary>
 This type parameter has been used in a way that constrains it to always be &apos;%s&apos;
 (Originally from FSComp.txt:519)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeParameterArityMismatch(System.Int32,System.Int32)">
<summary>
 This value, type or method expects %d type parameter(s) but was given %d
 (Originally from FSComp.txt:542)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeOrModule">
<summary>
 type or module
 (Originally from FSComp.txt:766)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeIsNotInterfaceType1(System.String)">
<summary>
 The type &apos;%s&apos; is not an interface type
 (Originally from FSComp.txt:741)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeIsNotInterfaceType0">
<summary>
 This type is not an interface type
 (Originally from FSComp.txt:759)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeIsNotARecordTypeNeedConstructor">
<summary>
 This type is not a record type. Values of class and struct types must be created using calls to object constructors.
 (Originally from FSComp.txt:646)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeIsNotARecordType">
<summary>
 This type is not a record type
 (Originally from FSComp.txt:647)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeIsInaccessible">
<summary>
 This type is not accessible from this code location
 (Originally from FSComp.txt:693)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeHasNoNestedTypes">
<summary>
 This type has no nested types
 (Originally from FSComp.txt:565)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeHasNoAccessibleConstructor">
<summary>
 This type has no accessible object constructors
 (Originally from FSComp.txt:656)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeExceptionOrModule">
<summary>
 type, exception or module
 (Originally from FSComp.txt:765)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeDoesNotInheritAttribute">
<summary>
 This type does not inherit Attribute, it will not work correctly with other .NET languages.
 (Originally from FSComp.txt:1519)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeDoesNotHaveAnyNull(System.String)">
<summary>
 The type &apos;%s&apos; does not support a nullness qualification.
 (Originally from FSComp.txt:1528)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit">
<summary>
 Type definitions may only have one &apos;inherit&apos; specification and it must be the first declaration
 (Originally from FSComp.txt:812)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers">
<summary>
 &apos;let&apos; and &apos;do&apos; bindings must come before member and interface definitions in type definitions
 (Originally from FSComp.txt:813)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeDefinitionIsCyclicThroughInheritance">
<summary>
 This type definition involves an immediate cyclic reference through a struct field or inheritance relation
 (Originally from FSComp.txt:808)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeDefinitionIsCyclic">
<summary>
 This type definition involves an immediate cyclic reference through an abbreviation
 (Originally from FSComp.txt:807)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeCastErased(System.String,System.String)">
<summary>
 This downcast will erase the provided type &apos;%s&apos; to the type &apos;%s&apos;.
 (Originally from FSComp.txt:1229)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeCannotBeEnumerated(System.String)">
<summary>
 The type &apos;%s&apos; is not a type whose values can be enumerated with this syntax, i.e. is not compatible with either seq&lt;_&gt;, IEnumerable&lt;_&gt; or IEnumerable and does not have a GetEnumerator method
 (Originally from FSComp.txt:549)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeAbbreviationsMayNotHaveMembers">
<summary>
 Type abbreviations cannot have members
 (Originally from FSComp.txt:748)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeAbbreviationsCheckedAtCompileTime">
<summary>
 As of F# 4.1, the accessibility of type abbreviations is checked at compile-time. Consider changing the accessibility of the type abbreviation. Ignoring this warning might lead to runtime errors.
 (Originally from FSComp.txt:749)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeAbbreviationsCannotHaveInterfaceDeclaration">
<summary>
 Type abbreviations cannot have interface declarations
 (Originally from FSComp.txt:757)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeAbbreviationsCannotHaveAugmentations">
<summary>
 Type abbreviations cannot have augmentations
 (Originally from FSComp.txt:817)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeAbbreviationHasTypeParametersMissingOnType">
<summary>
 This type abbreviation has one or more declared type parameters that do not appear in the type being abbreviated. Type abbreviations must use all declared type parameters in the type being abbreviated. Consider removing one or more type parameters, or use a concrete type definition that wraps an underlying type, such as &apos;type C&lt;&apos;a&gt; = C of ...&apos;.
 (Originally from FSComp.txt:781)
</summary>
</member>
<member name="M:FSComp.SR.tcTupleStructMismatch">
<summary>
 One tuple type is a struct tuple, the other is a reference tuple
 (Originally from FSComp.txt:1379)
</summary>
</member>
<member name="M:FSComp.SR.tcTupleMemberNotNormallyUsed">
<summary>
 This method or property is not normally used from F# code, use an explicit tuple pattern for deconstruction instead.
 (Originally from FSComp.txt:1499)
</summary>
</member>
<member name="M:FSComp.SR.tcTryWithMayNotBeUsedInQueries">
<summary>
 &apos;try/with&apos; expressions may not be used in queries
 (Originally from FSComp.txt:1321)
</summary>
</member>
<member name="M:FSComp.SR.tcTryIllegalInSequenceExpression">
<summary>
 &apos;try&apos;/&apos;with&apos; cannot be used within sequence expressions
 (Originally from FSComp.txt:652)
</summary>
</member>
<member name="M:FSComp.SR.tcTraitMayNotUseComplexThings">
<summary>
 A trait may not specify optional, in, out, ParamArray, CallerInfo or Quote arguments
 (Originally from FSComp.txt:1716)
</summary>
</member>
<member name="M:FSComp.SR.tcTraitIsStatic(System.String)">
<summary>
 Trait &apos;%s&apos; is static
 (Originally from FSComp.txt:1714)
</summary>
</member>
<member name="M:FSComp.SR.tcTraitIsNotStatic(System.String)">
<summary>
 Trait &apos;%s&apos; is not static
 (Originally from FSComp.txt:1715)
</summary>
</member>
<member name="M:FSComp.SR.tcTraitInvocationShouldUseTick">
<summary>
 Invocation of a static constraint should use \&quot;&apos;T.Ident\&quot; and not \&quot;^T.Ident\&quot;, even for statically resolved type parameters.
 (Originally from FSComp.txt:1718)
</summary>
</member>
<member name="M:FSComp.SR.tcTraitHasMultipleSupportTypes(System.String)">
<summary>
 The trait &apos;%s&apos; invoked by this call has multiple support types. This invocation syntax is not permitted for such traits. See https://aka.ms/fsharp-srtp for guidance.
 (Originally from FSComp.txt:1721)
</summary>
</member>
<member name="M:FSComp.SR.tcThreadStaticAndContextStaticMustBeStatic">
<summary>
 Thread-static and context-static variables must be static and given the [&lt;DefaultValue&gt;] attribute to indicate that the value is initialized to the default value on each new thread
 (Originally from FSComp.txt:732)
</summary>
</member>
<member name="M:FSComp.SR.tcThisValueMayNotBeInlined">
<summary>
 This member, function or value declaration may not be declared &apos;inline&apos;
 (Originally from FSComp.txt:1326)
</summary>
</member>
<member name="M:FSComp.SR.tcThisTypeMayNotHaveACLIMutableAttribute">
<summary>
 This type definition may not have the &apos;CLIMutable&apos; attribute. Only record types may have this attribute.
 (Originally from FSComp.txt:1308)
</summary>
</member>
<member name="M:FSComp.SR.tcTPFieldMustBeLiteral">
<summary>
 Invalid provided field. Provided fields of erased provided types must be literals.
 (Originally from FSComp.txt:1337)
</summary>
</member>
<member name="M:FSComp.SR.tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields">
<summary>
 The syntax &apos;expr.id&apos; may only be used with record labels, properties and fields
 (Originally from FSComp.txt:667)
</summary>
</member>
<member name="M:FSComp.SR.tcSyntaxErrorUnexpectedQMark">
<summary>
 Syntax error - unexpected &apos;?&apos; symbol
 (Originally from FSComp.txt:588)
</summary>
</member>
<member name="M:FSComp.SR.tcSyntaxCanOnlyBeUsedToCreateObjectTypes(System.String)">
<summary>
 &apos;%s&apos; may only be used to construct object types
 (Originally from FSComp.txt:616)
</summary>
</member>
<member name="M:FSComp.SR.tcSynTypeOrInvalidInDeclaration">
<summary>
 SynType.Or is not permitted in this declaration
 (Originally from FSComp.txt:1726)
</summary>
</member>
<member name="M:FSComp.SR.tcSubsumptionImplicitConversionUsed(System.String,System.String)">
<summary>
 This expression implicitly converts type &apos;%s&apos; to type &apos;%s&apos;. See https://aka.ms/fsharp-implicit-convs.
 (Originally from FSComp.txt:1669)
</summary>
</member>
<member name="M:FSComp.SR.tcStructuralEqualityNotSatisfied2(System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has the &apos;StructuralEquality&apos; attribute but the component type &apos;%s&apos; does not satisfy the &apos;equality&apos; constraint
 (Originally from FSComp.txt:1068)
</summary>
</member>
<member name="M:FSComp.SR.tcStructuralEqualityNotSatisfied1(System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has the &apos;StructuralEquality&apos; attribute but the type parameter &apos;%s&apos; does not satisfy the &apos;equality&apos; constraint. Consider adding the &apos;equality&apos; constraint to the type parameter
 (Originally from FSComp.txt:1067)
</summary>
</member>
<member name="M:FSComp.SR.tcStructuralComparisonNotSatisfied2(System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has the &apos;StructuralComparison&apos; attribute but the component type &apos;%s&apos; does not satisfy the &apos;comparison&apos; constraint
 (Originally from FSComp.txt:1062)
</summary>
</member>
<member name="M:FSComp.SR.tcStructuralComparisonNotSatisfied1(System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has the &apos;StructuralComparison&apos; attribute but the type parameter &apos;%s&apos; does not satisfy the &apos;comparison&apos; constraint. Consider adding the &apos;comparison&apos; constraint to the type parameter
 (Originally from FSComp.txt:1061)
</summary>
</member>
<member name="M:FSComp.SR.tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly">
<summary>
 Each argument of the primary constructor for a struct must be given a type, for example &apos;type S(x1:int, x2: int) = ...&apos;. These arguments determine the fields of the struct.
 (Originally from FSComp.txt:1069)
</summary>
</member>
<member name="M:FSComp.SR.tcStructsMayNotContainLetBindings">
<summary>
 Structs cannot contain value definitions because the default constructor for structs will not execute these bindings. Consider adding additional arguments to the primary constructor for the type.
 (Originally from FSComp.txt:753)
</summary>
</member>
<member name="M:FSComp.SR.tcStructsMayNotContainDoBindings">
<summary>
 Structs cannot contain &apos;do&apos; bindings because the default constructor for structs would not execute these bindings
 (Originally from FSComp.txt:752)
</summary>
</member>
<member name="M:FSComp.SR.tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes">
<summary>
 Structs, interfaces, enums and delegates cannot inherit from other types
 (Originally from FSComp.txt:782)
</summary>
</member>
<member name="M:FSComp.SR.tcStructsCannotHaveConstructorWithNoArguments">
<summary>
 Structs cannot have an object constructor with no arguments. This is a restriction imposed on all CLI languages as structs automatically support a default constructor.
 (Originally from FSComp.txt:724)
</summary>
</member>
<member name="M:FSComp.SR.tcStructsCanOnlyBindThisAtMemberDeclaration">
<summary>
 Structs may only bind a &apos;this&apos; parameter at member declarations
 (Originally from FSComp.txt:514)
</summary>
</member>
<member name="M:FSComp.SR.tcStructUnionMultiCaseFieldsSameType">
<summary>
 If a multicase union type is a struct, then all fields with the same name must be of the same type. This rule applies also to the generated &apos;Item&apos; name in case of unnamed fields.
 (Originally from FSComp.txt:1764)
</summary>
</member>
<member name="M:FSComp.SR.tcStructUnionMultiCaseDistinctFields">
<summary>
 If a multicase union type is a struct, then all union cases must have unique names. For example: &apos;type A = B of b: int | C of c: int&apos;.
 (Originally from FSComp.txt:1388)
</summary>
</member>
<member name="M:FSComp.SR.tcStructTypesCannotContainAbstractMembers">
<summary>
 Struct types cannot contain abstract members
 (Originally from FSComp.txt:802)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticValFieldsMustBeMutableAndPrivate">
<summary>
 Static &apos;val&apos; fields in types must be mutable, private and marked with the &apos;[&lt;DefaultValue&gt;]&apos; attribute. They are initialized to the &apos;null&apos; or &apos;zero&apos; value for their type. Consider also using a &apos;static let mutable&apos; binding in a class type.
 (Originally from FSComp.txt:735)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticOptimizationConditionalsOnlyForFSharpLibrary">
<summary>
 Static optimization conditionals are only for use within the F# library
 (Originally from FSComp.txt:673)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticMemberShouldNotHaveThis">
<summary>
 This static member should not have a &apos;this&apos; parameter. Consider using the notation &apos;member Member(args) = ...&apos;.
 (Originally from FSComp.txt:533)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticLetBindingsRequireClassesWithImplicitConstructors">
<summary>
 For F#7 and lower, static &apos;let&apos;,&apos;do&apos; and &apos;member val&apos; definitions may only be used in types with a primary constructor (&apos;type X(args) = ...&apos;). To enable them in all other types, use language version &apos;8&apos; or higher.
 (Originally from FSComp.txt:754)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticInitializersIllegalInInterface">
<summary>
 Interfaces cannot contain definitions of static initializers
 (Originally from FSComp.txt:719)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticInitializerRequiresArgument">
<summary>
 A static initializer requires an argument
 (Originally from FSComp.txt:531)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticFieldUsedWhenInstanceFieldExpected">
<summary>
 A static field was used where an instance field is expected
 (Originally from FSComp.txt:484)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticBindingInExtrinsicAugmentation">
<summary>
 Static bindings cannot be added to extrinsic augmentations. Consider using a &apos;static member&apos; instead.
 (Originally from FSComp.txt:1753)
</summary>
</member>
<member name="M:FSComp.SR.tcSimpleMethodNameRequired">
<summary>
 A simple method name is required here
 (Originally from FSComp.txt:626)
</summary>
</member>
<member name="M:FSComp.SR.tcSetterForInitOnlyPropertyCannotBeCalled1(System.String)">
<summary>
 Cannot call &apos;%s&apos; - a setter for init-only property, please use object initialization instead. See https://aka.ms/fsharp-assigning-values-to-properties-at-initialization
 (Originally from FSComp.txt:665)
</summary>
</member>
<member name="M:FSComp.SR.tcSeqResultsUseYield">
<summary>
 In sequence expressions, results are generated using &apos;yield&apos;
 (Originally from FSComp.txt:489)
</summary>
</member>
<member name="M:FSComp.SR.tcRuntimeSuppliedMethodCannotBeUsedInUserCode(System.String)">
<summary>
 Array method &apos;%s&apos; is supplied by the runtime and cannot be directly used in code. For operations with array elements consider using family of GetArray/SetArray functions from LanguagePrimitives.IntrinsicFunctions module.
 (Originally from FSComp.txt:1350)
</summary>
</member>
<member name="M:FSComp.SR.tcReturnValuesCannotHaveNames">
<summary>
 Return values cannot have names
 (Originally from FSComp.txt:495)
</summary>
</member>
<member name="M:FSComp.SR.tcReturnTypesForUnionMustBeSameAsType">
<summary>
 Return types of union cases must be identical to the type being defined, up to abbreviations
 (Originally from FSComp.txt:739)
</summary>
</member>
<member name="M:FSComp.SR.tcReturnMayNotBeUsedInQueries">
<summary>
 &apos;return&apos; and &apos;return!&apos; may not be used in queries
 (Originally from FSComp.txt:1319)
</summary>
</member>
<member name="M:FSComp.SR.tcResumableCodeNotSupported">
<summary>
 Using resumable code or resumable state machines requires /langversion:preview
 (Originally from FSComp.txt:1690)
</summary>
</member>
<member name="M:FSComp.SR.tcResumableCodeInvocation">
<summary>
 Resumable code invocation. Suppress this warning if you are defining new low-level resumable code in terms of existing resumable code.
 (Originally from FSComp.txt:1694)
</summary>
</member>
<member name="M:FSComp.SR.tcResumableCodeFunctionMustBeInline">
<summary>
 Invalid resumable code. Any method of function accepting or returning resumable code must be marked &apos;inline&apos;
 (Originally from FSComp.txt:1686)
</summary>
</member>
<member name="M:FSComp.SR.tcResumableCodeContainsLetRec">
<summary>
 Invalid resumable code. A &apos;let rec&apos; occurred in the resumable code specification
 (Originally from FSComp.txt:1689)
</summary>
</member>
<member name="M:FSComp.SR.tcResumableCodeArgMustHaveRightName">
<summary>
 Invalid resumable code. Resumable code parameter must have name beginning with &apos;__expand&apos;
 (Originally from FSComp.txt:1687)
</summary>
</member>
<member name="M:FSComp.SR.tcResumableCodeArgMustHaveRightKind">
<summary>
 Invalid resumable code. A resumable code parameter must be of delegate or function type
 (Originally from FSComp.txt:1688)
</summary>
</member>
<member name="M:FSComp.SR.tcReservedSyntaxForAugmentation">
<summary>
 The syntax &apos;type X with ...&apos; is reserved for augmentations. Types whose representations are hidden but which have members are now declared in signatures using &apos;type X = ...&apos;. You may also need to add the &apos;[&lt;Sealed&gt;] attribute to the type definition in the signature
 (Originally from FSComp.txt:809)
</summary>
</member>
<member name="M:FSComp.SR.tcRequireVarConstRecogOrLiteral">
<summary>
 This is not a variable, constant, active recognizer or literal
 (Originally from FSComp.txt:585)
</summary>
</member>
<member name="M:FSComp.SR.tcRequireMergeSourcesOrBindN(System.String)">
<summary>
 The &apos;let! ... and! ...&apos; construct may only be used if the computation expression builder defines either a &apos;%s&apos; method or appropriate &apos;MergeSources&apos; and &apos;Bind&apos; methods
 (Originally from FSComp.txt:1551)
</summary>
</member>
<member name="M:FSComp.SR.tcRequireBuilderMethod(System.String)">
<summary>
 This control construct may only be used if the computation expression builder defines a &apos;%s&apos; method
 (Originally from FSComp.txt:563)
</summary>
</member>
<member name="M:FSComp.SR.tcRequireActivePatternWithOneResult">
<summary>
 Only active patterns returning exactly one result may accept arguments
 (Originally from FSComp.txt:577)
</summary>
</member>
<member name="M:FSComp.SR.tcRepresentationOfTypeHiddenBySignature">
<summary>
 The representation of this type is hidden by the signature. It must be given an attribute such as [&lt;Sealed&gt;], [&lt;Class&gt;] or [&lt;Interface&gt;] to indicate the characteristics of the type.
 (Originally from FSComp.txt:788)
</summary>
</member>
<member name="M:FSComp.SR.tcRecursiveBindingsWithMembersMustBeDirectAugmentation">
<summary>
 Recursive bindings that include member specifications can only occur as a direct augmentation of a type
 (Originally from FSComp.txt:726)
</summary>
</member>
<member name="M:FSComp.SR.tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute">
<summary>
 Records, union, abbreviations and struct types cannot have the &apos;AllowNullLiteral&apos; attribute
 (Originally from FSComp.txt:784)
</summary>
</member>
<member name="M:FSComp.SR.tcRecordFieldInconsistentTypes">
<summary>
 This record contains fields from inconsistent types
 (Originally from FSComp.txt:512)
</summary>
</member>
<member name="M:FSComp.SR.tcRecImplied">
<summary>
 The &apos;rec&apos; on this module is implied by an outer &apos;rec&apos; declaration and is being ignored
 (Originally from FSComp.txt:1383)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyRequiresExplicitTypeParameters">
<summary>
 A property cannot have explicit type parameters. Consider using a method instead.
 (Originally from FSComp.txt:527)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyOrFieldNotFoundInAttribute">
<summary>
 This property or field was not found on this custom attribute type
 (Originally from FSComp.txt:700)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyIsStatic(System.String)">
<summary>
 Property &apos;%s&apos; is static
 (Originally from FSComp.txt:662)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyIsNotStatic(System.String)">
<summary>
 Property &apos;%s&apos; is not static
 (Originally from FSComp.txt:659)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyIsNotReadable(System.String)">
<summary>
 Property &apos;%s&apos; is not readable
 (Originally from FSComp.txt:660)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyCannotBeSet1(System.String)">
<summary>
 Property &apos;%s&apos; cannot be set
 (Originally from FSComp.txt:663)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyCannotBeSet0">
<summary>
 This property cannot be set
 (Originally from FSComp.txt:699)
</summary>
</member>
<member name="M:FSComp.SR.tcPredefinedTypeCannotBeUsedAsSuperType">
<summary>
 The types System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate and System.Array cannot be used as super types in an object expression or class
 (Originally from FSComp.txt:627)
</summary>
</member>
<member name="M:FSComp.SR.tcPassingWithoutNullTononNullFunction">
<summary>
 You can remove this `nonNull` assertion.
 (Originally from FSComp.txt:1538)
</summary>
</member>
<member name="M:FSComp.SR.tcPassingWithoutNullToValueOptionOfObj">
<summary>
 You can create &apos;ValueSome value&apos; directly instead of &apos;ofObj&apos;, or consider not using a voption for this value.
 (Originally from FSComp.txt:1535)
</summary>
</member>
<member name="M:FSComp.SR.tcPassingWithoutNullToOptionOfObj">
<summary>
 You can create &apos;Some value&apos; directly instead of &apos;ofObj&apos;, or consider not using an option for this value.
 (Originally from FSComp.txt:1534)
</summary>
</member>
<member name="M:FSComp.SR.tcPassingWithoutNullToNonNullQuickAP">
<summary>
 You can remove this |NonNullQuick| pattern usage.
 (Originally from FSComp.txt:1537)
</summary>
</member>
<member name="M:FSComp.SR.tcPassingWithoutNullToNonNullAP">
<summary>
 You can remove this |Null|NonNull| pattern usage.
 (Originally from FSComp.txt:1536)
</summary>
</member>
<member name="M:FSComp.SR.tcPassingWithoutNullToANullableExpectingFunc(System.String)">
<summary>
 Value known to be without null passed to a function meant for nullables: %s
 (Originally from FSComp.txt:1533)
</summary>
</member>
<member name="M:FSComp.SR.tcPartialActivePattern">
<summary>
 Multi-case partial active patterns are not supported. Consider using a single-case partial active pattern or a full active pattern.
 (Originally from FSComp.txt:1789)
</summary>
</member>
<member name="M:FSComp.SR.tcParenThenAdjacentListArgumentReserved">
<summary>
 The syntax &apos;(expr1)[expr2]&apos; is now reserved for indexing and is ambiguous when used as an argument. See https://aka.ms/fsharp-index-notation. If calling a function with multiple curried arguments, add a space between them, e.g. &apos;someFunction (expr1) [expr2]&apos;.
 (Originally from FSComp.txt:1638)
</summary>
</member>
<member name="M:FSComp.SR.tcParenThenAdjacentListArgumentNeedsAdjustment">
<summary>
 The syntax &apos;(expr1)[expr2]&apos; is ambiguous when used as an argument. See https://aka.ms/fsharp-index-notation. If you intend indexing or slicing then you must use &apos;(expr1).[expr2]&apos; in argument position. If calling a function with multiple curried arguments, add a space between them, e.g. &apos;someFunction (expr1) [expr2]&apos;.
 (Originally from FSComp.txt:1641)
</summary>
</member>
<member name="M:FSComp.SR.tcParameterRequiresName">
<summary>
 A parameter with attributes must also be given a name, e.g. &apos;[&lt;Attribute&gt;] Name : Type&apos;
 (Originally from FSComp.txt:494)
</summary>
</member>
<member name="M:FSComp.SR.tcParameterInferredByref(System.String)">
<summary>
 The parameter &apos;%s&apos; was inferred to have byref type. Parameters of byref type must be given an explicit type annotation, e.g. &apos;x1: byref&lt;int&gt;&apos;. When used, a byref parameter is implicitly dereferenced.
 (Originally from FSComp.txt:1084)
</summary>
</member>
<member name="M:FSComp.SR.tcOverridingMethodRequiresAllOrNoTypeParameters">
<summary>
 You must explicitly declare either all or no type parameters when overriding a generic abstract method
 (Originally from FSComp.txt:522)
</summary>
</member>
<member name="M:FSComp.SR.tcOverridesCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted on overrides or interface implementations
 (Originally from FSComp.txt:791)
</summary>
</member>
<member name="M:FSComp.SR.tcOverrideUsesMultipleArgumentsInsteadOfTuple">
<summary>
 This override takes a tuple instead of multiple arguments. Try to add an additional layer of parentheses at the method definition (e.g. &apos;member _.Foo((x, y))&apos;), or remove parentheses at the abstract method declaration (e.g. &apos;abstract member Foo: &apos;a * &apos;b -&gt; &apos;c&apos;).
 (Originally from FSComp.txt:1755)
</summary>
</member>
<member name="M:FSComp.SR.tcOverrideArityMismatch(System.String)">
<summary>
 This override takes a different number of arguments to the corresponding abstract member. The following abstract members were found:%s
 (Originally from FSComp.txt:711)
</summary>
</member>
<member name="M:FSComp.SR.tcOverloadsCannotHaveCurriedArguments">
<summary>
 One or more of the overloads of this method has curried arguments. Consider redesigning these members to take arguments in tupled form.
 (Originally from FSComp.txt:671)
</summary>
</member>
<member name="M:FSComp.SR.tcOtherThenAdjacentListArgumentReserved">
<summary>
 The syntax &apos;expr1[expr2]&apos; is now reserved for indexing and is ambiguous when used as an argument. See https://aka.ms/fsharp-index-notation. If calling a function with multiple curried arguments, add a space between them, e.g. &apos;someFunction expr1 [expr2]&apos;.
 (Originally from FSComp.txt:1640)
</summary>
</member>
<member name="M:FSComp.SR.tcOtherThenAdjacentListArgumentNeedsAdjustment">
<summary>
 The syntax &apos;expr1[expr2]&apos; is ambiguous when used as an argument. See https://aka.ms/fsharp-index-notation. If you intend indexing or slicing then you must use &apos;expr1.[expr2]&apos; in argument position. If calling a function with multiple curried arguments, add a space between them, e.g. &apos;someFunction expr1 [expr2]&apos;.
 (Originally from FSComp.txt:1643)
</summary>
</member>
<member name="M:FSComp.SR.tcOptionalArgumentsCannotBeUsedInCustomAttribute">
<summary>
 Optional arguments cannot be used in custom attributes
 (Originally from FSComp.txt:698)
</summary>
</member>
<member name="M:FSComp.SR.tcOptionalArgsOnlyOnMembers">
<summary>
 Optional arguments are only permitted on type members
 (Originally from FSComp.txt:573)
</summary>
</member>
<member name="M:FSComp.SR.tcOptionalArgsMustComeAfterNonOptionalArgs">
<summary>
 Optional arguments must come at the end of the argument list, after any non-optional arguments
 (Originally from FSComp.txt:1109)
</summary>
</member>
<member name="M:FSComp.SR.tcOperatorRequiresIn(System.String,System.String)">
<summary>
 &apos;%s&apos; must be followed by &apos;in&apos;. Usage: %s.
 (Originally from FSComp.txt:1344)
</summary>
</member>
<member name="M:FSComp.SR.tcOperatorIncorrectSyntax(System.String,System.String)">
<summary>
 Incorrect syntax for &apos;%s&apos;. Usage: %s.
 (Originally from FSComp.txt:1272)
</summary>
</member>
<member name="M:FSComp.SR.tcOperatorDoesntAcceptInto(System.String)">
<summary>
 The operator &apos;%s&apos; does not accept the use of &apos;into&apos;
 (Originally from FSComp.txt:1306)
</summary>
</member>
<member name="M:FSComp.SR.tcOpenUsedWithPartiallyQualifiedPath(System.String)">
<summary>
 This declaration opens the namespace or module &apos;%s&apos; through a partially qualified path. Adjust this code to use the full path of the namespace. This change will make your code more robust as new constructs are added to the F# and CLI libraries.
 (Originally from FSComp.txt:746)
</summary>
</member>
<member name="M:FSComp.SR.tcOpenFirstInMutRec">
<summary>
 In a recursive declaration group, &apos;open&apos; declarations must come first in each module
 (Originally from FSComp.txt:1384)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure">
<summary>
 Only types representing units-of-measure may be given the &apos;Measure&apos; attribute
 (Originally from FSComp.txt:790)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlyStructsCanHaveStructLayout">
<summary>
 Only structs and classes without primary constructors may be given the &apos;StructLayout&apos; attribute
 (Originally from FSComp.txt:787)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlySimplePatternsInLetRec">
<summary>
 Only simple variable patterns can be bound in &apos;let rec&apos; constructs
 (Originally from FSComp.txt:727)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlySimpleBindingsCanBeUsedInConstructionExpressions">
<summary>
 Only simple bindings of the form &apos;id = expr&apos; can be used in construction expressions
 (Originally from FSComp.txt:633)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlyRecordFieldsAndSimpleLetCanBeMutable">
<summary>
 Mutable &apos;let&apos; bindings can&apos;t be recursive or defined in recursive modules or namespaces
 (Originally from FSComp.txt:728)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlyFunctionsCanBeInline">
<summary>
 Only functions may be marked &apos;inline&apos;
 (Originally from FSComp.txt:687)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlyClassesCanHaveAbstract">
<summary>
 Only classes may be given the &apos;AbstractClass&apos; attribute
 (Originally from FSComp.txt:789)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectsMustBeInitializedWithObjectExpression">
<summary>
 Objects must be initialized by an object construction expression that calls an inherited object constructor and assigns a value to each field
 (Originally from FSComp.txt:634)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectOfIndeterminateTypeUsedRequireTypeConstraint">
<summary>
 The operator &apos;expr.[idx]&apos; has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
 (Originally from FSComp.txt:607)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual">
<summary>
 Only overrides of abstract and virtual members may be specified in object expressions
 (Originally from FSComp.txt:621)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectExpressionFormDeprecated">
<summary>
 This form of object expression is not used in F#. Use &apos;member this.MemberName ... = ...&apos; to define member implementations in object expressions.
 (Originally from FSComp.txt:537)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectConstructorsOnTypeParametersCannotTakeArguments">
<summary>
 Calls to object constructors on type parameters cannot be given arguments
 (Originally from FSComp.txt:609)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectConstructorsIllegalInInterface">
<summary>
 Interfaces cannot contain definitions of object constructors
 (Originally from FSComp.txt:720)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectConstructorRequiresArgument">
<summary>
 An object constructor requires an argument
 (Originally from FSComp.txt:532)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes">
<summary>
 Object construction expressions (i.e. record expressions with inheritance specifications) may only be used to implement constructors in object model types. Use &apos;new ObjectType(args)&apos; to construct instances of object model types outside of constructors
 (Originally from FSComp.txt:644)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectConstructionCanOnlyBeUsedInClassTypes">
<summary>
 Object construction expressions may only be used to implement constructors in class types
 (Originally from FSComp.txt:632)
</summary>
</member>
<member name="M:FSComp.SR.tcNumericLiteralRequiresModule(System.String)">
<summary>
 This numeric literal requires that a module &apos;%s&apos; defining functions FromZero, FromOne, FromInt32, FromInt64 and FromString be in scope
 (Originally from FSComp.txt:640)
</summary>
</member>
<member name="M:FSComp.SR.tcNullnessCheckingNotEnabled">
<summary>
 The &apos;nullness checking&apos; language feature is not enabled. This use of a nullness checking construct will be ignored.
 (Originally from FSComp.txt:1543)
</summary>
</member>
<member name="M:FSComp.SR.tcNullableToStringOverride">
<summary>
 With nullness checking enabled, overrides of .ToString() method must return a non-nullable string. You can handle potential nulls via the built-in string function.
 (Originally from FSComp.txt:1539)
</summary>
</member>
<member name="M:FSComp.SR.tcNotValidEnumCaseName">
<summary>
 This is not a valid name for an enumeration case
 (Originally from FSComp.txt:600)
</summary>
</member>
<member name="M:FSComp.SR.tcNotSufficientlyGenericBecauseOfScope(System.String)">
<summary>
 This code is not sufficiently generic. The type variable %s could not be generalized because it would escape its scope.
 (Originally from FSComp.txt:526)
</summary>
</member>
<member name="M:FSComp.SR.tcNotAnIndexerNamedIndexingNotYetEnabled(System.String)">
<summary>
 The value &apos;%s&apos; is not a function and does not support index notation.
 (Originally from FSComp.txt:1627)
</summary>
</member>
<member name="M:FSComp.SR.tcNotAnIndexerIndexingNotYetEnabled">
<summary>
 This expression is not a function and does not support index notation.
 (Originally from FSComp.txt:1628)
</summary>
</member>
<member name="M:FSComp.SR.tcNotAnException">
<summary>
 Not an exception
 (Originally from FSComp.txt:774)
</summary>
</member>
<member name="M:FSComp.SR.tcNotAFunctionButIndexerNamedIndexingNotYetEnabled(System.String,System.String)">
<summary>
 This value supports indexing, e.g. &apos;%s.[index]&apos;. The syntax &apos;%s[index]&apos; requires /langversion:preview. See https://aka.ms/fsharp-index-notation.
 (Originally from FSComp.txt:1625)
</summary>
</member>
<member name="M:FSComp.SR.tcNotAFunctionButIndexerIndexingNotYetEnabled">
<summary>
 This expression supports indexing, e.g. &apos;expr.[index]&apos;. The syntax &apos;expr[index]&apos; requires /langversion:preview. See https://aka.ms/fsharp-index-notation.
 (Originally from FSComp.txt:1626)
</summary>
</member>
<member name="M:FSComp.SR.tcNonZeroConstantCannotHaveGenericUnit">
<summary>
 Non-zero constants cannot have generic units. For generic zero, write 0.0&lt;_&gt;.
 (Originally from FSComp.txt:488)
</summary>
</member>
<member name="M:FSComp.SR.tcNonUniformMemberUse(System.String)">
<summary>
 The generic member &apos;%s&apos; has been used at a non-uniform instantiation prior to this program point. Consider reordering the members so this member occurs first. Alternatively, specify the full type of the member explicitly, including argument types, return type and any additional generic parameters and constraints.
 (Originally from FSComp.txt:1085)
</summary>
</member>
<member name="M:FSComp.SR.tcNonSimpleLetBindingInQuery">
<summary>
 This &apos;let&apos; definition may not be used in a query. Only simple value definitions may be used in queries.
 (Originally from FSComp.txt:1322)
</summary>
</member>
<member name="M:FSComp.SR.tcNonLiteralCannotBeUsedInPattern">
<summary>
 This value is not a literal and cannot be used in a pattern
 (Originally from FSComp.txt:545)
</summary>
</member>
<member name="M:FSComp.SR.tcNoWhileInQuery">
<summary>
 &apos;while&apos; expressions may not be used in queries
 (Originally from FSComp.txt:1315)
</summary>
</member>
<member name="M:FSComp.SR.tcNoTryFinallyInQuery">
<summary>
 &apos;try/finally&apos; expressions may not be used in queries
 (Originally from FSComp.txt:1316)
</summary>
</member>
<member name="M:FSComp.SR.tcNoStaticPropertyFoundForOverride">
<summary>
 No static abstract property was found that corresponds to this override
 (Originally from FSComp.txt:1767)
</summary>
</member>
<member name="M:FSComp.SR.tcNoStaticMemberFoundForOverride">
<summary>
 No static abstract member was found that corresponds to this override
 (Originally from FSComp.txt:1766)
</summary>
</member>
<member name="M:FSComp.SR.tcNoPropertyFoundForOverride">
<summary>
 No abstract property was found that corresponds to this override
 (Originally from FSComp.txt:714)
</summary>
</member>
<member name="M:FSComp.SR.tcNoMemberFoundForOverride">
<summary>
 No abstract or interface member was found that corresponds to this override
 (Originally from FSComp.txt:710)
</summary>
</member>
<member name="M:FSComp.SR.tcNoInterfaceImplementationForConstructionExpression">
<summary>
 Interface implementations cannot be given on construction expressions
 (Originally from FSComp.txt:631)
</summary>
</member>
<member name="M:FSComp.SR.tcNoIntegerForLoopInQuery">
<summary>
 In queries, use the form &apos;for x in n .. m do ...&apos; for ranging over integers
 (Originally from FSComp.txt:1314)
</summary>
</member>
<member name="M:FSComp.SR.tcNoEqualityNeeded2(System.String,System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; does not support structural equality because the type &apos;%s&apos; does not satisfy the &apos;equality&apos; constraint. Consider adding the &apos;NoEquality&apos; attribute to the type &apos;%s&apos; to clarify that the type does not support structural equality
 (Originally from FSComp.txt:1066)
</summary>
</member>
<member name="M:FSComp.SR.tcNoEqualityNeeded1(System.String,System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; does not support structural equality because the type parameter %s does not satisfy the &apos;equality&apos; constraint. Consider adding the &apos;NoEquality&apos; attribute to the type &apos;%s&apos; to clarify that the type does not support structural equality
 (Originally from FSComp.txt:1065)
</summary>
</member>
<member name="M:FSComp.SR.tcNoEagerConstraintApplicationAttribute">
<summary>
 Using methods with &apos;NoEagerConstraintApplicationAttribute&apos; requires /langversion:6.0 or later
 (Originally from FSComp.txt:1691)
</summary>
</member>
<member name="M:FSComp.SR.tcNoComparisonNeeded2(System.String,System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; is not structurally comparable because the type &apos;%s&apos; does not satisfy the &apos;comparison&apos; constraint. Consider adding the &apos;NoComparison&apos; attribute to the type &apos;%s&apos; to clarify that the type is not comparable
 (Originally from FSComp.txt:1064)
</summary>
</member>
<member name="M:FSComp.SR.tcNoComparisonNeeded1(System.String,System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; is not structurally comparable because the type parameter %s does not satisfy the &apos;comparison&apos; constraint. Consider adding the &apos;NoComparison&apos; attribute to the type &apos;%s&apos; to clarify that the type is not comparable
 (Originally from FSComp.txt:1063)
</summary>
</member>
<member name="M:FSComp.SR.tcNoArgumentsForRecordValue">
<summary>
 No arguments may be given when constructing a record value
 (Originally from FSComp.txt:630)
</summary>
</member>
<member name="M:FSComp.SR.tcNoAbstractOrVirtualMemberFound(System.String)">
<summary>
 The member &apos;%s&apos; does not correspond to any abstract or virtual method available to override or implement.
 (Originally from FSComp.txt:622)
</summary>
</member>
<member name="M:FSComp.SR.tcNewRequiresObjectConstructor">
<summary>
 &apos;new&apos; may only be used with object constructors
 (Originally from FSComp.txt:638)
</summary>
</member>
<member name="M:FSComp.SR.tcNewMustBeUsedWithNamedType">
<summary>
 &apos;new&apos; must be used with a named type
 (Originally from FSComp.txt:628)
</summary>
</member>
<member name="M:FSComp.SR.tcNewMemberHidesAbstractMemberWithSuffix(System.String)">
<summary>
 This new member hides the abstract member &apos;%s&apos; once tuples, functions, units of measure and/or provided types are erased. Rename the member or use &apos;override&apos; instead.
 (Originally from FSComp.txt:718)
</summary>
</member>
<member name="M:FSComp.SR.tcNewMemberHidesAbstractMember(System.String)">
<summary>
 This new member hides the abstract member &apos;%s&apos;. Rename the member or use &apos;override&apos; instead.
 (Originally from FSComp.txt:717)
</summary>
</member>
<member name="M:FSComp.SR.tcNewCannotBeUsedOnInterfaceType">
<summary>
 &apos;new&apos; cannot be used on interface types. Consider using an object expression &apos;{ new ... with ... }&apos; instead.
 (Originally from FSComp.txt:613)
</summary>
</member>
<member name="M:FSComp.SR.tcNamespaceCannotContainValues">
<summary>
 Namespaces cannot contain values. Consider using a module to hold your value declarations.
 (Originally from FSComp.txt:41)
</summary>
</member>
<member name="M:FSComp.SR.tcNamespaceCannotContainExtensionMembers">
<summary>
 Namespaces cannot contain extension members except in the same file and namespace declaration group where the type is defined. Consider using a module to hold declarations of extension members.
 (Originally from FSComp.txt:497)
</summary>
</member>
<member name="M:FSComp.SR.tcNamedTypeRequired(System.String)">
<summary>
 &apos;%s&apos; may only be used with named types
 (Originally from FSComp.txt:611)
</summary>
</member>
<member name="M:FSComp.SR.tcNamedArgumentsCannotBeUsedInMemberTraits">
<summary>
 Named arguments cannot be given to member trait calls
 (Originally from FSComp.txt:599)
</summary>
</member>
<member name="M:FSComp.SR.tcNamedArgumentDidNotMatch(System.String)">
<summary>
 The named argument &apos;%s&apos; did not match any argument or mutable property
 (Originally from FSComp.txt:670)
</summary>
</member>
<member name="M:FSComp.SR.tcNamedActivePattern(System.String)">
<summary>
 %s is an active pattern and cannot be treated as a discriminated union case with named fields.
 (Originally from FSComp.txt:1393)
</summary>
</member>
<member name="M:FSComp.SR.tcNameNotBoundInPattern(System.String)">
<summary>
 Name &apos;%s&apos; not bound in pattern context
 (Originally from FSComp.txt:574)
</summary>
</member>
<member name="M:FSComp.SR.tcNameArgumentsMustAppearLast">
<summary>
 Named arguments must appear after all other arguments
 (Originally from FSComp.txt:547)
</summary>
</member>
<member name="M:FSComp.SR.tcMutableValuesSyntax">
<summary>
 Mutable function values should be written &apos;let mutable f = (fun args -&gt; ...)&apos;
 (Originally from FSComp.txt:686)
</summary>
</member>
<member name="M:FSComp.SR.tcMutableValuesMayNotHaveGenericParameters">
<summary>
 Mutable values cannot have generic parameters
 (Originally from FSComp.txt:685)
</summary>
</member>
<member name="M:FSComp.SR.tcMutableValuesCannotBeInline">
<summary>
 Mutable values cannot be marked &apos;inline&apos;
 (Originally from FSComp.txt:684)
</summary>
</member>
<member name="M:FSComp.SR.tcMultipleVisibilityAttributesWithLet">
<summary>
 Multiple visibility attributes have been specified for this identifier. &apos;let&apos; bindings in classes are always private, as are any &apos;let&apos; bindings inside expressions.
 (Originally from FSComp.txt:499)
</summary>
</member>
<member name="M:FSComp.SR.tcMultipleVisibilityAttributes">
<summary>
 Multiple visibility attributes have been specified for this identifier
 (Originally from FSComp.txt:498)
</summary>
</member>
<member name="M:FSComp.SR.tcMultipleRecdTypeChoice(System.String,System.String,System.String)">
<summary>
 Multiple type matches were found:\n%s\nThe type &apos;%s&apos; was used. Due to the overlapping field names\n%s\nconsider using type annotations or change the order of open statements.
 (Originally from FSComp.txt:1746)
</summary>
</member>
<member name="M:FSComp.SR.tcMultipleFieldsInRecord(System.String)">
<summary>
 The field &apos;%s&apos; appears multiple times in this record expression or pattern
 (Originally from FSComp.txt:524)
</summary>
</member>
<member name="M:FSComp.SR.tcModuleRequiresQualifiedAccess(System.String)">
<summary>
 This declaration opens the module &apos;%s&apos;, which is marked as &apos;RequireQualifiedAccess&apos;. Adjust your code to use qualified references to the elements of the module instead, e.g. &apos;List.map&apos; instead of &apos;map&apos;. This change will ensure that your code is robust as new constructs are added to libraries.
 (Originally from FSComp.txt:745)
</summary>
</member>
<member name="M:FSComp.SR.tcModuleAbbreviationForNamespace(System.String)">
<summary>
 The path &apos;%s&apos; is a namespace. A module abbreviation may not abbreviate a namespace.
 (Originally from FSComp.txt:818)
</summary>
</member>
<member name="M:FSComp.SR.tcModuleAbbrevFirstInMutRec">
<summary>
 In a recursive declaration group, module abbreviations must come after all &apos;open&apos; declarations and before other declarations
 (Originally from FSComp.txt:1385)
</summary>
</member>
<member name="M:FSComp.SR.tcMissingRequiredMembers(System.String)">
<summary>
 The following required properties have to be initialized:%s
 (Originally from FSComp.txt:1722)
</summary>
</member>
<member name="M:FSComp.SR.tcMissingCustomOperation(System.String)">
<summary>
 A custom query operation for &apos;%s&apos; is required but not specified
 (Originally from FSComp.txt:1242)
</summary>
</member>
<member name="M:FSComp.SR.tcMethodOverridesIllegalHere">
<summary>
 Method overrides and interface implementations are not permitted here
 (Originally from FSComp.txt:709)
</summary>
</member>
<member name="M:FSComp.SR.tcMethodNotAccessible(System.String)">
<summary>
 Method &apos;%s&apos; is not accessible from this code location
 (Originally from FSComp.txt:485)
</summary>
</member>
<member name="M:FSComp.SR.tcMembersThatExtendInterfaceMustBePlacedInSeparateModule">
<summary>
 Members that extend interface, delegate or enum types must be placed in a module separate to the definition of the type. This module must either have the AutoOpen attribute or be opened explicitly by client code to bring the extension members into scope.
 (Originally from FSComp.txt:810)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberUsedInInvalidWay(System.String,System.String,System.String)">
<summary>
 The member &apos;%s&apos; is used in an invalid way. A use of &apos;%s&apos; has been inferred prior to the definition of &apos;%s&apos;, which is an invalid forward reference.
 (Originally from FSComp.txt:820)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberOverridesIllegalInInterface">
<summary>
 Interfaces cannot contain definitions of member overrides
 (Originally from FSComp.txt:721)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberOperatorDefinitionInExtrinsic">
<summary>
 Extension members cannot provide operator overloads.  Consider defining the operator as part of the type definition instead.
 (Originally from FSComp.txt:1111)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberNotPermittedInInterfaceImplementation">
<summary>
 This member is not permitted in an interface implementation
 (Originally from FSComp.txt:762)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberKindPropertyGetSetNotExpected">
<summary>
 SynMemberKind.PropertyGetSet only expected in parse trees
 (Originally from FSComp.txt:496)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberIsNotSufficientlyGeneric">
<summary>
 This member is not sufficiently generic
 (Originally from FSComp.txt:729)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberFoundIsNotAbstractOrVirtual(System.String,System.String)">
<summary>
 The type %s contains the member &apos;%s&apos; but it is not a virtual or abstract method that is available to override or implement.
 (Originally from FSComp.txt:623)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberAndLocalClassBindingHaveSameName(System.String)">
<summary>
 A member and a local class binding both have the name &apos;%s&apos;
 (Originally from FSComp.txt:756)
</summary>
</member>
<member name="M:FSComp.SR.tcMeasureDefinitionsCannotHaveTypeParameters">
<summary>
 Measure definitions cannot have type parameters
 (Originally from FSComp.txt:779)
</summary>
</member>
<member name="M:FSComp.SR.tcMeasureDeclarationsRequireStaticMembersNotConstructors">
<summary>
 Measure declarations may have only static members: constructors are not available
 (Originally from FSComp.txt:755)
</summary>
</member>
<member name="M:FSComp.SR.tcMeasureDeclarationsRequireStaticMembers">
<summary>
 Measure declarations may have only static members
 (Originally from FSComp.txt:751)
</summary>
</member>
<member name="M:FSComp.SR.tcMatchMayNotBeUsedWithQuery">
<summary>
 &apos;match&apos; expressions may not be used in queries
 (Originally from FSComp.txt:1341)
</summary>
</member>
<member name="M:FSComp.SR.tcLookupMayNotBeUsedHere">
<summary>
 This lookup cannot be used here
 (Originally from FSComp.txt:661)
</summary>
</member>
<member name="M:FSComp.SR.tcLocalClassBindingsCannotBeInline">
<summary>
 Local class bindings cannot be marked inline. Consider lifting the definition out of the class or else do not mark it as inline.
 (Originally from FSComp.txt:747)
</summary>
</member>
<member name="M:FSComp.SR.tcLiteralFieldAssignmentWithArg(System.String)">
<summary>
 Cannot assign &apos;%s&apos; to a value marked literal
 (Originally from FSComp.txt:1632)
</summary>
</member>
<member name="M:FSComp.SR.tcLiteralFieldAssignmentNoArg">
<summary>
 Cannot assign a value to another value marked literal
 (Originally from FSComp.txt:1633)
</summary>
</member>
<member name="M:FSComp.SR.tcLiteralDoesNotTakeArguments">
<summary>
 This literal pattern does not take arguments
 (Originally from FSComp.txt:1373)
</summary>
</member>
<member name="M:FSComp.SR.tcLiteralCannotHaveGenericParameters">
<summary>
 Literal values cannot have generic parameters
 (Originally from FSComp.txt:691)
</summary>
</member>
<member name="M:FSComp.SR.tcLiteralCannotBeMutable">
<summary>
 A literal value cannot be marked &apos;mutable&apos;
 (Originally from FSComp.txt:689)
</summary>
</member>
<member name="M:FSComp.SR.tcLiteralCannotBeInline">
<summary>
 A literal value cannot be marked &apos;inline&apos;
 (Originally from FSComp.txt:690)
</summary>
</member>
<member name="M:FSComp.SR.tcLiteralAttributeRequiresConstantValue">
<summary>
 A declaration may only be the [&lt;Literal&gt;] attribute if a constant value is also given, e.g. &apos;val x: int = 1&apos;
 (Originally from FSComp.txt:730)
</summary>
</member>
<member name="M:FSComp.SR.tcLiteralAttributeCannotUseActivePattern">
<summary>
 A [&lt;Literal&gt;] declaration cannot use an active pattern for its identifier
 (Originally from FSComp.txt:1683)
</summary>
</member>
<member name="M:FSComp.SR.tcListThenAdjacentListArgumentReserved">
<summary>
 The syntax &apos;[expr1][expr2]&apos; is now reserved for indexing and is ambiguous when used as an argument. See https://aka.ms/fsharp-index-notation. If calling a function with multiple curried arguments, add a space between them, e.g. &apos;someFunction [expr1] [expr2]&apos;.
 (Originally from FSComp.txt:1639)
</summary>
</member>
<member name="M:FSComp.SR.tcListThenAdjacentListArgumentNeedsAdjustment">
<summary>
 The syntax &apos;[expr1][expr2]&apos; is ambiguous when used as an argument. See https://aka.ms/fsharp-index-notation. If you intend indexing or slicing then you must use &apos;(expr1).[expr2]&apos; in argument position. If calling a function with multiple curried arguments, add a space between them, e.g. &apos;someFunction [expr1] [expr2]&apos;.
 (Originally from FSComp.txt:1642)
</summary>
</member>
<member name="M:FSComp.SR.tcListLiteralMaxSize">
<summary>
 This list expression exceeds the maximum size for list literals. Use an array for larger literals and call Array.ToList.
 (Originally from FSComp.txt:597)
</summary>
</member>
<member name="M:FSComp.SR.tcLetAndDoRequiresImplicitConstructionSequence">
<summary>
 This definition may only be used in a type with a primary constructor. Consider adding arguments to your type definition, e.g. &apos;type X(args) = ...&apos;.
 (Originally from FSComp.txt:816)
</summary>
</member>
<member name="M:FSComp.SR.tcLessGenericBecauseOfAnnotation(System.String,System.String)">
<summary>
 This code is less generic than required by its annotations because the explicit type variable &apos;%s&apos; could not be generalized. It was constrained to be &apos;%s&apos;.
 (Originally from FSComp.txt:516)
</summary>
</member>
<member name="M:FSComp.SR.tcKindOfTypeSpecifiedDoesNotMatchDefinition">
<summary>
 The kind of the type specified by its attributes does not match the kind implied by its definition
 (Originally from FSComp.txt:778)
</summary>
</member>
<member name="M:FSComp.SR.tcJoinMustUseSimplePattern(System.String)">
<summary>
 In queries, &apos;%s&apos; must use a simple pattern
 (Originally from FSComp.txt:1241)
</summary>
</member>
<member name="M:FSComp.SR.tcIsReadOnlyNotStruct">
<summary>
 A type annotated with IsReadOnly must also be a struct. Consider adding the [&lt;Struct&gt;] attribute to the type.
 (Originally from FSComp.txt:1510)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseOfTypeName">
<summary>
 Invalid use of a type name
 (Originally from FSComp.txt:655)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseOfReverseIndex">
<summary>
 Invalid use of reverse index in list expression.
 (Originally from FSComp.txt:1634)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseOfInterfaceType">
<summary>
 Invalid use of an interface type
 (Originally from FSComp.txt:657)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseOfDelegate">
<summary>
 Invalid use of a delegate constructor. Use the syntax &apos;new Type(args)&apos; or just &apos;Type(args)&apos;.
 (Originally from FSComp.txt:658)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseNullAsTrueValue">
<summary>
 The &apos;UseNullAsTrueValue&apos; attribute flag may only be used with union types that have one nullary case and at least one non-nullary case
 (Originally from FSComp.txt:1083)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseBinding">
<summary>
 &apos;use&apos; bindings must be of the form &apos;use &lt;var&gt; = &lt;expr&gt;&apos;
 (Originally from FSComp.txt:707)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseBangBindingNoAndBangs">
<summary>
 use! may not be combined with and!
 (Originally from FSComp.txt:1553)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseBangBinding">
<summary>
 &apos;use!&apos; bindings must be of the form &apos;use! &lt;var&gt; = &lt;expr&gt;&apos;
 (Originally from FSComp.txt:1118)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUnitsOfMeasurePrefix">
<summary>
 Units-of-measure cannot be used as prefix arguments to a type. Rewrite as postfix arguments in angle brackets.
 (Originally from FSComp.txt:561)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidTypeForUnitsOfMeasure">
<summary>
 Units-of-measure are only supported on float, float32, decimal, and integer types.
 (Originally from FSComp.txt:491)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidTypeForLiteralEnumeration">
<summary>
 Literal enumerations must have type int, uint, int16, uint16, int64, uint64, byte, sbyte or char
 (Originally from FSComp.txt:806)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidTypeExtension">
<summary>
 Invalid type extension
 (Originally from FSComp.txt:776)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidTypeArgumentUsage">
<summary>
 Type arguments cannot be specified here
 (Originally from FSComp.txt:576)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidTypeArgumentCount(System.Int32,System.Int32)">
<summary>
 The number of type arguments did not match: &apos;%d&apos; given, &apos;%d&apos; expected. This may be related to a previously reported error.
 (Originally from FSComp.txt:1235)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidStructReturn">
<summary>
 The use of &apos;[&lt;Struct&gt;]&apos; on values, functions and methods is only allowed on partial active pattern definitions
 (Originally from FSComp.txt:1667)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidSignatureForSet">
<summary>
 Invalid signature for set member
 (Originally from FSComp.txt:716)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidSequenceExpressionSyntaxForm">
<summary>
 Invalid record, sequence or computation expression. Sequence expressions should be of the form &apos;seq { ... }&apos;
 (Originally from FSComp.txt:594)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidSelfConstraint">
<summary>
 Invalid constraint. Valid constraint forms include \&quot;&apos;T :&gt; ISomeInterface\&quot; for interface constraints and \&quot;SomeConstrainingType&lt;&apos;T&gt;\&quot; for self-constraints. See https://aka.ms/fsharp-type-constraints.
 (Originally from FSComp.txt:1717)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidResumableConstruct(System.String)">
<summary>
 The construct &apos;%s&apos; may only be used in valid resumable code.
 (Originally from FSComp.txt:1685)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidRelationInJoin(System.String)">
<summary>
 Invalid join relation in &apos;%s&apos;. Expected &apos;expr &lt;op&gt; expr&apos;, where &lt;op&gt; is =, =?, ?= or ?=?.
 (Originally from FSComp.txt:1299)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidRecordConstruction">
<summary>
 Invalid record construction
 (Originally from FSComp.txt:641)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidPropertyType">
<summary>
 This property has an invalid type. Properties taking multiple indexer arguments should have types of the form &apos;ty1 * ty2 -&gt; ty3&apos;. Properties returning functions should have types of the form &apos;(ty1 -&gt; ty2)&apos;.
 (Originally from FSComp.txt:556)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidPattern">
<summary>
 This is not a valid pattern
 (Originally from FSComp.txt:586)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidOptionalAssignmentToPropertyOrField">
<summary>
 Invalid optional assignment to a property or field
 (Originally from FSComp.txt:675)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidOperatorDefinitionRelational(System.String)">
<summary>
 The &apos;%s&apos; operator should not normally be redefined. To define overloaded comparison semantics for a particular type, implement the &apos;System.IComparable&apos; interface in the definition of that type.
 (Originally from FSComp.txt:504)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidOperatorDefinitionEquality(System.String)">
<summary>
 The &apos;%s&apos; operator should not normally be redefined. To define equality semantics for a type, override the &apos;Object.Equals&apos; member in the definition of that type.
 (Originally from FSComp.txt:505)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidOperatorDefinition(System.String)">
<summary>
 The &apos;%s&apos; operator should not normally be redefined. Consider using a different operator name
 (Originally from FSComp.txt:506)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidObjectSequenceOrRecordExpression">
<summary>
 Invalid object, sequence or record expression
 (Originally from FSComp.txt:593)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidObjectExpressionSyntaxForm">
<summary>
 Invalid object expression. Objects without overrides or interfaces should use the expression form &apos;new Type(args)&apos; without braces.
 (Originally from FSComp.txt:592)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidObjectConstructionExpression">
<summary>
 This is not a valid object construction expression. Explicit object constructors must either call an alternate constructor or initialize all fields of the object and specify a call to a super class constructor.
 (Originally from FSComp.txt:551)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidNonPrimitiveLiteralInPatternMatch">
<summary>
 Non-primitive numeric literal constants cannot be used in pattern matches because they can be mapped to multiple different types through the use of a NumericLiteral module. Consider using replacing with a variable, and use &apos;when &lt;variable&gt; = &lt;constant&gt;&apos; at the end of the match clause.
 (Originally from FSComp.txt:575)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidNewConstraint">
<summary>
 &apos;new&apos; constraints must take one argument of type &apos;unit&apos; and return the constructed type
 (Originally from FSComp.txt:555)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidNamespaceModuleTypeUnionName">
<summary>
 Invalid namespace, module, type or union case name
 (Originally from FSComp.txt:737)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidModuleName">
<summary>
 Invalid module name
 (Originally from FSComp.txt:775)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidMixtureOfRecursiveForms">
<summary>
 This recursive binding uses an invalid mixture of recursive forms
 (Originally from FSComp.txt:550)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidMethodNameForRelationalOperator(System.String,System.String)">
<summary>
 The name &apos;(%s)&apos; should not be used as a member name. To define comparison semantics for a type, implement the &apos;System.IComparable&apos; interface. If defining a static member for use from other CLI languages then use the name &apos;%s&apos; instead.
 (Originally from FSComp.txt:500)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidMethodNameForEquality(System.String,System.String)">
<summary>
 The name &apos;(%s)&apos; should not be used as a member name. To define equality semantics for a type, override the &apos;Object.Equals&apos; member. If defining a static member for use from other CLI languages then use the name &apos;%s&apos; instead.
 (Originally from FSComp.txt:501)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidMemberNameFixedTypes(System.String)">
<summary>
 The name &apos;(%s)&apos; should not be used as a member name because it is given a standard definition in the F# library over fixed types
 (Originally from FSComp.txt:503)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidMemberNameCtor">
<summary>
 Invalid member name. Members may not have name &apos;.ctor&apos; or &apos;.cctor&apos;
 (Originally from FSComp.txt:1233)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidMemberName(System.String,System.String)">
<summary>
 The name &apos;(%s)&apos; should not be used as a member name. If defining a static member for use from other CLI languages then use the name &apos;%s&apos; instead.
 (Originally from FSComp.txt:502)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidMemberDeclNameMissingOrHasParen">
<summary>
 Invalid member declaration. The name of the member is missing or has parentheses.
 (Originally from FSComp.txt:1710)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidInlineSpecification">
<summary>
 Invalid inline specification
 (Originally from FSComp.txt:706)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidIndexerExpression">
<summary>
 Incomplete expression or invalid use of indexer syntax
 (Originally from FSComp.txt:606)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidIndexOperatorDefinition(System.String)">
<summary>
 The &apos;%s&apos; operator cannot be redefined. Consider using a different operator name
 (Originally from FSComp.txt:507)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidIndexIntoActivePatternArray">
<summary>
 Internal error. Invalid index into active pattern array
 (Originally from FSComp.txt:579)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidEnumerationLiteral">
<summary>
 This is not a valid value for an enumeration literal
 (Originally from FSComp.txt:740)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidEnumConstraint">
<summary>
 An &apos;enum&apos; constraint must be of the form &apos;enum&lt;type&gt;&apos;
 (Originally from FSComp.txt:554)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidDelegateSpecification">
<summary>
 Delegate specifications must be of the form &apos;typ -&gt; typ&apos;
 (Originally from FSComp.txt:804)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidDeclaration">
<summary>
 Invalid declaration
 (Originally from FSComp.txt:538)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidConstraintTypeSealed">
<summary>
 Invalid constraint: the type used for the constraint is sealed, which means the constraint could only be satisfied by at most one solution
 (Originally from FSComp.txt:553)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidConstraint">
<summary>
 Invalid constraint
 (Originally from FSComp.txt:552)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidConstantExpression">
<summary>
 This is not a valid constant expression
 (Originally from FSComp.txt:692)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidAssignment">
<summary>
 Invalid assignment
 (Originally from FSComp.txt:654)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidArgForParameterizedPattern">
<summary>
 Invalid argument to parameterized pattern label
 (Originally from FSComp.txt:578)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidAlignmentInInterpolatedString">
<summary>
 Invalid alignment in interpolated string
 (Originally from FSComp.txt:1653)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidActivePatternName(System.String)">
<summary>
 &apos;%s&apos; is not a valid method name. Use a &apos;let&apos; binding instead.
 (Originally from FSComp.txt:682)
</summary>
</member>
<member name="M:FSComp.SR.tcIntoNeedsRestOfQuery">
<summary>
 A use of &apos;into&apos; must be followed by the remainder of the computation
 (Originally from FSComp.txt:1305)
</summary>
</member>
<member name="M:FSComp.SR.tcInterpolationMixedWithPercent">
<summary>
 Mismatch in interpolated string. Interpolated strings may not use &apos;%%&apos; format specifiers unless each is given an expression, e.g. &apos;%%d{1+1}&apos;
 (Originally from FSComp.txt:1652)
</summary>
</member>
<member name="M:FSComp.SR.tcInterfacesShouldUseInheritNotInterface">
<summary>
 Interfaces inherited by other interfaces should be declared using &apos;inherit ...&apos; instead of &apos;interface ...&apos;
 (Originally from FSComp.txt:1100)
</summary>
</member>
<member name="M:FSComp.SR.tcInterfaceTypesCannotBeSealed">
<summary>
 Interface types cannot be sealed
 (Originally from FSComp.txt:803)
</summary>
</member>
<member name="M:FSComp.SR.tcInterfaceTypesAndDelegatesCannotContainFields">
<summary>
 Interface types and delegate types cannot contain fields
 (Originally from FSComp.txt:798)
</summary>
</member>
<member name="M:FSComp.SR.tcInstanceMemberRequiresTarget">
<summary>
 This instance member needs a parameter to represent the object being invoked. Make the member static or use the notation &apos;member x.Member(args) = ...&apos;.
 (Originally from FSComp.txt:529)
</summary>
</member>
<member name="M:FSComp.SR.tcInlineIfLambdaUsedOnNonInlineFunctionOrMethod">
<summary>
 The &apos;InlineIfLambda&apos; attribute may only be used on parameters of inlined functions of methods whose type is a function or F# delegate type.
 (Originally from FSComp.txt:1708)
</summary>
</member>
<member name="M:FSComp.SR.tcInitOnlyPropertyCannotBeSet1(System.String)">
<summary>
 Init-only property &apos;%s&apos; cannot be set outside the initialization code. See https://aka.ms/fsharp-assigning-values-to-properties-at-initialization
 (Originally from FSComp.txt:664)
</summary>
</member>
<member name="M:FSComp.SR.tcInheritedTypeIsNotObjectModelType">
<summary>
 The inherited type is not an object model type
 (Originally from FSComp.txt:643)
</summary>
</member>
<member name="M:FSComp.SR.tcInheritIllegalHere">
<summary>
 A inheritance declaration is not permitted here
 (Originally from FSComp.txt:744)
</summary>
</member>
<member name="M:FSComp.SR.tcInheritDeclarationMissingArguments">
<summary>
 This &apos;inherit&apos; declaration specifies the inherited type but no arguments. Consider supplying arguments, e.g. &apos;inherit BaseType(args)&apos;.
 (Originally from FSComp.txt:814)
</summary>
</member>
<member name="M:FSComp.SR.tcInheritConstructionCallNotPartOfImplicitSequence">
<summary>
 This &apos;inherit&apos; declaration has arguments, but is not in a type with a primary constructor. Consider adding arguments to your type definition, e.g. &apos;type X(args) = ...&apos;.
 (Originally from FSComp.txt:815)
</summary>
</member>
<member name="M:FSComp.SR.tcInheritCannotBeUsedOnInterfaceType">
<summary>
 &apos;inherit&apos; cannot be used on interface types. Consider implementing the interface by using &apos;interface ... with ... end&apos; instead.
 (Originally from FSComp.txt:612)
</summary>
</member>
<member name="M:FSComp.SR.tcInfoIfFunctionShadowsUnionCase">
<summary>
 This is a function definition that shadows a union case. If this is what you want, ignore or suppress this warning. If you want it to be a union case deconstruction, add parentheses.
 (Originally from FSComp.txt:1761)
</summary>
</member>
<member name="M:FSComp.SR.tcInferredGenericTypeGivesRiseToInconsistency(System.String,System.String)">
<summary>
 The function or member &apos;%s&apos; is used in a way that requires further type annotations at its definition to ensure consistency of inferred types. The inferred signature is &apos;%s&apos;.
 (Originally from FSComp.txt:1234)
</summary>
</member>
<member name="M:FSComp.SR.tcIndexNotationDeprecated">
<summary>
 The syntax &apos;arr.[idx]&apos; is now revised to &apos;arr[idx]&apos;. Please update your code.
 (Originally from FSComp.txt:1636)
</summary>
</member>
<member name="M:FSComp.SR.tcImplicitMeasureFollowingSlash">
<summary>
 Implicit product of measures following /
 (Originally from FSComp.txt:486)
</summary>
</member>
<member name="M:FSComp.SR.tcImplicitConversionUsedForNonMethodArg(System.String,System.String,System.String)">
<summary>
 This expression uses the implicit conversion &apos;%s&apos; to convert type &apos;%s&apos; to type &apos;%s&apos;. See https://aka.ms/fsharp-implicit-convs. This warning may be disabled using &apos;#nowarn \&quot;3391\&quot;.
 (Originally from FSComp.txt:1678)
</summary>
</member>
<member name="M:FSComp.SR.tcImplicitConversionUsedForMethodArg(System.String,System.String,System.String)">
<summary>
 This expression uses the implicit conversion &apos;%s&apos; to convert type &apos;%s&apos; to type &apos;%s&apos;.
 (Originally from FSComp.txt:1682)
</summary>
</member>
<member name="M:FSComp.SR.tcImplementsIStructuralEquatableExplicitly(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; implements the interface &apos;System.IStructuralEquatable&apos; explicitly. Apply the &apos;CustomEquality&apos; attribute to the type.
 (Originally from FSComp.txt:767)
</summary>
</member>
<member name="M:FSComp.SR.tcImplementsIStructuralComparableExplicitly(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; implements the interface &apos;System.IStructuralComparable&apos; explicitly. Apply the &apos;CustomComparison&apos; attribute to the type.
 (Originally from FSComp.txt:511)
</summary>
</member>
<member name="M:FSComp.SR.tcImplementsIEquatableExplicitly(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; implements the interface &apos;System.IEquatable&lt;_&gt;&apos; explicitly. Apply the &apos;CustomEquality&apos; attribute to the type and provide a consistent implementation of the non-generic override &apos;System.Object.Equals(obj)&apos;.
 (Originally from FSComp.txt:768)
</summary>
</member>
<member name="M:FSComp.SR.tcImplementsIComparableExplicitly(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; implements the interface &apos;System.IComparable&apos; explicitly. You must apply the &apos;CustomComparison&apos; attribute to the type.
 (Originally from FSComp.txt:509)
</summary>
</member>
<member name="M:FSComp.SR.tcImplementsGenericIComparableExplicitly(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; implements the interface &apos;System.IComparable&lt;_&gt;&apos; explicitly. You must apply the &apos;CustomComparison&apos; attribute to the type, and should also provide a consistent implementation of the non-generic interface System.IComparable.
 (Originally from FSComp.txt:510)
</summary>
</member>
<member name="M:FSComp.SR.tcIllegalSyntaxInTypeExpression">
<summary>
 Illegal syntax in type expression
 (Originally from FSComp.txt:568)
</summary>
</member>
<member name="M:FSComp.SR.tcIllegalStructTypeForConstantExpression">
<summary>
 This is not valid literal expression. The [&lt;Literal&gt;] attribute will be ignored.
 (Originally from FSComp.txt:1359)
</summary>
</member>
<member name="M:FSComp.SR.tcIllegalPattern">
<summary>
 Illegal pattern
 (Originally from FSComp.txt:587)
</summary>
</member>
<member name="M:FSComp.SR.tcIllegalFormForExplicitTypeDeclaration">
<summary>
 Explicit type declarations for constructors must be of the form &apos;ty1 * ... * tyN -&gt; resTy&apos;. Parentheses may be required around &apos;resTy&apos;
 (Originally from FSComp.txt:738)
</summary>
</member>
<member name="M:FSComp.SR.tcIllegalByrefsInOpenTypeDeclaration">
<summary>
 Byref types are not allowed in an open type declaration.
 (Originally from FSComp.txt:1527)
</summary>
</member>
<member name="M:FSComp.SR.tcIllegalAttributesForLiteral">
<summary>
 A literal value cannot be given the [&lt;ThreadStatic&gt;] or [&lt;ContextStatic&gt;] attributes
 (Originally from FSComp.txt:688)
</summary>
</member>
<member name="M:FSComp.SR.tcIfThenElseMayNotBeUsedWithinQueries">
<summary>
 An if/then/else expression may not be used within queries. Consider using either an if/then expression, or use a sequence expression instead.
 (Originally from FSComp.txt:1262)
</summary>
</member>
<member name="M:FSComp.SR.tcIDisposableTypeShouldUseNew">
<summary>
 It is recommended that objects supporting the IDisposable interface are created using the syntax &apos;new Type(args)&apos;, rather than &apos;Type(args)&apos; or &apos;Type&apos; as a function value representing the constructor, to indicate that resources may be owned by the generated value
 (Originally from FSComp.txt:615)
</summary>
</member>
<member name="M:FSComp.SR.tcHighPrecedenceFunctionApplicationToListReserved">
<summary>
 The syntax &apos;expr1[expr2]&apos; is now reserved for indexing. See https://aka.ms/fsharp-index-notation. If calling a function, add a space between the function and argument, e.g. &apos;someFunction [expr]&apos;.
 (Originally from FSComp.txt:1637)
</summary>
</member>
<member name="M:FSComp.SR.tcHighPrecedenceFunctionApplicationToListDeprecated">
<summary>
 The syntax &apos;expr1[expr2]&apos; is used for indexing. Consider adding a type annotation to enable indexing, or if calling a function add a space, e.g. &apos;expr1 [expr2]&apos;.
 (Originally from FSComp.txt:1635)
</summary>
</member>
<member name="M:FSComp.SR.tcGlobalsSystemTypeNotFound(System.String)">
<summary>
 The system type &apos;%s&apos; was required but no referenced system DLL contained this type
 (Originally from FSComp.txt:1395)
</summary>
</member>
<member name="M:FSComp.SR.tcGenericTypesCannotHaveStructLayout">
<summary>
 Generic types cannot be given the &apos;StructLayout&apos; attribute
 (Originally from FSComp.txt:786)
</summary>
</member>
<member name="M:FSComp.SR.tcGenericParameterHasBeenConstrained(System.String)">
<summary>
 A generic type parameter has been used in a way that constrains it to always be &apos;%s&apos;
 (Originally from FSComp.txt:518)
</summary>
</member>
<member name="M:FSComp.SR.tcGeneratedTypesShouldBeInternalOrPrivate">
<summary>
 The provided types generated by this use of a type provider may not be used from other F# assemblies and should be marked internal or private. Consider using &apos;type internal TypeName = ...&apos; or &apos;type private TypeName = ...&apos;.
 (Originally from FSComp.txt:1348)
</summary>
</member>
<member name="M:FSComp.SR.tcFunctionRequiresExplicitTypeArguments(System.String)">
<summary>
 The generic function &apos;%s&apos; must be given explicit type argument(s)
 (Originally from FSComp.txt:540)
</summary>
</member>
<member name="M:FSComp.SR.tcFunctionRequiresExplicitLambda(System.Int32)">
<summary>
 This function value is being used to construct a delegate type whose signature includes a byref argument. You must use an explicit lambda expression taking %d arguments.
 (Originally from FSComp.txt:548)
</summary>
</member>
<member name="M:FSComp.SR.tcFormalArgumentIsNotOptional">
<summary>
 The corresponding formal argument is not optional
 (Originally from FSComp.txt:674)
</summary>
</member>
<member name="M:FSComp.SR.tcFixedNotAllowed">
<summary>
 Invalid use of &apos;fixed&apos;. &apos;fixed&apos; may only be used in a declaration of the form &apos;use x = fixed expr&apos; where the expression is one of the following: an array, the address of an array element, a string, a byref, an inref, or a type implementing GetPinnableReference()
 (Originally from FSComp.txt:1390)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldsDoNotDetermineUniqueRecordType">
<summary>
 The field labels and expected type of this record expression or pattern do not uniquely determine a corresponding record type
 (Originally from FSComp.txt:523)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldValIllegalHere">
<summary>
 A field/val declaration is not permitted here
 (Originally from FSComp.txt:743)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldRequiresName">
<summary>
 This field requires a name
 (Originally from FSComp.txt:736)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldRequiresAssignment(System.String,System.String)">
<summary>
 No assignment given for field &apos;%s&apos; of type &apos;%s&apos;
 (Originally from FSComp.txt:619)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldNotLiteralCannotBeUsedInPattern">
<summary>
 This field is not a literal and cannot be used in a pattern
 (Originally from FSComp.txt:584)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldNameIsUsedModeThanOnce(System.String)">
<summary>
 Named field &apos;%s&apos; is used more than once.
 (Originally from FSComp.txt:1356)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldNameConflictsWithGeneratedNameForAnonymousField(System.String)">
<summary>
 Named field &apos;%s&apos; conflicts with autogenerated name for anonymous field.
 (Originally from FSComp.txt:1357)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldIsReadonly">
<summary>
 This field is readonly
 (Originally from FSComp.txt:546)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldIsNotStatic(System.String)">
<summary>
 Field &apos;%s&apos; is not static
 (Originally from FSComp.txt:583)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldIsNotMutable">
<summary>
 This field is not mutable
 (Originally from FSComp.txt:601)
</summary>
</member>
<member name="M:FSComp.SR.tcFSharpCoreRequiresExplicit">
<summary>
 All record, union and struct types in FSharp.Core.dll must be explicitly labelled with &apos;StructuralComparison&apos; or &apos;NoComparison&apos;
 (Originally from FSComp.txt:1060)
</summary>
</member>
<member name="M:FSComp.SR.tcExtraneousFieldsGivenValues">
<summary>
 Extraneous fields have been given values
 (Originally from FSComp.txt:620)
</summary>
</member>
<member name="M:FSComp.SR.tcExpressionWithIfRequiresParenthesis">
<summary>
 This list or array expression includes an element of the form &apos;if ... then ... else&apos;. Parenthesize this expression to indicate it is an individual element of the list or array, to disambiguate this from a list generated using a sequence expression
 (Originally from FSComp.txt:595)
</summary>
</member>
<member name="M:FSComp.SR.tcExpressionRequiresSequence">
<summary>
 This expression form may only be used in sequence and computation expressions
 (Originally from FSComp.txt:591)
</summary>
</member>
<member name="M:FSComp.SR.tcExpressionFormRequiresRecordTypes">
<summary>
 The expression form { expr with ... } may only be used with record types. To build object types use { new Type(...) with ... }
 (Originally from FSComp.txt:642)
</summary>
</member>
<member name="M:FSComp.SR.tcExpressionFormRequiresObjectConstructor">
<summary>
 The expression form &apos;expr then expr&apos; may only be used as part of an explicit object constructor
 (Originally from FSComp.txt:598)
</summary>
</member>
<member name="M:FSComp.SR.tcExpressionCountMisMatch(System.Int32,System.Int32)">
<summary>
 Expected %d expressions, got %d
 (Originally from FSComp.txt:589)
</summary>
</member>
<member name="M:FSComp.SR.tcExprUndelayed">
<summary>
 TcExprUndelayed: delayed
 (Originally from FSComp.txt:590)
</summary>
</member>
<member name="M:FSComp.SR.tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors">
<summary>
 Explicit type specifications cannot be used for exception constructors
 (Originally from FSComp.txt:769)
</summary>
</member>
<member name="M:FSComp.SR.tcExplicitTypeParameterInvalid">
<summary>
 Explicit type parameters may only be used on module or member bindings
 (Originally from FSComp.txt:521)
</summary>
</member>
<member name="M:FSComp.SR.tcExplicitStaticInitializerSyntax">
<summary>
 An explicit static initializer should use the syntax &apos;static new(args) = expr&apos;
 (Originally from FSComp.txt:534)
</summary>
</member>
<member name="M:FSComp.SR.tcExplicitObjectConstructorSyntax">
<summary>
 An explicit object constructor should use the syntax &apos;new(args) = expr&apos;
 (Originally from FSComp.txt:535)
</summary>
</member>
<member name="M:FSComp.SR.tcExpectedUnitOfMeasureNotType">
<summary>
 Expected unit-of-measure, not type
 (Originally from FSComp.txt:560)
</summary>
</member>
<member name="M:FSComp.SR.tcExpectedUnitOfMeasureMarkWithAttribute">
<summary>
 Expected unit-of-measure parameter, not type parameter. Explicit unit-of-measure parameters must be marked with the [&lt;Measure&gt;] attribute.
 (Originally from FSComp.txt:557)
</summary>
</member>
<member name="M:FSComp.SR.tcExpectedTypeParameter">
<summary>
 Expected type parameter, not unit-of-measure parameter
 (Originally from FSComp.txt:558)
</summary>
</member>
<member name="M:FSComp.SR.tcExpectedTypeNotUnitOfMeasure">
<summary>
 Expected type, not unit-of-measure
 (Originally from FSComp.txt:559)
</summary>
</member>
<member name="M:FSComp.SR.tcExpectedInterfaceType">
<summary>
 Expected an interface type
 (Originally from FSComp.txt:635)
</summary>
</member>
<member name="M:FSComp.SR.tcExpectModuleOrNamespaceParent(System.String)">
<summary>
 Expected module or namespace parent %s
 (Originally from FSComp.txt:508)
</summary>
</member>
<member name="M:FSComp.SR.tcExceptionConstructorDoesNotHaveFieldWithGivenName(System.String,System.String)">
<summary>
 The exception &apos;%s&apos; does not have a field named &apos;%s&apos;.
 (Originally from FSComp.txt:1352)
</summary>
</member>
<member name="M:FSComp.SR.tcExceptionAbbreviationsShouldNotHaveArgumentList">
<summary>
 Exception abbreviations should not have argument lists
 (Originally from FSComp.txt:770)
</summary>
</member>
<member name="M:FSComp.SR.tcExceptionAbbreviationsMustReferToValidExceptions">
<summary>
 Exception abbreviations must refer to existing exceptions or F# types deriving from System.Exception
 (Originally from FSComp.txt:772)
</summary>
</member>
<member name="M:FSComp.SR.tcEventIsStatic(System.String)">
<summary>
 Event &apos;%s&apos; is static
 (Originally from FSComp.txt:668)
</summary>
</member>
<member name="M:FSComp.SR.tcEventIsNotStatic(System.String)">
<summary>
 Event &apos;%s&apos; is not static
 (Originally from FSComp.txt:669)
</summary>
</member>
<member name="M:FSComp.SR.tcEnumerationsMayNotHaveMembers">
<summary>
 Enumerations cannot have members
 (Originally from FSComp.txt:750)
</summary>
</member>
<member name="M:FSComp.SR.tcEnumerationsCannotHaveInterfaceDeclaration">
<summary>
 Enumerations cannot have interface declarations
 (Originally from FSComp.txt:758)
</summary>
</member>
<member name="M:FSComp.SR.tcEnumTypeCannotBeEnumerated(System.String)">
<summary>
 The type &apos;%s&apos; is not a valid enumerator type , i.e. does not have a &apos;MoveNext()&apos; method returning a bool, and a &apos;Current&apos; property
 (Originally from FSComp.txt:1120)
</summary>
</member>
<member name="M:FSComp.SR.tcEntryPointAttributeRequiresFunctionInModule">
<summary>
 The &apos;EntryPointAttribute&apos; attribute may only be used on function definitions in modules
 (Originally from FSComp.txt:683)
</summary>
</member>
<member name="M:FSComp.SR.tcEmptyRecordInvalid">
<summary>
 &apos;{ }&apos; is not a valid expression. Records must include at least one field. Empty sequences are specified by using Seq.empty or an empty list &apos;[]&apos;.
 (Originally from FSComp.txt:645)
</summary>
</member>
<member name="M:FSComp.SR.tcEmptyCopyAndUpdateRecordInvalid">
<summary>
 Copy-and-update record expressions must include at least one field.
 (Originally from FSComp.txt:1346)
</summary>
</member>
<member name="M:FSComp.SR.tcEmptyBodyRequiresBuilderZeroMethod">
<summary>
 An empty body may only be used if the computation expression builder defines a &apos;Zero&apos; method.
 (Originally from FSComp.txt:564)
</summary>
</member>
<member name="M:FSComp.SR.tcDuplicateSpecOfInterface">
<summary>
 Duplicate specification of an interface
 (Originally from FSComp.txt:742)
</summary>
</member>
<member name="M:FSComp.SR.tcDowncastFromNullableToWithoutNull(System.String,System.String,System.String)">
<summary>
 Nullness warning: Downcasting from &apos;%s&apos; into &apos;%s&apos; can introduce unexpected null values. Cast to &apos;%s|null&apos; instead or handle the null before downcasting.
 (Originally from FSComp.txt:1540)
</summary>
</member>
<member name="M:FSComp.SR.tcDotLambdaAtNotSupportedExpression">
<summary>
 Shorthand lambda syntax is only supported for atomic expressions, such as method, property, field or indexer on the implied &apos;_&apos; argument. For example: &apos;let f = _.Length&apos;.
 (Originally from FSComp.txt:1763)
</summary>
</member>
<member name="M:FSComp.SR.tcDoesNotAllowExplicitTypeArguments(System.String)">
<summary>
 The method or function &apos;%s&apos; should not be given explicit type argument(s) because it does not declare its type parameters explicitly
 (Originally from FSComp.txt:541)
</summary>
</member>
<member name="M:FSComp.SR.tcDoBangIllegalInSequenceExpression">
<summary>
 &apos;do!&apos; cannot be used within sequence expressions
 (Originally from FSComp.txt:650)
</summary>
</member>
<member name="M:FSComp.SR.tcDllImportStubsCannotBeInlined">
<summary>
 DLLImport stubs cannot be inlined
 (Originally from FSComp.txt:513)
</summary>
</member>
<member name="M:FSComp.SR.tcDllImportNotAllowed">
<summary>
 DLLImport bindings must be static members in a class or function definitions in a module
 (Originally from FSComp.txt:1114)
</summary>
</member>
<member name="M:FSComp.SR.tcDisallowedNullableApplication(System.String,System.String)">
<summary>
 Application of method &apos;%s&apos; attempted to create a nullable type (&apos;T | null) for &apos;%s&apos;. Nullness warnings won&apos;t be reported correctly for such types.
 (Originally from FSComp.txt:1541)
</summary>
</member>
<member name="M:FSComp.SR.tcDelegatesCannotBeCurried">
<summary>
 Delegate specifications must not be curried types. Use &apos;typ * ... * typ -&gt; typ&apos; for multi-argument delegates, and &apos;typ -&gt; (typ -&gt; typ)&apos; for delegates returning function values.
 (Originally from FSComp.txt:805)
</summary>
</member>
<member name="M:FSComp.SR.tcDelegateConstructorMustBePassed">
<summary>
 A delegate constructor must be passed a single function value
 (Originally from FSComp.txt:676)
</summary>
</member>
<member name="M:FSComp.SR.tcDefaultValueAttributeRequiresVal">
<summary>
 The &apos;DefaultValue&apos; attribute may only be used on &apos;val&apos; declarations
 (Originally from FSComp.txt:680)
</summary>
</member>
<member name="M:FSComp.SR.tcDefaultStructConstructorCall">
<summary>
 The default, zero-initializing constructor of a struct type may only be used if all the fields of the struct type admit default initialization
 (Originally from FSComp.txt:543)
</summary>
</member>
<member name="M:FSComp.SR.tcDefaultImplementationForInterfaceHasAlreadyBeenAdded">
<summary>
 A default implementation of this interface has already been added because the explicit implementation of the interface was not specified at the definition of the type
 (Originally from FSComp.txt:761)
</summary>
</member>
<member name="M:FSComp.SR.tcDefaultImplementationAlreadyExists">
<summary>
 This method already has a default implementation
 (Originally from FSComp.txt:712)
</summary>
</member>
<member name="M:FSComp.SR.tcDefaultAmbiguous">
<summary>
 The method implemented by this default is ambiguous
 (Originally from FSComp.txt:713)
</summary>
</member>
<member name="M:FSComp.SR.tcDeclaredTypeParametersForExtensionDoNotMatchOriginal(System.String)">
<summary>
 One or more of the declared type parameters for this type extension have a missing or wrong type constraint not matching the original type constraints on &apos;%s&apos;
 (Originally from FSComp.txt:811)
</summary>
</member>
<member name="M:FSComp.SR.tcDeclarationElementNotPermittedInAugmentation">
<summary>
 This declaration element is not permitted in an augmentation
 (Originally from FSComp.txt:763)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomOperationNotUsedCorrectly2(System.String,System.String)">
<summary>
 &apos;%s&apos; is not used correctly. Usage: %s. This is a custom operation in this query or computation expression.
 (Originally from FSComp.txt:1267)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomOperationNotUsedCorrectly(System.String)">
<summary>
 &apos;%s&apos; is not used correctly. This is a custom operation in this query or computation expression.
 (Originally from FSComp.txt:1266)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings">
<summary>
 A custom operation may not be used in conjunction with a non-value or recursive &apos;let&apos; binding in another part of this computation expression
 (Originally from FSComp.txt:1248)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomOperationMayNotBeUsedHere">
<summary>
 A custom operation may not be used in conjunction with &apos;use&apos;, &apos;try/with&apos;, &apos;try/finally&apos;, &apos;if/then/else&apos; or &apos;match&apos; operators within this computation expression
 (Originally from FSComp.txt:1249)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomOperationMayNotBeOverloaded(System.String)">
<summary>
 The custom operation &apos;%s&apos; refers to a method which is overloaded. The implementations of custom operations may not be overloaded.
 (Originally from FSComp.txt:1250)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomOperationInvalid(System.String)">
<summary>
 The definition of the custom operator &apos;%s&apos; does not use a valid combination of attribute flags
 (Originally from FSComp.txt:1307)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomOperationHasIncorrectArgCount(System.String,System.Int32,System.Int32)">
<summary>
 &apos;%s&apos; is used with an incorrect number of arguments. This is a custom operation in this query or computation expression. Expected %d argument(s), but given %d.
 (Originally from FSComp.txt:1274)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomAttributeMustInvokeConstructor">
<summary>
 A custom attribute must invoke an object constructor
 (Originally from FSComp.txt:703)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomAttributeMustBeReferenceType">
<summary>
 A custom attribute must be a reference type
 (Originally from FSComp.txt:701)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomAttributeArgumentMismatch">
<summary>
 The number of args for a custom attribute does not match the expected number of args for the attribute constructor
 (Originally from FSComp.txt:702)
</summary>
</member>
<member name="M:FSComp.SR.tcCouldNotFindOffsetToStringData">
<summary>
 Could not find method System.Runtime.CompilerServices.OffsetToStringData in references when building &apos;fixed&apos; expression.
 (Originally from FSComp.txt:1391)
</summary>
</member>
<member name="M:FSComp.SR.tcCouldNotFindIDisposable">
<summary>
 Couldn&apos;t find Dispose on IDisposable, or it was overloaded
 (Originally from FSComp.txt:544)
</summary>
</member>
<member name="M:FSComp.SR.tcCopyAndUpdateRecordChangesAllFields(System.String)">
<summary>
 This copy-and-update record expression changes all fields of record type &apos;%s&apos;. Consider using the record construction syntax instead.
 (Originally from FSComp.txt:1738)
</summary>
</member>
<member name="M:FSComp.SR.tcCopyAndUpdateNeedsRecordType">
<summary>
 The input to a copy-and-update expression that creates an anonymous record must be either an anonymous record or a record
 (Originally from FSComp.txt:1522)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorsIllegalInAugmentation">
<summary>
 Constructors are not permitted as extension members - they must be defined as part of the original definition of the type
 (Originally from FSComp.txt:1374)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorsIllegalForThisType">
<summary>
 Constructors cannot be defined for this type
 (Originally from FSComp.txt:725)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorsDisallowedInExceptionAugmentation">
<summary>
 Constructors cannot be specified in exception augmentations
 (Originally from FSComp.txt:723)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorsCannotBeFirstClassValues">
<summary>
 Constructors must be applied to arguments and cannot be used as first-class values. If necessary use an anonymous function &apos;(fun arg1 ... argN -&gt; new Type(arg1,...,argN))&apos;.
 (Originally from FSComp.txt:666)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorRequiresCall(System.String)">
<summary>
 Constructors for the type &apos;%s&apos; must directly or indirectly call its implicit object constructor. Use a call to the implicit object constructor instead of a record expression.
 (Originally from FSComp.txt:617)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorRequiresArguments">
<summary>
 This object constructor requires arguments
 (Originally from FSComp.txt:637)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorForInterfacesDoNotTakeArguments">
<summary>
 Constructor expressions for interfaces do not take arguments
 (Originally from FSComp.txt:636)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorDoesNotHaveFieldWithGivenName(System.String)">
<summary>
 The constructor does not have a field named &apos;%s&apos;.
 (Originally from FSComp.txt:1354)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorCannotHaveTypeParameters">
<summary>
 A constructor cannot have explicit type parameters. Consider using a static construction method instead.
 (Originally from FSComp.txt:528)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructRequiresSequenceOrComputations">
<summary>
 This construct may only be used within sequence or computation expressions
 (Originally from FSComp.txt:604)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructRequiresListArrayOrSequence">
<summary>
 This construct may only be used within list, array and sequence expressions, e.g. expressions of the form &apos;seq { ... }&apos;, &apos;[ ... ]&apos; or &apos;[| ... |]&apos;. These use the syntax &apos;for ... in ... do ... yield...&apos; to generate elements
 (Originally from FSComp.txt:602)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructRequiresComputationExpressions">
<summary>
 This construct may only be used within computation expressions. To return a value from an ordinary function simply write the expression without &apos;return&apos;.
 (Originally from FSComp.txt:603)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructRequiresComputationExpression">
<summary>
 This construct may only be used within computation expressions
 (Originally from FSComp.txt:605)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructIsAmbiguousInSequenceExpression">
<summary>
 This construct is ambiguous as part of a sequence expression. Nested expressions may be written using &apos;let _ = (...)&apos; and nested sequences using &apos;yield! seq {... }&apos;.
 (Originally from FSComp.txt:649)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructIsAmbiguousInComputationExpression">
<summary>
 This construct is ambiguous as part of a computation expression. Nested expressions may be written using &apos;let _ = (...)&apos; and nested computations using &apos;let! res = builder { ... }&apos;.
 (Originally from FSComp.txt:648)
</summary>
</member>
<member name="M:FSComp.SR.tcConstrainedTypeVariableCannotBeGeneralized">
<summary>
 One or more of the explicit class or function type variables for this binding could not be generalized, because they were constrained to other types
 (Originally from FSComp.txt:517)
</summary>
</member>
<member name="M:FSComp.SR.tcConditionalAttributeUsage">
<summary>
 Attribute &apos;System.Diagnostics.ConditionalAttribute&apos; is only valid on methods or attribute classes
 (Originally from FSComp.txt:1110)
</summary>
</member>
<member name="M:FSComp.SR.tcConditionalAttributeRequiresMembers">
<summary>
 The &apos;ConditionalAttribute&apos; attribute may only be used on members
 (Originally from FSComp.txt:681)
</summary>
</member>
<member name="M:FSComp.SR.tcConcreteMembersIllegalInInterface">
<summary>
 Interfaces cannot contain definitions of concrete instance members. You may need to define a constructor on your type to indicate that the type is a class.
 (Originally from FSComp.txt:722)
</summary>
</member>
<member name="M:FSComp.SR.tcCompiledNameAttributeMisused">
<summary>
 The &apos;CompiledName&apos; attribute cannot be used with this language element
 (Originally from FSComp.txt:610)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotPartiallyApplyExtensionMethodForByref(System.String)">
<summary>
 Cannot partially apply the extension method &apos;%s&apos; because the first parameter is a byref type.
 (Originally from FSComp.txt:1518)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotOverrideSealedMethod(System.String)">
<summary>
 Cannot override inherited member &apos;%s&apos; because it is sealed
 (Originally from FSComp.txt:1236)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotInheritFromVariableType">
<summary>
 Cannot inherit from a variable type
 (Originally from FSComp.txt:608)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotInheritFromSealedType">
<summary>
 Cannot inherit a sealed type
 (Originally from FSComp.txt:800)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotInheritFromInterfaceType">
<summary>
 Cannot inherit from interface type. Use interface ... with instead.
 (Originally from FSComp.txt:801)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotInheritFromErasedType">
<summary>
 Cannot inherit from erased provided type
 (Originally from FSComp.txt:1231)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotCreateExtensionOfSealedType">
<summary>
 Cannot create an extension of a sealed type
 (Originally from FSComp.txt:629)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotCallExtensionMethodInrefToByref(System.String)">
<summary>
 Cannot call the byref extension method &apos;%s. &apos;this&apos; parameter requires the value to be mutable or a non-readonly byref type.
 (Originally from FSComp.txt:1516)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotCallAbstractBaseMember(System.String)">
<summary>
 Cannot call an abstract base member: &apos;%s&apos;
 (Originally from FSComp.txt:1087)
</summary>
</member>
<member name="M:FSComp.SR.tcCallerInfoWrongType(System.String,System.String,System.String)">
<summary>
 &apos;%s&apos; must be applied to an argument of type &apos;%s&apos;, but has been applied to an argument of type &apos;%s&apos;
 (Originally from FSComp.txt:1129)
</summary>
</member>
<member name="M:FSComp.SR.tcCallerInfoNotOptional(System.String)">
<summary>
 &apos;%s&apos; can only be applied to optional arguments
 (Originally from FSComp.txt:1130)
</summary>
</member>
<member name="M:FSComp.SR.tcByrefsMayNotHaveTypeExtensions">
<summary>
 Byref types are not allowed to have optional type extensions.
 (Originally from FSComp.txt:1517)
</summary>
</member>
<member name="M:FSComp.SR.tcByrefReturnImplicitlyDereferenced">
<summary>
 A byref pointer returned by a function or method is implicitly dereferenced as of F# 4.5. To acquire the return value as a pointer, use the address-of operator, e.g. &apos;&amp;f(x)&apos; or &apos;&amp;obj.Method(arg1, arg2)&apos;.
 (Originally from FSComp.txt:1505)
</summary>
</member>
<member name="M:FSComp.SR.tcByRefLikeNotStruct">
<summary>
 A type annotated with IsByRefLike must also be a struct. Consider adding the [&lt;Struct&gt;] attribute to the type.
 (Originally from FSComp.txt:1506)
</summary>
</member>
<member name="M:FSComp.SR.tcBuiltInImplicitConversionUsed(System.String,System.String)">
<summary>
 This expression uses a built-in implicit conversion to convert type &apos;%s&apos; to type &apos;%s&apos;. See https://aka.ms/fsharp-implicit-convs.
 (Originally from FSComp.txt:1670)
</summary>
</member>
<member name="M:FSComp.SR.tcBindingCannotBeUseAndRec">
<summary>
 A binding cannot be marked both &apos;use&apos; and &apos;rec&apos;
 (Originally from FSComp.txt:677)
</summary>
</member>
<member name="M:FSComp.SR.tcBindMayNotBeUsedInQueries">
<summary>
 &apos;let!&apos;, &apos;use!&apos; and &apos;do!&apos; expressions may not be used in queries
 (Originally from FSComp.txt:1318)
</summary>
</member>
<member name="M:FSComp.SR.tcBinaryOperatorRequiresVariable(System.String,System.String)">
<summary>
 &apos;%s&apos; must be followed by a variable name. Usage: %s.
 (Originally from FSComp.txt:1271)
</summary>
</member>
<member name="M:FSComp.SR.tcBinaryOperatorRequiresBody(System.String,System.String)">
<summary>
 &apos;%s&apos; must come after a &apos;for&apos; selection clause and be followed by the rest of the query. Syntax: ... %s ...
 (Originally from FSComp.txt:1273)
</summary>
</member>
<member name="M:FSComp.SR.tcAutoPropertyRequiresImplicitConstructionSequence">
<summary>
 &apos;member val&apos; definitions are only permitted in types with a primary constructor. Consider adding arguments to your type definition, e.g. &apos;type X(args) = ...&apos;.
 (Originally from FSComp.txt:1309)
</summary>
</member>
<member name="M:FSComp.SR.tcAugmentationsCannotHaveAttributes">
<summary>
 Attributes cannot be applied to type extensions.
 (Originally from FSComp.txt:1523)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributesOfTypeSpecifyMultipleKindsForType">
<summary>
 The attributes of this type specify multiple kinds for the type
 (Originally from FSComp.txt:777)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributesInvalidInPatterns">
<summary>
 Attributes are not allowed within patterns
 (Originally from FSComp.txt:539)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributesAreNotPermittedOnLetBindings">
<summary>
 Attributes are not permitted on &apos;let&apos; bindings in expressions
 (Originally from FSComp.txt:679)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributeIsNotValidForLanguageElementUseDo">
<summary>
 This attribute is not valid for use on this language element. Assembly attributes should be attached to a &apos;do ()&apos; declaration, if necessary within an F# module.
 (Originally from FSComp.txt:696)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributeIsNotValidForLanguageElement">
<summary>
 This attribute is not valid for use on this language element
 (Originally from FSComp.txt:697)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributeExpressionsMustBeConstructorCalls">
<summary>
 Attribute expressions must be calls to object constructors
 (Originally from FSComp.txt:704)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributeAutoOpenWasIgnored(System.String,System.String)">
<summary>
 The attribute &apos;AutoOpen(\&quot;%s\&quot;)&apos; in the assembly &apos;%s&apos; did not refer to a valid module or namespace in that assembly and has been ignored
 (Originally from FSComp.txt:821)
</summary>
</member>
<member name="M:FSComp.SR.tcAttribArgsDiffer(System.String)">
<summary>
 The attribute &apos;%s&apos; appears in both the implementation and the signature, but the attribute arguments differ. Only the attribute from the signature will be included in the compiled code.
 (Originally from FSComp.txt:1086)
</summary>
</member>
<member name="M:FSComp.SR.tcAtLeastOneOverrideIsInvalid">
<summary>
 At least one override did not correctly implement its corresponding abstract member
 (Originally from FSComp.txt:639)
</summary>
</member>
<member name="M:FSComp.SR.tcArgumentArityMismatchOneOverload(System.String,System.Int32,System.Int32,System.String,System.String)">
<summary>
 The member &apos;%s&apos; does not accept the correct number of arguments. One overload accepts %d arguments, but %d were given. The required signature is &apos;%s&apos;.%s
 (Originally from FSComp.txt:625)
</summary>
</member>
<member name="M:FSComp.SR.tcArgumentArityMismatch(System.String,System.Int32,System.Int32,System.String,System.String)">
<summary>
 The member &apos;%s&apos; does not accept the correct number of arguments. %d argument(s) are expected, but %d were given. The required signature is &apos;%s&apos;.%s
 (Originally from FSComp.txt:624)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonymousUnitsOfMeasureCannotBeNested">
<summary>
 Anonymous unit-of-measure cannot be nested inside another unit-of-measure expression
 (Originally from FSComp.txt:569)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonymousTypeInvalidInDeclaration">
<summary>
 Anonymous type variables are not permitted in this declaration
 (Originally from FSComp.txt:570)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonRecdTypeDuplicateFieldId(System.String)">
<summary>
 The field &apos;%s&apos; appears multiple times in this anonymous record type.
 (Originally from FSComp.txt:1712)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonRecdSingleFieldNameSuperset(System.String)">
<summary>
 This anonymous record has an extra field. Remove field &apos;%s&apos;.
 (Originally from FSComp.txt:1404)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonRecdSingleFieldNameSubset(System.String)">
<summary>
 This anonymous record is missing field &apos;%s&apos;.
 (Originally from FSComp.txt:1402)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonRecdSingleFieldNameSingleDifferent(System.String,System.String)">
<summary>
 This anonymous record should have field &apos;%s&apos; but here has field &apos;%s&apos;.
 (Originally from FSComp.txt:1406)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonRecdSingleFieldNameMultipleDifferent(System.String,System.String)">
<summary>
 This anonymous record should have field &apos;%s&apos; but here has fields %s.
 (Originally from FSComp.txt:1407)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonRecdMultipleFieldsNameSuperset(System.String)">
<summary>
 This anonymous record has extra fields. Remove fields %s.
 (Originally from FSComp.txt:1405)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonRecdMultipleFieldsNameSubset(System.String)">
<summary>
 This anonymous record is missing fields %s.
 (Originally from FSComp.txt:1403)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonRecdMultipleFieldNameSingleDifferent(System.String,System.String)">
<summary>
 This anonymous record should have fields %s; but here has field &apos;%s&apos;.
 (Originally from FSComp.txt:1408)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonRecdMultipleFieldNameMultipleDifferent(System.String,System.String)">
<summary>
 This anonymous record should have fields %s; but here has fields %s.
 (Originally from FSComp.txt:1409)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonRecdInvalid">
<summary>
 Invalid Anonymous Record type declaration.
 (Originally from FSComp.txt:1399)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonRecdFieldNameMismatch(System.String,System.String)">
<summary>
 This anonymous record does not exactly match the expected shape. Add the missing fields %s and remove the extra fields %s.
 (Originally from FSComp.txt:1401)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonRecdDuplicateFieldId(System.String)">
<summary>
 The field &apos;%s&apos; appears multiple times in this record expression.
 (Originally from FSComp.txt:1711)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonRecdCcuMismatch(System.String,System.String)">
<summary>
 Two anonymous record types are from different assemblies &apos;%s&apos; and &apos;%s&apos;
 (Originally from FSComp.txt:1400)
</summary>
</member>
<member name="M:FSComp.SR.tcAndBangNotSupported">
<summary>
 This feature is not supported in this version of F#. You may need to add /langversion:preview to use this feature.
 (Originally from FSComp.txt:1552)
</summary>
</member>
<member name="M:FSComp.SR.tcAmbiguousImplicitConversion(System.String,System.String,System.String)">
<summary>
 This expression has type &apos;%s&apos; and is only made compatible with type &apos;%s&apos; through an ambiguous implicit conversion. Consider using an explicit call to &apos;op_Implicit&apos;. The applicable implicit conversions are:%s
 (Originally from FSComp.txt:1668)
</summary>
</member>
<member name="M:FSComp.SR.tcAmbiguousDiscardDotLambda">
<summary>
 The meaning of _ is ambiguous here. It cannot be used for a discarded variable and a function shorthand in the same scope.
 (Originally from FSComp.txt:1750)
</summary>
</member>
<member name="M:FSComp.SR.tcAllowNullTypesMayOnlyInheritFromAllowNullTypes">
<summary>
 Types with the &apos;AllowNullLiteral&apos; attribute may only inherit from or implement types which also allow the use of the null literal
 (Originally from FSComp.txt:785)
</summary>
</member>
<member name="M:FSComp.SR.tcAllImplementedInterfacesShouldBeDeclared">
<summary>
 All implemented interfaces should be declared on the initial declaration of the type
 (Originally from FSComp.txt:760)
</summary>
</member>
<member name="M:FSComp.SR.tcActivePatternsDoNotHaveFields">
<summary>
 Active patterns do not have fields. This syntax is invalid.
 (Originally from FSComp.txt:1353)
</summary>
</member>
<member name="M:FSComp.SR.tcActivePatternArgsCountNotMatchOnlyPat(System.String)">
<summary>
 This active pattern expects exactly one pattern argument, e.g., &apos;%s pat&apos;.
 (Originally from FSComp.txt:1777)
</summary>
</member>
<member name="M:FSComp.SR.tcActivePatternArgsCountNotMatchNoArgsNoPat(System.String,System.String)">
<summary>
 This active pattern does not expect any arguments, i.e., it should be used like &apos;%s&apos; instead of &apos;%s x&apos;.
 (Originally from FSComp.txt:1776)
</summary>
</member>
<member name="M:FSComp.SR.tcActivePatternArgsCountNotMatchArgsAndPat(System.Int32,System.String,System.String)">
<summary>
 This active pattern expects %d expression argument(s) and a pattern argument, e.g., &apos;%s%s pat&apos;.
 (Originally from FSComp.txt:1779)
</summary>
</member>
<member name="M:FSComp.SR.tcActivePatternArgsCountNotMatchArgs(System.Int32,System.String,System.String)">
<summary>
 This active pattern expects %d expression argument(s), e.g., &apos;%s%s&apos;.
 (Originally from FSComp.txt:1778)
</summary>
</member>
<member name="M:FSComp.SR.tcAccessModifiersNotAllowedInSRTPConstraint">
<summary>
 Access modifiers cannot be applied to an SRTP constraint.
 (Originally from FSComp.txt:1786)
</summary>
</member>
<member name="M:FSComp.SR.tcAbstractTypeCannotBeInstantiated">
<summary>
 Instances of this type cannot be created since it has been marked abstract or not all methods have been given implementations. Consider using an object expression &apos;{ new ... with ... }&apos; instead.
 (Originally from FSComp.txt:614)
</summary>
</member>
<member name="M:FSComp.SR.tcAbstractPropertyMissingGetOrSet(System.String)">
<summary>
 This property overrides or implements an abstract property but the abstract property doesn&apos;t have a corresponding %s
 (Originally from FSComp.txt:715)
</summary>
</member>
<member name="M:FSComp.SR.tcAbstractMembersIllegalInAugmentation">
<summary>
 Abstract members are not permitted in an augmentation - they must be defined as part of the type itself
 (Originally from FSComp.txt:708)
</summary>
</member>
<member name="M:FSComp.SR.tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor">
<summary>
 Abbreviations for Common IL exception types must have a matching object constructor
 (Originally from FSComp.txt:773)
</summary>
</member>
<member name="M:FSComp.SR.tcAbbreviationsFordotNetExceptionsCannotTakeArguments">
<summary>
 Abbreviations for Common IL exceptions cannot take arguments
 (Originally from FSComp.txt:771)
</summary>
</member>
<member name="M:FSComp.SR.tcAbbreviatedTypesCannotBeSealed">
<summary>
 Abbreviated types cannot be given the &apos;Sealed&apos; attribute
 (Originally from FSComp.txt:799)
</summary>
</member>
<member name="M:FSComp.SR.tastopsMaxArrayThirtyTwo(System.Int32)">
<summary>
 F# supports array ranks between 1 and 32. The value %d is not allowed.
 (Originally from FSComp.txt:1313)
</summary>
</member>
<member name="M:FSComp.SR.tastValueMustBeMutable">
<summary>
 A value must be mutable in order to mutate the contents or take the address of a value type, e.g. &apos;let mutable x = ...&apos;
 (Originally from FSComp.txt:94)
</summary>
</member>
<member name="M:FSComp.SR.tastValueMustBeLocal">
<summary>
 A value defined in a module must be mutable in order to take its address, e.g. &apos;let mutable x = ...&apos;
 (Originally from FSComp.txt:1509)
</summary>
</member>
<member name="M:FSComp.SR.tastValueHasBeenCopied">
<summary>
 The value has been copied to ensure the original is not mutated by this operation or because the copy is implicit when returning a struct from a member and another member is then accessed
 (Originally from FSComp.txt:96)
</summary>
</member>
<member name="M:FSComp.SR.tastValueDoesNotHaveSetterType">
<summary>
 This value does not have a valid property setter type
 (Originally from FSComp.txt:90)
</summary>
</member>
<member name="M:FSComp.SR.tastUnexpectedDecodeOfInternalsVisibleToAttribute">
<summary>
 Unexpected decode of InternalsVisibleToAttribute
 (Originally from FSComp.txt:101)
</summary>
</member>
<member name="M:FSComp.SR.tastUnexpectedDecodeOfInterfaceDataVersionAttribute">
<summary>
 Unexpected decode of InterfaceDataVersionAttribute
 (Originally from FSComp.txt:102)
</summary>
</member>
<member name="M:FSComp.SR.tastUnexpectedDecodeOfAutoOpenAttribute">
<summary>
 Unexpected decode of AutoOpenAttribute
 (Originally from FSComp.txt:100)
</summary>
</member>
<member name="M:FSComp.SR.tastUnexpectedByRef">
<summary>
 Unexpected use of a byref-typed variable
 (Originally from FSComp.txt:93)
</summary>
</member>
<member name="M:FSComp.SR.tastUndefinedItemRefVal(System.String,System.String,System.String)">
<summary>
 The module/namespace &apos;%s&apos; from compilation unit &apos;%s&apos; did not contain the val &apos;%s&apos;
 (Originally from FSComp.txt:1081)
</summary>
</member>
<member name="M:FSComp.SR.tastUndefinedItemRefModuleNamespaceType(System.String,System.String,System.String)">
<summary>
 The module/namespace &apos;%s&apos; from compilation unit &apos;%s&apos; did not contain the namespace, module or type &apos;%s&apos;
 (Originally from FSComp.txt:1082)
</summary>
</member>
<member name="M:FSComp.SR.tastUndefinedItemRefModuleNamespace(System.String,System.String,System.String)">
<summary>
 The module/namespace &apos;%s&apos; from compilation unit &apos;%s&apos; did not contain the module/namespace &apos;%s&apos;
 (Originally from FSComp.txt:1080)
</summary>
</member>
<member name="M:FSComp.SR.tastTypeOrModuleNotConcrete(System.String)">
<summary>
 The type/module &apos;%s&apos; is not a concrete module or type
 (Originally from FSComp.txt:82)
</summary>
</member>
<member name="M:FSComp.SR.tastTypeHasAssemblyCodeRepresentation(System.String)">
<summary>
 The type &apos;%s&apos; has an inline assembly code representation
 (Originally from FSComp.txt:83)
</summary>
</member>
<member name="M:FSComp.SR.tastTwoModulesWithSameNameInAssembly(System.String)">
<summary>
 Two modules named &apos;%s&apos; occur in two parts of this assembly
 (Originally from FSComp.txt:86)
</summary>
</member>
<member name="M:FSComp.SR.tastRecursiveValuesMayNotBeInConstructionOfTuple">
<summary>
 Recursively defined values cannot appear directly as part of the construction of a tuple value within a recursive binding
 (Originally from FSComp.txt:97)
</summary>
</member>
<member name="M:FSComp.SR.tastRecursiveValuesMayNotBeAssignedToNonMutableField(System.String,System.String)">
<summary>
 Recursive values cannot be directly assigned to the non-mutable field &apos;%s&apos; of the type &apos;%s&apos; within a recursive binding. Consider using a mutable field instead.
 (Originally from FSComp.txt:99)
</summary>
</member>
<member name="M:FSComp.SR.tastRecursiveValuesMayNotAppearInConstructionOfType(System.String)">
<summary>
 Recursive values cannot appear directly as a construction of the type &apos;%s&apos; within a recursive binding. This feature has been removed from the F# language. Consider using a record instead.
 (Originally from FSComp.txt:98)
</summary>
</member>
<member name="M:FSComp.SR.tastNotAConstantExpression">
<summary>
 This is not a valid constant expression or custom attribute value
 (Originally from FSComp.txt:104)
</summary>
</member>
<member name="M:FSComp.SR.tastNamespaceAndModuleWithSameNameInAssembly(System.String)">
<summary>
 A namespace and a module named &apos;%s&apos; both occur in two parts of this assembly
 (Originally from FSComp.txt:85)
</summary>
</member>
<member name="M:FSComp.SR.tastInvalidMutationOfConstant">
<summary>
 Invalid mutation of a constant expression. Consider copying the expression to a mutable local, e.g. &apos;let mutable x = ...&apos;.
 (Originally from FSComp.txt:95)
</summary>
</member>
<member name="M:FSComp.SR.tastInvalidMemberSignature">
<summary>
 Invalid member signature encountered because of an earlier error
 (Originally from FSComp.txt:89)
</summary>
</member>
<member name="M:FSComp.SR.tastInvalidFormForPropertySetter">
<summary>
 Invalid form for a property setter. At least one argument is required.
 (Originally from FSComp.txt:92)
</summary>
</member>
<member name="M:FSComp.SR.tastInvalidFormForPropertyGetter">
<summary>
 Invalid form for a property getter. At least one &apos;()&apos; argument is required when using the explicit syntax.
 (Originally from FSComp.txt:91)
</summary>
</member>
<member name="M:FSComp.SR.tastInvalidAddressOfMutableAcrossAssemblyBoundary">
<summary>
 This operation accesses a mutable top-level value defined in another assembly in an unsupported way. The value cannot be accessed through its address. Consider copying the expression to a mutable local, e.g. &apos;let mutable x = ...&apos;, and if necessary assigning the value back after the completion of the operation
 (Originally from FSComp.txt:1076)
</summary>
</member>
<member name="M:FSComp.SR.tastDuplicateTypeDefinitionInAssembly(System.String,System.String)">
<summary>
 Two type definitions named &apos;%s&apos; occur in namespace &apos;%s&apos; in two parts of this assembly
 (Originally from FSComp.txt:87)
</summary>
</member>
<member name="M:FSComp.SR.tastConstantExpressionOverflow">
<summary>
 This literal expression or attribute argument results in an arithmetic overflow.
 (Originally from FSComp.txt:1358)
</summary>
</member>
<member name="M:FSComp.SR.tastConflictingModuleAndTypeDefinitionInAssembly(System.String,System.String)">
<summary>
 A module and a type definition named &apos;%s&apos; occur in namespace &apos;%s&apos; in two parts of this assembly
 (Originally from FSComp.txt:88)
</summary>
</member>
<member name="M:FSComp.SR.tastCantTakeAddressOfExpression">
<summary>
 Cannot take the address of the value returned from the expression. Assign the returned value to a let-bound value before taking the address.
 (Originally from FSComp.txt:1515)
</summary>
</member>
<member name="M:FSComp.SR.tastActivePatternsLimitedToSeven">
<summary>
 Active patterns cannot return more than 7 possibilities
 (Originally from FSComp.txt:103)
</summary>
</member>
<member name="M:FSComp.SR.suggestedName">
<summary>
 (Suggested name)
 (Originally from FSComp.txt:970)
</summary>
</member>
<member name="M:FSComp.SR.structOrClassFieldIsNotAccessible(System.String)">
<summary>
 The struct or class field &apos;%s&apos; is not accessible from this code location
 (Originally from FSComp.txt:979)
</summary>
</member>
<member name="M:FSComp.SR.srcFileTooLarge">
<summary>
 Source file is too large to embed in a portable PDB
 (Originally from FSComp.txt:874)
</summary>
</member>
<member name="P:FSComp.SR.SwallowResourceText(System.Boolean)">
<summary>
 If set to true, then all error messages will just return the filled &apos;holes&apos; delimited by &apos;,,,&apos;s - this is for language-neutral testing (e.g. localization-invariant baselines).
</summary>
</member>
<member name="M:FSComp.SR.scriptSdkNotDeterminedUnexpected(System.String)">
<summary>
 The .NET SDK for this script could not be determined. If the script is in a directory using a &apos;global.json&apos; then ensure the relevant .NET SDK is installed. Unexpected error &apos;%s&apos;.
 (Originally from FSComp.txt:1665)
</summary>
</member>
<member name="M:FSComp.SR.scriptSdkNotDeterminedNoHost">
<summary>
 The .NET SDK for this script could not be determined. dotnet.exe could not be found ensure a .NET SDK is installed.
 (Originally from FSComp.txt:1666)
</summary>
</member>
<member name="M:FSComp.SR.scriptSdkNotDetermined(System.String,System.String,System.String,System.Int32)">
<summary>
 The .NET SDK for this script could not be determined. If the script is in a directory using a &apos;global.json&apos; then ensure the relevant .NET SDK is installed. The output from &apos;%s --version&apos; in the directory &apos;%s&apos; was: &apos;%s&apos; and the exit code was &apos;%d&apos;.
 (Originally from FSComp.txt:1664)
</summary>
</member>
<member name="M:FSComp.SR.returnUsedInsteadOfReturnBang">
<summary>
 Consider using &apos;return!&apos; instead of &apos;return&apos;.
 (Originally from FSComp.txt:37)
</summary>
</member>
<member name="M:FSComp.SR.reprStateMachineNotCompilableNoAlternative(System.String)">
<summary>
 This state machine is not statically compilable and no alternative is available. %s. Use an &apos;if __useResumableCode then &lt;state-machine&gt; else &lt;alternative&gt;&apos; to give an alternative.
 (Originally from FSComp.txt:1693)
</summary>
</member>
<member name="M:FSComp.SR.reprStateMachineNotCompilable(System.String)">
<summary>
 This state machine is not statically compilable. %s. An alternative dynamic implementation will be used, which may be slower. Consider adjusting your code to ensure this state machine is statically compilable, or else suppress this warning.
 (Originally from FSComp.txt:1692)
</summary>
</member>
<member name="M:FSComp.SR.reprStateMachineInvalidForm">
<summary>
 The state machine has an unexpected form
 (Originally from FSComp.txt:1705)
</summary>
</member>
<member name="M:FSComp.SR.reprResumableCodeValueHasNoDefinition(System.String)">
<summary>
 The resumable code value(s) &apos;%s&apos; does not have a definition
 (Originally from FSComp.txt:1703)
</summary>
</member>
<member name="M:FSComp.SR.reprResumableCodeInvokeNotReduced(System.String)">
<summary>
 A resumable code invocation at &apos;%s&apos; could not be reduced
 (Originally from FSComp.txt:1696)
</summary>
</member>
<member name="M:FSComp.SR.reprResumableCodeDefinitionWasGeneric">
<summary>
 A delegate or function producing resumable code in a state machine has type parameters
 (Originally from FSComp.txt:1704)
</summary>
</member>
<member name="M:FSComp.SR.reprResumableCodeContainsResumptionInTryFinally">
<summary>
 A try/finally may not contain resumption points
 (Originally from FSComp.txt:1700)
</summary>
</member>
<member name="M:FSComp.SR.reprResumableCodeContainsResumptionInHandlerOrFilter">
<summary>
 The &apos;with&apos; block of a try/with may not contain resumption points
 (Originally from FSComp.txt:1701)
</summary>
</member>
<member name="M:FSComp.SR.reprResumableCodeContainsLetRec">
<summary>
 A &apos;let rec&apos; occurred in the resumable code specification
 (Originally from FSComp.txt:1697)
</summary>
</member>
<member name="M:FSComp.SR.reprResumableCodeContainsFastIntegerForLoop">
<summary>
 A fast integer for loop may not contain resumption points
 (Originally from FSComp.txt:1702)
</summary>
</member>
<member name="M:FSComp.SR.reprResumableCodeContainsDynamicResumeAtInBody">
<summary>
 A target label for __resumeAt was not statically determined. A __resumeAt with a non-static target label may only appear at the start of a resumable code method
 (Originally from FSComp.txt:1699)
</summary>
</member>
<member name="M:FSComp.SR.reprResumableCodeContainsConstrainedGenericLet">
<summary>
 A constrained generic construct occurred in the resumable code specification
 (Originally from FSComp.txt:1698)
</summary>
</member>
<member name="M:FSComp.SR.replaceWithSuggestion(System.String)">
<summary>
 Replace with &apos;%s&apos;
 (Originally from FSComp.txt:20)
</summary>
</member>
<member name="M:FSComp.SR.recursiveClassHierarchy(System.String)">
<summary>
 Recursive class hierarchy in type &apos;%s&apos;
 (Originally from FSComp.txt:971)
</summary>
</member>
<member name="M:FSComp.SR.readOnlyAttributeOnStructWithMutableField">
<summary>
 A ReadOnly attribute has been applied to a struct type with a mutable field.
 (Originally from FSComp.txt:1504)
</summary>
</member>
<member name="M:FSComp.SR.ppparsUnexpectedToken(System.String)">
<summary>
 Unexpected token &apos;%s&apos; in preprocessor expression
 (Originally from FSComp.txt:1365)
</summary>
</member>
<member name="M:FSComp.SR.ppparsMissingToken(System.String)">
<summary>
 Missing token &apos;%s&apos; in preprocessor expression
 (Originally from FSComp.txt:1367)
</summary>
</member>
<member name="M:FSComp.SR.ppparsIncompleteExpression">
<summary>
 Incomplete preprocessor expression
 (Originally from FSComp.txt:1366)
</summary>
</member>
<member name="M:FSComp.SR.pplexUnexpectedChar(System.String)">
<summary>
 Unexpected character &apos;%s&apos; in preprocessor expression
 (Originally from FSComp.txt:1364)
</summary>
</member>
<member name="M:FSComp.SR.pplexExpectedSingleLineComment">
<summary>
 Expected single line comment or end of line
 (Originally from FSComp.txt:1056)
</summary>
</member>
<member name="M:FSComp.SR.poundiNotSupportedByRegisteredDependencyManagers">
<summary>
 #i is not supported by the registered PackageManagers
 (Originally from FSComp.txt:1550)
</summary>
</member>
<member name="M:FSComp.SR.pickleUnexpectedNonZero(System.String)">
<summary>
 An error occurred while reading the F# metadata of assembly &apos;%s&apos;. A reserved construct was utilized. You may need to upgrade your F# compiler or use an earlier version of the assembly that doesn&apos;t make use of a specific construct.
 (Originally from FSComp.txt:1498)
</summary>
</member>
<member name="M:FSComp.SR.pickleMissingDefinition(System.Int32,System.String,System.String)">
<summary>
 An error occurred while reading the F# metadata node at position %d in table &apos;%s&apos; of assembly &apos;%s&apos;. The node had no matching declaration. Please report this warning. You may need to recompile the F# assembly you are using.
 (Originally from FSComp.txt:1368)
</summary>
</member>
<member name="M:FSComp.SR.pickleFsharpCoreBackwardsCompatible(System.String,System.String)">
<summary>
 Newly added pickle state cannot be used in FSharp.Core, since it must be working in older compilers+tooling as well. The time window is at least 3 years after feature introduction. Violation: %s . Context: \n %s 
 (Originally from FSComp.txt:1754)
</summary>
</member>
<member name="M:FSComp.SR.pickleErrorReadingWritingMetadata(System.String,System.String)">
<summary>
 Error reading/writing metadata for the F# compiled DLL &apos;%s&apos;. Was the DLL compiled with an earlier version of the F# compiler? (error: &apos;%s&apos;).
 (Originally from FSComp.txt:81)
</summary>
</member>
<member name="M:FSComp.SR.patternMatchGuardIsNotBool(System.String)">
<summary>
 A pattern match guard must be of type &apos;bool&apos;, but this &apos;when&apos; expression is of type &apos;%s&apos;.
 (Originally from FSComp.txt:33)
</summary>
</member>
<member name="M:FSComp.SR.pathIsInvalid(System.String)">
<summary>
 Problem with filename &apos;%s&apos;: Illegal characters in path.
 (Originally from FSComp.txt:1174)
</summary>
</member>
<member name="M:FSComp.SR.patcPartialActivePatternsGenerateOneResult">
<summary>
 Partial active patterns may only generate one result
 (Originally from FSComp.txt:989)
</summary>
</member>
<member name="M:FSComp.SR.patcMissingVariable(System.String)">
<summary>
 Missing variable &apos;%s&apos;
 (Originally from FSComp.txt:988)
</summary>
</member>
<member name="M:FSComp.SR.parsWhileDoExpected">
<summary>
 Missing &apos;do&apos; in &apos;while&apos; expression. Expected &apos;while &lt;expr&gt; do &lt;expr&gt;&apos;.
 (Originally from FSComp.txt:1297)
</summary>
</member>
<member name="M:FSComp.SR.parsVisibilityIllegalOnInherit">
<summary>
 Accessibility modifiers are not permitted on an &apos;inherits&apos; declaration
 (Originally from FSComp.txt:433)
</summary>
</member>
<member name="M:FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier">
<summary>
 Accessibility modifiers should come immediately prior to the identifier naming a construct
 (Originally from FSComp.txt:404)
</summary>
</member>
<member name="M:FSComp.SR.parsUseBindingsIllegalInModules">
<summary>
 &apos;use&apos; bindings are not permitted in modules and are treated as &apos;let&apos; bindings
 (Originally from FSComp.txt:397)
</summary>
</member>
<member name="M:FSComp.SR.parsUseBindingsIllegalInImplicitClassConstructors">
<summary>
 &apos;use&apos; bindings are not permitted in primary constructors
 (Originally from FSComp.txt:396)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedWith">
<summary>
 Unmatched &apos;with&apos; or badly formatted &apos;with&apos; block
 (Originally from FSComp.txt:420)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedUseBang">
<summary>
 Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the &apos;use!&apos; keyword.
 (Originally from FSComp.txt:1295)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedUse">
<summary>
 Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the &apos;use&apos; keyword.
 (Originally from FSComp.txt:1296)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedParen">
<summary>
 Unmatched &apos;(&apos;
 (Originally from FSComp.txt:446)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedLetBang">
<summary>
 Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the &apos;let!&apos; keyword.
 (Originally from FSComp.txt:1294)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedLet">
<summary>
 Incomplete value or function definition. If this is in an expression, the body of the expression must be indented to the same column as the &apos;let&apos; keyword.
 (Originally from FSComp.txt:1293)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedLBrackLess">
<summary>
 Unmatched &apos;[&lt;&apos;. Expected closing &apos;&gt;]&apos;
 (Originally from FSComp.txt:1277)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedClassInterfaceOrStruct">
<summary>
 Unmatched &apos;class&apos;, &apos;interface&apos; or &apos;struct&apos;
 (Originally from FSComp.txt:418)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedBracketBar">
<summary>
 Unmatched &apos;[|&apos;
 (Originally from FSComp.txt:462)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedBracket">
<summary>
 Unmatched &apos;[&apos;
 (Originally from FSComp.txt:457)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedBraceBar">
<summary>
 Unmatched &apos;{|&apos;
 (Originally from FSComp.txt:464)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedBrace">
<summary>
 Unmatched &apos;{&apos;
 (Originally from FSComp.txt:463)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedBeginOrStruct">
<summary>
 Unmatched &apos;begin&apos; or &apos;struct&apos;
 (Originally from FSComp.txt:411)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedBegin">
<summary>
 Unmatched &apos;begin&apos;
 (Originally from FSComp.txt:423)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatched(System.String)">
<summary>
 Unmatched &apos;%s&apos;
 (Originally from FSComp.txt:461)
</summary>
</member>
<member name="M:FSComp.SR.parsUnionCasesCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted on union cases. Use &apos;type U = internal ...&apos; or &apos;type U = private ...&apos; to give an accessibility to the whole representation.
 (Originally from FSComp.txt:441)
</summary>
</member>
<member name="M:FSComp.SR.parsUnfinishedExpression(System.String)">
<summary>
 Unexpected token &apos;%s&apos; or incomplete expression
 (Originally from FSComp.txt:1333)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedVisibilityDeclaration(System.String)">
<summary>
 Accessibility modifiers are not permitted here, but &apos;%s&apos; was given.
 (Originally from FSComp.txt:402)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedSymbolEqualsInsteadOfIn">
<summary>
 Unexpected symbol &apos;=&apos; in expression. Did you intend to use &apos;for x in y .. z do&apos; instead?
 (Originally from FSComp.txt:1398)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedSymbolDot">
<summary>
 Unexpected symbol &apos;.&apos; in member definition. Expected &apos;with&apos;, &apos;=&apos; or other token.
 (Originally from FSComp.txt:40)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedSemicolon">
<summary>
 A semicolon is not expected at this point
 (Originally from FSComp.txt:400)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString">
<summary>
 Unexpected quotation operator &apos;&lt;@&apos; in type definition. If you intend to pass a verbatim string as a static argument to a type provider, put a space between the &apos;&lt;&apos; and &apos;@&apos; characters.
 (Originally from FSComp.txt:1126)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedOperatorForUnitOfMeasure">
<summary>
 Unexpected infix operator in unit-of-measure expression. Legal operators are &apos;*&apos;, &apos;/&apos; and &apos;^&apos;.
 (Originally from FSComp.txt:472)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedIntegerLiteralForUnitOfMeasure">
<summary>
 Unexpected integer literal in unit-of-measure expression
 (Originally from FSComp.txt:473)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedInfixOperator">
<summary>
 Unexpected infix operator in type expression
 (Originally from FSComp.txt:469)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedIdentifier(System.String)">
<summary>
 Unexpected identifier: &apos;%s&apos;
 (Originally from FSComp.txt:440)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileWith">
<summary>
 Unexpected end of input in &apos;match&apos; or &apos;try&apos; expression
 (Originally from FSComp.txt:1282)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileWhile">
<summary>
 Unexpected end of input in &apos;while&apos; expression. Expected &apos;while &lt;expr&gt; do &lt;expr&gt;&apos;.
 (Originally from FSComp.txt:1280)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileTypeSignature">
<summary>
 Unexpected end of input in type signature
 (Originally from FSComp.txt:1287)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileTypeDefinition">
<summary>
 Unexpected end of input in type definition
 (Originally from FSComp.txt:1288)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileTypeArgs">
<summary>
 Unexpected end of input in type arguments
 (Originally from FSComp.txt:1286)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileTry">
<summary>
 Unexpected end of input in &apos;try&apos; expression. Expected &apos;try &lt;expr&gt; with &lt;rules&gt;&apos; or &apos;try &lt;expr&gt; finally &lt;expr&gt;&apos;.
 (Originally from FSComp.txt:1279)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileThen">
<summary>
 Unexpected end of input in &apos;then&apos; branch of conditional expression. Expected &apos;if &lt;expr&gt; then &lt;expr&gt;&apos; or &apos;if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;&apos;.
 (Originally from FSComp.txt:1283)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileObjectMembers">
<summary>
 Unexpected end of input in object members
 (Originally from FSComp.txt:1289)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileMatch">
<summary>
 Unexpected end of input in &apos;match&apos; expression. Expected &apos;match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...&apos;.
 (Originally from FSComp.txt:1278)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileFunBody">
<summary>
 Unexpected end of input in body of lambda expression. Expected &apos;fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;&apos;.
 (Originally from FSComp.txt:1285)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileFor">
<summary>
 Unexpected end of input in &apos;for&apos; expression. Expected &apos;for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;&apos;.
 (Originally from FSComp.txt:1281)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileExpression">
<summary>
 Unexpected end of input in expression
 (Originally from FSComp.txt:1291)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileElse">
<summary>
 Unexpected end of input in &apos;else&apos; branch of conditional expression. Expected &apos;if &lt;expr&gt; then &lt;expr&gt;&apos; or &apos;if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;&apos;.
 (Originally from FSComp.txt:1284)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileElif">
<summary>
 Unexpected end of input in &apos;else if&apos; or &apos;elif&apos; branch of conditional expression. Expected &apos;elif &lt;expr&gt; then &lt;expr&gt;&apos; or &apos;else if &lt;expr&gt; then &lt;expr&gt;&apos;.
 (Originally from FSComp.txt:1740)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileDefinition">
<summary>
 Unexpected end of input in value, function or member definition
 (Originally from FSComp.txt:1290)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFile">
<summary>
 Unexpected end of input
 (Originally from FSComp.txt:401)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEmptyModuleDefn">
<summary>
 Unexpected empty type moduleDefn list
 (Originally from FSComp.txt:413)
</summary>
</member>
<member name="M:FSComp.SR.parsUnderscoreInvalidFieldName">
<summary>
 &apos;_&apos; cannot be used as field name
 (Originally from FSComp.txt:1347)
</summary>
</member>
<member name="M:FSComp.SR.parsUnClosedBlockInHashLight">
<summary>
 Unclosed block
 (Originally from FSComp.txt:410)
</summary>
</member>
<member name="M:FSComp.SR.parsTypeNameCannotBeEmpty">
<summary>
 Type name cannot be empty.
 (Originally from FSComp.txt:1335)
</summary>
</member>
<member name="M:FSComp.SR.parsTypeAnnotationsOnGetSet">
<summary>
 Type annotations on property getters and setters must be given after the &apos;get()&apos; or &apos;set(v)&apos;, e.g. &apos;with get() : string = ...&apos;
 (Originally from FSComp.txt:426)
</summary>
</member>
<member name="M:FSComp.SR.parsTypeAbbreviationsCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted in this position for type abbreviations
 (Originally from FSComp.txt:436)
</summary>
</member>
<member name="M:FSComp.SR.parsSyntaxModuleStructEndDeprecated">
<summary>
 The syntax &apos;module ... = struct .. end&apos; is not used in F# code. Consider using &apos;module ... = begin .. end&apos;
 (Originally from FSComp.txt:482)
</summary>
</member>
<member name="M:FSComp.SR.parsSyntaxModuleSigEndDeprecated">
<summary>
 The syntax &apos;module ... : sig .. end&apos; is not used in F# code. Consider using &apos;module ... = begin .. end&apos;
 (Originally from FSComp.txt:483)
</summary>
</member>
<member name="M:FSComp.SR.parsSyntaxErrorInLabeledType">
<summary>
 Syntax error in labelled type argument
 (Originally from FSComp.txt:468)
</summary>
</member>
<member name="M:FSComp.SR.parsSyntaxError">
<summary>
 Syntax error
 (Originally from FSComp.txt:416)
</summary>
</member>
<member name="M:FSComp.SR.parsSuccessivePatternsShouldBeSpacedOrTupled">
<summary>
 Successive patterns should be separated by spaces or tupled
 (Originally from FSComp.txt:447)
</summary>
</member>
<member name="M:FSComp.SR.parsSuccessiveArgsShouldBeSpacedOrTupled">
<summary>
 Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
 (Originally from FSComp.txt:456)
</summary>
</member>
<member name="M:FSComp.SR.parsStaticMemberImcompleteSyntax">
<summary>
 Incomplete declaration of a static construct. Use &apos;static let&apos;,&apos;static do&apos;,&apos;static member&apos; or &apos;static val&apos; for declaration.
 (Originally from FSComp.txt:1770)
</summary>
</member>
<member name="M:FSComp.SR.parsSetterAtMostTwoArguments">
<summary>
 A setter property may have at most two argument groups
 (Originally from FSComp.txt:1073)
</summary>
</member>
<member name="M:FSComp.SR.parsSetSyntax">
<summary>
 Property setters must be defined using &apos;set value = &apos;, &apos;set idx value = &apos; or &apos;set (idx1,...,idxN) value = ... &apos;
 (Originally from FSComp.txt:429)
</summary>
</member>
<member name="M:FSComp.SR.parsRecordFieldsCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted on record fields. Use &apos;type R = internal ...&apos; or &apos;type R = private ...&apos; to give an accessibility to the whole representation.
 (Originally from FSComp.txt:444)
</summary>
</member>
<member name="M:FSComp.SR.parsParenFormIsForML">
<summary>
 In F# code you may use &apos;expr.[expr]&apos;. A type annotation may be required to indicate the first expression is an array
 (Originally from FSComp.txt:459)
</summary>
</member>
<member name="M:FSComp.SR.parsOnlySimplePatternsAreAllowedInConstructors">
<summary>
 Only simple patterns are allowed in primary constructors
 (Originally from FSComp.txt:1773)
</summary>
</member>
<member name="M:FSComp.SR.parsOnlyOneWithAugmentationAllowed">
<summary>
 At most one &apos;with&apos; augmentation is permitted
 (Originally from FSComp.txt:399)
</summary>
</member>
<member name="M:FSComp.SR.parsOnlyHashDirectivesAllowed">
<summary>
 Only &apos;#&apos; compiler directives may occur prior to the first &apos;namespace&apos; declaration
 (Originally from FSComp.txt:403)
</summary>
</member>
<member name="M:FSComp.SR.parsOnlyClassCanTakeValueArguments">
<summary>
 Only class types may take value arguments
 (Originally from FSComp.txt:422)
</summary>
</member>
<member name="M:FSComp.SR.parsNonAtomicType">
<summary>
 The use of the type syntax &apos;int C&apos; and &apos;C  &lt;int&gt;&apos; is not permitted here. Consider adjusting this type to be written in the form &apos;C&lt;int&gt;&apos;
 (Originally from FSComp.txt:1079)
</summary>
</member>
<member name="M:FSComp.SR.parsNonAdjacentTypars">
<summary>
 Remove spaces between the type name and type parameter, e.g. \&quot;type C&lt;&apos;T&gt;\&quot;, not type \&quot;C   &lt;&apos;T&gt;\&quot;. Type parameters must be placed directly adjacent to the type name.
 (Originally from FSComp.txt:1077)
</summary>
</member>
<member name="M:FSComp.SR.parsNonAdjacentTyargs">
<summary>
 Remove spaces between the type name and type parameter, e.g. \&quot;C&lt;&apos;T&gt;\&quot;, not \&quot;C &lt;&apos;T&gt;\&quot;. Type parameters must be placed directly adjacent to the type name.
 (Originally from FSComp.txt:1078)
</summary>
</member>
<member name="M:FSComp.SR.parsNoMatchingInForLet">
<summary>
 No matching &apos;in&apos; found for this &apos;let&apos;
 (Originally from FSComp.txt:448)
</summary>
</member>
<member name="M:FSComp.SR.parsNoHashEndIfFound">
<summary>
 No #endif found for #if or #else
 (Originally from FSComp.txt:394)
</summary>
</member>
<member name="M:FSComp.SR.parsNoEqualShouldFollowNamespace">
<summary>
 No &apos;=&apos; symbol should follow a &apos;namespace&apos; declaration
 (Originally from FSComp.txt:481)
</summary>
</member>
<member name="M:FSComp.SR.parsNewExprMemberAccess">
<summary>
 This member access is ambiguous. Please use parentheses around the object creation, e.g. &apos;(new SomeType(args)).MemberName&apos;
 (Originally from FSComp.txt:1681)
</summary>
</member>
<member name="M:FSComp.SR.parsNamespaceOrModuleNotBoth">
<summary>
 Files should begin with either a namespace or module declaration, e.g. &apos;namespace SomeNamespace.SubNamespace&apos; or &apos;module SomeNamespace.SomeModule&apos;, but not both. To define a module within a namespace use &apos;module SomeModule = ...&apos;
 (Originally from FSComp.txt:405)
</summary>
</member>
<member name="M:FSComp.SR.parsMutableOnAutoPropertyShouldBeGetSetNotJustSet">
<summary>
 To indicate that this property can be set, use &apos;member val PropertyName = expr with get,set&apos;.
 (Originally from FSComp.txt:1311)
</summary>
</member>
<member name="M:FSComp.SR.parsMutableOnAutoPropertyShouldBeGetSet">
<summary>
 Property definitions may not be declared mutable. To indicate that this property can be set, use &apos;member val PropertyName = expr with get,set&apos;.
 (Originally from FSComp.txt:1310)
</summary>
</member>
<member name="M:FSComp.SR.parsMultipleAccessibilitiesForGetSet">
<summary>
 When the visibility for a property is specified, setting the visibility of the set or get method is not allowed.
 (Originally from FSComp.txt:428)
</summary>
</member>
<member name="M:FSComp.SR.parsMultiArgumentGenericTypeFormDeprecated">
<summary>
 The syntax &apos;(typ,...,typ) ident&apos; is not used in F# code. Consider using &apos;ident&lt;typ,...,typ&gt;&apos; instead
 (Originally from FSComp.txt:470)
</summary>
</member>
<member name="M:FSComp.SR.parsModuleDefnMustBeSimpleName">
<summary>
 A module name must be a simple name, not a path
 (Originally from FSComp.txt:412)
</summary>
</member>
<member name="M:FSComp.SR.parsModuleAbbreviationMustBeSimpleName">
<summary>
 A module abbreviation must be a simple name, not a path
 (Originally from FSComp.txt:406)
</summary>
</member>
<member name="M:FSComp.SR.parsMissingUnionCaseName">
<summary>
 Missing union case name
 (Originally from FSComp.txt:1742)
</summary>
</member>
<member name="M:FSComp.SR.parsMissingTypeArgs">
<summary>
 Expected type argument or static argument
 (Originally from FSComp.txt:1124)
</summary>
</member>
<member name="M:FSComp.SR.parsMissingQualificationAfterDot">
<summary>
 Missing qualification after &apos;.&apos;
 (Originally from FSComp.txt:458)
</summary>
</member>
<member name="M:FSComp.SR.parsMissingMemberBody">
<summary>
 Expecting member body
 (Originally from FSComp.txt:1747)
</summary>
</member>
<member name="M:FSComp.SR.parsMissingKeyword(System.String)">
<summary>
 Missing keyword &apos;%s&apos;
 (Originally from FSComp.txt:1748)
</summary>
</member>
<member name="M:FSComp.SR.parsMissingGreaterThan">
<summary>
 Unmatched &apos;&lt;&apos;. Expected closing &apos;&gt;&apos;
 (Originally from FSComp.txt:1125)
</summary>
</member>
<member name="M:FSComp.SR.parsMissingFunctionBody">
<summary>
 Missing function body
 (Originally from FSComp.txt:467)
</summary>
</member>
<member name="M:FSComp.SR.parsMismatchedQuote(System.String)">
<summary>
 Mismatched quotation, beginning with &apos;%s&apos;
 (Originally from FSComp.txt:460)
</summary>
</member>
<member name="M:FSComp.SR.parsMismatchedQuotationName(System.String)">
<summary>
 Mismatched quotation operator name, beginning with &apos;%s&apos;
 (Originally from FSComp.txt:475)
</summary>
</member>
<member name="M:FSComp.SR.parsMemberIllegalInObjectImplementation">
<summary>
 This member is not permitted in an object implementation
 (Originally from FSComp.txt:466)
</summary>
</member>
<member name="M:FSComp.SR.parsLetAndForNonRecBindings">
<summary>
 The declaration form &apos;let ... and ...&apos; for non-recursive bindings is not used in F# code. Consider using a sequence of &apos;let&apos; bindings
 (Originally from FSComp.txt:445)
</summary>
</member>
<member name="M:FSComp.SR.parsInvalidUseOfRec">
<summary>
 Invalid use of &apos;rec&apos; keyword
 (Originally from FSComp.txt:1387)
</summary>
</member>
<member name="M:FSComp.SR.parsInvalidProperty">
<summary>
 Invalid property getter or setter
 (Originally from FSComp.txt:1074)
</summary>
</member>
<member name="M:FSComp.SR.parsInvalidPrefixOperatorDefinition">
<summary>
 Invalid operator definition. Prefix operator definitions must use a valid prefix operator name.
 (Originally from FSComp.txt:1102)
</summary>
</member>
<member name="M:FSComp.SR.parsInvalidPrefixOperator">
<summary>
 Invalid prefix operator
 (Originally from FSComp.txt:1101)
</summary>
</member>
<member name="M:FSComp.SR.parsInvalidLiteralInType">
<summary>
 Invalid literal in type
 (Originally from FSComp.txt:471)
</summary>
</member>
<member name="M:FSComp.SR.parsInvalidDeclarationSyntax">
<summary>
 Invalid declaration syntax
 (Originally from FSComp.txt:424)
</summary>
</member>
<member name="M:FSComp.SR.parsInvalidAnonRecdType">
<summary>
 Invalid anonymous record type
 (Originally from FSComp.txt:1521)
</summary>
</member>
<member name="M:FSComp.SR.parsInvalidAnonRecdExpr">
<summary>
 Invalid anonymous record expression
 (Originally from FSComp.txt:1520)
</summary>
</member>
<member name="M:FSComp.SR.parsInterfacesHaveSameVisibilityAsEnclosingType">
<summary>
 Interfaces always have the same visibility as the enclosing type
 (Originally from FSComp.txt:430)
</summary>
</member>
<member name="M:FSComp.SR.parsIntegerForLoopRequiresSimpleIdentifier">
<summary>
 An integer for loop must use a simple identifier
 (Originally from FSComp.txt:398)
</summary>
</member>
<member name="M:FSComp.SR.parsInlineAssemblyCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted on inline assembly code types
 (Originally from FSComp.txt:439)
</summary>
</member>
<member name="M:FSComp.SR.parsInheritDeclarationsCannotHaveAsBindings">
<summary>
 &apos;inherit&apos; declarations cannot have &apos;as&apos; bindings. To access members of the base class when overriding a method, the syntax &apos;base.SomeMember&apos; may be used; &apos;base&apos; is a keyword. Remove this &apos;as&apos; binding.
 (Originally from FSComp.txt:434)
</summary>
</member>
<member name="M:FSComp.SR.parsIndexerPropertyRequiresAtLeastOneArgument">
<summary>
 An indexer property must be given at least one argument
 (Originally from FSComp.txt:1075)
</summary>
</member>
<member name="M:FSComp.SR.parsIncompleteTyparExpr2">
<summary>
 Incomplete operator expression (example a^b) or qualified type invocation (example: ^T.Name)
 (Originally from FSComp.txt:480)
</summary>
</member>
<member name="M:FSComp.SR.parsIncompleteTyparExpr1">
<summary>
 Incomplete character literal (example: &apos;Q&apos;) or qualified type invocation (example: &apos;T.Name)
 (Originally from FSComp.txt:479)
</summary>
</member>
<member name="M:FSComp.SR.parsIncompleteIf">
<summary>
 Incomplete conditional. Expected &apos;if &lt;expr&gt; then &lt;expr&gt;&apos; or &apos;if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;&apos;.
 (Originally from FSComp.txt:451)
</summary>
</member>
<member name="M:FSComp.SR.parsInOrEqualExpected">
<summary>
 &apos;in&apos; or &apos;=&apos; expected
 (Originally from FSComp.txt:454)
</summary>
</member>
<member name="M:FSComp.SR.parsIllegalMemberVarInObjectImplementation">
<summary>
 Neither &apos;member val&apos; nor &apos;override val&apos; definitions are permitted in object expressions.
 (Originally from FSComp.txt:1345)
</summary>
</member>
<member name="M:FSComp.SR.parsIllegalDenominatorForMeasureExponent">
<summary>
 Denominator must not be 0 in unit-of-measure exponent
 (Originally from FSComp.txt:478)
</summary>
</member>
<member name="M:FSComp.SR.parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate(System.String)">
<summary>
 The &apos;%s&apos; visibility attribute is not allowed on module abbreviation. Module abbreviations are always private.
 (Originally from FSComp.txt:409)
</summary>
</member>
<member name="M:FSComp.SR.parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate(System.String)">
<summary>
 The &apos;%s&apos; accessibility attribute is not allowed on module abbreviation. Module abbreviations are always private.
 (Originally from FSComp.txt:408)
</summary>
</member>
<member name="M:FSComp.SR.parsIgnoreAttributesOnModuleAbbreviation">
<summary>
 Ignoring attributes on module abbreviation
 (Originally from FSComp.txt:407)
</summary>
</member>
<member name="M:FSComp.SR.parsIdentifierExpected">
<summary>
 Identifier expected
 (Originally from FSComp.txt:453)
</summary>
</member>
<member name="M:FSComp.SR.parsGetterMustHaveAtLeastOneArgument">
<summary>
 A getter property is expected to be a function, e.g. &apos;get() = ...&apos; or &apos;get(index) = ...&apos;
 (Originally from FSComp.txt:427)
</summary>
</member>
<member name="M:FSComp.SR.parsGetterAtMostOneArgument">
<summary>
 A getter property may have at most one argument group
 (Originally from FSComp.txt:1072)
</summary>
</member>
<member name="M:FSComp.SR.parsGetOrSetRequired">
<summary>
 &apos;get&apos;, &apos;set&apos; or &apos;get,set&apos; required
 (Originally from FSComp.txt:421)
</summary>
</member>
<member name="M:FSComp.SR.parsGetAndOrSetRequired">
<summary>
 &apos;get&apos; and/or &apos;set&apos; required
 (Originally from FSComp.txt:425)
</summary>
</member>
<member name="M:FSComp.SR.parsForDoExpected">
<summary>
 Missing &apos;do&apos; in &apos;for&apos; expression. Expected &apos;for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;&apos;.
 (Originally from FSComp.txt:1298)
</summary>
</member>
<member name="M:FSComp.SR.parsFieldBinding">
<summary>
 Field bindings must have the form &apos;id = expr;&apos;
 (Originally from FSComp.txt:465)
</summary>
</member>
<member name="M:FSComp.SR.parsExpectingUnionCaseField">
<summary>
 Expecting union case field
 (Originally from FSComp.txt:1784)
</summary>
</member>
<member name="M:FSComp.SR.parsExpectingType">
<summary>
 Expecting type
 (Originally from FSComp.txt:1743)
</summary>
</member>
<member name="M:FSComp.SR.parsExpectingRecordField">
<summary>
 Expecting record field
 (Originally from FSComp.txt:1771)
</summary>
</member>
<member name="M:FSComp.SR.parsExpectingPattern">
<summary>
 Expecting pattern
 (Originally from FSComp.txt:1723)
</summary>
</member>
<member name="M:FSComp.SR.parsExpectingExpression">
<summary>
 Expecting expression
 (Originally from FSComp.txt:1713)
</summary>
</member>
<member name="M:FSComp.SR.parsExpectedTypeAfterToken">
<summary>
 Expected a type after this point
 (Originally from FSComp.txt:1276)
</summary>
</member>
<member name="M:FSComp.SR.parsExpectedPatternAfterToken">
<summary>
 Expected a pattern after this point
 (Originally from FSComp.txt:1724)
</summary>
</member>
<member name="M:FSComp.SR.parsExpectedNameAfterToken">
<summary>
 Unexpected end of type. Expected a name after this point.
 (Originally from FSComp.txt:1292)
</summary>
</member>
<member name="M:FSComp.SR.parsExpectedExpressionAfterToken">
<summary>
 Expected an expression after this point
 (Originally from FSComp.txt:1275)
</summary>
</member>
<member name="M:FSComp.SR.parsExpectedExpressionAfterLet(System.String,System.String)">
<summary>
 The block following this &apos;%s&apos; is unfinished. Every code block is an expression and must have a result. &apos;%s&apos; cannot be the final code element in a block. Consider giving this block an explicit result.
 (Originally from FSComp.txt:450)
</summary>
</member>
<member name="M:FSComp.SR.parsErrorParsingAsOperatorName">
<summary>
 Attempted to parse this as an operator name, but failed
 (Originally from FSComp.txt:1127)
</summary>
</member>
<member name="M:FSComp.SR.parsErrorInReturnForLetIncorrectIndentation">
<summary>
 Error in the return expression for this &apos;let&apos;. Possible incorrect indentation.
 (Originally from FSComp.txt:449)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInVerbatimStringInComment">
<summary>
 End of file in verbatim string embedded in comment begun at or before here
 (Originally from FSComp.txt:391)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInVerbatimString">
<summary>
 End of file in verbatim string begun at or before here
 (Originally from FSComp.txt:388)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInTripleQuoteStringInComment">
<summary>
 End of file in triple-quote string embedded in comment begun at or before here
 (Originally from FSComp.txt:1122)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInTripleQuoteString">
<summary>
 End of file in triple-quote string begun at or before here
 (Originally from FSComp.txt:1121)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInStringInComment">
<summary>
 End of file in string embedded in comment begun at or before here
 (Originally from FSComp.txt:390)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInString">
<summary>
 End of file in string begun at or before here
 (Originally from FSComp.txt:387)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInInterpolatedVerbatimString">
<summary>
 Incomplete interpolated verbatim string begun at or before here
 (Originally from FSComp.txt:1660)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInInterpolatedTripleQuoteString">
<summary>
 Incomplete interpolated triple-quote string begun at or before here
 (Originally from FSComp.txt:1661)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInInterpolatedStringFill">
<summary>
 Incomplete interpolated string expression fill begun at or before here
 (Originally from FSComp.txt:1658)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInInterpolatedString">
<summary>
 Incomplete interpolated string begun at or before here
 (Originally from FSComp.txt:1659)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInIfOcaml">
<summary>
 End of file in IF-OCAML section begun at or before here
 (Originally from FSComp.txt:392)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInHashIf">
<summary>
 End of file in #if section begun at or after here
 (Originally from FSComp.txt:386)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInDirective">
<summary>
 End of file in directive begun at or before here
 (Originally from FSComp.txt:393)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInComment">
<summary>
 End of file in comment begun at or before here
 (Originally from FSComp.txt:389)
</summary>
</member>
<member name="M:FSComp.SR.parsEnumTypesCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted in this position for enum types
 (Originally from FSComp.txt:437)
</summary>
</member>
<member name="M:FSComp.SR.parsEnumFieldsCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted on enumeration fields
 (Originally from FSComp.txt:442)
</summary>
</member>
<member name="M:FSComp.SR.parsEmptyTypeDefinition">
<summary>
 A type definition requires one or more members or other declarations. If you intend to define an empty class, struct or interface, then use &apos;type ... = class end&apos;, &apos;interface end&apos; or &apos;struct end&apos;.
 (Originally from FSComp.txt:419)
</summary>
</member>
<member name="M:FSComp.SR.parsEmptyFillInInterpolatedString">
<summary>
 Invalid interpolated string. This interpolated string expression fill is empty, an expression was expected.
 (Originally from FSComp.txt:1662)
</summary>
</member>
<member name="M:FSComp.SR.parsDoCannotHaveVisibilityDeclarations(System.String)">
<summary>
 Accessibility modifiers are not permitted on &apos;do&apos; bindings, but &apos;%s&apos; was given.
 (Originally from FSComp.txt:385)
</summary>
</member>
<member name="M:FSComp.SR.parsConstraintIntersectionSyntaxUsedWithNonFlexibleType">
<summary>
 Constraint intersection syntax may only be used with flexible types, e.g. &apos;#IDisposable &amp; #ISomeInterface&apos;.
 (Originally from FSComp.txt:1752)
</summary>
</member>
<member name="M:FSComp.SR.parsConsiderUsingSeparateRecordType">
<summary>
 Consider using a separate record type instead
 (Originally from FSComp.txt:443)
</summary>
</member>
<member name="M:FSComp.SR.parsAugmentationsIllegalOnDelegateType">
<summary>
 Augmentations are not permitted on delegate type moduleDefns
 (Originally from FSComp.txt:417)
</summary>
</member>
<member name="M:FSComp.SR.parsAttributesMustComeBeforeVal">
<summary>
 Attributes should be placed before &apos;val&apos;
 (Originally from FSComp.txt:414)
</summary>
</member>
<member name="M:FSComp.SR.parsAttributesIllegalOnInherit">
<summary>
 Attributes are not permitted on &apos;inherit&apos; declarations
 (Originally from FSComp.txt:432)
</summary>
</member>
<member name="M:FSComp.SR.parsAttributesIllegalHere">
<summary>
 Attributes are not allowed here
 (Originally from FSComp.txt:435)
</summary>
</member>
<member name="M:FSComp.SR.parsAttributesIgnored">
<summary>
 Attributes have been ignored in this construct
 (Originally from FSComp.txt:395)
</summary>
</member>
<member name="M:FSComp.SR.parsAttributesAreNotPermittedOnInterfaceImplementations">
<summary>
 Attributes are not permitted on interface implementations
 (Originally from FSComp.txt:415)
</summary>
</member>
<member name="M:FSComp.SR.parsAttributeOnIncompleteCode">
<summary>
 Cannot find code target for this attribute, possibly because the code after the attribute is incomplete.
 (Originally from FSComp.txt:1334)
</summary>
</member>
<member name="M:FSComp.SR.parsAssertIsNotFirstClassValue">
<summary>
 &apos;assert&apos; may not be used as a first class value. Use &apos;assert &lt;expr&gt;&apos; instead.
 (Originally from FSComp.txt:452)
</summary>
</member>
<member name="M:FSComp.SR.parsArrowUseIsLimited">
<summary>
 The use of &apos;-&gt;&apos; in sequence and computation expressions is limited to the form &apos;for pat in expr -&gt; expr&apos;. Use the syntax &apos;for ... in ... do ... yield...&apos; to generate elements in more complex sequence expressions.
 (Originally from FSComp.txt:455)
</summary>
</member>
<member name="M:FSComp.SR.parsAllEnumFieldsRequireValues">
<summary>
 All enum fields must be given values
 (Originally from FSComp.txt:438)
</summary>
</member>
<member name="M:FSComp.SR.parsActivePatternCaseMustBeginWithUpperCase">
<summary>
 Active pattern case identifiers must begin with an uppercase letter
 (Originally from FSComp.txt:476)
</summary>
</member>
<member name="M:FSComp.SR.parsActivePatternCaseContainsPipe">
<summary>
 The &apos;|&apos; character is not permitted in active pattern case identifiers
 (Originally from FSComp.txt:477)
</summary>
</member>
<member name="M:FSComp.SR.parsAccessibilityModsIllegalForAbstract">
<summary>
 Accessibility modifiers are not allowed on this member. Abstract slots always have the same visibility as the enclosing type.
 (Originally from FSComp.txt:431)
</summary>
</member>
<member name="M:FSComp.SR.packageManagerUnknown(System.String,System.String,System.String)">
<summary>
 Package manager key &apos;%s&apos; was not registered in %s. Currently registered: %s. You can provide extra path(s) by passing &apos;--compilertool:&lt;extensionsfolder&gt;&apos; to the command line. To learn more about extensions, visit: https://aka.ms/dotnetdepmanager
 (Originally from FSComp.txt:843)
</summary>
</member>
<member name="M:FSComp.SR.packageManagerError(System.String)">
<summary>
 %s
 (Originally from FSComp.txt:844)
</summary>
</member>
<member name="M:FSComp.SR.packageManagementRequiresVFive">
<summary>
 The &apos;package management&apos; feature requires language version 5.0 or above
 (Originally from FSComp.txt:1548)
</summary>
</member>
<member name="M:FSComp.SR.optsWriteXml">
<summary>
 Write the xmldoc of the assembly to the given file
 (Originally from FSComp.txt:855)
</summary>
</member>
<member name="M:FSComp.SR.optsWin32res">
<summary>
 Specify a Win32 resource file (.res)
 (Originally from FSComp.txt:867)
</summary>
</member>
<member name="M:FSComp.SR.optsWin32manifest">
<summary>
 Specify a Win32 manifest file
 (Originally from FSComp.txt:868)
</summary>
</member>
<member name="M:FSComp.SR.optsWin32icon">
<summary>
 Specify a Win32 icon file (.ico)
 (Originally from FSComp.txt:866)
</summary>
</member>
<member name="M:FSComp.SR.optsWarnaserrorPM(System.String)">
<summary>
 Report all warnings as errors (%s by default)
 (Originally from FSComp.txt:888)
</summary>
</member>
<member name="M:FSComp.SR.optsWarnaserror">
<summary>
 Report specific warnings as errors
 (Originally from FSComp.txt:889)
</summary>
</member>
<member name="M:FSComp.SR.optsWarnOn">
<summary>
 Enable specific warnings that may be off by default
 (Originally from FSComp.txt:892)
</summary>
</member>
<member name="M:FSComp.SR.optsWarn">
<summary>
 Set a warning level (0-5)
 (Originally from FSComp.txt:890)
</summary>
</member>
<member name="M:FSComp.SR.optsVersion">
<summary>
 Display compiler version banner and exit
 (Originally from FSComp.txt:898)
</summary>
</member>
<member name="M:FSComp.SR.optsUtf8output">
<summary>
 Output messages in UTF-8 encoding
 (Originally from FSComp.txt:902)
</summary>
</member>
<member name="M:FSComp.SR.optsUseHighEntropyVA(System.String)">
<summary>
 Enable high-entropy ASLR (%s by default)
 (Originally from FSComp.txt:929)
</summary>
</member>
<member name="M:FSComp.SR.optsUnrecognizedTarget(System.String)">
<summary>
 Unrecognized target &apos;%s&apos;, expected &apos;exe&apos;, &apos;winexe&apos;, &apos;library&apos; or &apos;module&apos;
 (Originally from FSComp.txt:939)
</summary>
</member>
<member name="M:FSComp.SR.optsUnrecognizedLanguageVersion(System.String)">
<summary>
 Unrecognized value &apos;%s&apos; for --langversion use --langversion:? for complete list
 (Originally from FSComp.txt:84)
</summary>
</member>
<member name="M:FSComp.SR.optsUnrecognizedDebugType(System.String)">
<summary>
 Unrecognized debug type &apos;%s&apos;, expected &apos;pdbonly&apos; or &apos;full&apos;
 (Originally from FSComp.txt:940)
</summary>
</member>
<member name="M:FSComp.SR.optsUnknownSignatureData(System.String)">
<summary>
 Invalid value &apos;%s&apos; for --interfacedata, valid value are: none, file, compress.
 (Originally from FSComp.txt:936)
</summary>
</member>
<member name="M:FSComp.SR.optsUnknownPlatform(System.String)">
<summary>
 Unrecognized platform &apos;%s&apos;, valid values are &apos;x86&apos;, &apos;x64&apos;, &apos;Arm&apos;, &apos;Arm64&apos;, &apos;Itanium&apos;, &apos;anycpu32bitpreferred&apos;, and &apos;anycpu&apos;. The default is anycpu.
 (Originally from FSComp.txt:945)
</summary>
</member>
<member name="M:FSComp.SR.optsUnknownOptimizationData(System.String)">
<summary>
 Invalid value &apos;%s&apos; for --optimizationdata, valid value are: none, file, compress.
 (Originally from FSComp.txt:938)
</summary>
</member>
<member name="M:FSComp.SR.optsUnknownChecksumAlgorithm(System.String)">
<summary>
 Algorithm &apos;%s&apos; is not supported
 (Originally from FSComp.txt:946)
</summary>
</member>
<member name="M:FSComp.SR.optsUnknownArgumentToTheTestSwitch(System.String)">
<summary>
 Unknown --test argument: &apos;%s&apos;
 (Originally from FSComp.txt:944)
</summary>
</member>
<member name="M:FSComp.SR.optsTargetProfile">
<summary>
 Specify target framework profile of this assembly. Valid values are mscorlib, netcore or netstandard. Default - mscorlib
 (Originally from FSComp.txt:931)
</summary>
</member>
<member name="M:FSComp.SR.optsTailcalls(System.String)">
<summary>
 Enable or disable tailcalls (%s by default)
 (Originally from FSComp.txt:880)
</summary>
</member>
<member name="M:FSComp.SR.optsSupportedLangVersions">
<summary>
 Supported language versions:
 (Originally from FSComp.txt:1564)
</summary>
</member>
<member name="M:FSComp.SR.optsSubSystemVersion">
<summary>
 Specify subsystem version of this assembly
 (Originally from FSComp.txt:930)
</summary>
</member>
<member name="M:FSComp.SR.optsStrongKeyFile">
<summary>
 Specify a strong name key file
 (Originally from FSComp.txt:856)
</summary>
</member>
<member name="M:FSComp.SR.optsStrongKeyContainer">
<summary>
 Specify a strong name key container
 (Originally from FSComp.txt:857)
</summary>
</member>
<member name="M:FSComp.SR.optsStrictIndentation(System.String)">
<summary>
 Override indentation rules implied by the language version (%s by default)
 (Originally from FSComp.txt:1565)
</summary>
</member>
<member name="M:FSComp.SR.optsStaticlink">
<summary>
 Statically link the given assembly and all referenced DLLs that depend on this assembly. Use an assembly name e.g. mylib, not a DLL name.
 (Originally from FSComp.txt:909)
</summary>
</member>
<member name="M:FSComp.SR.optsStandalone">
<summary>
 Statically link the F# library and all referenced DLLs that depend on it into the assembly being generated
 (Originally from FSComp.txt:908)
</summary>
</member>
<member name="M:FSComp.SR.optsSourceLink">
<summary>
 Source link information file to embed in the portable PDB file
 (Originally from FSComp.txt:872)
</summary>
</member>
<member name="M:FSComp.SR.optsSimpleresolution">
<summary>
 Resolve assembly references using directory-based rules rather than MSBuild resolution
 (Originally from FSComp.txt:912)
</summary>
</member>
<member name="M:FSComp.SR.optsSignatureData">
<summary>
 Include F# interface information, the default is file. Essential for distributing libraries.
 (Originally from FSComp.txt:935)
</summary>
</member>
<member name="M:FSComp.SR.optsSig">
<summary>
 Print the inferred interface of the assembly to a file
 (Originally from FSComp.txt:862)
</summary>
</member>
<member name="M:FSComp.SR.optsShortFormOf(System.String)">
<summary>
 Short form of &apos;%s&apos;
 (Originally from FSComp.txt:913)
</summary>
</member>
<member name="M:FSComp.SR.optsSetLangVersion">
<summary>
 Specify language version such as &apos;latest&apos; or &apos;preview&apos;.
 (Originally from FSComp.txt:1563)
</summary>
</member>
<member name="M:FSComp.SR.optsResponseFileNotFound(System.String,System.String)">
<summary>
 Response file &apos;%s&apos; not found in &apos;%s&apos;
 (Originally from FSComp.txt:1376)
</summary>
</member>
<member name="M:FSComp.SR.optsResponseFileNameInvalid(System.String)">
<summary>
 Response file name &apos;%s&apos; is empty, contains invalid characters, has a drive specification without an absolute path, or is too long
 (Originally from FSComp.txt:1377)
</summary>
</member>
<member name="M:FSComp.SR.optsResponseFile">
<summary>
 Read response file for more options
 (Originally from FSComp.txt:899)
</summary>
</member>
<member name="M:FSComp.SR.optsResource">
<summary>
 Embed the specified managed resource
 (Originally from FSComp.txt:875)
</summary>
</member>
<member name="M:FSComp.SR.optsResident">
<summary>
 Use a resident background compilation service to improve compiler startup times.
 (Originally from FSComp.txt:910)
</summary>
</member>
<member name="M:FSComp.SR.optsReflectionFree">
<summary>
 Disable implicit generation of constructs using reflection
 (Originally from FSComp.txt:887)
</summary>
</member>
<member name="M:FSComp.SR.optsReference">
<summary>
 Reference an assembly (Short form: -r)
 (Originally from FSComp.txt:864)
</summary>
</member>
<member name="M:FSComp.SR.optsRefOut">
<summary>
 Produce a reference assembly with the specified file path.
 (Originally from FSComp.txt:884)
</summary>
</member>
<member name="M:FSComp.SR.optsRefOnly(System.String)">
<summary>
 Produce a reference assembly, instead of a full assembly, as the primary output (%s by default)
 (Originally from FSComp.txt:883)
</summary>
</member>
<member name="M:FSComp.SR.optsRealsig(System.String)">
<summary>
 Generate assembly with IL visibility that matches the source code visibility (%s by default)
 (Originally from FSComp.txt:882)
</summary>
</member>
<member name="M:FSComp.SR.optsPublicSign(System.String)">
<summary>
 Public-sign the assembly using only the public portion of the strong name key, and mark the assembly as signed (%s by default)
 (Originally from FSComp.txt:854)
</summary>
</member>
<member name="M:FSComp.SR.optsProblemWithCodepage(System.Int32,System.String)">
<summary>
 Problem with codepage &apos;%d&apos;: %s
 (Originally from FSComp.txt:845)
</summary>
</member>
<member name="M:FSComp.SR.optsPreferredUiLang">
<summary>
 Specify the preferred output language culture name (e.g. es-ES, ja-JP)
 (Originally from FSComp.txt:933)
</summary>
</member>
<member name="M:FSComp.SR.optsPlatform">
<summary>
 Limit which platforms this code can run on: x86, x64, Arm, Arm64, Itanium, anycpu32bitpreferred, or anycpu. The default is anycpu.
 (Originally from FSComp.txt:859)
</summary>
</member>
<member name="M:FSComp.SR.optsPdbMatchesOutputFileName">
<summary>
 The pdb output file name cannot match the build output filename use --pdb:filename.pdb
 (Originally from FSComp.txt:873)
</summary>
</member>
<member name="M:FSComp.SR.optsPdb">
<summary>
 Name the output debug file
 (Originally from FSComp.txt:911)
</summary>
</member>
<member name="M:FSComp.SR.optsPathMap">
<summary>
 Maps physical paths to source path names output by the compiler
 (Originally from FSComp.txt:885)
</summary>
</member>
<member name="M:FSComp.SR.optsOptimize(System.String)">
<summary>
 Enable optimizations (Short form: -O) (%s by default)
 (Originally from FSComp.txt:879)
</summary>
</member>
<member name="M:FSComp.SR.optsOptimizationData">
<summary>
 Specify included optimization information, the default is file. Important for distributed libraries.
 (Originally from FSComp.txt:937)
</summary>
</member>
<member name="M:FSComp.SR.optsNowin32manifest">
<summary>
 Do not include the default Win32 manifest
 (Originally from FSComp.txt:869)
</summary>
</member>
<member name="M:FSComp.SR.optsNowarn">
<summary>
 Disable specific warning messages
 (Originally from FSComp.txt:891)
</summary>
</member>
<member name="M:FSComp.SR.optsNologo">
<summary>
 Suppress compiler copyright message
 (Originally from FSComp.txt:896)
</summary>
</member>
<member name="M:FSComp.SR.optsNoframework">
<summary>
 Do not reference the default CLI assemblies by default
 (Originally from FSComp.txt:907)
</summary>
</member>
<member name="M:FSComp.SR.optsNoOpt">
<summary>
 Only include optimization information essential for implementing inlined constructs. Inhibits cross-module inlining but improves binary compatibility.
 (Originally from FSComp.txt:860)
</summary>
</member>
<member name="M:FSComp.SR.optsNoInterface">
<summary>
 Don&apos;t add a resource to the generated assembly containing F#-specific metadata
 (Originally from FSComp.txt:861)
</summary>
</member>
<member name="M:FSComp.SR.optsNoCopyFsharpCore">
<summary>
 Don&apos;t copy FSharp.Core.dll along the produced binaries
 (Originally from FSComp.txt:934)
</summary>
</member>
<member name="M:FSComp.SR.optsNameOfOutputFile">
<summary>
 Name of the output file (Short form: -o)
 (Originally from FSComp.txt:848)
</summary>
</member>
<member name="M:FSComp.SR.optsMlcompatibility">
<summary>
 Ignore ML compatibility warnings
 (Originally from FSComp.txt:895)
</summary>
</member>
<member name="M:FSComp.SR.optsLinkresource">
<summary>
 Link the specified resource to this assembly where the resinfo format is &lt;file&gt;[,&lt;string name&gt;[,public|private]]
 (Originally from FSComp.txt:876)
</summary>
</member>
<member name="M:FSComp.SR.optsLib">
<summary>
 Specify a directory for the include path which is used to resolve source files and assemblies (Short form: -I)
 (Originally from FSComp.txt:904)
</summary>
</member>
<member name="M:FSComp.SR.optsInvalidWarningLevel(System.Int32)">
<summary>
 Invalid warning level &apos;%d&apos;
 (Originally from FSComp.txt:941)
</summary>
</member>
<member name="M:FSComp.SR.optsInvalidTargetProfile(System.String)">
<summary>
 Invalid value &apos;%s&apos; for &apos;--targetprofile&apos;, valid values are &apos;mscorlib&apos;, &apos;netcore&apos; or &apos;netstandard&apos;.
 (Originally from FSComp.txt:943)
</summary>
</member>
<member name="M:FSComp.SR.optsInvalidSubSystemVersion(System.String)">
<summary>
 Invalid version &apos;%s&apos; for &apos;--subsystemversion&apos;. The version must be 4.00 or greater.
 (Originally from FSComp.txt:942)
</summary>
</member>
<member name="M:FSComp.SR.optsInvalidResponseFile(System.String,System.String)">
<summary>
 Invalid response file &apos;%s&apos; ( &apos;%s&apos; )
 (Originally from FSComp.txt:1375)
</summary>
</member>
<member name="M:FSComp.SR.optsInvalidRefOut">
<summary>
 Invalid reference assembly path&apos;
 (Originally from FSComp.txt:1179)
</summary>
</member>
<member name="M:FSComp.SR.optsInvalidRefAssembly">
<summary>
 Invalid use of emitting a reference assembly, do not use &apos;--standalone or --staticlink&apos; with &apos;--refonly or --refout&apos;.
 (Originally from FSComp.txt:1180)
</summary>
</member>
<member name="M:FSComp.SR.optsInvalidPathMapFormat">
<summary>
 Invalid path map. Mappings must be comma separated and of the format &apos;path=sourcePath&apos;
 (Originally from FSComp.txt:1178)
</summary>
</member>
<member name="M:FSComp.SR.optsInternalNoDescription(System.String)">
<summary>
 The command-line option &apos;%s&apos; is for test purposes only
 (Originally from FSComp.txt:924)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerResources">
<summary>
 - RESOURCES -
 (Originally from FSComp.txt:918)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerOutputFiles">
<summary>
 - OUTPUT FILES -
 (Originally from FSComp.txt:916)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerMisc">
<summary>
 - MISCELLANEOUS -
 (Originally from FSComp.txt:921)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerLanguage">
<summary>
 - LANGUAGE -
 (Originally from FSComp.txt:922)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerInputFiles">
<summary>
 - INPUT FILES -
 (Originally from FSComp.txt:917)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerErrsAndWarns">
<summary>
 - ERRORS AND WARNINGS -
 (Originally from FSComp.txt:923)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerCodeGen">
<summary>
 - CODE GENERATION -
 (Originally from FSComp.txt:919)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerAdvanced">
<summary>
 - ADVANCED -
 (Originally from FSComp.txt:920)
</summary>
</member>
<member name="M:FSComp.SR.optsHelp">
<summary>
 Display this usage message (Short form: -?)
 (Originally from FSComp.txt:897)
</summary>
</member>
<member name="M:FSComp.SR.optsGetLangVersions">
<summary>
 Display the allowed values for language version.
 (Originally from FSComp.txt:1562)
</summary>
</member>
<member name="M:FSComp.SR.optsFullpaths">
<summary>
 Output messages with fully qualified paths
 (Originally from FSComp.txt:903)
</summary>
</member>
<member name="M:FSComp.SR.optsEmitDebugInfoInQuotations(System.String)">
<summary>
 Emit debug information in quotations (%s by default)
 (Originally from FSComp.txt:932)
</summary>
</member>
<member name="M:FSComp.SR.optsEmbedSource">
<summary>
 Embed specific source files in the portable PDB file
 (Originally from FSComp.txt:871)
</summary>
</member>
<member name="M:FSComp.SR.optsEmbedAllSource(System.String)">
<summary>
 Embed all source files in the portable PDB file (%s by default)
 (Originally from FSComp.txt:870)
</summary>
</member>
<member name="M:FSComp.SR.optsDeterministic(System.String)">
<summary>
 Produce a deterministic assembly (including module version GUID and timestamp) (%s by default)
 (Originally from FSComp.txt:881)
</summary>
</member>
<member name="M:FSComp.SR.optsDelaySign(System.String)">
<summary>
 Delay-sign the assembly using only the public portion of the strong name key (%s by default)
 (Originally from FSComp.txt:853)
</summary>
</member>
<member name="M:FSComp.SR.optsDefine">
<summary>
 Define conditional compilation symbols (Short form: -d)
 (Originally from FSComp.txt:894)
</summary>
</member>
<member name="M:FSComp.SR.optsDebugPM(System.String)">
<summary>
 Emit debug information (Short form: -g) (%s by default)
 (Originally from FSComp.txt:877)
</summary>
</member>
<member name="M:FSComp.SR.optsDebug(System.String)">
<summary>
 Specify debugging type: full, portable, embedded, pdbonly. (&apos;%s&apos; is the default if no debugging type specified and enables attaching a debugger to a running program, &apos;portable&apos; is a cross-platform format, &apos;embedded&apos; is a cross-platform format embedded into the output file).
 (Originally from FSComp.txt:878)
</summary>
</member>
<member name="M:FSComp.SR.optsDCLONoDescription(System.String)">
<summary>
 The command-line option &apos;%s&apos; has been deprecated
 (Originally from FSComp.txt:925)
</summary>
</member>
<member name="M:FSComp.SR.optsDCLOHtmlDoc(System.String)">
<summary>
 The command-line option &apos;%s&apos; has been deprecated. HTML document generation is now part of the F# Power Pack, via the tool FsHtmlDoc.exe.
 (Originally from FSComp.txt:927)
</summary>
</member>
<member name="M:FSComp.SR.optsDCLODeprecatedSuggestAlternative(System.String,System.String)">
<summary>
 The command-line option &apos;%s&apos; has been deprecated. Use &apos;%s&apos; instead.
 (Originally from FSComp.txt:926)
</summary>
</member>
<member name="M:FSComp.SR.optsCrossoptimize(System.String)">
<summary>
 Enable or disable cross-module optimizations (%s by default)
 (Originally from FSComp.txt:886)
</summary>
</member>
<member name="M:FSComp.SR.optsCopyrightCommunity">
<summary>
 Freely distributed under the MIT Open Source License.  https://github.com/Microsoft/visualfsharp/blob/master/License.txt
 (Originally from FSComp.txt:847)
</summary>
</member>
<member name="M:FSComp.SR.optsCopyright">
<summary>
 Copyright (c) Microsoft Corporation. All Rights Reserved.
 (Originally from FSComp.txt:846)
</summary>
</member>
<member name="M:FSComp.SR.optsConsoleColors(System.String)">
<summary>
 Output warning and error messages in color (%s by default)
 (Originally from FSComp.txt:928)
</summary>
</member>
<member name="M:FSComp.SR.optsCompressMetadata(System.String)">
<summary>
 Compress interface and optimization data files (%s by default)
 (Originally from FSComp.txt:858)
</summary>
</member>
<member name="M:FSComp.SR.optsCompilerTool">
<summary>
 Reference an assembly or directory containing a design time tool (Short form: -t)
 (Originally from FSComp.txt:865)
</summary>
</member>
<member name="M:FSComp.SR.optsCodepage">
<summary>
 Specify the codepage used to read source files
 (Originally from FSComp.txt:900)
</summary>
</member>
<member name="M:FSComp.SR.optsClirootDescription">
<summary>
 Use to override where the compiler looks for mscorlib.dll and framework components
 (Originally from FSComp.txt:915)
</summary>
</member>
<member name="M:FSComp.SR.optsClirootDeprecatedMsg">
<summary>
 The command-line option &apos;--cliroot&apos; has been deprecated. Use an explicit reference to a specific copy of mscorlib.dll instead.
 (Originally from FSComp.txt:914)
</summary>
</member>
<member name="M:FSComp.SR.optsClearResultsCache">
<summary>
 Clear the package manager results cache
 (Originally from FSComp.txt:901)
</summary>
</member>
<member name="M:FSComp.SR.optsChecksumAlgorithm">
<summary>
 Specify algorithm for calculating source file checksum stored in PDB. Supported values are: SHA1 or SHA256 (default)
 (Originally from FSComp.txt:906)
</summary>
</member>
<member name="M:FSComp.SR.optsChecked(System.String)">
<summary>
 Generate overflow checks (%s by default)
 (Originally from FSComp.txt:893)
</summary>
</member>
<member name="M:FSComp.SR.optsCheckNulls(System.String)">
<summary>
 Enable nullness declarations and checks (%s by default)
 (Originally from FSComp.txt:1560)
</summary>
</member>
<member name="M:FSComp.SR.optsBuildWindows">
<summary>
 Build a Windows executable
 (Originally from FSComp.txt:850)
</summary>
</member>
<member name="M:FSComp.SR.optsBuildModule">
<summary>
 Build a module that can be added to another assembly
 (Originally from FSComp.txt:852)
</summary>
</member>
<member name="M:FSComp.SR.optsBuildLibrary">
<summary>
 Build a library (Short form: -a)
 (Originally from FSComp.txt:851)
</summary>
</member>
<member name="M:FSComp.SR.optsBuildConsole">
<summary>
 Build a console executable
 (Originally from FSComp.txt:849)
</summary>
</member>
<member name="M:FSComp.SR.optsBaseaddress">
<summary>
 Base address for the library to be built
 (Originally from FSComp.txt:905)
</summary>
</member>
<member name="M:FSComp.SR.optsAllSigs">
<summary>
 Print the inferred interfaces of all compilation files to associated signature files
 (Originally from FSComp.txt:863)
</summary>
</member>
<member name="M:FSComp.SR.optValueMarkedInlineHasUnexpectedValue">
<summary>
 A value marked as &apos;inline&apos; has an unexpected value
 (Originally from FSComp.txt:997)
</summary>
</member>
<member name="M:FSComp.SR.optValueMarkedInlineCouldNotBeInlined">
<summary>
 A value marked as &apos;inline&apos; could not be inlined
 (Originally from FSComp.txt:998)
</summary>
</member>
<member name="M:FSComp.SR.optValueMarkedInlineButWasNotBoundInTheOptEnv(System.String)">
<summary>
 The value &apos;%s&apos; was marked inline but was not bound in the optimization environment
 (Originally from FSComp.txt:996)
</summary>
</member>
<member name="M:FSComp.SR.optValueMarkedInlineButIncomplete(System.String)">
<summary>
 The value &apos;%s&apos; was marked inline but its implementation makes use of an internal or private function which is not sufficiently accessible
 (Originally from FSComp.txt:995)
</summary>
</member>
<member name="M:FSComp.SR.optRecursiveValValue(System.String)">
<summary>
 Recursive ValValue %s
 (Originally from FSComp.txt:1000)
</summary>
</member>
<member name="M:FSComp.SR.optFailedToInlineValue(System.String)">
<summary>
 Failed to inline the value &apos;%s&apos; marked &apos;inline&apos;, perhaps because a recursive value was marked &apos;inline&apos;
 (Originally from FSComp.txt:999)
</summary>
</member>
<member name="M:FSComp.SR.optFailedToInlineSuggestedValue(System.String)">
<summary>
 The value &apos;%s&apos; was marked &apos;InlineIfLambda&apos; but was not determined to have a lambda value. This warning is for informational purposes only.
 (Originally from FSComp.txt:1706)
</summary>
</member>
<member name="M:FSComp.SR.nrUnionTypeNeedsQualifiedAccess(System.String,System.String)">
<summary>
 The union type for union case &apos;%s&apos; was defined with the RequireQualifiedAccessAttribute. Include the name of the union type (&apos;%s&apos;) in the name you are using.
 (Originally from FSComp.txt:1014)
</summary>
</member>
<member name="M:FSComp.SR.nrUnexpectedEmptyLongId">
<summary>
 Unexpected empty long identifier
 (Originally from FSComp.txt:1009)
</summary>
</member>
<member name="M:FSComp.SR.nrTypeInstantiationNeededToDisambiguateTypesWithSameName(System.String,System.String)">
<summary>
 Multiple types exist called &apos;%s&apos;, taking different numbers of generic parameters. Provide a type instantiation to disambiguate the type resolution, e.g. &apos;%s&apos;.
 (Originally from FSComp.txt:1005)
</summary>
</member>
<member name="M:FSComp.SR.nrTypeInstantiationIsMissingAndCouldNotBeInferred(System.String,System.String)">
<summary>
 The instantiation of the generic type &apos;%s&apos; is missing and can&apos;t be inferred from the arguments or return type of this member. Consider providing a type instantiation when accessing this type, e.g. &apos;%s&apos;.
 (Originally from FSComp.txt:1006)
</summary>
</member>
<member name="M:FSComp.SR.nrRecordTypeNeedsQualifiedAccess(System.String,System.String)">
<summary>
 The record type for the record field &apos;%s&apos; was defined with the RequireQualifiedAccessAttribute. Include the name of the record type (&apos;%s&apos;) in the name you are using.
 (Originally from FSComp.txt:1015)
</summary>
</member>
<member name="M:FSComp.SR.nrRecordDoesNotContainSuchLabel(System.String,System.String)">
<summary>
 The record type &apos;%s&apos; does not contain a label &apos;%s&apos;.
 (Originally from FSComp.txt:1010)
</summary>
</member>
<member name="M:FSComp.SR.nrNoConstructorsAvailableForType(System.String)">
<summary>
 No constructors are available for the type &apos;%s&apos;
 (Originally from FSComp.txt:1013)
</summary>
</member>
<member name="M:FSComp.SR.nrIsNotConstructorOrLiteral">
<summary>
 This is not a constructor or literal, or a constructor is being used incorrectly
 (Originally from FSComp.txt:1008)
</summary>
</member>
<member name="M:FSComp.SR.nrInvalidModuleExprType">
<summary>
 Invalid module/expression/type
 (Originally from FSComp.txt:1004)
</summary>
</member>
<member name="M:FSComp.SR.nrInvalidFieldLabel">
<summary>
 Invalid field label
 (Originally from FSComp.txt:1011)
</summary>
</member>
<member name="M:FSComp.SR.nrInvalidExpression(System.String)">
<summary>
 Invalid expression &apos;%s&apos;
 (Originally from FSComp.txt:1012)
</summary>
</member>
<member name="M:FSComp.SR.nrGlobalUsedOnlyAsFirstName">
<summary>
 &apos;global&apos; may only be used as the first name in a qualified path
 (Originally from FSComp.txt:1007)
</summary>
</member>
<member name="M:FSComp.SR.notAFunctionButMaybeIndexerWithName2(System.String)">
<summary>
 This value is not a function and cannot be applied. Did you intend to access the indexer via &apos;%s[index]&apos;?
 (Originally from FSComp.txt:1494)
</summary>
</member>
<member name="M:FSComp.SR.notAFunctionButMaybeIndexerWithName(System.String)">
<summary>
 This value is not a function and cannot be applied. Did you intend to access the indexer via &apos;%s.[index]&apos;?
 (Originally from FSComp.txt:1492)
</summary>
</member>
<member name="M:FSComp.SR.notAFunctionButMaybeIndexerErrorCode">
<summary>
 (Originally from FSComp.txt:1496)
</summary>
</member>
<member name="M:FSComp.SR.notAFunctionButMaybeIndexer2">
<summary>
 This expression is not a function and cannot be applied. Did you intend to access the indexer via &apos;expr[index]&apos;?
 (Originally from FSComp.txt:1495)
</summary>
</member>
<member name="M:FSComp.SR.notAFunctionButMaybeIndexer">
<summary>
 This expression is not a function and cannot be applied. Did you intend to access the indexer via &apos;expr.[index]&apos;?
 (Originally from FSComp.txt:1493)
</summary>
</member>
<member name="M:FSComp.SR.notAFunctionButMaybeDeclaration">
<summary>
 This value is not a function and cannot be applied. Did you forget to terminate a declaration?
 (Originally from FSComp.txt:1497)
</summary>
</member>
<member name="M:FSComp.SR.notAFunction">
<summary>
 This value is not a function and cannot be applied.
 (Originally from FSComp.txt:1491)
</summary>
</member>
<member name="M:FSComp.SR.noInvokeMethodsFound">
<summary>
 No Invoke methods found for delegate type
 (Originally from FSComp.txt:981)
</summary>
</member>
<member name="M:FSComp.SR.noEqualSignAfterModule">
<summary>
 Files in libraries or multiple-file applications must begin with a namespace or module declaration. When using a module declaration at the start of a file the &apos;=&apos; sign is not allowed. If this is a top-level module, consider removing the = to resolve this error.
 (Originally from FSComp.txt:58)
</summary>
</member>
<member name="M:FSComp.SR.nicePrintOtherOverloadsN(System.Int32)">
<summary>
 + %d overloads
 (Originally from FSComp.txt:1331)
</summary>
</member>
<member name="M:FSComp.SR.nicePrintOtherOverloads1">
<summary>
 + 1 overload
 (Originally from FSComp.txt:1330)
</summary>
</member>
<member name="M:FSComp.SR.nativeResourceHeaderMalformed(System.String)">
<summary>
 Resource header beginning at offset %s is malformed.
 (Originally from FSComp.txt:1567)
</summary>
</member>
<member name="M:FSComp.SR.nativeResourceFormatError">
<summary>
 Stream does not begin with a null resource and is not in &apos;.RES&apos; format.
 (Originally from FSComp.txt:1566)
</summary>
</member>
<member name="M:FSComp.SR.moreThanOneInvokeMethodFound">
<summary>
 More than one Invoke method found for delegate type
 (Originally from FSComp.txt:982)
</summary>
</member>
<member name="M:FSComp.SR.mlCompatStructEndNoLongerSupported">
<summary>
 The use of &apos;module M = struct ... end &apos; was deprecated in F# 2.0 and is no longer supported. Remove the &apos;struct&apos; and &apos;end&apos; and use indentation instead
 (Originally from FSComp.txt:1098)
</summary>
</member>
<member name="M:FSComp.SR.mlCompatSigEndNoLongerSupported">
<summary>
 The use of &apos;module M = sig ... end &apos; was deprecated in F# 2.0 and is no longer supported. Remove the &apos;sig&apos; and &apos;end&apos; and use indentation instead
 (Originally from FSComp.txt:1096)
</summary>
</member>
<member name="M:FSComp.SR.mlCompatSigColonNoLongerSupported">
<summary>
 The use of &apos;module M: sig ... end &apos; was deprecated in F# 2.0 and is no longer supported. Change the &apos;:&apos; to an &apos;=&apos; and remove the &apos;sig&apos; and &apos;end&apos; and use indentation instead
 (Originally from FSComp.txt:1095)
</summary>
</member>
<member name="M:FSComp.SR.mlCompatMultiPrefixTyparsNoLongerSupported">
<summary>
 The use of multiple parenthesized type parameters before a generic type name such as &apos;(int, int) Map&apos; was deprecated in F# 2.0 and is no longer supported
 (Originally from FSComp.txt:1097)
</summary>
</member>
<member name="M:FSComp.SR.mlCompatMessage(System.String)">
<summary>
 This construct is for ML compatibility. %s. You can disable this warning by using &apos;--mlcompatibility&apos; or &apos;--nowarn:62&apos;.
 (Originally from FSComp.txt:1091)
</summary>
</member>
<member name="M:FSComp.SR.mlCompatLightOffNoLongerSupported">
<summary>
 The use of &apos;#light \&quot;off\&quot;&apos; or &apos;#indent \&quot;off\&quot;&apos; was deprecated in F# 2.0 and is no longer supported
 (Originally from FSComp.txt:1094)
</summary>
</member>
<member name="M:FSComp.SR.mlCompatKeyword(System.String)">
<summary>
 In previous versions of F# &apos;%s&apos; was a reserved keyword but the use of this keyword is now deprecated
 (Originally from FSComp.txt:1093)
</summary>
</member>
<member name="M:FSComp.SR.mlCompatError(System.String)">
<summary>
 This construct is deprecated. %s. You can enable this feature by using &apos;--langversion:5.0&apos; and &apos;--mlcompatibility&apos;.
 (Originally from FSComp.txt:1092)
</summary>
</member>
<member name="M:FSComp.SR.missingElseBranch(System.String)">
<summary>
 This &apos;if&apos; expression is missing an &apos;else&apos; branch. Because &apos;if&apos; is an expression, and not a statement, add an &apos;else&apos; branch which also returns a value of type &apos;%s&apos;.
 (Originally from FSComp.txt:26)
</summary>
</member>
<member name="M:FSComp.SR.methodIsNotStatic(System.String)">
<summary>
 Method or object constructor &apos;%s&apos; is not static
 (Originally from FSComp.txt:1397)
</summary>
</member>
<member name="M:FSComp.SR.memberOperatorDefinitionWithNonTripleArgument(System.String,System.Int32)">
<summary>
 Infix operator member &apos;%s&apos; has %d initial argument(s). Expected a tuple of 3 arguments
 (Originally from FSComp.txt:1342)
</summary>
</member>
<member name="M:FSComp.SR.memberOperatorDefinitionWithNonPairArgument(System.String,System.Int32)">
<summary>
 Infix operator member &apos;%s&apos; has %d initial argument(s). Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...
 (Originally from FSComp.txt:1058)
</summary>
</member>
<member name="M:FSComp.SR.memberOperatorDefinitionWithNoArguments(System.String)">
<summary>
 Infix operator member &apos;%s&apos; has no arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...
 (Originally from FSComp.txt:1057)
</summary>
</member>
<member name="M:FSComp.SR.memberOperatorDefinitionWithCurriedArguments(System.String)">
<summary>
 Infix operator member &apos;%s&apos; has extra curried arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...
 (Originally from FSComp.txt:1059)
</summary>
</member>
<member name="M:FSComp.SR.matchNotAllowedForUnionCaseWithNoData">
<summary>
 Pattern discard is not allowed for union case that takes no data.
 (Originally from FSComp.txt:1725)
</summary>
</member>
<member name="M:FSComp.SR.loadingDescription">
<summary>
 (loading description...)
 (Originally from FSComp.txt:1338)
</summary>
</member>
<member name="M:FSComp.SR.listElementHasWrongTypeTuple(System.Int32,System.String,System.Int32,System.String)">
<summary>
 All elements of a list must be implicitly convertible to the type of the first element, which here is a tuple of length %d of type\n    %s    \nThis element is a tuple of length %d of type\n    %s    \n
 (Originally from FSComp.txt:23)
</summary>
</member>
<member name="M:FSComp.SR.listElementHasWrongType(System.String,System.String)">
<summary>
 All elements of a list must be implicitly convertible to the type of the first element, which here is &apos;%s&apos;. This element has type &apos;%s&apos;.
 (Originally from FSComp.txt:22)
</summary>
</member>
<member name="M:FSComp.SR.lexhlpIdentifiersContainingAtSymbolReserved">
<summary>
 Identifiers containing &apos;@&apos; are reserved for use in F# code generation
 (Originally from FSComp.txt:986)
</summary>
</member>
<member name="M:FSComp.SR.lexhlpIdentifierReserved(System.String)">
<summary>
 The identifier &apos;%s&apos; is reserved for future use by F#
 (Originally from FSComp.txt:987)
</summary>
</member>
<member name="M:FSComp.SR.lexfltTokenIsOffsideOfContextStartedEarlier(System.String)">
<summary>
 Unexpected syntax or possible incorrect indentation: this token is offside of context started at position %s. Try indenting this further.\nTo continue using non-conforming indentation, pass the &apos;--strict-indentation-&apos; flag to the compiler, or set the language version to F# 7.
 (Originally from FSComp.txt:1002)
</summary>
</member>
<member name="M:FSComp.SR.lexfltSeparatorTokensOfPatternMatchMisaligned">
<summary>
 The &apos;|&apos; tokens separating rules of this pattern match are misaligned by one column. Consider realigning your code or using further indentation.
 (Originally from FSComp.txt:1003)
</summary>
</member>
<member name="M:FSComp.SR.lexfltIncorrentIndentationOfIn">
<summary>
 The indentation of this &apos;in&apos; token is incorrect with respect to the corresponding &apos;let&apos;
 (Originally from FSComp.txt:1001)
</summary>
</member>
<member name="M:FSComp.SR.lexWrongNestedHashEndif">
<summary>
 Syntax error. Wrong nested #endif, unexpected tokens before it.
 (Originally from FSComp.txt:1054)
</summary>
</member>
<member name="M:FSComp.SR.lexUnmatchedRBracesInTripleQuote">
<summary>
 The interpolated string contains unmatched closing braces.
 (Originally from FSComp.txt:1132)
</summary>
</member>
<member name="M:FSComp.SR.lexUnexpectedChar(System.String)">
<summary>
 Unexpected character &apos;%s&apos;
 (Originally from FSComp.txt:1022)
</summary>
</member>
<member name="M:FSComp.SR.lexTripleQuoteInTripleQuote">
<summary>
 Invalid interpolated string. Triple quote string literals may not be used in interpolated expressions. Consider using an explicit &apos;let&apos; binding for the interpolation expression.
 (Originally from FSComp.txt:1655)
</summary>
</member>
<member name="M:FSComp.SR.lexTooManyPercentsInTripleQuote">
<summary>
 The interpolated triple quoted string literal does not start with enough &apos;$&apos; characters to allow this many consecutive &apos;%%&apos; characters.
 (Originally from FSComp.txt:1133)
</summary>
</member>
<member name="M:FSComp.SR.lexTooManyLBracesInTripleQuote">
<summary>
 The interpolated triple quoted string literal does not start with enough &apos;$&apos; characters to allow this many consecutive opening braces as content.
 (Originally from FSComp.txt:1131)
</summary>
</member>
<member name="M:FSComp.SR.lexTokenReserved">
<summary>
 This token is reserved for future use
 (Originally from FSComp.txt:1044)
</summary>
</member>
<member name="M:FSComp.SR.lexThisUnicodeOnlyInStringLiterals">
<summary>
 This Unicode encoding is only valid in string literals
 (Originally from FSComp.txt:1043)
</summary>
</member>
<member name="M:FSComp.SR.lexTabsNotAllowed">
<summary>
 TABs are not allowed in F# code unless the #indent \&quot;off\&quot; option is used
 (Originally from FSComp.txt:1045)
</summary>
</member>
<member name="M:FSComp.SR.lexSingleQuoteInSingleQuote">
<summary>
 Invalid interpolated string. Single quote or verbatim string literals may not be used in interpolated expressions in single quote or verbatim strings. Consider using an explicit &apos;let&apos; binding for the interpolation expression or use a triple quote string as the outer string literal.
 (Originally from FSComp.txt:1654)
</summary>
</member>
<member name="M:FSComp.SR.lexRBraceInInterpolatedString">
<summary>
 A &apos;}&apos; character must be escaped (by doubling) in an interpolated string.
 (Originally from FSComp.txt:1663)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideThirtyTwoBitUnsigned">
<summary>
 This number is outside the allowable range for 32-bit unsigned integers
 (Originally from FSComp.txt:1031)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideThirtyTwoBitSigned">
<summary>
 This number is outside the allowable range for 32-bit signed integers
 (Originally from FSComp.txt:1030)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideThirtyTwoBitFloat">
<summary>
 This number is outside the allowable range for 32-bit floats
 (Originally from FSComp.txt:1038)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideSixtyFourBitUnsigned">
<summary>
 This number is outside the allowable range for 64-bit unsigned integers
 (Originally from FSComp.txt:1033)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideSixtyFourBitSigned">
<summary>
 This number is outside the allowable range for 64-bit signed integers
 (Originally from FSComp.txt:1032)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideSixteenBitUnsigned">
<summary>
 This number is outside the allowable range for 16-bit unsigned integers
 (Originally from FSComp.txt:1029)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideSixteenBitSigned">
<summary>
 This number is outside the allowable range for 16-bit signed integers
 (Originally from FSComp.txt:1028)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideNativeUnsigned">
<summary>
 This number is outside the allowable range for unsigned native integers
 (Originally from FSComp.txt:1035)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideNativeSigned">
<summary>
 This number is outside the allowable range for signed native integers
 (Originally from FSComp.txt:1034)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideIntegerRange">
<summary>
 This number is outside the allowable range for this integer type
 (Originally from FSComp.txt:1017)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideEightBitUnsigned">
<summary>
 This number is outside the allowable range for 8-bit unsigned integers
 (Originally from FSComp.txt:1027)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideEightBitSignedHex">
<summary>
 This number is outside the allowable range for hexadecimal 8-bit signed integers
 (Originally from FSComp.txt:1026)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideEightBitSigned">
<summary>
 This number is outside the allowable range for 8-bit signed integers
 (Originally from FSComp.txt:1025)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideDecimal">
<summary>
 This number is outside the allowable range for decimal literals
 (Originally from FSComp.txt:1037)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidUnicodeLiteral(System.String)">
<summary>
 \U%s is not a valid Unicode character escape sequence
 (Originally from FSComp.txt:1128)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidTrigraphAsciiByteLiteral">
<summary>
 This is not a valid byte character literal. The value must be less than or equal to &apos;\127&apos;B.\nNote: In a future F# version this warning will be promoted to an error.
 (Originally from FSComp.txt:1041)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidNumericLiteral">
<summary>
 This is not a valid numeric literal. Valid numeric literals include 1, 0x1, 0o1, 0b1, 1l (int/int32), 1u (uint/uint32), 1L (int64), 1UL (uint64), 1s (int16), 1us (uint16), 1y (int8/sbyte), 1uy (uint8/byte), 1.0 (float/double), 1.0f (float32/single), 1.0m (decimal), 1I (bigint).
 (Originally from FSComp.txt:1039)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidLineNumber(System.String)">
<summary>
 Invalid line number: &apos;%s&apos;
 (Originally from FSComp.txt:1046)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidIdentifier">
<summary>
 This is not a valid identifier
 (Originally from FSComp.txt:1741)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidFloat">
<summary>
 Invalid floating point number
 (Originally from FSComp.txt:1036)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidCharLiteralInString(System.String,System.String)">
<summary>
 &apos;%s&apos; is not a valid character literal.\nNote: Currently the value is wrapped around byte range to &apos;%s&apos;. In a future F# version this warning will be promoted to an error.
 (Originally from FSComp.txt:1135)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidCharLiteral">
<summary>
 This is not a valid character literal
 (Originally from FSComp.txt:1042)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidAsciiByteLiteral">
<summary>
 This is not a valid byte character literal. The value must be less than or equal to &apos;\127&apos;B.
 (Originally from FSComp.txt:1040)
</summary>
</member>
<member name="M:FSComp.SR.lexIndentOffForML">
<summary>
 Consider using a file with extension &apos;.ml&apos; or &apos;.mli&apos; instead
 (Originally from FSComp.txt:1104)
</summary>
</member>
<member name="M:FSComp.SR.lexIfOCaml">
<summary>
 IF-FSHARP/IF-CAML regions are no longer supported
 (Originally from FSComp.txt:1105)
</summary>
</member>
<member name="M:FSComp.SR.lexIdentEndInMarkReserved(System.String)">
<summary>
 Identifiers followed by &apos;%s&apos; are reserved for future use
 (Originally from FSComp.txt:1024)
</summary>
</member>
<member name="M:FSComp.SR.lexHashIfMustHaveIdent">
<summary>
 #if directive should be immediately followed by an identifier
 (Originally from FSComp.txt:1053)
</summary>
</member>
<member name="M:FSComp.SR.lexHashIfMustBeFirst">
<summary>
 #if directive must appear as the first non-whitespace character on a line
 (Originally from FSComp.txt:1047)
</summary>
</member>
<member name="M:FSComp.SR.lexHashEndingNoMatchingIf">
<summary>
 #endif has no matching #if
 (Originally from FSComp.txt:1051)
</summary>
</member>
<member name="M:FSComp.SR.lexHashEndifRequiredForElse">
<summary>
 #endif required for #else
 (Originally from FSComp.txt:1049)
</summary>
</member>
<member name="M:FSComp.SR.lexHashEndifMustBeFirst">
<summary>
 #endif directive must appear as the first non-whitespace character on a line
 (Originally from FSComp.txt:1052)
</summary>
</member>
<member name="M:FSComp.SR.lexHashElseNoMatchingIf">
<summary>
 #else has no matching #if
 (Originally from FSComp.txt:1048)
</summary>
</member>
<member name="M:FSComp.SR.lexHashElseMustBeFirst">
<summary>
 #else directive must appear as the first non-whitespace character on a line
 (Originally from FSComp.txt:1050)
</summary>
</member>
<member name="M:FSComp.SR.lexHashBangMustBeFirstInFile">
<summary>
 #! may only appear as the first line at the start of a file.
 (Originally from FSComp.txt:1055)
</summary>
</member>
<member name="M:FSComp.SR.lexExtendedStringInterpolationNotSupported">
<summary>
 Extended string interpolation is not supported in this version of F#.
 (Originally from FSComp.txt:1134)
</summary>
</member>
<member name="M:FSComp.SR.lexCharNotAllowedInOperatorNames(System.String)">
<summary>
 &apos;%s&apos; is not permitted as a character in operator names and is reserved for future use
 (Originally from FSComp.txt:1021)
</summary>
</member>
<member name="M:FSComp.SR.lexByteStringMayNotBeInterpolated">
<summary>
 a byte string may not be interpolated
 (Originally from FSComp.txt:1657)
</summary>
</member>
<member name="M:FSComp.SR.lexByteArrayOutisdeAscii(System.Int32)">
<summary>
 This byte array literal contains %d non-ASCII characters. All characters should be &lt; 128y.
 (Originally from FSComp.txt:1136)
</summary>
</member>
<member name="M:FSComp.SR.lexByteArrayCannotEncode(System.Int32)">
<summary>
 This byte array literal contains %d characters that do not encode as a single byte
 (Originally from FSComp.txt:1023)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionYieldBang">
<summary>
 Used in a computation expression to append the result of a given computation expression to a collection of results for the containing computation expression.
 (Originally from FSComp.txt:1481)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionYield">
<summary>
 Used in a sequence expression to produce a value for a sequence.
 (Originally from FSComp.txt:1480)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionWith">
<summary>
 Used together with the match keyword in pattern matching expressions. Also used in object expressions, record copying expressions, and type extensions to introduce member definitions, and to introduce exception handlers.
 (Originally from FSComp.txt:1479)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionWhileBang">
<summary>
 Used in computation expressions to introduce a looping construct where the condition is the result of another computation expression.
 (Originally from FSComp.txt:1478)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionWhile">
<summary>
 Introduces a looping construct.
 (Originally from FSComp.txt:1477)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionWhen">
<summary>
 Used for Boolean conditions (when guards) on pattern matches and to introduce a constraint clause for a generic type parameter.
 (Originally from FSComp.txt:1476)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionVoid">
<summary>
 Indicates the .NET void type. Used when interoperating with other .NET languages.
 (Originally from FSComp.txt:1475)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionVal">
<summary>
 Used in a signature to indicate a value, or in a type to declare a member, in limited situations.
 (Originally from FSComp.txt:1474)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionUseBang">
<summary>
 Used instead of let! in computation expressions for computation expression results that implement IDisposable.
 (Originally from FSComp.txt:1473)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionUse">
<summary>
 Used instead of let for values that implement IDisposable
 (Originally from FSComp.txt:1472)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionUpcast">
<summary>
 Used to convert to a type that is higher in the inheritance chain.
 (Originally from FSComp.txt:1471)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionUntypedQuotation">
<summary>
 Delimits a untyped code quotation.
 (Originally from FSComp.txt:1487)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionTypedQuotation">
<summary>
 Delimits a typed code quotation.
 (Originally from FSComp.txt:1486)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionTypeTest">
<summary>
 Used to check if an object is of the given type in a pattern or binding.
 (Originally from FSComp.txt:1470)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionType">
<summary>
 Used to declare a class, record, structure, discriminated union, enumeration type, unit of measure, or type abbreviation.
 (Originally from FSComp.txt:1469)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionTry">
<summary>
 Used to introduce a block of code that might generate an exception. Used together with &apos;with&apos; or &apos;finally&apos;.
 (Originally from FSComp.txt:1468)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionTrueFalse">
<summary>
 Used as a Boolean literal.
 (Originally from FSComp.txt:1429)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionTo">
<summary>
 Used in for loops to indicate a range.
 (Originally from FSComp.txt:1467)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionThen">
<summary>
 Used in conditional expressions. Also used to perform side effects after object construction.
 (Originally from FSComp.txt:1466)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionStruct">
<summary>
 Used to declare a structure type. Also used in generic parameter constraints.
 (Originally from FSComp.txt:1465)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionStatic">
<summary>
 Used to indicate a method or property that can be called without an instance of a type, or a value member that is shared among all instances of a type.
 (Originally from FSComp.txt:1464)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionSig">
<summary>
 Keyword reserved for ML-compatibility.
 (Originally from FSComp.txt:1463)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionSelect">
<summary>
 Used in query expressions to specify what fields or columns to extract. Note that this is a contextual keyword, which means that it is not actually a reserved word and it only acts like a keyword in appropriate context.
 (Originally from FSComp.txt:1462)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionRightArrow">
<summary>
 In function types, delimits arguments and return values. Yields an expression (in sequence expressions); equivalent to the yield keyword. Used in match expressions
 (Originally from FSComp.txt:1482)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionReturnBang">
<summary>
 Used to provide a value for the result of the containing computation expression, where that value itself comes from the result another computation expression.
 (Originally from FSComp.txt:1461)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionReturn">
<summary>
 Used to provide a value for the result of the containing computation expression.
 (Originally from FSComp.txt:1460)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionRec">
<summary>
 Used to indicate that a function is recursive.
 (Originally from FSComp.txt:1459)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionPublic">
<summary>
 Allows access to a member from outside the type.
 (Originally from FSComp.txt:1458)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionPrivate">
<summary>
 Restricts access to a member to code in the same type or module.
 (Originally from FSComp.txt:1457)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionOverride">
<summary>
 Used to implement a version of an abstract or virtual method that differs from the base version.
 (Originally from FSComp.txt:1456)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionOr">
<summary>
 Used with Boolean conditions as a Boolean or operator. Equivalent to ||. Also used in member constraints.
 (Originally from FSComp.txt:1455)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionOpen">
<summary>
 Used to make the contents of a namespace or module available without qualification.
 (Originally from FSComp.txt:1454)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionOf">
<summary>
 Used in discriminated unions to indicate the type of categories of values, and in delegate and exception declarations.
 (Originally from FSComp.txt:1453)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionNull">
<summary>
 Indicates the absence of an object. Also used in generic parameter constraints.
 (Originally from FSComp.txt:1452)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionNot">
<summary>
 Not actually a keyword. However, not struct in combination is used as a generic parameter constraint.
 (Originally from FSComp.txt:1451)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionNew">
<summary>
 Used to declare, define, or invoke a constructor that creates or that can create an object. Also used in generic parameter constraints to indicate that a type must have a certain constructor.
 (Originally from FSComp.txt:1450)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionNamespace">
<summary>
 Used to associate a name with a group of related types and modules, to logically separate it from other code.
 (Originally from FSComp.txt:1449)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionMutable">
<summary>
 Used to declare a variable, that is, a value that can be changed.
 (Originally from FSComp.txt:1448)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionModule">
<summary>
 Used to associate a name with a group of related types, values, and functions, to logically separate it from other code.
 (Originally from FSComp.txt:1447)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionMember">
<summary>
 Used to declare a property or method in an object type.
 (Originally from FSComp.txt:1446)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionMatchBang">
<summary>
 Used in computation expressions to pattern match directly over the result of another computation expression.
 (Originally from FSComp.txt:1445)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionMatch">
<summary>
 Used to branch by comparing a value to a pattern.
 (Originally from FSComp.txt:1444)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionLetBang">
<summary>
 Used in computation expressions to bind a name to the result of another computation expression.
 (Originally from FSComp.txt:1443)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionLet">
<summary>
 Used to associate, or bind, a name to a value or function.
 (Originally from FSComp.txt:1442)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionLeftArrow">
<summary>
 Assigns a value to a variable.
 (Originally from FSComp.txt:1483)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionLazy">
<summary>
 Used to specify a computation that is to be performed only when a result is needed.
 (Originally from FSComp.txt:1441)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionInternal">
<summary>
 Used to specify that a member is visible inside an assembly but not outside it.
 (Originally from FSComp.txt:1440)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionInterface">
<summary>
 Used to declare and implement interfaces.
 (Originally from FSComp.txt:1439)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionInline">
<summary>
 Used to indicate a function that should be integrated directly into the caller&apos;s code.
 (Originally from FSComp.txt:1438)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionInherit">
<summary>
 Used to specify a base class or base interface.
 (Originally from FSComp.txt:1437)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionIn">
<summary>
 Used for sequence expressions and, in verbose syntax, to separate expressions from bindings.
 (Originally from FSComp.txt:1436)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionIf">
<summary>
 Used in conditional branching constructs.
 (Originally from FSComp.txt:1435)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionGlobal">
<summary>
 Used to reference the top-level .NET namespace.
 (Originally from FSComp.txt:1434)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionFunction">
<summary>
 Used as a shorter alternative to the fun keyword and a match expression in a lambda expression that has pattern matching on a single argument.
 (Originally from FSComp.txt:1433)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionFun">
<summary>
 Used in lambda expressions, also known as anonymous functions.
 (Originally from FSComp.txt:1432)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionFor">
<summary>
 Used in looping constructs.
 (Originally from FSComp.txt:1431)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionFinally">
<summary>
 Used together with try to introduce a block of code that executes regardless of whether an exception occurs.
 (Originally from FSComp.txt:1430)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionExtern">
<summary>
 Indicates that a declared program element is defined in another binary or assembly.
 (Originally from FSComp.txt:1428)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionException">
<summary>
 Used to declare an exception type.
 (Originally from FSComp.txt:1427)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionEnd">
<summary>
 In type definitions and type extensions, indicates the end of a section of member definitions. In verbose syntax, used to specify the end of a code block that starts with the begin keyword.
 (Originally from FSComp.txt:1426)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionElse">
<summary>
 Used in conditional branching.
 (Originally from FSComp.txt:1425)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionElif">
<summary>
 Used in conditional branching. A short form of else if.
 (Originally from FSComp.txt:1424)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionDynamicCast">
<summary>
 Converts a type to a type that is lower in the hierarchy.
 (Originally from FSComp.txt:1485)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionDownto">
<summary>
 In a for expression, used when counting in reverse.
 (Originally from FSComp.txt:1423)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionDowncast">
<summary>
 Used to convert to a type that is lower in the inheritance chain.
 (Originally from FSComp.txt:1422)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionDone">
<summary>
 In verbose syntax, indicates the end of a block of code in a looping expression.
 (Originally from FSComp.txt:1421)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionDo">
<summary>
 Used in looping constructs or to execute imperative code.
 (Originally from FSComp.txt:1420)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionDelegate">
<summary>
 Used to declare a delegate.
 (Originally from FSComp.txt:1419)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionDefault">
<summary>
 Indicates an implementation of an abstract method; used together with an abstract method declaration to create a virtual method.
 (Originally from FSComp.txt:1418)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionConst">
<summary>
 Keyword to specify a constant literal as a type parameter argument in Type Providers.
 (Originally from FSComp.txt:1417)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionClass">
<summary>
 In verbose syntax, indicates the start of a class definition.
 (Originally from FSComp.txt:1416)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionCast">
<summary>
 Converts a type to type that is higher in the hierarchy.
 (Originally from FSComp.txt:1484)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionBegin">
<summary>
 In verbose syntax, indicates the start of a code block.
 (Originally from FSComp.txt:1415)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionBase">
<summary>
 Used as the name of the base class object.
 (Originally from FSComp.txt:1414)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionAssert">
<summary>
 Used to verify code during debugging.
 (Originally from FSComp.txt:1413)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionAs">
<summary>
 Used to give the current class object an object name. Also used to give a name to a whole pattern within a pattern match.
 (Originally from FSComp.txt:1412)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionAnd">
<summary>
 Used in mutually recursive bindings, in property declarations, and with multiple constraints on generic parameters.
 (Originally from FSComp.txt:1411)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionAbstract">
<summary>
 Indicates a method that either has no implementation in the type in which it is declared or that is virtual and has a default implementation.
 (Originally from FSComp.txt:1410)
</summary>
</member>
<member name="M:FSComp.SR.itemNotFoundInTypeDuringDynamicCodeGen(System.String,System.String,System.String,System.String)">
<summary>
 %s &apos;%s&apos; not found in type &apos;%s&apos; from assembly &apos;%s&apos;. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.
 (Originally from FSComp.txt:1489)
</summary>
</member>
<member name="M:FSComp.SR.itemNotFoundDuringDynamicCodeGen(System.String,System.String,System.String)">
<summary>
 %s &apos;%s&apos; not found in assembly &apos;%s&apos;. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.
 (Originally from FSComp.txt:1488)
</summary>
</member>
<member name="M:FSComp.SR.invalidXmlDocPosition">
<summary>
 XML comment is not placed on a valid language element.
 (Originally from FSComp.txt:1709)
</summary>
</member>
<member name="M:FSComp.SR.invalidPlatformTarget">
<summary>
 The &apos;anycpu32bitpreferred&apos; platform can only be used with EXE targets. You must use &apos;anycpu&apos; instead.
 (Originally from FSComp.txt:1325)
</summary>
</member>
<member name="M:FSComp.SR.invalidNamespaceForProvidedType">
<summary>
 invalid namespace for provided type
 (Originally from FSComp.txt:1221)
</summary>
</member>
<member name="M:FSComp.SR.invalidFullNameForProvidedType">
<summary>
 invalid full name for provided type
 (Originally from FSComp.txt:1222)
</summary>
</member>
<member name="M:FSComp.SR.infosInvalidProvidedLiteralValue(System.String)">
<summary>
 Invalid provided literal value &apos;%s&apos;
 (Originally from FSComp.txt:1324)
</summary>
</member>
<member name="M:FSComp.SR.implicitlyDiscardedSequenceInSequenceExpression(System.String)">
<summary>
 This expression returns a value of type &apos;%s&apos; but is implicitly discarded. Consider using &apos;let&apos; to bind the result to a name, e.g. &apos;let result = expression&apos;. If you intended to use the expression as a value in the sequence then use an explicit &apos;yield!&apos;.
 (Originally from FSComp.txt:1501)
</summary>
</member>
<member name="M:FSComp.SR.implicitlyDiscardedInSequenceExpression(System.String)">
<summary>
 This expression returns a value of type &apos;%s&apos; but is implicitly discarded. Consider using &apos;let&apos; to bind the result to a name, e.g. &apos;let result = expression&apos;. If you intended to use the expression as a value in the sequence then use an explicit &apos;yield&apos;.
 (Originally from FSComp.txt:1500)
</summary>
</member>
<member name="M:FSComp.SR.implMissingInlineIfLambda">
<summary>
 The &apos;InlineIfLambda&apos; attribute is present in the signature but not the implementation.
 (Originally from FSComp.txt:1707)
</summary>
</member>
<member name="M:FSComp.SR.impTypeRequiredUnavailable(System.String,System.String)">
<summary>
 The type &apos;%s&apos; is required here and is unavailable. You must add a reference to assembly &apos;%s&apos;.
 (Originally from FSComp.txt:990)
</summary>
</member>
<member name="M:FSComp.SR.impReferencedTypeCouldNotBeFoundInAssembly(System.String,System.String)">
<summary>
 A reference to the type &apos;%s&apos; in assembly &apos;%s&apos; was found, but the type could not be found in that assembly
 (Originally from FSComp.txt:991)
</summary>
</member>
<member name="M:FSComp.SR.impReferenceToDllRequiredByAssembly(System.String,System.String,System.String)">
<summary>
 A reference to the DLL %s is required by assembly %s. The imported type %s is located in the first assembly and could not be resolved.
 (Originally from FSComp.txt:993)
</summary>
</member>
<member name="M:FSComp.SR.impNotEnoughTypeParamsInScopeWhileImporting">
<summary>
 Internal error or badly formed metadata: not enough type parameters were in scope while importing
 (Originally from FSComp.txt:992)
</summary>
</member>
<member name="M:FSComp.SR.impInvalidNumberOfGenericArguments(System.String,System.Int32,System.Int32)">
<summary>
 Invalid number of generic arguments to type &apos;%s&apos; in provided type. Expected &apos;%d&apos; arguments, given &apos;%d&apos;.
 (Originally from FSComp.txt:1301)
</summary>
</member>
<member name="M:FSComp.SR.impInvalidMeasureArgument2(System.String)">
<summary>
 Invalid value unit-of-measure parameter &apos;%s&apos;
 (Originally from FSComp.txt:1303)
</summary>
</member>
<member name="M:FSComp.SR.impInvalidMeasureArgument1(System.String,System.String)">
<summary>
 Invalid value &apos;%s&apos; for unit-of-measure parameter &apos;%s&apos;
 (Originally from FSComp.txt:1302)
</summary>
</member>
<member name="M:FSComp.SR.impImportedAssemblyUsesNotPublicType(System.String)">
<summary>
 An imported assembly uses the type &apos;%s&apos; but that type is not public
 (Originally from FSComp.txt:994)
</summary>
</member>
<member name="M:FSComp.SR.ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen">
<summary>
 Invalid argument to &apos;methodhandleof&apos; during codegen
 (Originally from FSComp.txt:1263)
</summary>
</member>
<member name="M:FSComp.SR.ilxgenInvalidConstructInStateMachineDuringCodegen(System.String)">
<summary>
 The resumable code construct &apos;%s&apos; may only be used in inlined code protected by &apos;if __useResumableCode then ...&apos; and the overall composition must form valid resumable code.
 (Originally from FSComp.txt:1684)
</summary>
</member>
<member name="M:FSComp.SR.ilxGenUnknownDebugPoint(System.String,System.String)">
<summary>
 Unknown debug point &apos;%s&apos;. The available debug points are &apos;%s&apos;.
 (Originally from FSComp.txt:1695)
</summary>
</member>
<member name="M:FSComp.SR.ilwriteErrorCreatingPdb(System.String)">
<summary>
 Unexpected error creating debug information file &apos;%s&apos;
 (Originally from FSComp.txt:1016)
</summary>
</member>
<member name="M:FSComp.SR.ilreadFileChanged(System.String)">
<summary>
 The file &apos;%s&apos; changed on disk unexpectedly, please reload.
 (Originally from FSComp.txt:1502)
</summary>
</member>
<member name="M:FSComp.SR.ilUnexpectedUnrealizedValue">
<summary>
 Compiler error: unexpected unrealized value
 (Originally from FSComp.txt:835)
</summary>
</member>
<member name="M:FSComp.SR.ilUnexpectedGetSetAnnotation">
<summary>
 Unexpected GetSet annotation on a property
 (Originally from FSComp.txt:838)
</summary>
</member>
<member name="M:FSComp.SR.ilUndefinedValue(System.String)">
<summary>
 Undefined value &apos;%s&apos;
 (Originally from FSComp.txt:822)
</summary>
</member>
<member name="M:FSComp.SR.ilTypeCannotBeUsedForLiteralField">
<summary>
 This type cannot be used for a literal field
 (Originally from FSComp.txt:837)
</summary>
</member>
<member name="M:FSComp.SR.ilStructLayoutAttributeCouldNotBeDecoded">
<summary>
 The StructLayout attribute could not be decoded
 (Originally from FSComp.txt:840)
</summary>
</member>
<member name="M:FSComp.SR.ilStaticMethodIsNotLambda(System.String)">
<summary>
 GenSetStorage: %s was represented as a static method but was not an appropriate lambda expression
 (Originally from FSComp.txt:833)
</summary>
</member>
<member name="M:FSComp.SR.ilSignatureForExternalFunctionContainsTypeParameters">
<summary>
 The signature for this external function contains type parameters. Constrain the argument and return types to indicate the types of the corresponding C function.
 (Originally from FSComp.txt:830)
</summary>
</member>
<member name="M:FSComp.SR.ilSignRsaKeyExpected">
<summary>
 RSA key expected
 (Originally from FSComp.txt:1145)
</summary>
</member>
<member name="M:FSComp.SR.ilSignPrivateKeyExpected">
<summary>
 Private key expected
 (Originally from FSComp.txt:1144)
</summary>
</member>
<member name="M:FSComp.SR.ilSignNoSignatureDirectory">
<summary>
 No signature directory
 (Originally from FSComp.txt:1150)
</summary>
</member>
<member name="M:FSComp.SR.ilSignInvalidSignatureSize">
<summary>
 Invalid signature size
 (Originally from FSComp.txt:1149)
</summary>
</member>
<member name="M:FSComp.SR.ilSignInvalidRSAParams">
<summary>
 Invalid RSAParameters structure - &apos;{0}&apos; expected
 (Originally from FSComp.txt:1147)
</summary>
</member>
<member name="M:FSComp.SR.ilSignInvalidPKBlob">
<summary>
 Invalid Public Key blob
 (Originally from FSComp.txt:1151)
</summary>
</member>
<member name="M:FSComp.SR.ilSignInvalidMagicValue">
<summary>
 Invalid Magic value in CLR Header
 (Originally from FSComp.txt:1142)
</summary>
</member>
<member name="M:FSComp.SR.ilSignInvalidBitLen">
<summary>
 Invalid bit Length
 (Originally from FSComp.txt:1146)
</summary>
</member>
<member name="M:FSComp.SR.ilSignInvalidAlgId">
<summary>
 Invalid algId - &apos;Exponent&apos; expected
 (Originally from FSComp.txt:1148)
</summary>
</member>
<member name="M:FSComp.SR.ilSignBadImageFormat">
<summary>
 Bad image format
 (Originally from FSComp.txt:1143)
</summary>
</member>
<member name="M:FSComp.SR.ilReflectedDefinitionsCannotUseSliceOperator">
<summary>
 Reflected definitions cannot contain uses of the prefix splice operator &apos;%%&apos;
 (Originally from FSComp.txt:842)
</summary>
</member>
<member name="M:FSComp.SR.ilMutableVariablesCannotEscapeMethod">
<summary>
 Mutable variables cannot escape their method
 (Originally from FSComp.txt:834)
</summary>
</member>
<member name="M:FSComp.SR.ilMarshalAsAttributeCannotBeDecoded">
<summary>
 The MarshalAs attribute could not be decoded
 (Originally from FSComp.txt:829)
</summary>
</member>
<member name="M:FSComp.SR.ilMainModuleEmpty">
<summary>
 Main module of program is empty: nothing will happen when it is run
 (Originally from FSComp.txt:836)
</summary>
</member>
<member name="M:FSComp.SR.ilLiteralFieldsCannotBeSet">
<summary>
 Literal fields cannot be set
 (Originally from FSComp.txt:832)
</summary>
</member>
<member name="M:FSComp.SR.ilLabelNotFound(System.String)">
<summary>
 Label %s not found
 (Originally from FSComp.txt:823)
</summary>
</member>
<member name="M:FSComp.SR.ilIncorrectNumberOfTypeArguments">
<summary>
 Incorrect number of type arguments to local call
 (Originally from FSComp.txt:824)
</summary>
</member>
<member name="M:FSComp.SR.ilFieldOffsetAttributeCouldNotBeDecoded">
<summary>
 The FieldOffset attribute could not be decoded
 (Originally from FSComp.txt:839)
</summary>
</member>
<member name="M:FSComp.SR.ilFieldHasOffsetForSequentialLayout">
<summary>
 The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)
 (Originally from FSComp.txt:1108)
</summary>
</member>
<member name="M:FSComp.SR.ilFieldDoesNotHaveValidOffsetForStructureLayout(System.String,System.String)">
<summary>
 The type &apos;%s&apos; has been marked as having an Explicit layout, but the field &apos;%s&apos; has not been marked with the &apos;FieldOffset&apos; attribute
 (Originally from FSComp.txt:1099)
</summary>
</member>
<member name="M:FSComp.SR.ilDynamicInvocationNotSupported(System.String)">
<summary>
 Dynamic invocation of %s is not supported
 (Originally from FSComp.txt:825)
</summary>
</member>
<member name="M:FSComp.SR.ilDllImportAttributeCouldNotBeDecoded">
<summary>
 The DllImport attribute could not be decoded
 (Originally from FSComp.txt:831)
</summary>
</member>
<member name="M:FSComp.SR.ilDefaultAugmentationAttributeCouldNotBeDecoded">
<summary>
 The DefaultAugmentation attribute could not be decoded
 (Originally from FSComp.txt:841)
</summary>
</member>
<member name="M:FSComp.SR.ilCustomMarshallersCannotBeUsedInFSharp">
<summary>
 Custom marshallers cannot be specified in F# code. Consider using a C# helper function.
 (Originally from FSComp.txt:828)
</summary>
</member>
<member name="M:FSComp.SR.ilAddressOfValueHereIsInvalid(System.String)">
<summary>
 This operation involves taking the address of a value &apos;%s&apos; represented using a local variable or other special representation. This is invalid.
 (Originally from FSComp.txt:827)
</summary>
</member>
<member name="M:FSComp.SR.ilAddressOfLiteralFieldIsInvalid">
<summary>
 Taking the address of a literal field is invalid
 (Originally from FSComp.txt:826)
</summary>
</member>
<member name="M:FSComp.SR.ifExpressionTuple(System.Int32,System.String,System.Int32,System.String)">
<summary>
 The &apos;if&apos; expression needs to return a tuple of length %d of type\n    %s    \nto satisfy context type requirements. It currently returns a tuple of length %d of type\n    %s    \n
 (Originally from FSComp.txt:28)
</summary>
</member>
<member name="M:FSComp.SR.ifExpression(System.String,System.String)">
<summary>
 The &apos;if&apos; expression needs to have type &apos;%s&apos; to satisfy context type requirements. It currently has type &apos;%s&apos;.
 (Originally from FSComp.txt:27)
</summary>
</member>
<member name="P:FSComp.SR.SwallowResourceText">
<summary>
 If set to true, then all error messages will just return the filled &apos;holes&apos; delimited by &apos;,,,&apos;s - this is for language-neutral testing (e.g. localization-invariant baselines).
</summary>
</member>
<member name="M:FSComp.SR.fsiInvalidDirective(System.String,System.String)">
<summary>
 Invalid directive &apos;#%s %s&apos;
 (Originally from FSComp.txt:1558)
</summary>
</member>
<member name="M:FSComp.SR.fsharpCoreNotFoundToBeCopied">
<summary>
 Cannot find FSharp.Core.dll in compiler&apos;s directory
 (Originally from FSComp.txt:1378)
</summary>
</member>
<member name="M:FSComp.SR.fscTwoResourceManifests">
<summary>
 Conflicting options specified: &apos;win32manifest&apos; and &apos;win32res&apos;. Only one of these can be used.
 (Originally from FSComp.txt:1157)
</summary>
</member>
<member name="M:FSComp.SR.fscTooManyErrors">
<summary>
 Exiting - too many errors
 (Originally from FSComp.txt:1153)
</summary>
</member>
<member name="M:FSComp.SR.fscSystemRuntimeInteropServicesIsRequired">
<summary>
 System.Runtime.InteropServices assembly is required to use UnknownWrapper\DispatchWrapper classes.
 (Originally from FSComp.txt:1360)
</summary>
</member>
<member name="M:FSComp.SR.fscStaticLinkingNoProfileMismatches">
<summary>
 Static linking may not be used on an assembly referencing mscorlib (e.g. a .NET Framework assembly) when generating an assembly that references System.Runtime (e.g. a .NET Core or Portable assembly).
 (Originally from FSComp.txt:1176)
</summary>
</member>
<member name="M:FSComp.SR.fscStaticLinkingNoMixedDLL">
<summary>
 Static linking may not include a mixed managed/unmanaged DLL
 (Originally from FSComp.txt:1161)
</summary>
</member>
<member name="M:FSComp.SR.fscStaticLinkingNoEXE">
<summary>
 Static linking may not include a .EXE
 (Originally from FSComp.txt:1160)
</summary>
</member>
<member name="M:FSComp.SR.fscResxSourceFileDeprecated(System.String)">
<summary>
 Passing a .resx file (%s) as a source file to the compiler is deprecated. Use resgen.exe to transform the .resx file into a .resources file to pass as a --resource option. If you are using MSBuild, this can be done via an &lt;EmbeddedResource&gt; item in the .fsproj project file.
 (Originally from FSComp.txt:1175)
</summary>
</member>
<member name="M:FSComp.SR.fscRemotingError">
<summary>
 The resident compilation service was not used because a problem occurred in communicating with the server.
 (Originally from FSComp.txt:1173)
</summary>
</member>
<member name="M:FSComp.SR.fscReferenceOnCommandLine(System.String)">
<summary>
 The assembly &apos;%s&apos; is listed on the command line. Assemblies should be referenced using a command line flag such as &apos;-r&apos;.
 (Originally from FSComp.txt:1172)
</summary>
</member>
<member name="M:FSComp.SR.fscQuotationLiteralsStaticLinking0">
<summary>
 Code in this assembly makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.
 (Originally from FSComp.txt:1159)
</summary>
</member>
<member name="M:FSComp.SR.fscQuotationLiteralsStaticLinking(System.String)">
<summary>
 The code in assembly &apos;%s&apos; makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.
 (Originally from FSComp.txt:1158)
</summary>
</member>
<member name="M:FSComp.SR.fscProblemWritingBinary(System.String,System.String)">
<summary>
 A problem occurred writing the binary &apos;%s&apos;: %s
 (Originally from FSComp.txt:1166)
</summary>
</member>
<member name="M:FSComp.SR.fscNoImplementationFiles">
<summary>
 No implementation files specified
 (Originally from FSComp.txt:1155)
</summary>
</member>
<member name="M:FSComp.SR.fscKeyNameWarning">
<summary>
 Option &apos;--keycontainer&apos; overrides attribute &apos;System.Reflection.AssemblyNameAttribute&apos; given in a source file or added module
 (Originally from FSComp.txt:1171)
</summary>
</member>
<member name="M:FSComp.SR.fscKeyFileWarning">
<summary>
 Option &apos;--keyfile&apos; overrides attribute &apos;System.Reflection.AssemblyKeyFileAttribute&apos; given in a source file or added module
 (Originally from FSComp.txt:1170)
</summary>
</member>
<member name="M:FSComp.SR.fscKeyFileCouldNotBeOpened(System.String)">
<summary>
 The key file &apos;%s&apos; could not be opened
 (Originally from FSComp.txt:1165)
</summary>
</member>
<member name="M:FSComp.SR.fscIgnoringMixedWhenLinking(System.String)">
<summary>
 Ignoring mixed managed/unmanaged assembly &apos;%s&apos; during static linking
 (Originally from FSComp.txt:1162)
</summary>
</member>
<member name="M:FSComp.SR.fscDelaySignWarning">
<summary>
 Option &apos;--delaysign&apos; overrides attribute &apos;System.Reflection.AssemblyDelaySignAttribute&apos; given in a source file or added module
 (Originally from FSComp.txt:1169)
</summary>
</member>
<member name="M:FSComp.SR.fscBadAssemblyVersion(System.String,System.String)">
<summary>
 The attribute %s specified version &apos;%s&apos;, but this value is invalid and has been ignored
 (Originally from FSComp.txt:1156)
</summary>
</member>
<member name="M:FSComp.SR.fscAssumeStaticLinkContainsNoDependencies(System.String)">
<summary>
 Assembly &apos;%s&apos; was referenced transitively and the assembly could not be resolved automatically. Static linking will assume this DLL has no dependencies on the F# library or other statically linked DLLs. Consider adding an explicit reference to this DLL.
 (Originally from FSComp.txt:1163)
</summary>
</member>
<member name="M:FSComp.SR.fscAssemblyWildcardAndDeterminism(System.String,System.String)">
<summary>
 An %s specified version &apos;%s&apos;, but this value is a wildcard, and you have requested a deterministic build, these are in conflict.
 (Originally from FSComp.txt:1177)
</summary>
</member>
<member name="M:FSComp.SR.fscAssemblyVersionAttributeIgnored">
<summary>
 The &apos;AssemblyVersionAttribute&apos; has been ignored because a version was given using a command line option
 (Originally from FSComp.txt:1167)
</summary>
</member>
<member name="M:FSComp.SR.fscAssemblyNotFoundInDependencySet(System.String)">
<summary>
 Assembly &apos;%s&apos; not found in dependency set of target binary. Statically linked roots should be specified using an assembly name, without a DLL or EXE extension. If this assembly was referenced explicitly then it is possible the assembly was not actually required by the generated binary, in which case it should not be statically linked.
 (Originally from FSComp.txt:1164)
</summary>
</member>
<member name="M:FSComp.SR.fscAssemblyCultureAttributeError">
<summary>
 Error emitting &apos;System.Reflection.AssemblyCultureAttribute&apos; attribute -- &apos;Executables cannot be satellite assemblies, Culture should always be empty&apos;
 (Originally from FSComp.txt:1168)
</summary>
</member>
<member name="M:FSComp.SR.fromEndSlicingRequiresVFive">
<summary>
 The &apos;from the end slicing&apos; feature requires language version &apos;preview&apos;.
 (Originally from FSComp.txt:1549)
</summary>
</member>
<member name="M:FSComp.SR.formatDashItem(System.String)">
<summary>
  - %s
 (Originally from FSComp.txt:1568)
</summary>
</member>
<member name="M:FSComp.SR.forPrefixFlagSpacePlusSetTwice">
<summary>
 Prefix flag (&apos; &apos; or &apos;+&apos;) set twice
 (Originally from FSComp.txt:232)
</summary>
</member>
<member name="M:FSComp.SR.forPrecisionMissingAfterDot">
<summary>
 Precision missing after the &apos;.&apos;
 (Originally from FSComp.txt:237)
</summary>
</member>
<member name="M:FSComp.SR.forPositionalSpecifiersNotPermitted">
<summary>
 Positional specifiers are not permitted in format strings
 (Originally from FSComp.txt:229)
</summary>
</member>
<member name="M:FSComp.SR.forPercentAInReflectionFreeCode">
<summary>
 The &apos;%%A&apos; format specifier may not be used in an assembly being compiled with option &apos;--reflectionfree&apos;. This construct implicitly uses reflection.
 (Originally from FSComp.txt:244)
</summary>
</member>
<member name="M:FSComp.SR.forMissingFormatSpecifier">
<summary>
 Missing format specifier
 (Originally from FSComp.txt:230)
</summary>
</member>
<member name="M:FSComp.SR.forLIsUnnecessary">
<summary>
 The &apos;l&apos; or &apos;L&apos; in this format specifier is unnecessary. In F# code you can use %%d, %%x, %%o or %%u instead, which are overloaded to work with all basic integer types.
 (Originally from FSComp.txt:240)
</summary>
</member>
<member name="M:FSComp.SR.forHashSpecifierIsInvalid">
<summary>
 The # formatting modifier is invalid in F#
 (Originally from FSComp.txt:233)
</summary>
</member>
<member name="M:FSComp.SR.forHIsUnnecessary">
<summary>
 The &apos;h&apos; or &apos;H&apos; in this format specifier is unnecessary. You can use %%d, %%x, %%o or %%u instead, which are overloaded to work with all basic integer types.
 (Originally from FSComp.txt:241)
</summary>
</member>
<member name="M:FSComp.SR.forFormatInvalidForInterpolated4">
<summary>
 Interpolated strings used as type IFormattable or type FormattableString may not use &apos;%%&apos; specifiers, only .NET-style interpolands such as &apos;{expr}&apos;, &apos;{expr,3}&apos; or &apos;{expr:N5}&apos; may be used.
 (Originally from FSComp.txt:1651)
</summary>
</member>
<member name="M:FSComp.SR.forFormatInvalidForInterpolated3">
<summary>
 The &apos;%%P&apos; specifier may not be used explicitly.
 (Originally from FSComp.txt:1650)
</summary>
</member>
<member name="M:FSComp.SR.forFormatInvalidForInterpolated2">
<summary>
 .NET-style format specifiers such as &apos;{x,3}&apos; or &apos;{x:N5}&apos; may not be mixed with &apos;%%&apos; format specifiers.
 (Originally from FSComp.txt:1649)
</summary>
</member>
<member name="M:FSComp.SR.forFormatInvalidForInterpolated">
<summary>
 Interpolated strings may not use &apos;%%&apos; format specifiers unless each is given an expression, e.g. &apos;%%d{1+1}&apos;.
 (Originally from FSComp.txt:1648)
</summary>
</member>
<member name="M:FSComp.SR.forFormatDoesntSupportPrecision(System.String)">
<summary>
 &apos;%s&apos; format does not support precision
 (Originally from FSComp.txt:238)
</summary>
</member>
<member name="M:FSComp.SR.forFlagSetTwice(System.String)">
<summary>
 &apos;%s&apos; flag set twice
 (Originally from FSComp.txt:231)
</summary>
</member>
<member name="M:FSComp.SR.forDoesNotSupportZeroFlag(System.String)">
<summary>
 &apos;%s&apos; format does not support &apos;0&apos; flag
 (Originally from FSComp.txt:236)
</summary>
</member>
<member name="M:FSComp.SR.forDoesNotSupportPrefixFlag(System.String,System.String)">
<summary>
 &apos;%s&apos; does not support prefix &apos;%s&apos; flag
 (Originally from FSComp.txt:242)
</summary>
</member>
<member name="M:FSComp.SR.forBadWidth">
<summary>
 Bad width in format specifier
 (Originally from FSComp.txt:235)
</summary>
</member>
<member name="M:FSComp.SR.forBadPrecision">
<summary>
 Bad precision in format specifier
 (Originally from FSComp.txt:234)
</summary>
</member>
<member name="M:FSComp.SR.forBadFormatSpecifierGeneral(System.String)">
<summary>
 Bad format specifier: &apos;%s&apos;
 (Originally from FSComp.txt:243)
</summary>
</member>
<member name="M:FSComp.SR.forBadFormatSpecifier">
<summary>
 Bad format specifier (after l or L): Expected ld,li,lo,lu,lx or lX. In F# code you can use %%d, %%x, %%o or %%u instead, which are overloaded to work with all basic integer types.
 (Originally from FSComp.txt:239)
</summary>
</member>
<member name="M:FSComp.SR.followingPatternMatchClauseHasWrongTypeTuple(System.Int32,System.String,System.Int32,System.String)">
<summary>
 All branches of a pattern match expression must return values implicitly convertible to the type of the first branch, which here is a tuple of length %d of type\n    %s    \nThis branch returns a tuple of length %d of type\n    %s    \n
 (Originally from FSComp.txt:32)
</summary>
</member>
<member name="M:FSComp.SR.followingPatternMatchClauseHasWrongType(System.String,System.String)">
<summary>
 All branches of a pattern match expression must return values implicitly convertible to the type of the first branch, which here is &apos;%s&apos;. This branch returns a value of type &apos;%s&apos;.
 (Originally from FSComp.txt:31)
</summary>
</member>
<member name="M:FSComp.SR.fieldIsNotAccessible(System.String)">
<summary>
 The record, struct or class field &apos;%s&apos; is not accessible from this code location
 (Originally from FSComp.txt:978)
</summary>
</member>
<member name="M:FSComp.SR.featureWitnessPassing">
<summary>
 witness passing for trait constraints in F# quotations
 (Originally from FSComp.txt:1585)
</summary>
</member>
<member name="M:FSComp.SR.featureWildCardInForLoop">
<summary>
 wild card in for loop
 (Originally from FSComp.txt:1570)
</summary>
</member>
<member name="M:FSComp.SR.featureWhileBang">
<summary>
 &apos;while!&apos; expression
 (Originally from FSComp.txt:1613)
</summary>
</member>
<member name="M:FSComp.SR.featureWarningWhenMultipleRecdTypeChoice">
<summary>
 Raises warnings when multiple record type matches were found during name resolution because of overlapping field names.
 (Originally from FSComp.txt:1608)
</summary>
</member>
<member name="M:FSComp.SR.featureWarningWhenInliningMethodImplNoInlineMarkedFunction">
<summary>
 Raises warnings when &apos;let inline ... =&apos; is used together with [&lt;MethodImpl(MethodImplOptions.NoInlining)&gt;] attribute. Function is not getting inlined.
 (Originally from FSComp.txt:1599)
</summary>
</member>
<member name="M:FSComp.SR.featureWarningWhenCopyAndUpdateRecordChangesAllFields">
<summary>
 Raises warnings when an copy-and-update record expression changes all fields of a record.
 (Originally from FSComp.txt:1603)
</summary>
</member>
<member name="M:FSComp.SR.featureWarningIndexedPropertiesGetSetSameType">
<summary>
 Indexed properties getter and setter must have the same type
 (Originally from FSComp.txt:1617)
</summary>
</member>
<member name="M:FSComp.SR.featureUseTypeSubsumptionCache">
<summary>
 Use type conversion cache during compilation
 (Originally from FSComp.txt:1788)
</summary>
</member>
<member name="M:FSComp.SR.featureUnmanagedConstraintCsharpInterop">
<summary>
 Interop between C#&apos;s and F#&apos;s unmanaged generic constraint (emit additional modreq)
 (Originally from FSComp.txt:1756)
</summary>
</member>
<member name="M:FSComp.SR.featureUnionIsPropertiesVisible">
<summary>
 Union case test properties
 (Originally from FSComp.txt:1619)
</summary>
</member>
<member name="M:FSComp.SR.featureTryWithInSeqExpressions">
<summary>
 Support for try-with in sequence expressions
 (Originally from FSComp.txt:1602)
</summary>
</member>
<member name="M:FSComp.SR.featureSupportValueOptionsAsOptionalParameters">
<summary>
 Support ValueOption as valid type for optional member parameters
 (Originally from FSComp.txt:1793)
</summary>
</member>
<member name="M:FSComp.SR.featureStructActivePattern">
<summary>
 struct representation for active patterns
 (Originally from FSComp.txt:1587)
</summary>
</member>
<member name="M:FSComp.SR.featureStringInterpolation">
<summary>
 string interpolation
 (Originally from FSComp.txt:1584)
</summary>
</member>
<member name="M:FSComp.SR.featureStrictIndentation">
<summary>
 Raises errors on incorrect indentation, allows better recovery and analysis during editing
 (Originally from FSComp.txt:1610)
</summary>
</member>
<member name="M:FSComp.SR.featureStaticMembersInInterfaces">
<summary>
 Static members in interfaces
 (Originally from FSComp.txt:1604)
</summary>
</member>
<member name="M:FSComp.SR.featureStaticLetInRecordsDusEmptyTypes">
<summary>
 Allow static let bindings in union, record, struct, non-incremental-class types
 (Originally from FSComp.txt:1745)
</summary>
</member>
<member name="M:FSComp.SR.featureSingleUnderscorePattern">
<summary>
 single underscore pattern
 (Originally from FSComp.txt:1569)
</summary>
</member>
<member name="M:FSComp.SR.featureSelfTypeConstraints">
<summary>
 self type constraints
 (Originally from FSComp.txt:1592)
</summary>
</member>
<member name="M:FSComp.SR.featureReuseSameFieldsInStructUnions">
<summary>
 Share underlying fields in a [&lt;Struct&gt;] discriminated union as long as they have same name and type
 (Originally from FSComp.txt:1765)
</summary>
</member>
<member name="M:FSComp.SR.featureResumableStateMachines">
<summary>
 resumable state machines
 (Originally from FSComp.txt:1581)
</summary>
</member>
<member name="M:FSComp.SR.featureRequiredProperties">
<summary>
 support for required properties
 (Originally from FSComp.txt:1593)
</summary>
</member>
<member name="M:FSComp.SR.featureRelaxWhitespace2">
<summary>
 whitespace relaxation v2
 (Originally from FSComp.txt:1588)
</summary>
</member>
<member name="M:FSComp.SR.featureRelaxWhitespace">
<summary>
 whitespace relaxation
 (Originally from FSComp.txt:1571)
</summary>
</member>
<member name="M:FSComp.SR.featureRefCellNotationInformationals">
<summary>
 informational messages related to reference cells
 (Originally from FSComp.txt:1255)
</summary>
</member>
<member name="M:FSComp.SR.featureReallyLongList">
<summary>
 list literals of any size
 (Originally from FSComp.txt:1589)
</summary>
</member>
<member name="M:FSComp.SR.featurePrintfBinaryFormat">
<summary>
 binary formatting for integers
 (Originally from FSComp.txt:1253)
</summary>
</member>
<member name="M:FSComp.SR.featurePreferStringGetPinnableReference">
<summary>
 prefer String.GetPinnableReference in fixed bindings
 (Originally from FSComp.txt:1615)
</summary>
</member>
<member name="M:FSComp.SR.featurePreferExtensionMethodOverPlainProperty">
<summary>
 prefer extension method over plain property
 (Originally from FSComp.txt:1616)
</summary>
</member>
<member name="M:FSComp.SR.featureParsedHashDirectiveUnexpectedInteger(System.Int32)">
<summary>
 Unexpected integer literal &apos;%d&apos;.
 (Originally from FSComp.txt:1781)
</summary>
</member>
<member name="M:FSComp.SR.featureParsedHashDirectiveUnexpectedIdentifier(System.String)">
<summary>
 Unexpected identifier &apos;%s&apos;.
 (Originally from FSComp.txt:1782)
</summary>
</member>
<member name="M:FSComp.SR.featureParsedHashDirectiveArgumentNonString">
<summary>
 # directives with non-quoted string arguments
 (Originally from FSComp.txt:1780)
</summary>
</member>
<member name="M:FSComp.SR.featurePackageManagement">
<summary>
 package management
 (Originally from FSComp.txt:1576)
</summary>
</member>
<member name="M:FSComp.SR.featureOverloadsForCustomOperations">
<summary>
 overloads for custom operations
 (Originally from FSComp.txt:1251)
</summary>
</member>
<member name="M:FSComp.SR.featureOpenTypeDeclaration">
<summary>
 open type declaration
 (Originally from FSComp.txt:1574)
</summary>
</member>
<member name="M:FSComp.SR.featureNullnessChecking">
<summary>
 nullness checking
 (Originally from FSComp.txt:1580)
</summary>
</member>
<member name="M:FSComp.SR.featureNullableOptionalInterop">
<summary>
 nullable optional interop
 (Originally from FSComp.txt:1582)
</summary>
</member>
<member name="M:FSComp.SR.featureNonVariablePatternsToRightOfAsPatterns">
<summary>
 non-variable patterns to the right of &apos;as&apos; patterns
 (Originally from FSComp.txt:1257)
</summary>
</member>
<member name="M:FSComp.SR.featureNonInlineLiteralsAsPrintfFormat">
<summary>
 String values marked as literals and IL constants as printf format
 (Originally from FSComp.txt:1605)
</summary>
</member>
<member name="M:FSComp.SR.featureNestedCopyAndUpdate">
<summary>
 Nested record field copy-and-update
 (Originally from FSComp.txt:1606)
</summary>
</member>
<member name="M:FSComp.SR.featureNameOf">
<summary>
 nameof
 (Originally from FSComp.txt:1572)
</summary>
</member>
<member name="M:FSComp.SR.featureMatchNotAllowedForUnionCaseWithNoData">
<summary>
 Pattern match discard is not allowed for union case that takes no data.
 (Originally from FSComp.txt:1596)
</summary>
</member>
<member name="M:FSComp.SR.featureMLCompatRevisions">
<summary>
 ML compatibility revisions
 (Originally from FSComp.txt:1259)
</summary>
</member>
<member name="M:FSComp.SR.featureLowercaseDUWhenRequireQualifiedAccess">
<summary>
 Allow lowercase DU when RequireQualifiedAccess attribute
 (Originally from FSComp.txt:1595)
</summary>
</member>
<member name="M:FSComp.SR.featureLowerSimpleMappingsInComprehensionsToFastLoops">
<summary>
 Lowers [for x in xs -&gt; f x] and [|for x in xs -&gt; f x|] to fast loops when xs is a list or an array, respectively.
 (Originally from FSComp.txt:1624)
</summary>
</member>
<member name="M:FSComp.SR.featureLowerInterpolatedStringToConcat">
<summary>
 Optimizes interpolated strings in certain cases, by lowering to concatenation
 (Originally from FSComp.txt:1622)
</summary>
</member>
<member name="M:FSComp.SR.featureLowerIntegralRangesToFastLoops">
<summary>
 Optimizes certain uses of the integral range (..) and range-step (.. ..) operators to fast while-loops.
 (Originally from FSComp.txt:1623)
</summary>
</member>
<member name="M:FSComp.SR.featureInterfacesWithMultipleGenericInstantiation">
<summary>
 interfaces with multiple generic instantiation
 (Originally from FSComp.txt:1631)
</summary>
</member>
<member name="M:FSComp.SR.featureInterfacesWithAbstractStaticMembers">
<summary>
 static abstract interface members
 (Originally from FSComp.txt:1591)
</summary>
</member>
<member name="M:FSComp.SR.featureInitProperties">
<summary>
 support for consuming init properties
 (Originally from FSComp.txt:1594)
</summary>
</member>
<member name="M:FSComp.SR.featureInformationalObjInferenceDiagnostic">
<summary>
 Diagnostic 3559 (warn when obj inferred) at informational level, off by default
 (Originally from FSComp.txt:1744)
</summary>
</member>
<member name="M:FSComp.SR.featureIndexerNotationWithoutDot">
<summary>
 expr[idx] notation for indexing and slicing
 (Originally from FSComp.txt:1254)
</summary>
</member>
<member name="M:FSComp.SR.featureImprovedImpliedArgumentNames">
<summary>
 Improved implied argument names
 (Originally from FSComp.txt:1609)
</summary>
</member>
<member name="M:FSComp.SR.featureImplicitYield">
<summary>
 implicit yield
 (Originally from FSComp.txt:1573)
</summary>
</member>
<member name="M:FSComp.SR.featureFromEndSlicing">
<summary>
 from-end slicing
 (Originally from FSComp.txt:1577)
</summary>
</member>
<member name="M:FSComp.SR.featureFixedIndexSlice3d4d">
<summary>
 fixed-index slice 3d/4d
 (Originally from FSComp.txt:1578)
</summary>
</member>
<member name="M:FSComp.SR.featureExtendedStringInterpolation">
<summary>
 Extended string interpolation similar to C# raw string literals.
 (Originally from FSComp.txt:1607)
</summary>
</member>
<member name="M:FSComp.SR.featureExtendedFixedBindings">
<summary>
 extended fixed bindings for byref and GetPinnableReference
 (Originally from FSComp.txt:1614)
</summary>
</member>
<member name="M:FSComp.SR.featureExpandedMeasurables">
<summary>
 more types support units of measure
 (Originally from FSComp.txt:1252)
</summary>
</member>
<member name="M:FSComp.SR.featureEscapeBracesInFormattableString">
<summary>
 Escapes curly braces before calling FormattableStringFactory.Create when interpolated string literal is typed as FormattableString
 (Originally from FSComp.txt:1728)
</summary>
</member>
<member name="M:FSComp.SR.featureErrorReportingOnStaticClasses">
<summary>
 Error reporting on static classes
 (Originally from FSComp.txt:1601)
</summary>
</member>
<member name="M:FSComp.SR.featureErrorOnDeprecatedRequireQualifiedAccess">
<summary>
 give error on deprecated access of construct with RequireQualifiedAccess attribute
 (Originally from FSComp.txt:1590)
</summary>
</member>
<member name="M:FSComp.SR.featureErrorForNonVirtualMembersOverrides">
<summary>
 Raises errors for non-virtual members overrides
 (Originally from FSComp.txt:1598)
</summary>
</member>
<member name="M:FSComp.SR.featureEnforceAttributeTargets">
<summary>
 Enforce AttributeTargets
 (Originally from FSComp.txt:1621)
</summary>
</member>
<member name="M:FSComp.SR.featureEmptyBodiedComputationExpressions">
<summary>
 Support for computation expressions with empty bodies: builder { }
 (Originally from FSComp.txt:1783)
</summary>
</member>
<member name="M:FSComp.SR.featureDotlessFloat32Literal">
<summary>
 dotless float32 literal
 (Originally from FSComp.txt:1575)
</summary>
</member>
<member name="M:FSComp.SR.featureDontWarnOnUppercaseIdentifiersInBindingPatterns">
<summary>
 Don&apos;t warn on uppercase identifiers in binding patterns
 (Originally from FSComp.txt:1790)
</summary>
</member>
<member name="M:FSComp.SR.featureDiscardUseValue">
<summary>
 discard pattern in use binding
 (Originally from FSComp.txt:1256)
</summary>
</member>
<member name="M:FSComp.SR.featureDeprecatePlacesWhereSeqCanBeOmitted">
<summary>
 Deprecate places where &apos;seq&apos; can be omitted
 (Originally from FSComp.txt:1792)
</summary>
</member>
<member name="M:FSComp.SR.featureDelegateTypeNameResolutionFix">
<summary>
 fix to resolution of delegate type names, see https://github.com/dotnet/fsharp/issues/10228
 (Originally from FSComp.txt:1261)
</summary>
</member>
<member name="M:FSComp.SR.featureDefaultInterfaceMemberConsumption">
<summary>
 default interface member consumption
 (Originally from FSComp.txt:1583)
</summary>
</member>
<member name="M:FSComp.SR.featureConstraintIntersectionOnFlexibleTypes">
<summary>
 Constraint intersection on flexible types
 (Originally from FSComp.txt:1611)
</summary>
</member>
<member name="M:FSComp.SR.featureChkTailCallAttrOnNonRec">
<summary>
 Raises warnings if the &apos;TailCall&apos; attribute is used on non-recursive functions.
 (Originally from FSComp.txt:1618)
</summary>
</member>
<member name="M:FSComp.SR.featureChkNotTailRecursive">
<summary>
 Raises warnings if a member or function has the &apos;TailCall&apos; attribute, but is not being used in a tail recursive way.
 (Originally from FSComp.txt:1612)
</summary>
</member>
<member name="M:FSComp.SR.featureCSharpExtensionAttributeNotRequired">
<summary>
 Allow implicit Extension attribute on declaring types, modules
 (Originally from FSComp.txt:1597)
</summary>
</member>
<member name="M:FSComp.SR.featureBooleanReturningAndReturnTypeDirectedPartialActivePattern">
<summary>
 Boolean-returning and return-type-directed partial active patterns
 (Originally from FSComp.txt:1620)
</summary>
</member>
<member name="M:FSComp.SR.featureBetterExceptionPrinting">
<summary>
 automatic generation of &apos;Message&apos; property for &apos;exception&apos; declarations
 (Originally from FSComp.txt:1260)
</summary>
</member>
<member name="M:FSComp.SR.featureAttributesToRightOfModuleKeyword">
<summary>
 attributes to the right of the &apos;module&apos; keyword
 (Originally from FSComp.txt:1258)
</summary>
</member>
<member name="M:FSComp.SR.featureArithmeticInLiterals">
<summary>
 Arithmetic and logical operations in literals, enum definitions and attributes
 (Originally from FSComp.txt:1600)
</summary>
</member>
<member name="M:FSComp.SR.featureAndBang">
<summary>
 applicative computation expressions
 (Originally from FSComp.txt:1579)
</summary>
</member>
<member name="M:FSComp.SR.featureAllowObjectExpressionWithoutOverrides">
<summary>
 Allow object expressions without overrides
 (Originally from FSComp.txt:1787)
</summary>
</member>
<member name="M:FSComp.SR.featureAllowAccessModifiersToAutoPropertiesGettersAndSetters">
<summary>
 Allow access modifiers to auto properties getters and setters
 (Originally from FSComp.txt:1785)
</summary>
</member>
<member name="M:FSComp.SR.featureAdditionalImplicitConversions">
<summary>
 additional type-directed conversions
 (Originally from FSComp.txt:1586)
</summary>
</member>
<member name="M:FSComp.SR.featureAccessorFunctionShorthand">
<summary>
 underscore dot shorthand for accessor only function
 (Originally from FSComp.txt:1751)
</summary>
</member>
<member name="M:FSComp.SR.fSharpBannerVersion(System.String,System.String)">
<summary>
 %s for F# %s
 (Originally from FSComp.txt:1561)
</summary>
</member>
<member name="M:FSComp.SR.expressionHasNoName">
<summary>
 Expression does not have a name.
 (Originally from FSComp.txt:1525)
</summary>
</member>
<member name="M:FSComp.SR.experimentalConstruct">
<summary>
 This construct is experimental
 (Originally from FSComp.txt:980)
</summary>
</member>
<member name="M:FSComp.SR.eventHasNonStandardType(System.String,System.String,System.String)">
<summary>
 The event &apos;%s&apos; has a non-standard type. If this event is declared in another CLI language, you may need to access this event using the explicit %s and %s methods for the event. If this event is declared in F#, make the type of the event an instantiation of either &apos;IDelegateEvent&lt;_&gt;&apos; or &apos;IEvent&lt;_,_&gt;&apos;.
 (Originally from FSComp.txt:973)
</summary>
</member>
<member name="M:FSComp.SR.etUnsupportedProvidedExpression(System.String)">
<summary>
 Unsupported expression &apos;%s&apos; from type provider. If you are the author of this type provider, consider adjusting it to provide a different provided expression.
 (Originally from FSComp.txt:1200)
</summary>
</member>
<member name="M:FSComp.SR.etUnsupportedMemberKind(System.String,System.String)">
<summary>
 Invalid member &apos;%s&apos; on provided type &apos;%s&apos;. Only properties, methods and constructors are allowed
 (Originally from FSComp.txt:1192)
</summary>
</member>
<member name="M:FSComp.SR.etUnsupportedConstantType(System.String)">
<summary>
 Unsupported constant type &apos;%s&apos;. Quotations provided by type providers can only contain simple constants. The implementation of the type provider may need to be adjusted by moving a value declared outside a provided quotation literal to be a &apos;let&apos; binding inside the quotation literal.
 (Originally from FSComp.txt:1199)
</summary>
</member>
<member name="M:FSComp.SR.etUnknownStaticArgumentKind(System.String,System.String)">
<summary>
 Unknown static argument kind &apos;%s&apos; when resolving a reference to a provided type or method &apos;%s&apos;
 (Originally from FSComp.txt:1218)
</summary>
</member>
<member name="M:FSComp.SR.etUnexpectedNullFromProvidedTypeMember(System.String,System.String)">
<summary>
 Unexpected &apos;null&apos; return value from provided type &apos;%s&apos; member &apos;%s&apos;
 (Originally from FSComp.txt:1213)
</summary>
</member>
<member name="M:FSComp.SR.etUnexpectedExceptionFromProvidedTypeMember(System.String,System.String,System.String)">
<summary>
 Unexpected exception from provided type &apos;%s&apos; member &apos;%s&apos;: %s
 (Originally from FSComp.txt:1198)
</summary>
</member>
<member name="M:FSComp.SR.etUnexpectedExceptionFromProvidedMemberMember(System.String,System.String,System.String,System.String)">
<summary>
 Unexpected exception from member &apos;%s&apos; of provided type &apos;%s&apos; member &apos;%s&apos;: %s
 (Originally from FSComp.txt:1214)
</summary>
</member>
<member name="M:FSComp.SR.etTypeProviderConstructorException(System.String)">
<summary>
 The type provider constructor has thrown an exception: %s
 (Originally from FSComp.txt:1224)
</summary>
</member>
<member name="M:FSComp.SR.etTooManyStaticParameters(System.Int32,System.Int32,System.Int32)">
<summary>
 Too many static parameters. Expected at most %d parameters, but got %d unnamed and %d named parameters.
 (Originally from FSComp.txt:1323)
</summary>
</member>
<member name="M:FSComp.SR.etStaticParameterRequiresAValue(System.String,System.String,System.String,System.String)">
<summary>
 The static parameter &apos;%s&apos; of the provided type or method &apos;%s&apos; requires a value. Static parameters to type providers may be optionally specified using named arguments, e.g. &apos;%s&lt;%s=...&gt;&apos;.
 (Originally from FSComp.txt:1244)
</summary>
</member>
<member name="M:FSComp.SR.etStaticParameterAlreadyHasValue(System.String)">
<summary>
 The static parameter &apos;%s&apos; has already been given a value
 (Originally from FSComp.txt:1246)
</summary>
</member>
<member name="M:FSComp.SR.etProviderReturnedNull(System.String)">
<summary>
 The type provider returned &apos;null&apos;, which is not a valid return value from &apos;%s&apos;
 (Originally from FSComp.txt:1223)
</summary>
</member>
<member name="M:FSComp.SR.etProviderHasWrongDesignerAssemblyNoPath(System.String,System.String,System.String,System.String)">
<summary>
 Assembly attribute &apos;%s&apos; refers to a designer assembly &apos;%s&apos; which cannot be loaded or doesn&apos;t exist. The exception reported was: %s - %s
 (Originally from FSComp.txt:1204)
</summary>
</member>
<member name="M:FSComp.SR.etProviderHasWrongDesignerAssembly(System.String,System.String,System.String,System.String,System.String)">
<summary>
 Assembly attribute &apos;%s&apos; refers to a designer assembly &apos;%s&apos; which cannot be loaded from path &apos;%s&apos;. The exception reported was: %s - %s
 (Originally from FSComp.txt:1205)
</summary>
</member>
<member name="M:FSComp.SR.etProviderHasDesignerAssemblyException(System.String,System.String,System.String,System.String)">
<summary>
 The type provider designer assembly &apos;%s&apos; could not be loaded from folder &apos;%s&apos;. The exception reported was: %s - %s
 (Originally from FSComp.txt:1220)
</summary>
</member>
<member name="M:FSComp.SR.etProviderHasDesignerAssemblyDependency(System.String,System.String,System.String,System.String)">
<summary>
 The type provider designer assembly &apos;%s&apos; could not be loaded from folder &apos;%s&apos; because a dependency was missing or could not loaded. All dependencies of the type provider designer assembly must be located in the same folder as that assembly. The exception reported was: %s - %s
 (Originally from FSComp.txt:1219)
</summary>
</member>
<member name="M:FSComp.SR.etProviderErrorWithContext(System.String,System.String,System.String,System.String)">
<summary>
 The type provider &apos;%s&apos; reported an error in the context of provided type &apos;%s&apos;, member &apos;%s&apos;. The error: %s
 (Originally from FSComp.txt:1237)
</summary>
</member>
<member name="M:FSComp.SR.etProviderError(System.String,System.String)">
<summary>
 The type provider &apos;%s&apos; reported an error: %s
 (Originally from FSComp.txt:1207)
</summary>
</member>
<member name="M:FSComp.SR.etProviderDoesNotHaveValidConstructor">
<summary>
 The type provider does not have a valid constructor. A constructor taking either no arguments or one argument of type &apos;TypeProviderConfig&apos; was expected.
 (Originally from FSComp.txt:1206)
</summary>
</member>
<member name="M:FSComp.SR.etProvidedTypeWithNullOrEmptyName(System.String)">
<summary>
 The &apos;%s&apos; of a provided type was null or empty.
 (Originally from FSComp.txt:1239)
</summary>
</member>
<member name="M:FSComp.SR.etProvidedTypeWithNameException(System.String,System.String)">
<summary>
 An exception occurred when accessing the &apos;%s&apos; of a provided type: %s
 (Originally from FSComp.txt:1238)
</summary>
</member>
<member name="M:FSComp.SR.etProvidedTypeReferenceMissingArgument(System.String)">
<summary>
 A reference to a provided type was missing a value for the static parameter &apos;%s&apos;. You may need to recompile one or more referenced assemblies.
 (Originally from FSComp.txt:1264)
</summary>
</member>
<member name="M:FSComp.SR.etProvidedTypeReferenceInvalidText(System.String)">
<summary>
 A reference to a provided type had an invalid value &apos;%s&apos; for a static parameter. You may need to recompile one or more referenced assemblies.
 (Originally from FSComp.txt:1265)
</summary>
</member>
<member name="M:FSComp.SR.etProvidedTypeHasUnexpectedPath(System.String,System.String)">
<summary>
 Expected provided type with path &apos;%s&apos; but provided type has path &apos;%s&apos;
 (Originally from FSComp.txt:1212)
</summary>
</member>
<member name="M:FSComp.SR.etProvidedTypeHasUnexpectedName(System.String,System.String)">
<summary>
 Expected provided type named &apos;%s&apos; but provided type has &apos;Name&apos; with value &apos;%s&apos;
 (Originally from FSComp.txt:1201)
</summary>
</member>
<member name="M:FSComp.SR.etProvidedAppliedTypeHadWrongName(System.String,System.String,System.String)">
<summary>
 The type provider &apos;%s&apos; returned an invalid type from &apos;ApplyStaticArguments&apos;. A type with name &apos;%s&apos; was expected, but a type with name &apos;%s&apos; was returned.
 (Originally from FSComp.txt:1226)
</summary>
</member>
<member name="M:FSComp.SR.etProvidedAppliedMethodHadWrongName(System.String,System.String,System.String)">
<summary>
 The type provider &apos;%s&apos; returned an invalid method from &apos;ApplyStaticArgumentsForMethod&apos;. A method with name &apos;%s&apos; was expected, but a method with name &apos;%s&apos; was returned.
 (Originally from FSComp.txt:1227)
</summary>
</member>
<member name="M:FSComp.SR.etPropertyNeedsCanWriteOrCanRead(System.String,System.String)">
<summary>
 Property &apos;%s&apos; on provided type &apos;%s&apos; is neither readable nor writable as it has CanRead=false and CanWrite=false
 (Originally from FSComp.txt:1304)
</summary>
</member>
<member name="M:FSComp.SR.etPropertyHasSetterButNoCanWrite(System.String,System.String)">
<summary>
 Property &apos;%s&apos; on provided type &apos;%s&apos; has CanWrite=false but GetSetMethod() returned a method
 (Originally from FSComp.txt:1196)
</summary>
</member>
<member name="M:FSComp.SR.etPropertyHasGetterButNoCanRead(System.String,System.String)">
<summary>
 Property &apos;%s&apos; on provided type &apos;%s&apos; has CanRead=false but GetGetMethod() returned a method
 (Originally from FSComp.txt:1194)
</summary>
</member>
<member name="M:FSComp.SR.etPropertyCanWriteButHasNoSetter(System.String,System.String)">
<summary>
 Property &apos;%s&apos; on provided type &apos;%s&apos; has CanWrite=true but there was no value from GetSetMethod()
 (Originally from FSComp.txt:1195)
</summary>
</member>
<member name="M:FSComp.SR.etPropertyCanReadButHasNoGetter(System.String,System.String)">
<summary>
 Property &apos;%s&apos; on provided type &apos;%s&apos; has CanRead=true but there was no value from GetGetMethod()
 (Originally from FSComp.txt:1193)
</summary>
</member>
<member name="M:FSComp.SR.etOneOrMoreErrorsSeenDuringExtensionTypeSetting">
<summary>
 One or more errors seen during provided type setup
 (Originally from FSComp.txt:1197)
</summary>
</member>
<member name="M:FSComp.SR.etNullProvidedExpression(System.String)">
<summary>
 Type provider &apos;%s&apos; returned null from GetInvokerExpression.
 (Originally from FSComp.txt:1225)
</summary>
</member>
<member name="M:FSComp.SR.etNullOrEmptyMemberName(System.String)">
<summary>
 The provided type &apos;%s&apos; returned a member with a null or empty member name
 (Originally from FSComp.txt:1182)
</summary>
</member>
<member name="M:FSComp.SR.etNullMemberDeclaringTypeDifferentFromProvidedType(System.String,System.String,System.String)">
<summary>
 The provided type &apos;%s&apos; has member &apos;%s&apos; which has declaring type &apos;%s&apos;. Expected declaring type to be the same as provided type.
 (Originally from FSComp.txt:1185)
</summary>
</member>
<member name="M:FSComp.SR.etNullMemberDeclaringType(System.String,System.String)">
<summary>
 The provided type &apos;%s&apos; member info &apos;%s&apos; has null declaring type
 (Originally from FSComp.txt:1184)
</summary>
</member>
<member name="M:FSComp.SR.etNullMember(System.String)">
<summary>
 The provided type &apos;%s&apos; returned a null member
 (Originally from FSComp.txt:1183)
</summary>
</member>
<member name="M:FSComp.SR.etNoStaticParameterWithName(System.String)">
<summary>
 No static parameter exists with name &apos;%s&apos;
 (Originally from FSComp.txt:1245)
</summary>
</member>
<member name="M:FSComp.SR.etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters">
<summary>
 Nested provided types do not take static arguments or generic parameters
 (Originally from FSComp.txt:1215)
</summary>
</member>
<member name="M:FSComp.SR.etMustNotBeGeneric(System.String)">
<summary>
 Provided type &apos;%s&apos; has &apos;IsGenericType&apos; as true, but generic types are not supported.
 (Originally from FSComp.txt:1189)
</summary>
</member>
<member name="M:FSComp.SR.etMustNotBeAnArray(System.String)">
<summary>
 Provided type &apos;%s&apos; has &apos;IsArray&apos; as true, but array types are not supported.
 (Originally from FSComp.txt:1190)
</summary>
</member>
<member name="M:FSComp.SR.etMultipleStaticParameterWithName(System.String)">
<summary>
 Multiple static parameters exist with name &apos;%s&apos;
 (Originally from FSComp.txt:1247)
</summary>
</member>
<member name="M:FSComp.SR.etMissingStaticArgumentsToMethod">
<summary>
 This provided method requires static parameters
 (Originally from FSComp.txt:1380)
</summary>
</member>
<member name="M:FSComp.SR.etMethodHasRequirements(System.String,System.String)">
<summary>
 Invalid member &apos;%s&apos; on provided type &apos;%s&apos;. Provided type members must be public, and not be generic, virtual, or abstract.
 (Originally from FSComp.txt:1191)
</summary>
</member>
<member name="M:FSComp.SR.etInvalidTypeProviderAssemblyName(System.String,System.String)">
<summary>
 Assembly &apos;%s&apos; has TypeProviderAssembly attribute with invalid value &apos;%s&apos;. The value should be a valid assembly name
 (Originally from FSComp.txt:1232)
</summary>
</member>
<member name="M:FSComp.SR.etInvalidStaticArgument(System.String)">
<summary>
 Invalid static argument to provided type. Expected an argument of kind &apos;%s&apos;.
 (Originally from FSComp.txt:1216)
</summary>
</member>
<member name="M:FSComp.SR.etIncorrectProvidedMethod(System.String,System.String,System.Int32,System.String)">
<summary>
 The type provider &apos;%s&apos; provided a method with a name &apos;%s&apos; and metadata token &apos;%d&apos;, which is not reported among its methods of its declaring type &apos;%s&apos;
 (Originally from FSComp.txt:1209)
</summary>
</member>
<member name="M:FSComp.SR.etIncorrectProvidedConstructor(System.String,System.String)">
<summary>
 The type provider &apos;%s&apos; provided a constructor which is not reported among the constructors of its declaring type &apos;%s&apos;
 (Originally from FSComp.txt:1210)
</summary>
</member>
<member name="M:FSComp.SR.etIncorrectParameterExpression(System.String,System.String)">
<summary>
 The type provider &apos;%s&apos; used an invalid parameter in the ParameterExpression: %s
 (Originally from FSComp.txt:1208)
</summary>
</member>
<member name="M:FSComp.SR.etIllegalCharactersInTypeName(System.String,System.String)">
<summary>
 Character &apos;%s&apos; is not allowed in provided type name &apos;%s&apos;
 (Originally from FSComp.txt:1240)
</summary>
</member>
<member name="M:FSComp.SR.etIllegalCharactersInNamespaceName(System.String,System.String)">
<summary>
 Character &apos;%s&apos; is not allowed in provided namespace name &apos;%s&apos;
 (Originally from FSComp.txt:1181)
</summary>
</member>
<member name="M:FSComp.SR.etHostingAssemblyFoundWithoutHosts(System.String,System.String)">
<summary>
 Referenced assembly &apos;%s&apos; has assembly level attribute &apos;%s&apos; but no public type provider classes were found
 (Originally from FSComp.txt:1186)
</summary>
</member>
<member name="M:FSComp.SR.etEventNoRemove(System.String,System.String)">
<summary>
 Event &apos;%s&apos; on provided type &apos;%s&apos; has no value from GetRemoveMethod()
 (Originally from FSComp.txt:1203)
</summary>
</member>
<member name="M:FSComp.SR.etEventNoAdd(System.String,System.String)">
<summary>
 Event &apos;%s&apos; on provided type &apos;%s&apos; has no value from GetAddMethod()
 (Originally from FSComp.txt:1202)
</summary>
</member>
<member name="M:FSComp.SR.etErrorApplyingStaticArgumentsToType">
<summary>
 An error occurred applying the static arguments to a provided type
 (Originally from FSComp.txt:1217)
</summary>
</member>
<member name="M:FSComp.SR.etErrorApplyingStaticArgumentsToMethod">
<summary>
 An error occurred applying the static arguments to a provided method
 (Originally from FSComp.txt:1363)
</summary>
</member>
<member name="M:FSComp.SR.etErasedTypeUsedInGeneration(System.String,System.String)">
<summary>
 The provider &apos;%s&apos; returned a non-generated type &apos;%s&apos; in the context of a set of generated types. Consider adjusting the type provider to only return generated types.
 (Originally from FSComp.txt:1327)
</summary>
</member>
<member name="M:FSComp.SR.etEmptyNamespaceOfTypeNotAllowed(System.String,System.String)">
<summary>
 Type &apos;%s&apos; from type provider &apos;%s&apos; has an empty namespace. Use &apos;null&apos; for the global namespace.
 (Originally from FSComp.txt:1187)
</summary>
</member>
<member name="M:FSComp.SR.etEmptyNamespaceNotAllowed(System.String)">
<summary>
 Empty namespace found from the type provider &apos;%s&apos;. Use &apos;null&apos; for the global namespace.
 (Originally from FSComp.txt:1188)
</summary>
</member>
<member name="M:FSComp.SR.etDirectReferenceToGeneratedTypeNotAllowed(System.String)">
<summary>
 A direct reference to the generated type &apos;%s&apos; is not permitted. Instead, use a type definition, e.g. &apos;type TypeAlias = &lt;path&gt;&apos;. This indicates that a type provider adds generated types to your assembly.
 (Originally from FSComp.txt:1211)
</summary>
</member>
<member name="M:FSComp.SR.etBadUnnamedStaticArgs">
<summary>
 Named static arguments must come after all unnamed static arguments
 (Originally from FSComp.txt:1243)
</summary>
</member>
<member name="M:FSComp.SR.estApplyStaticArgumentsForMethodNotImplemented">
<summary>
 A type provider implemented GetStaticParametersForMethod, but ApplyStaticArgumentsForMethod was not implemented or invalid
 (Originally from FSComp.txt:1362)
</summary>
</member>
<member name="M:FSComp.SR.erasedTo">
<summary>
 Erased to
 (Originally from FSComp.txt:1332)
</summary>
</member>
<member name="M:FSComp.SR.elseBranchHasWrongTypeTuple(System.Int32,System.String,System.Int32,System.String)">
<summary>
 All branches of an &apos;if&apos; expression must return values implicitly convertible to the type of the first branch, which here is a tuple of length %d of type\n    %s    \nThis branch returns a tuple of length %d of type\n    %s    \n
 (Originally from FSComp.txt:30)
</summary>
</member>
<member name="M:FSComp.SR.elseBranchHasWrongType(System.String,System.String)">
<summary>
 All branches of an &apos;if&apos; expression must return values implicitly convertible to the type of the first branch, which here is &apos;%s&apos;. This branch returns a value of type &apos;%s&apos;.
 (Originally from FSComp.txt:29)
</summary>
</member>
<member name="M:FSComp.SR.elSysEnvExitDidntExit">
<summary>
 System.Environment.Exit did not exit
 (Originally from FSComp.txt:245)
</summary>
</member>
<member name="M:FSComp.SR.elDeprecatedOperator">
<summary>
 The treatment of this operator is now handled directly by the F# compiler and its meaning cannot be redefined
 (Originally from FSComp.txt:246)
</summary>
</member>
<member name="M:FSComp.SR.docfileNoXmlSuffix">
<summary>
 The documentation file has no .xml suffix
 (Originally from FSComp.txt:1154)
</summary>
</member>
<member name="M:FSComp.SR.descriptionWordIs">
<summary>
 is
 (Originally from FSComp.txt:1490)
</summary>
</member>
<member name="M:FSComp.SR.descriptionUnavailable">
<summary>
 (description unavailable...)
 (Originally from FSComp.txt:1339)
</summary>
</member>
<member name="M:FSComp.SR.derefInsteadOfNot">
<summary>
 The &apos;!&apos; operator is used to dereference a ref cell. Consider using &apos;not expr&apos; here.
 (Originally from FSComp.txt:35)
</summary>
</member>
<member name="M:FSComp.SR.delegatesNotAllowedToHaveCurriedSignatures">
<summary>
 Delegates are not allowed to have curried signatures
 (Originally from FSComp.txt:983)
</summary>
</member>
<member name="M:FSComp.SR.customOperationTextLikeZip(System.String)">
<summary>
 %s var in collection
 (Originally from FSComp.txt:1270)
</summary>
</member>
<member name="M:FSComp.SR.customOperationTextLikeJoin(System.String,System.String,System.String)">
<summary>
 %s var in collection %s (outerKey = innerKey). Note that parentheses are required after &apos;%s&apos;
 (Originally from FSComp.txt:1268)
</summary>
</member>
<member name="M:FSComp.SR.customOperationTextLikeGroupJoin(System.String,System.String,System.String)">
<summary>
 %s var in collection %s (outerKey = innerKey) into group. Note that parentheses are required after &apos;%s&apos;
 (Originally from FSComp.txt:1269)
</summary>
</member>
<member name="M:FSComp.SR.csUnmanagedConstraintInconsistent">
<summary>
 The constraints &apos;unmanaged&apos; and &apos;not struct&apos; are inconsistent
 (Originally from FSComp.txt:324)
</summary>
</member>
<member name="M:FSComp.SR.csTypesDoNotSupportOperatorNullable(System.String,System.String)">
<summary>
 None of the types &apos;%s&apos; support the operator &apos;%s&apos;. Consider opening the module &apos;Microsoft.FSharp.Linq.NullableOperators&apos;.
 (Originally from FSComp.txt:318)
</summary>
</member>
<member name="M:FSComp.SR.csTypesDoNotSupportOperator(System.String,System.String)">
<summary>
 None of the types &apos;%s&apos; support the operator &apos;%s&apos;
 (Originally from FSComp.txt:315)
</summary>
</member>
<member name="M:FSComp.SR.csTypeParameterCannotBeNullable">
<summary>
 This type parameter cannot be instantiated to &apos;Nullable&apos;. This is a restriction imposed in order to ensure the meaning of &apos;null&apos; in some CLI languages is not confusing when used in conjunction with &apos;Nullable&apos; values.
 (Originally from FSComp.txt:336)
</summary>
</member>
<member name="M:FSComp.SR.csTypeNotCompatibleBecauseOfPrintf(System.String,System.String)">
<summary>
 The type &apos;%s&apos; is not compatible with any of the types %s, arising from the use of a printf-style format string
 (Originally from FSComp.txt:339)
</summary>
</member>
<member name="M:FSComp.SR.csTypeIsNotEnumType(System.String)">
<summary>
 The type &apos;%s&apos; is not a CLI enum type
 (Originally from FSComp.txt:333)
</summary>
</member>
<member name="M:FSComp.SR.csTypeIsNotDelegateType(System.String)">
<summary>
 The type &apos;%s&apos; is not a CLI delegate type
 (Originally from FSComp.txt:335)
</summary>
</member>
<member name="M:FSComp.SR.csTypeInstantiationLengthMismatch">
<summary>
 Type instantiation length mismatch
 (Originally from FSComp.txt:344)
</summary>
</member>
<member name="M:FSComp.SR.csTypeInferenceMaxDepth">
<summary>
 Type inference problem too complicated (maximum iteration depth reached). Consider adding further type annotations.
 (Originally from FSComp.txt:310)
</summary>
</member>
<member name="M:FSComp.SR.csTypeHasNullAsTrueValue(System.String)">
<summary>
 The type &apos;%s&apos; uses &apos;null&apos; as a representation value but a non-null type is expected
 (Originally from FSComp.txt:1544)
</summary>
</member>
<member name="M:FSComp.SR.csTypeHasNullAsExtraValue(System.String)">
<summary>
 The type &apos;%s&apos; supports &apos;null&apos; but a non-null type is expected
 (Originally from FSComp.txt:1545)
</summary>
</member>
<member name="M:FSComp.SR.csTypeHasNonStandardDelegateType(System.String)">
<summary>
 The type &apos;%s&apos; has a non-standard delegate type
 (Originally from FSComp.txt:334)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportOperatorNullable(System.String,System.String)">
<summary>
 The type &apos;%s&apos; does not support the operator &apos;%s&apos;. Consider opening the module &apos;Microsoft.FSharp.Linq.NullableOperators&apos;.
 (Originally from FSComp.txt:319)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportOperator(System.String,System.String)">
<summary>
 The type &apos;%s&apos; does not support the operator &apos;%s&apos;
 (Originally from FSComp.txt:316)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportEquality3(System.String)">
<summary>
 The type &apos;%s&apos; does not support the &apos;equality&apos; constraint because it is a record, union or struct with one or more structural element types which do not support the &apos;equality&apos; constraint. Either avoid the use of equality with this type, or add the &apos;StructuralEquality&apos; attribute to the type to determine which field type does not support equality
 (Originally from FSComp.txt:332)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportEquality2(System.String)">
<summary>
 The type &apos;%s&apos; does not support the &apos;equality&apos; constraint because it is a function type
 (Originally from FSComp.txt:331)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportEquality1(System.String)">
<summary>
 The type &apos;%s&apos; does not support the &apos;equality&apos; constraint because it has the &apos;NoEquality&apos; attribute
 (Originally from FSComp.txt:330)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportConversion(System.String,System.String)">
<summary>
 The type &apos;%s&apos; does not support a conversion to the type &apos;%s&apos;
 (Originally from FSComp.txt:320)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportComparison3(System.String)">
<summary>
 The type &apos;%s&apos; does not support the &apos;comparison&apos; constraint because it is a record, union or struct with one or more structural element types which do not support the &apos;comparison&apos; constraint. Either avoid the use of comparison with this type, or add the &apos;StructuralComparison&apos; attribute to the type to determine which field type does not support comparison
 (Originally from FSComp.txt:329)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportComparison2(System.String)">
<summary>
 The type &apos;%s&apos; does not support the &apos;comparison&apos; constraint. For example, it does not support the &apos;System.IComparable&apos; interface
 (Originally from FSComp.txt:328)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportComparison1(System.String)">
<summary>
 The type &apos;%s&apos; does not support the &apos;comparison&apos; constraint because it has the &apos;NoComparison&apos; attribute
 (Originally from FSComp.txt:327)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotHaveNull(System.String)">
<summary>
 The type &apos;%s&apos; does not have &apos;null&apos; as a proper value
 (Originally from FSComp.txt:325)
</summary>
</member>
<member name="M:FSComp.SR.csTypeCannotBeResolvedAtCompileTime(System.String)">
<summary>
 The declared type parameter &apos;%s&apos; cannot be used here since the type parameter cannot be resolved at compile time
 (Originally from FSComp.txt:308)
</summary>
</member>
<member name="M:FSComp.SR.csStructConstraintInconsistent">
<summary>
 The constraints &apos;struct&apos; and &apos;not struct&apos; are inconsistent
 (Originally from FSComp.txt:323)
</summary>
</member>
<member name="M:FSComp.SR.csRequiredSignatureIs(System.String)">
<summary>
 The required signature is %s
 (Originally from FSComp.txt:357)
</summary>
</member>
<member name="M:FSComp.SR.csOverloadCandidateNamedArgumentTypeMismatch(System.String)">
<summary>
 Argument &apos;%s&apos; doesn&apos;t match
 (Originally from FSComp.txt:383)
</summary>
</member>
<member name="M:FSComp.SR.csOverloadCandidateIndexedArgumentTypeMismatch(System.Int32)">
<summary>
 Argument at index %d doesn&apos;t match
 (Originally from FSComp.txt:384)
</summary>
</member>
<member name="M:FSComp.SR.csOptionalArgumentNotPermittedHere">
<summary>
 Optional arguments not permitted here
 (Originally from FSComp.txt:345)
</summary>
</member>
<member name="M:FSComp.SR.csNullableTypeDoesNotHaveNull(System.String)">
<summary>
 The type &apos;%s&apos; does not have &apos;null&apos; as a proper value. To create a null value for a Nullable type use &apos;System.Nullable()&apos;.
 (Originally from FSComp.txt:326)
</summary>
</member>
<member name="M:FSComp.SR.csNullNotNullConstraintInconsistent">
<summary>
 The constraints &apos;null&apos; and &apos;not null&apos; are inconsistent
 (Originally from FSComp.txt:1542)
</summary>
</member>
<member name="M:FSComp.SR.csNoOverloadsFoundTypeParametersPrefixSingular(System.String)">
<summary>
 Known type parameter: %s
 (Originally from FSComp.txt:377)
</summary>
</member>
<member name="M:FSComp.SR.csNoOverloadsFoundTypeParametersPrefixPlural(System.String)">
<summary>
 Known type parameters: %s
 (Originally from FSComp.txt:378)
</summary>
</member>
<member name="M:FSComp.SR.csNoOverloadsFoundReturnType(System.String)">
<summary>
 Known return type: %s
 (Originally from FSComp.txt:379)
</summary>
</member>
<member name="M:FSComp.SR.csNoOverloadsFoundArgumentsPrefixSingular(System.String)">
<summary>
 Known type of argument: %s
 (Originally from FSComp.txt:375)
</summary>
</member>
<member name="M:FSComp.SR.csNoOverloadsFoundArgumentsPrefixPlural(System.String)">
<summary>
 Known types of arguments: %s
 (Originally from FSComp.txt:376)
</summary>
</member>
<member name="M:FSComp.SR.csNoOverloadsFound(System.String)">
<summary>
 No overloads match for method &apos;%s&apos;.
 (Originally from FSComp.txt:374)
</summary>
</member>
<member name="M:FSComp.SR.csNoMemberTakesTheseArguments3(System.String,System.String,System.Int32,System.String)">
<summary>
 No %s member or object constructor named &apos;%s&apos; takes %d arguments. The named argument &apos;%s&apos; doesn&apos;t correspond to any argument or settable return property for any overload.
 (Originally from FSComp.txt:372)
</summary>
</member>
<member name="M:FSComp.SR.csNoMemberTakesTheseArguments2(System.String,System.String,System.Int32,System.Int32)">
<summary>
 No %s member or object constructor named &apos;%s&apos; takes %d arguments. Note the call to this member also provides %d named arguments.
 (Originally from FSComp.txt:371)
</summary>
</member>
<member name="M:FSComp.SR.csNoMemberTakesTheseArguments(System.String,System.String,System.Int32)">
<summary>
 No %s member or object constructor named &apos;%s&apos; takes %d arguments
 (Originally from FSComp.txt:370)
</summary>
</member>
<member name="M:FSComp.SR.csMethodNotFound(System.String)">
<summary>
 Method or object constructor &apos;%s&apos; not found
 (Originally from FSComp.txt:373)
</summary>
</member>
<member name="M:FSComp.SR.csMethodIsOverloaded(System.String)">
<summary>
 A unique overload for method &apos;%s&apos; could not be determined based on type information prior to this program point. A type annotation may be needed.
 (Originally from FSComp.txt:380)
</summary>
</member>
<member name="M:FSComp.SR.csMethodIsNotAnInstanceMethod(System.String)">
<summary>
 %s is not an instance method
 (Originally from FSComp.txt:354)
</summary>
</member>
<member name="M:FSComp.SR.csMethodIsNotAStaticMethod(System.String)">
<summary>
 %s is not a static method
 (Originally from FSComp.txt:353)
</summary>
</member>
<member name="M:FSComp.SR.csMethodFoundButIsStatic(System.String,System.String,System.String)">
<summary>
 The type &apos;%s&apos; has a method &apos;%s&apos; (full name &apos;%s&apos;), but the method is static
 (Originally from FSComp.txt:321)
</summary>
</member>
<member name="M:FSComp.SR.csMethodFoundButIsNotStatic(System.String,System.String,System.String)">
<summary>
 The type &apos;%s&apos; has a method &apos;%s&apos; (full name &apos;%s&apos;), but the method is not static
 (Originally from FSComp.txt:322)
</summary>
</member>
<member name="M:FSComp.SR.csMethodExpectsParams">
<summary>
 This method expects a CLI &apos;params&apos; parameter in this position. &apos;params&apos; is a way of passing a variable number of arguments to a method in languages such as C#. Consider passing an array for this argument
 (Originally from FSComp.txt:350)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatchArityType(System.String,System.Int32,System.Int32,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; takes %d type argument(s) but is here given %d. The required signature is &apos;%s&apos;.
 (Originally from FSComp.txt:366)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatchArityNamed(System.String,System.Int32,System.Int32,System.Int32,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; requires %d argument(s) but is here given %d unnamed and %d named argument(s). The required signature is &apos;%s&apos;.
 (Originally from FSComp.txt:362)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatchArity(System.String,System.Int32,System.Int32,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; takes %d argument(s) but is here given %d. The required signature is &apos;%s&apos;.
 (Originally from FSComp.txt:363)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatch4(System.String,System.Int32,System.String,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; requires %d additional argument(s). The required signature is &apos;%s&apos;. Some names for missing arguments are %s.
 (Originally from FSComp.txt:361)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatch3(System.String,System.Int32,System.String,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; requires %d argument(s). The required signature is &apos;%s&apos;. Some names for missing arguments are %s.
 (Originally from FSComp.txt:360)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatch2(System.String,System.Int32,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; requires %d additional argument(s). The required signature is &apos;%s&apos;.
 (Originally from FSComp.txt:359)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatch(System.String,System.Int32,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; requires %d argument(s). The required signature is &apos;%s&apos;.
 (Originally from FSComp.txt:358)
</summary>
</member>
<member name="M:FSComp.SR.csMemberOverloadArityMismatch(System.String,System.Int32,System.Int32)">
<summary>
 The member or object constructor &apos;%s&apos; does not take %d argument(s). An overload was found taking %d arguments.
 (Originally from FSComp.txt:369)
</summary>
</member>
<member name="M:FSComp.SR.csMemberNotAccessible(System.String,System.Int32,System.String,System.Int32)">
<summary>
 A member or object constructor &apos;%s&apos; taking %d arguments is not accessible from this code location. All accessible versions of method &apos;%s&apos; take %d arguments.
 (Originally from FSComp.txt:367)
</summary>
</member>
<member name="M:FSComp.SR.csMemberIsNotStatic(System.String)">
<summary>
 %s is not a static member
 (Originally from FSComp.txt:346)
</summary>
</member>
<member name="M:FSComp.SR.csMemberIsNotInstance(System.String)">
<summary>
 %s is not an instance member
 (Originally from FSComp.txt:347)
</summary>
</member>
<member name="M:FSComp.SR.csMemberIsNotAccessible2(System.String,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; is not %s. Private members may only be accessed from within the declaring type. Protected members may only be accessed from an extending type and cannot be accessed from inner lambda expressions.
 (Originally from FSComp.txt:352)
</summary>
</member>
<member name="M:FSComp.SR.csMemberIsNotAccessible(System.String,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; is not %s
 (Originally from FSComp.txt:351)
</summary>
</member>
<member name="M:FSComp.SR.csMemberHasNoArgumentOrReturnProperty(System.String,System.String,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; has no argument or settable return property &apos;%s&apos;. %s.
 (Originally from FSComp.txt:355)
</summary>
</member>
<member name="M:FSComp.SR.csIndexArgumentMismatch(System.Int32,System.Int32)">
<summary>
 This indexer expects %d arguments but is here given %d
 (Originally from FSComp.txt:312)
</summary>
</member>
<member name="M:FSComp.SR.csIncorrectGenericInstantiation(System.String,System.String,System.Int32)">
<summary>
 Incorrect generic instantiation. No %s member named &apos;%s&apos; takes %d generic arguments.
 (Originally from FSComp.txt:368)
</summary>
</member>
<member name="M:FSComp.SR.csGenericConstructRequiresUnmanagedType(System.String)">
<summary>
 A generic construct requires that the type &apos;%s&apos; is an unmanaged type
 (Originally from FSComp.txt:338)
</summary>
</member>
<member name="M:FSComp.SR.csGenericConstructRequiresStructType(System.String)">
<summary>
 A generic construct requires that the type &apos;%s&apos; is a CLI or F# struct type
 (Originally from FSComp.txt:337)
</summary>
</member>
<member name="M:FSComp.SR.csGenericConstructRequiresStructOrReferenceConstraint">
<summary>
 A generic construct requires that a generic type parameter be known as a struct or reference type. Consider adding a type annotation.
 (Originally from FSComp.txt:343)
</summary>
</member>
<member name="M:FSComp.SR.csGenericConstructRequiresReferenceSemantics(System.String)">
<summary>
 A generic construct requires that the type &apos;%s&apos; have reference semantics, but it does not, i.e. it is a struct
 (Originally from FSComp.txt:340)
</summary>
</member>
<member name="M:FSComp.SR.csGenericConstructRequiresPublicDefaultConstructor(System.String)">
<summary>
 A generic construct requires that the type &apos;%s&apos; have a public default constructor
 (Originally from FSComp.txt:342)
</summary>
</member>
<member name="M:FSComp.SR.csGenericConstructRequiresNonAbstract(System.String)">
<summary>
 A generic construct requires that the type &apos;%s&apos; be non-abstract
 (Originally from FSComp.txt:341)
</summary>
</member>
<member name="M:FSComp.SR.csFunctionDoesNotSupportType(System.String,System.String,System.String)">
<summary>
 &apos;%s&apos; does not support the type &apos;%s&apos;, because the latter lacks the required (real or built-in) member &apos;%s&apos;
 (Originally from FSComp.txt:317)
</summary>
</member>
<member name="M:FSComp.SR.csExpectedArguments">
<summary>
 Expected arguments to an instance member
 (Originally from FSComp.txt:311)
</summary>
</member>
<member name="M:FSComp.SR.csExpectTypeWithOperatorButGivenTuple(System.String)">
<summary>
 Expecting a type supporting the operator &apos;%s&apos; but given a tuple type
 (Originally from FSComp.txt:314)
</summary>
</member>
<member name="M:FSComp.SR.csExpectTypeWithOperatorButGivenFunction(System.String)">
<summary>
 Expecting a type supporting the operator &apos;%s&apos; but given a function type. You may be missing an argument to a function.
 (Originally from FSComp.txt:313)
</summary>
</member>
<member name="M:FSComp.SR.csCtorSignatureMismatchArityProp(System.String,System.Int32,System.Int32,System.String)">
<summary>
 The object constructor &apos;%s&apos; takes %d argument(s) but is here given %d. The required signature is &apos;%s&apos;. If some of the arguments are meant to assign values to properties, consider separating those arguments with a comma (&apos;,&apos;).
 (Originally from FSComp.txt:365)
</summary>
</member>
<member name="M:FSComp.SR.csCtorSignatureMismatchArity(System.String,System.Int32,System.Int32,System.String)">
<summary>
 The object constructor &apos;%s&apos; takes %d argument(s) but is here given %d. The required signature is &apos;%s&apos;.
 (Originally from FSComp.txt:364)
</summary>
</member>
<member name="M:FSComp.SR.csCtorHasNoArgumentOrReturnProperty(System.String,System.String,System.String)">
<summary>
 The object constructor &apos;%s&apos; has no argument or settable return property &apos;%s&apos;. %s.
 (Originally from FSComp.txt:356)
</summary>
</member>
<member name="M:FSComp.SR.csCodeLessGeneric">
<summary>
 This code is less generic than indicated by its annotations. A unit-of-measure specified using &apos;_&apos; has been determined to be &apos;1&apos;, i.e. dimensionless. Consider making the code generic, or removing the use of &apos;_&apos;.
 (Originally from FSComp.txt:309)
</summary>
</member>
<member name="M:FSComp.SR.csCandidates(System.String)">
<summary>
 Candidates:\n%s
 (Originally from FSComp.txt:381)
</summary>
</member>
<member name="M:FSComp.SR.csAvailableOverloads(System.String)">
<summary>
 Available overloads:\n%s
 (Originally from FSComp.txt:382)
</summary>
</member>
<member name="M:FSComp.SR.csArgumentTypesDoNotMatch">
<summary>
 The argument types don&apos;t match
 (Originally from FSComp.txt:349)
</summary>
</member>
<member name="M:FSComp.SR.csArgumentLengthMismatch">
<summary>
 Argument length mismatch
 (Originally from FSComp.txt:348)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantSetUnionFields">
<summary>
 Quotations cannot contain expressions that set union case fields
 (Originally from FSComp.txt:300)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantSetExceptionFields">
<summary>
 Quotations cannot contain expressions that set fields in exception values
 (Originally from FSComp.txt:301)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantRequireByref">
<summary>
 Quotations cannot contain expressions that require byref pointers
 (Originally from FSComp.txt:302)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantFetchUnionIndexes">
<summary>
 Quotations cannot contain expressions that fetch union case indexes
 (Originally from FSComp.txt:299)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainThisType">
<summary>
 Quotations cannot contain this kind of type
 (Originally from FSComp.txt:307)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainThisPatternMatch">
<summary>
 Quotations cannot contain this kind of pattern match
 (Originally from FSComp.txt:305)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainThisConstant">
<summary>
 Quotations cannot contain this kind of constant
 (Originally from FSComp.txt:304)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainStaticFieldRef">
<summary>
 Quotations cannot contain expressions that fetch static fields
 (Originally from FSComp.txt:296)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainObjExprs">
<summary>
 Quotations cannot contain object expressions
 (Originally from FSComp.txt:294)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainInlineIL">
<summary>
 Quotations cannot contain inline assembly code or pattern matching on arrays
 (Originally from FSComp.txt:297)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainGenericFunctions">
<summary>
 Quotations cannot contain function definitions that are inferred or declared to be generic. Consider adding some type constraints to make this a valid quoted expression.
 (Originally from FSComp.txt:293)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainGenericExprs">
<summary>
 Quotations cannot contain uses of generic expressions
 (Originally from FSComp.txt:292)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainDescendingForLoops">
<summary>
 Quotations cannot contain descending for loops
 (Originally from FSComp.txt:298)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainArrayPatternMatching">
<summary>
 Quotations cannot contain array pattern matching
 (Originally from FSComp.txt:306)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainAddressOf">
<summary>
 Quotations cannot contain expressions that take the address of a field
 (Originally from FSComp.txt:295)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantCallTraitMembers">
<summary>
 Quotations cannot contain expressions that make member constraint calls, or uses of operators that implicitly resolve to a member constraint call
 (Originally from FSComp.txt:303)
</summary>
</member>
<member name="M:FSComp.SR.crefNoSetOfHole">
<summary>
 A quotation may not involve an assignment to or taking the address of a captured local variable
 (Originally from FSComp.txt:1329)
</summary>
</member>
<member name="M:FSComp.SR.crefNoInnerGenericsInQuotations">
<summary>
 Inner generic functions are not permitted in quoted expressions. Consider adding some type constraints until this function is no longer generic.
 (Originally from FSComp.txt:1119)
</summary>
</member>
<member name="M:FSComp.SR.crefBoundVarUsedInSplice(System.String)">
<summary>
 The variable &apos;%s&apos; is bound in a quotation but is used as part of a spliced expression. This is not permitted since it may escape its scope.
 (Originally from FSComp.txt:291)
</summary>
</member>
<member name="M:FSComp.SR.couldNotLoadDependencyManagerExtension(System.String,System.String)">
<summary>
 The dependency manager extension %s could not be loaded. Message: %s
 (Originally from FSComp.txt:1524)
</summary>
</member>
<member name="M:FSComp.SR.containerSigningUnsupportedOnThisPlatform">
<summary>
 Key container signing is not supported on this platform.
 (Originally from FSComp.txt:1680)
</summary>
</member>
<member name="M:FSComp.SR.containerDeprecated">
<summary>
 The &apos;AssemblyKeyNameAttribute&apos; has been deprecated. Use &apos;AssemblyKeyFileAttribute&apos; instead.
 (Originally from FSComp.txt:1679)
</summary>
</member>
<member name="M:FSComp.SR.considerUpcastOperator(System.String,System.String)">
<summary>
 The conversion from %s to %s is a compile-time safe upcast, not a downcast. Consider using the :&gt; (upcast) operator instead of the :?&gt; (downcast) operator.
 (Originally from FSComp.txt:1382)
</summary>
</member>
<member name="M:FSComp.SR.considerUpcast(System.String,System.String)">
<summary>
 The conversion from %s to %s is a compile-time safe upcast, not a downcast. Consider using &apos;upcast&apos; instead of &apos;downcast&apos;.
 (Originally from FSComp.txt:1381)
</summary>
</member>
<member name="M:FSComp.SR.commaInsteadOfSemicolonInRecord">
<summary>
 A &apos;;&apos; is used to separate field values in records. Consider replacing &apos;,&apos; with &apos;;&apos;.
 (Originally from FSComp.txt:34)
</summary>
</member>
<member name="M:FSComp.SR.chkVariableUsedInInvalidWay(System.String)">
<summary>
 The variable &apos;%s&apos; is used in an invalid way
 (Originally from FSComp.txt:250)
</summary>
</member>
<member name="M:FSComp.SR.chkValueWithDefaultValueMustHaveDefaultValue">
<summary>
 The type of a field using the &apos;DefaultValue&apos; attribute must admit default initialization, i.e. have &apos;null&apos; as a proper value or be a struct type whose fields all admit default initialization. You can use &apos;DefaultValue(false)&apos; to disable this check
 (Originally from FSComp.txt:289)
</summary>
</member>
<member name="M:FSComp.SR.chkUnusedValue(System.String)">
<summary>
 The value &apos;%s&apos; is unused
 (Originally from FSComp.txt:1070)
</summary>
</member>
<member name="M:FSComp.SR.chkUnusedThisVariable(System.String)">
<summary>
 The recursive object reference &apos;%s&apos; is unused. The presence of a recursive object reference adds runtime initialization checks to members in this and derived types. Consider removing this recursive object reference.
 (Originally from FSComp.txt:1071)
</summary>
</member>
<member name="M:FSComp.SR.chkUnionCaseDefaultAugmentation">
<summary>
 default augmentation of the union case
 (Originally from FSComp.txt:275)
</summary>
</member>
<member name="M:FSComp.SR.chkUnionCaseCompiledForm">
<summary>
 compiled form of the union case
 (Originally from FSComp.txt:274)
</summary>
</member>
<member name="M:FSComp.SR.chkTypeLessAccessibleThanType(System.String,System.String)">
<summary>
 The type &apos;%s&apos; is less accessible than the value, member or type &apos;%s&apos; it is used in.
 (Originally from FSComp.txt:251)
</summary>
</member>
<member name="M:FSComp.SR.chkTyparMultipleClassConstraints">
<summary>
 A type variable has been constrained by multiple different class types. A type variable may only have one class constraint.
 (Originally from FSComp.txt:1340)
</summary>
</member>
<member name="M:FSComp.SR.chkTailCallAttrOnNonRec">
<summary>
 The TailCall attribute should only be applied to recursive functions.
 (Originally from FSComp.txt:1769)
</summary>
</member>
<member name="M:FSComp.SR.chkSystemVoidOnlyInTypeof">
<summary>
 &apos;System.Void&apos; can only be used as &apos;typeof&lt;System.Void&gt;&apos; in F#
 (Originally from FSComp.txt:252)
</summary>
</member>
<member name="M:FSComp.SR.chkStructsMayNotReturnAddressesOfContents">
<summary>
 Struct members cannot return the address of fields of the struct by reference
 (Originally from FSComp.txt:1511)
</summary>
</member>
<member name="M:FSComp.SR.chkStaticMembersOnObjectExpressions">
<summary>
 Object expressions cannot implement interfaces with static abstract members or declare static members.
 (Originally from FSComp.txt:1768)
</summary>
</member>
<member name="M:FSComp.SR.chkStaticAbstractMembersOnClasses">
<summary>
 Classes cannot contain static abstract members.
 (Originally from FSComp.txt:1775)
</summary>
</member>
<member name="M:FSComp.SR.chkStaticAbstractInterfaceMembers(System.String)">
<summary>
 A static abstract non-virtual interface member should only be called via type parameter (for example: &apos;T.%s).
 (Originally from FSComp.txt:1774)
</summary>
</member>
<member name="M:FSComp.SR.chkSplicingOnlyInQuotations">
<summary>
 Expression-splicing operators may only be used within quotations
 (Originally from FSComp.txt:255)
</summary>
</member>
<member name="M:FSComp.SR.chkReturnTypeNoByref">
<summary>
 A method return type would contain byrefs which is not permitted
 (Originally from FSComp.txt:267)
</summary>
</member>
<member name="M:FSComp.SR.chkReflectedDefCantSplice">
<summary>
 [&lt;ReflectedDefinition&gt;] terms cannot contain uses of the prefix splice operator &apos;%%&apos;
 (Originally from FSComp.txt:272)
</summary>
</member>
<member name="M:FSComp.SR.chkProtectedOrBaseCalled">
<summary>
 A protected member is called or &apos;base&apos; is being used. This is only allowed in the direct implementation of members since they could escape their object scope.
 (Originally from FSComp.txt:247)
</summary>
</member>
<member name="M:FSComp.SR.chkPropertySameNameMethod(System.String,System.String)">
<summary>
 The property &apos;%s&apos; has the same name as a method in type &apos;%s&apos;.
 (Originally from FSComp.txt:276)
</summary>
</member>
<member name="M:FSComp.SR.chkPropertySameNameIndexer(System.String,System.String)">
<summary>
 The property &apos;%s&apos; has the same name as another property in type &apos;%s&apos;, but one takes indexer arguments and the other does not. You may be missing an indexer argument to one of your properties.
 (Originally from FSComp.txt:278)
</summary>
</member>
<member name="M:FSComp.SR.chkNotTailRecursive(System.String)">
<summary>
 The member or function &apos;%s&apos; has the &apos;TailCallAttribute&apos; attribute, but is not being used in a tail recursive way.
 (Originally from FSComp.txt:1749)
</summary>
</member>
<member name="M:FSComp.SR.chkNoWriteToLimitedSpan(System.String)">
<summary>
 This value can&apos;t be assigned because the target &apos;%s&apos; may refer to non-stack-local memory, while the expression being assigned is assessed to potentially refer to stack-local memory. This is to help prevent pointers to stack-bound memory escaping their scope.
 (Originally from FSComp.txt:1508)
</summary>
</member>
<member name="M:FSComp.SR.chkNoSpanLikeVariable(System.String)">
<summary>
 The Span or IsByRefLike variable &apos;%s&apos; cannot be used at this point. This is to ensure the address of the local value does not escape its scope.
 (Originally from FSComp.txt:1513)
</summary>
</member>
<member name="M:FSComp.SR.chkNoSpanLikeValueFromExpression">
<summary>
 A Span or IsByRefLike value returned from the expression cannot be used at ths point. This is to ensure the address of the local value does not escape its scope.
 (Originally from FSComp.txt:1514)
</summary>
</member>
<member name="M:FSComp.SR.chkNoReflectedDefinitionOnStructMember">
<summary>
 ReflectedDefinitionAttribute may not be applied to an instance member on a struct type, because the instance member takes an implicit &apos;this&apos; byref parameter
 (Originally from FSComp.txt:1113)
</summary>
</member>
<member name="M:FSComp.SR.chkNoFirstClassSplicing">
<summary>
 First-class uses of the expression-splicing operator are not permitted
 (Originally from FSComp.txt:256)
</summary>
</member>
<member name="M:FSComp.SR.chkNoFirstClassRethrow">
<summary>
 First-class uses of the &apos;reraise&apos; function is not permitted
 (Originally from FSComp.txt:258)
</summary>
</member>
<member name="M:FSComp.SR.chkNoFirstClassNameOf">
<summary>
 Using the &apos;nameof&apos; operator as a first-class function value is not permitted.
 (Originally from FSComp.txt:1526)
</summary>
</member>
<member name="M:FSComp.SR.chkNoFirstClassAddressOf">
<summary>
 First-class uses of the address-of operators are not permitted
 (Originally from FSComp.txt:257)
</summary>
</member>
<member name="M:FSComp.SR.chkNoByrefsOfByrefs(System.String)">
<summary>
 Type &apos;%s&apos; is illegal because in byref&lt;T&gt;, T cannot contain byref types.
 (Originally from FSComp.txt:1312)
</summary>
</member>
<member name="M:FSComp.SR.chkNoByrefLikeFunctionCall">
<summary>
 The function or method call cannot be used at this point, because one argument that is a byref of a non-stack-local Span or IsByRefLike type is used with another argument that is a stack-local Span or IsByRefLike type. This is to ensure the address of the local value does not escape its scope.
 (Originally from FSComp.txt:1512)
</summary>
</member>
<member name="M:FSComp.SR.chkNoByrefInTypeAbbrev">
<summary>
 The type abbreviation contains byrefs. This is not permitted by F#.
 (Originally from FSComp.txt:290)
</summary>
</member>
<member name="M:FSComp.SR.chkNoByrefAtThisPoint(System.String)">
<summary>
 The byref typed value &apos;%s&apos; cannot be used at this point
 (Originally from FSComp.txt:259)
</summary>
</member>
<member name="M:FSComp.SR.chkNoByrefAsTopValue">
<summary>
 A byref typed value would be stored here. Top-level let-bound byref values are not permitted.
 (Originally from FSComp.txt:271)
</summary>
</member>
<member name="M:FSComp.SR.chkNoByrefAddressOfValueFromExpression">
<summary>
 The address of a value returned from the expression cannot be used at this point. This is to ensure the address of the local value does not escape its scope.
 (Originally from FSComp.txt:1507)
</summary>
</member>
<member name="M:FSComp.SR.chkNoByrefAddressOfLocal(System.String)">
<summary>
 The address of the variable &apos;%s&apos; or a related expression cannot be used at this point. This is to ensure the address of the local value does not escape its scope.
 (Originally from FSComp.txt:1392)
</summary>
</member>
<member name="M:FSComp.SR.chkNoAddressStaticFieldAtThisPoint(System.String)">
<summary>
 The address of the static field &apos;%s&apos; cannot be used at this point
 (Originally from FSComp.txt:263)
</summary>
</member>
<member name="M:FSComp.SR.chkNoAddressOfAtThisPoint(System.String)">
<summary>
 The address of the variable &apos;%s&apos; cannot be used at this point
 (Originally from FSComp.txt:262)
</summary>
</member>
<member name="M:FSComp.SR.chkNoAddressOfArrayElementAtThisPoint">
<summary>
 The address of an array element cannot be used at this point
 (Originally from FSComp.txt:265)
</summary>
</member>
<member name="M:FSComp.SR.chkNoAddressFieldAtThisPoint(System.String)">
<summary>
 The address of the field &apos;%s&apos; cannot be used at this point
 (Originally from FSComp.txt:264)
</summary>
</member>
<member name="M:FSComp.SR.chkMultipleGenericInterfaceInstantiations(System.String,System.String)">
<summary>
 This type implements the same interface at different generic instantiations &apos;%s&apos; and &apos;%s&apos;. This is not permitted in this version of F#.
 (Originally from FSComp.txt:288)
</summary>
</member>
<member name="M:FSComp.SR.chkMemberUsedInInvalidWay(System.String,System.String,System.String)">
<summary>
 The member &apos;%s&apos; is used in an invalid way. A use of &apos;%s&apos; has been inferred prior to its definition at or near &apos;%s&apos;. This is an invalid forward reference.
 (Originally from FSComp.txt:270)
</summary>
</member>
<member name="M:FSComp.SR.chkLimitationsOfBaseKeyword">
<summary>
 &apos;base&apos; values may only be used to make direct calls to the base implementations of overridden members
 (Originally from FSComp.txt:260)
</summary>
</member>
<member name="M:FSComp.SR.chkInvalidFunctionReturnType(System.String)">
<summary>
 The function or method has an invalid return type &apos;%s&apos;. This is not permitted by the rules of Common IL.
 (Originally from FSComp.txt:1547)
</summary>
</member>
<member name="M:FSComp.SR.chkInvalidFunctionParameterType(System.String,System.String)">
<summary>
 The parameter &apos;%s&apos; has an invalid type &apos;%s&apos;. This is not permitted by the rules of Common IL.
 (Originally from FSComp.txt:1546)
</summary>
</member>
<member name="M:FSComp.SR.chkInvalidCustAttrVal">
<summary>
 Invalid custom attribute value (not a constant or literal)
 (Originally from FSComp.txt:268)
</summary>
</member>
<member name="M:FSComp.SR.chkInstanceMemberOnStaticClasses">
<summary>
 If a type uses both [&lt;Sealed&gt;] and [&lt;AbstractClass&gt;] attributes, it means it is static. Instance members are not allowed.
 (Originally from FSComp.txt:1732)
</summary>
</member>
<member name="M:FSComp.SR.chkInstanceLetBindingOnStaticClasses">
<summary>
 If a type uses both [&lt;Sealed&gt;] and [&lt;AbstractClass&gt;] attributes, it means it is static. Instance let bindings are not allowed.
 (Originally from FSComp.txt:1733)
</summary>
</member>
<member name="M:FSComp.SR.chkInfoRefcellIncr">
<summary>
 The use of &apos;incr&apos; from the F# library is deprecated. See https://aka.ms/fsharp-refcell-ops. For example, please change &apos;incr cell&apos; to &apos;cell.Value &lt;- cell.Value + 1&apos;.
 (Originally from FSComp.txt:1646)
</summary>
</member>
<member name="M:FSComp.SR.chkInfoRefcellDeref">
<summary>
 The use of &apos;!&apos; from the F# library is deprecated. See https://aka.ms/fsharp-refcell-ops. For example, please change &apos;!cell&apos; to &apos;cell.Value&apos;.
 (Originally from FSComp.txt:1644)
</summary>
</member>
<member name="M:FSComp.SR.chkInfoRefcellDecr">
<summary>
 The use of &apos;decr&apos; from the F# library is deprecated. See https://aka.ms/fsharp-refcell-ops. For example, please change &apos;decr cell&apos; to &apos;cell.Value &lt;- cell.Value - 1&apos;.
 (Originally from FSComp.txt:1647)
</summary>
</member>
<member name="M:FSComp.SR.chkInfoRefcellAssign">
<summary>
 The use of &apos;:=&apos; from the F# library is deprecated. See https://aka.ms/fsharp-refcell-ops. For example, please change &apos;cell := expr&apos; to &apos;cell.Value &lt;- expr&apos;.
 (Originally from FSComp.txt:1645)
</summary>
</member>
<member name="M:FSComp.SR.chkIndexedGetterAndSetterHaveSamePropertyType(System.String,System.String,System.String)">
<summary>
 An indexed property&apos;s getter and setter must have the same type. Property &apos;%s&apos; has getter of type &apos;%s&apos; but setter of type &apos;%s&apos;.
 (Originally from FSComp.txt:1760)
</summary>
</member>
<member name="M:FSComp.SR.chkImplementingInterfacesOnStaticClasses">
<summary>
 If a type uses both [&lt;Sealed&gt;] and [&lt;AbstractClass&gt;] attributes, it means it is static. Implementing interfaces is not allowed.
 (Originally from FSComp.txt:1734)
</summary>
</member>
<member name="M:FSComp.SR.chkGetterSetterDoNotMatchAbstract(System.String,System.String)">
<summary>
 The property &apos;%s&apos; of type &apos;%s&apos; has a getter and a setter that do not match. If one is abstract then the other must be as well.
 (Originally from FSComp.txt:277)
</summary>
</member>
<member name="M:FSComp.SR.chkGetterAndSetterHaveSamePropertyType(System.String,System.String,System.String)">
<summary>
 A property&apos;s getter and setter must have the same type. Property &apos;%s&apos; has getter of type &apos;%s&apos; but setter of type &apos;%s&apos;.
 (Originally from FSComp.txt:1349)
</summary>
</member>
<member name="M:FSComp.SR.chkFirstClassFuncNoByref">
<summary>
 The type of a first-class function cannot contain byrefs
 (Originally from FSComp.txt:266)
</summary>
</member>
<member name="M:FSComp.SR.chkFeatureNotSupportedInLibrary(System.String,System.String)">
<summary>
 Feature &apos;%s&apos; requires the F# library for language version %s or greater.
 (Originally from FSComp.txt:1554)
</summary>
</member>
<member name="M:FSComp.SR.chkFeatureNotRuntimeSupported(System.String)">
<summary>
 Feature &apos;%s&apos; is not supported by target runtime.
 (Originally from FSComp.txt:1556)
</summary>
</member>
<member name="M:FSComp.SR.chkFeatureNotLanguageSupported(System.String,System.String,System.String)">
<summary>
 Feature &apos;%s&apos; is not available in F# %s. Please use language version %s or greater.
 (Originally from FSComp.txt:1555)
</summary>
</member>
<member name="M:FSComp.SR.chkExplicitFieldsDeclarationsOnStaticClasses">
<summary>
 If a type uses both [&lt;Sealed&gt;] and [&lt;AbstractClass&gt;] attributes, it means it is static. Explicit field declarations are not allowed.
 (Originally from FSComp.txt:1736)
</summary>
</member>
<member name="M:FSComp.SR.chkErrorUseOfByref">
<summary>
 A type instantiation involves a byref type. This is not permitted by the rules of Common IL.
 (Originally from FSComp.txt:253)
</summary>
</member>
<member name="M:FSComp.SR.chkErrorContainsCallToRethrow">
<summary>
 Calls to &apos;reraise&apos; may only occur directly in a handler of a try-with
 (Originally from FSComp.txt:254)
</summary>
</member>
<member name="M:FSComp.SR.chkEntryPointUsage">
<summary>
 A function labeled with the &apos;EntryPointAttribute&apos; attribute must be the last declaration in the last file in the compilation sequence.
 (Originally from FSComp.txt:273)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicatedMethodParameter(System.String)">
<summary>
 Duplicate parameter. The parameter &apos;%s&apos; has been used more that once in this method.
 (Originally from FSComp.txt:1727)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicatePropertyWithSuffix(System.String,System.String)">
<summary>
 Duplicate property. The property &apos;%s&apos; has the same name and signature as another property in type &apos;%s&apos; once tuples, functions, units of measure and/or provided types are erased.
 (Originally from FSComp.txt:285)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicateProperty(System.String,System.String)">
<summary>
 Duplicate property. The property &apos;%s&apos; has the same name and signature as another property in type &apos;%s&apos;.
 (Originally from FSComp.txt:284)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicateMethodWithSuffix(System.String,System.String)">
<summary>
 Duplicate method. The method &apos;%s&apos; has the same name and signature as another method in type &apos;%s&apos; once tuples, functions, units of measure and/or provided types are erased.
 (Originally from FSComp.txt:281)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicateMethodInheritedTypeWithSuffix(System.String)">
<summary>
 Duplicate method. The abstract method &apos;%s&apos; has the same name and signature as an abstract method in an inherited type once tuples, functions, units of measure and/or provided types are erased.
 (Originally from FSComp.txt:287)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicateMethodInheritedType(System.String)">
<summary>
 Duplicate method. The abstract method &apos;%s&apos; has the same name and signature as an abstract method in an inherited type.
 (Originally from FSComp.txt:286)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicateMethodCurried(System.String,System.String)">
<summary>
 The method &apos;%s&apos; has curried arguments but has the same name as another method in type &apos;%s&apos;. Methods with curried arguments cannot be overloaded. Consider using a method taking tupled arguments.
 (Originally from FSComp.txt:282)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicateMethod(System.String,System.String)">
<summary>
 Duplicate method. The method &apos;%s&apos; has the same name and signature as another method in type &apos;%s&apos;.
 (Originally from FSComp.txt:280)
</summary>
</member>
<member name="M:FSComp.SR.chkDeprecatePlacesWhereSeqCanBeOmitted">
<summary>
 This construct is deprecated. Sequence expressions should be of the form &apos;seq { ... }&apos;
 (Originally from FSComp.txt:1791)
</summary>
</member>
<member name="M:FSComp.SR.chkCurriedMethodsCantHaveOutParams">
<summary>
 Methods with curried arguments cannot declare &apos;out&apos;, &apos;ParamArray&apos;, &apos;optional&apos;, &apos;ReflectedDefinition&apos;, &apos;byref&apos;, &apos;CallerLineNumber&apos;, &apos;CallerMemberName&apos;, or &apos;CallerFilePath&apos; arguments
 (Originally from FSComp.txt:283)
</summary>
</member>
<member name="M:FSComp.SR.chkCopyUpdateSyntaxInAnonRecords">
<summary>
 This expression is an anonymous record, use {|...|} instead of {...}.
 (Originally from FSComp.txt:1757)
</summary>
</member>
<member name="M:FSComp.SR.chkConstructorWithArgumentsOnStaticClasses">
<summary>
 If a type uses both [&lt;Sealed&gt;] and [&lt;AbstractClass&gt;] attributes, it means it is static. Constructor with arguments is not allowed.
 (Originally from FSComp.txt:1730)
</summary>
</member>
<member name="M:FSComp.SR.chkCantStoreByrefValue">
<summary>
 A type would store a byref typed value. This is not permitted by Common IL.
 (Originally from FSComp.txt:279)
</summary>
</member>
<member name="M:FSComp.SR.chkByrefUsedInInvalidWay(System.String)">
<summary>
 The byref-typed variable &apos;%s&apos; is used in an invalid way. Byrefs cannot be captured by closures or passed to inner functions.
 (Originally from FSComp.txt:248)
</summary>
</member>
<member name="M:FSComp.SR.chkBaseUsedInInvalidWay">
<summary>
 The &apos;base&apos; keyword is used in an invalid way. Base calls cannot be used in closures. Consider using a private member to make base calls.
 (Originally from FSComp.txt:249)
</summary>
</member>
<member name="M:FSComp.SR.chkAttributeAliased(System.String)">
<summary>
 %s should not be aliased.
 (Originally from FSComp.txt:1739)
</summary>
</member>
<member name="M:FSComp.SR.chkAttrHasAllowMultiFalse(System.String)">
<summary>
 The attribute type &apos;%s&apos; has &apos;AllowMultiple=false&apos;. Multiple instances of this attribute cannot be attached to a single language element.
 (Originally from FSComp.txt:269)
</summary>
</member>
<member name="M:FSComp.SR.chkAdditionalConstructorOnStaticClasses">
<summary>
 If a type uses both [&lt;Sealed&gt;] and [&lt;AbstractClass&gt;] attributes, it means it is static. Additional constructor is not allowed.
 (Originally from FSComp.txt:1731)
</summary>
</member>
<member name="M:FSComp.SR.chkAbstractMembersDeclarationsOnStaticClasses">
<summary>
 If a type uses both [&lt;Sealed&gt;] and [&lt;AbstractClass&gt;] attributes, it means it is static. Abstract member declarations are not allowed.
 (Originally from FSComp.txt:1735)
</summary>
</member>
<member name="M:FSComp.SR.checkRaiseFamilyFunctionArgumentCount(System.String,System.Int32,System.Int32)">
<summary>
 Redundant arguments are being ignored in function &apos;%s&apos;. Expected %d but got %d arguments.
 (Originally from FSComp.txt:1371)
</summary>
</member>
<member name="M:FSComp.SR.checkNotSufficientlyGenericBecauseOfScopeAnon">
<summary>
 Type inference caused an inference type variable to escape its scope. Consider adding type annotations to make your code less generic.
 (Originally from FSComp.txt:1370)
</summary>
</member>
<member name="M:FSComp.SR.checkNotSufficientlyGenericBecauseOfScope(System.String)">
<summary>
 Type inference caused the type variable %s to escape its scope. Consider adding an explicit type parameter declaration or adjusting your code to be less generic.
 (Originally from FSComp.txt:1369)
</summary>
</member>
<member name="M:FSComp.SR.checkLowercaseLiteralBindingInPattern(System.String)">
<summary>
 Lowercase literal &apos;%s&apos; is being shadowed by a new pattern with the same name. Only uppercase and module-prefixed literals can be used as named patterns.
 (Originally from FSComp.txt:1372)
</summary>
</member>
<member name="M:FSComp.SR.cannotResolveNullableOperators(System.String)">
<summary>
 The operator &apos;%s&apos; cannot be resolved. Consider opening the module &apos;Microsoft.FSharp.Linq.NullableOperators&apos;.
 (Originally from FSComp.txt:1343)
</summary>
</member>
<member name="M:FSComp.SR.buildUnrecognizedOption(System.String)">
<summary>
 Unrecognized option: &apos;%s&apos;. Use &apos;--help&apos; to learn about recognized command line options.
 (Originally from FSComp.txt:79)
</summary>
</member>
<member name="M:FSComp.SR.buildUnexpectedTypeArgs(System.String,System.Int32)">
<summary>
 The non-generic type &apos;%s&apos; does not expect any type arguments, but here is given %d type argument(s)
 (Originally from FSComp.txt:36)
</summary>
</member>
<member name="M:FSComp.SR.buildUnexpectedFileNameCharacter(System.String,System.String)">
<summary>
 Filename &apos;%s&apos; contains invalid character &apos;%s&apos;
 (Originally from FSComp.txt:1117)
</summary>
</member>
<member name="M:FSComp.SR.buildSignatureWithoutImplementation(System.String)">
<summary>
 The signature file &apos;%s&apos; does not have a corresponding implementation file. If an implementation file exists then check the &apos;module&apos; and &apos;namespace&apos; declarations in the signature and implementation files match.
 (Originally from FSComp.txt:76)
</summary>
</member>
<member name="M:FSComp.SR.buildSignatureAlreadySpecified(System.String)">
<summary>
 A signature for the file or module &apos;%s&apos; has already been specified
 (Originally from FSComp.txt:73)
</summary>
</member>
<member name="M:FSComp.SR.buildSearchDirectoryNotFound(System.String)">
<summary>
 The search directory &apos;%s&apos; could not be found
 (Originally from FSComp.txt:50)
</summary>
</member>
<member name="M:FSComp.SR.buildProblemWithFilename(System.String,System.String)">
<summary>
 Problem with filename &apos;%s&apos;: %s
 (Originally from FSComp.txt:46)
</summary>
</member>
<member name="M:FSComp.SR.buildProblemReadingAssembly(System.String,System.String)">
<summary>
 Problem reading assembly &apos;%s&apos;: %s
 (Originally from FSComp.txt:1336)
</summary>
</member>
<member name="M:FSComp.SR.buildPdbRequiresDebug">
<summary>
 The &apos;--pdb&apos; option requires the &apos;--debug&apos; option to be used
 (Originally from FSComp.txt:48)
</summary>
</member>
<member name="M:FSComp.SR.buildOptionRequiresParameter(System.String)">
<summary>
 Option requires parameter: %s
 (Originally from FSComp.txt:60)
</summary>
</member>
<member name="M:FSComp.SR.buildNoInputsSpecified">
<summary>
 No inputs specified
 (Originally from FSComp.txt:47)
</summary>
</member>
<member name="M:FSComp.SR.buildMultipleToplevelModules">
<summary>
 This file contains multiple declarations of the form &apos;module SomeNamespace.SomeModule&apos;. Only one declaration of this form is permitted in a file. Change your file to use an initial namespace declaration and/or use &apos;module ModuleName = ...&apos; to define your modules.
 (Originally from FSComp.txt:59)
</summary>
</member>
<member name="M:FSComp.SR.buildMultiFileRequiresNamespaceOrModule">
<summary>
 Files in libraries or multiple-file applications must begin with a namespace or module declaration, e.g. &apos;namespace SomeNamespace.SubNamespace&apos; or &apos;module SomeNamespace.SomeModule&apos;. Only the last source file of an application may omit such a declaration.
 (Originally from FSComp.txt:57)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidWarningNumber(System.String)">
<summary>
 Invalid warning number &apos;%s&apos;
 (Originally from FSComp.txt:43)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidVersionString(System.String)">
<summary>
 Invalid version string &apos;%s&apos;
 (Originally from FSComp.txt:44)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidVersionFile(System.String)">
<summary>
 Invalid version file &apos;%s&apos;
 (Originally from FSComp.txt:45)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidSourceFileExtensionUpdated(System.String)">
<summary>
 The file extension of &apos;%s&apos; is not recognized. Source files must have extension .fs, .fsi, .fsx or .fsscript
 (Originally from FSComp.txt:63)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidSourceFileExtensionML(System.String)">
<summary>
 The file extension of &apos;%s&apos; is not recognized. Source files must have extension .fs, .fsi, .fsx or .fsscript. To enable the deprecated use of .ml or .mli extensions, use &apos;--langversion:5.0&apos; and &apos;--mlcompatibility&apos;.
 (Originally from FSComp.txt:64)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidSourceFileExtension(System.String)">
<summary>
 The file extension of &apos;%s&apos; is not recognized. Source files must have extension .fs, .fsi, .fsx, .fsscript, .ml or .mli.
 (Originally from FSComp.txt:62)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidSearchDirectory(System.String)">
<summary>
 The search directory &apos;%s&apos; is invalid
 (Originally from FSComp.txt:49)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidPrivacy(System.String)">
<summary>
 Unrecognized privacy setting &apos;%s&apos; for managed resource, valid options are &apos;public&apos; and &apos;private&apos;
 (Originally from FSComp.txt:53)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidModuleOrNamespaceName">
<summary>
 Invalid module or namespace name
 (Originally from FSComp.txt:80)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidHashtimeDirective">
<summary>
 Invalid directive. Expected &apos;#time&apos;, &apos;#time \&quot;on\&quot;&apos; or &apos;#time \&quot;off\&quot;&apos;.
 (Originally from FSComp.txt:71)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidHashrDirective">
<summary>
 Invalid directive. Expected &apos;#r \&quot;&lt;file-or-assembly&gt;\&quot;&apos;.
 (Originally from FSComp.txt:69)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidHashloadDirective">
<summary>
 Invalid directive. Expected &apos;#load \&quot;&lt;file&gt;\&quot; ... \&quot;&lt;file&gt;\&quot;&apos;.
 (Originally from FSComp.txt:70)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidHashIDirective">
<summary>
 Invalid directive. Expected &apos;#I \&quot;&lt;path&gt;\&quot;&apos;.
 (Originally from FSComp.txt:68)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidFilename(System.String)">
<summary>
 &apos;%s&apos; is not a valid filename
 (Originally from FSComp.txt:51)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidAssemblyName(System.String)">
<summary>
 &apos;%s&apos; is not a valid assembly name
 (Originally from FSComp.txt:52)
</summary>
</member>
<member name="M:FSComp.SR.buildImplicitModuleIsNotLegalIdentifier(System.String,System.String)">
<summary>
 The declarations in this file will be placed in an implicit module &apos;%s&apos; based on the file name &apos;%s&apos;. However this is not a valid F# identifier, so the contents will not be accessible from other files. Consider renaming the file or adding a &apos;module&apos; or &apos;namespace&apos; declaration at the top of the file.
 (Originally from FSComp.txt:56)
</summary>
</member>
<member name="M:FSComp.SR.buildImplementationAlreadyGivenDetail(System.String)">
<summary>
 An implementation of file or module &apos;%s&apos; has already been given. Compilation order is significant in F# because of type inference. You may need to adjust the order of your files to place the signature file before the implementation. In Visual Studio files are type-checked in the order they appear in the project file, which can be edited manually or adjusted using the solution explorer.
 (Originally from FSComp.txt:74)
</summary>
</member>
<member name="M:FSComp.SR.buildImplementationAlreadyGiven(System.String)">
<summary>
 An implementation of the file or module &apos;%s&apos; has already been given
 (Originally from FSComp.txt:75)
</summary>
</member>
<member name="M:FSComp.SR.buildExpectedSigdataFile(System.String)">
<summary>
 FSharp.Core.sigdata not found alongside FSharp.Core. File expected in %s. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.
 (Originally from FSComp.txt:1115)
</summary>
</member>
<member name="M:FSComp.SR.buildExpectedFileAlongSideFSharpCore(System.String,System.String)">
<summary>
 File &apos;%s&apos; not found alongside FSharp.Core. File expected in %s. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.
 (Originally from FSComp.txt:1116)
</summary>
</member>
<member name="M:FSComp.SR.buildErrorOpeningBinaryFile(System.String,System.String)">
<summary>
 Error opening binary file &apos;%s&apos;: %s
 (Originally from FSComp.txt:66)
</summary>
</member>
<member name="M:FSComp.SR.buildDuplicateFile(System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 The source file &apos;%s&apos; (at position %d/%d) already appeared in the compilation list (at position %d/%d). Please verify that it is included only once in the project file.
 (Originally from FSComp.txt:1729)
</summary>
</member>
<member name="M:FSComp.SR.buildDirectivesInModulesAreIgnored">
<summary>
 Directives inside modules are ignored
 (Originally from FSComp.txt:72)
</summary>
</member>
<member name="M:FSComp.SR.buildDifferentVersionMustRecompile(System.String)">
<summary>
 The F#-compiled DLL &apos;%s&apos; needs to be recompiled to be used with this version of F#
 (Originally from FSComp.txt:67)
</summary>
</member>
<member name="M:FSComp.SR.buildCouldNotResolveAssembly(System.String)">
<summary>
 Could not resolve assembly &apos;%s&apos;
 (Originally from FSComp.txt:65)
</summary>
</member>
<member name="M:FSComp.SR.buildCouldNotFindSourceFile(System.String)">
<summary>
 Source file &apos;%s&apos; could not be found
 (Originally from FSComp.txt:61)
</summary>
</member>
<member name="M:FSComp.SR.buildCompilingExtensionIsForML">
<summary>
 The file extensions &apos;.ml&apos; and &apos;.mli&apos; are for ML compatibility
 (Originally from FSComp.txt:1103)
</summary>
</member>
<member name="M:FSComp.SR.buildCannotReadAssembly(System.String)">
<summary>
 Unable to read assembly &apos;%s&apos;
 (Originally from FSComp.txt:54)
</summary>
</member>
<member name="M:FSComp.SR.buildAssemblyResolutionFailed">
<summary>
 Assembly resolution failure at or near this location
 (Originally from FSComp.txt:55)
</summary>
</member>
<member name="M:FSComp.SR.buildArgInvalidInt(System.String)">
<summary>
 &apos;%s&apos; is not a valid integer argument
 (Originally from FSComp.txt:77)
</summary>
</member>
<member name="M:FSComp.SR.buildArgInvalidFloat(System.String)">
<summary>
 &apos;%s&apos; is not a valid floating point argument
 (Originally from FSComp.txt:78)
</summary>
</member>
<member name="M:FSComp.SR.augTypeCantHaveRefEqAndStructAttrs">
<summary>
 A type cannot have both the &apos;ReferenceEquality&apos; and &apos;StructuralEquality&apos; or &apos;StructuralComparison&apos; attributes
 (Originally from FSComp.txt:221)
</summary>
</member>
<member name="M:FSComp.SR.augStructEqNeedsNoCompOrStructComp">
<summary>
 The &apos;StructuralEquality&apos; attribute must be used in conjunction with the &apos;NoComparison&apos; or &apos;StructuralComparison&apos; attributes
 (Originally from FSComp.txt:220)
</summary>
</member>
<member name="M:FSComp.SR.augStructCompNeedsStructEquality">
<summary>
 The &apos;StructuralComparison&apos; attribute must be used in conjunction with the &apos;StructuralEquality&apos; attribute
 (Originally from FSComp.txt:219)
</summary>
</member>
<member name="M:FSComp.SR.augRefEqCantHaveObjEquals">
<summary>
 A type with attribute &apos;ReferenceEquality&apos; cannot have an explicit implementation of &apos;Object.Equals(obj)&apos;, &apos;System.IEquatable&lt;_&gt;&apos; or &apos;System.Collections.IStructuralEquatable&apos;
 (Originally from FSComp.txt:223)
</summary>
</member>
<member name="M:FSComp.SR.augOnlyCertainTypesCanHaveAttrs">
<summary>
 Only record, union, exception and struct types may be augmented with the &apos;ReferenceEquality&apos;, &apos;StructuralEquality&apos; and &apos;StructuralComparison&apos; attributes
 (Originally from FSComp.txt:222)
</summary>
</member>
<member name="M:FSComp.SR.augNoRefEqualsOnStruct">
<summary>
 The &apos;ReferenceEquality&apos; attribute cannot be used on structs. Consider using the &apos;StructuralEquality&apos; attribute instead, or implement an override for &apos;System.Object.Equals(obj)&apos;.
 (Originally from FSComp.txt:216)
</summary>
</member>
<member name="M:FSComp.SR.augNoEqualityNeedsNoComparison">
<summary>
 The &apos;NoEquality&apos; attribute must be used in conjunction with the &apos;NoComparison&apos; attribute
 (Originally from FSComp.txt:218)
</summary>
</member>
<member name="M:FSComp.SR.augNoEqNeedsNoObjEquals">
<summary>
 A type with attribute &apos;NoEquality&apos; should not usually have an explicit implementation of &apos;Object.Equals(obj)&apos;. Disable this warning if this is intentional for interoperability purposes
 (Originally from FSComp.txt:226)
</summary>
</member>
<member name="M:FSComp.SR.augNoCompCantImpIComp">
<summary>
 A type with attribute &apos;NoComparison&apos; should not usually have an explicit implementation of &apos;System.IComparable&apos;, &apos;System.IComparable&lt;_&gt;&apos; or &apos;System.Collections.IStructuralComparable&apos;. Disable this warning if this is intentional for interoperability purposes
 (Originally from FSComp.txt:227)
</summary>
</member>
<member name="M:FSComp.SR.augInvalidAttrs">
<summary>
 This type uses an invalid mix of the attributes &apos;NoEquality&apos;, &apos;ReferenceEquality&apos;, &apos;StructuralEquality&apos;, &apos;NoComparison&apos; and &apos;StructuralComparison&apos;
 (Originally from FSComp.txt:217)
</summary>
</member>
<member name="M:FSComp.SR.augCustomEqNeedsObjEquals">
<summary>
 A type with attribute &apos;CustomEquality&apos; must have an explicit implementation of at least one of &apos;Object.Equals(obj)&apos;, &apos;System.IEquatable&lt;_&gt;&apos; or &apos;System.Collections.IStructuralEquatable&apos;
 (Originally from FSComp.txt:224)
</summary>
</member>
<member name="M:FSComp.SR.augCustomEqNeedsNoCompOrCustomComp">
<summary>
 The &apos;CustomEquality&apos; attribute must be used in conjunction with the &apos;NoComparison&apos; or &apos;CustomComparison&apos; attributes
 (Originally from FSComp.txt:228)
</summary>
</member>
<member name="M:FSComp.SR.augCustomCompareNeedsIComp">
<summary>
 A type with attribute &apos;CustomComparison&apos; must have an explicit implementation of at least one of &apos;System.IComparable&apos; or &apos;System.Collections.IStructuralComparable&apos;
 (Originally from FSComp.txt:225)
</summary>
</member>
<member name="M:FSComp.SR.astParseEmbeddedILTypeError">
<summary>
 Error while parsing embedded IL type
 (Originally from FSComp.txt:213)
</summary>
</member>
<member name="M:FSComp.SR.astParseEmbeddedILError">
<summary>
 Error while parsing embedded IL
 (Originally from FSComp.txt:212)
</summary>
</member>
<member name="M:FSComp.SR.astInvalidExprLeftHandOfAssignment">
<summary>
 Invalid expression on left of assignment
 (Originally from FSComp.txt:215)
</summary>
</member>
<member name="M:FSComp.SR.astDeprecatedIndexerNotation">
<summary>
 This indexer notation has been removed from the F# language
 (Originally from FSComp.txt:214)
</summary>
</member>
<member name="M:FSComp.SR.arrayElementHasWrongTypeTuple(System.Int32,System.String,System.Int32,System.String)">
<summary>
 All elements of an array must be implicitly convertible to the type of the first element, which here is a tuple of length %d of type\n    %s    \nThis element is a tuple of length %d of type\n    %s    \n
 (Originally from FSComp.txt:25)
</summary>
</member>
<member name="M:FSComp.SR.arrayElementHasWrongType(System.String,System.String)">
<summary>
 All elements of an array must be implicitly convertible to the type of the first element, which here is &apos;%s&apos;. This element has type &apos;%s&apos;.
 (Originally from FSComp.txt:24)
</summary>
</member>
<member name="M:FSComp.SR.alwaysUseTypedStringInterpolation">
<summary>
 Interpolated string contains untyped identifiers. Adding typed format specifiers is recommended.
 (Originally from FSComp.txt:1758)
</summary>
</member>
<member name="M:FSComp.SR.addIndexerDot">
<summary>
 Add . for indexer access.
 (Originally from FSComp.txt:21)
</summary>
</member>
<member name="M:FSComp.SR.activePatternIdentIsNotFunctionTyped(System.String)">
<summary>
 Active pattern &apos;%s&apos; is not a function
 (Originally from FSComp.txt:1106)
</summary>
</member>
<member name="M:FSComp.SR.activePatternChoiceHasFreeTypars(System.String)">
<summary>
 Active pattern &apos;%s&apos; has a result type containing type variables that are not determined by the input. The common cause is a when a result case is not mentioned, e.g. &apos;let (|A|B|) (x:int) = A x&apos;. This can be fixed with a type constraint, e.g. &apos;let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x&apos;
 (Originally from FSComp.txt:1107)
</summary>
</member>
<member name="M:FSComp.SR.abImplicitHeapAllocation(System.String)">
<summary>
 The mutable local &apos;%s&apos; is implicitly allocated as a reference cell because it has been captured by a closure. This warning is for informational purposes only to indicate where implicit allocations are performed.
 (Originally from FSComp.txt:1361)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityVirtualsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is virtual and the other isn&apos;t
 (Originally from FSComp.txt:122)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityTypesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe types differ
 (Originally from FSComp.txt:114)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityStaticsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is static and the other isn&apos;t
 (Originally from FSComp.txt:121)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityStaticButInstance(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe compiled representation of this method is as a static member but the signature indicates its compiled representation is as an instance member
 (Originally from FSComp.txt:127)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityParameterCountsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe respective type parameter counts differ
 (Originally from FSComp.txt:113)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityOverridesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is marked as an override and the other isn&apos;t
 (Originally from FSComp.txt:125)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityOneIsTypeFunction(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is a type function and the other is not. The signature requires explicit type parameters if they are present in the implementation.
 (Originally from FSComp.txt:112)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityOneIsConstructor(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is a constructor/property and the other is not
 (Originally from FSComp.txt:126)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityNamesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe names differ
 (Originally from FSComp.txt:106)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityLiteralConstantValuesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe literal constant values and/or attributes differ
 (Originally from FSComp.txt:111)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityInstanceButStatic(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe compiled representation of this method is as an instance member, but the signature indicates its compiled representation is as a static member
 (Originally from FSComp.txt:128)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityInlineFlagsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe inline flags differ
 (Originally from FSComp.txt:110)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityGenericParametersDiffer(System.String,System.String,System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe number of generic parameters in the signature and implementation differ (the signature declares %s but the implementation declares %s
 (Originally from FSComp.txt:117)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityGenericParametersAreDifferentKinds(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe generic parameters in the signature and implementation have different kinds. Perhaps there is a missing [&lt;Measure&gt;] attribute.
 (Originally from FSComp.txt:118)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityFinalsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is final and the other isn&apos;t
 (Originally from FSComp.txt:124)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityExtensionsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is an extension member and the other is not
 (Originally from FSComp.txt:115)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityDotNetNamesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe CLI member names differ
 (Originally from FSComp.txt:120)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityDisplayNamesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe display names differ
 (Originally from FSComp.txt:108)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityCompiledNamesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe compiled names differ
 (Originally from FSComp.txt:107)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityAttributesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe mutability attributes differ
 (Originally from FSComp.txt:105)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityArityNotInferred(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nAn arity was not inferred for this value
 (Originally from FSComp.txt:116)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityAritiesDiffer(System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe arities in the signature and implementation differ. The signature specifies that &apos;%s&apos; is function definition or lambda expression accepting at least %s argument(s), but the implementation is a computed function value. To declare that a computed function value is a permitted implementation simply parenthesize its type in the signature, e.g.\n\tval %s: int -&gt; (int -&gt; int)\ninstead of\n\tval %s: int -&gt; int -&gt; int.
 (Originally from FSComp.txt:119)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityAccessibilityMore(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe accessibility specified in the signature is more than that specified in the implementation
 (Originally from FSComp.txt:109)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityAbstractsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is abstract and the other isn&apos;t
 (Originally from FSComp.txt:123)
</summary>
</member>
<member name="M:FSComp.SR.ModuleContainsConstructorButTypesOfFieldsDiffer(System.String,System.String)">
<summary>
 The module contains the constructor\n    %s    \nbut its signature specifies\n    %s    \nThe types of the fields differ
 (Originally from FSComp.txt:162)
</summary>
</member>
<member name="M:FSComp.SR.ModuleContainsConstructorButNamesDiffer(System.String,System.String)">
<summary>
 The module contains the constructor\n    %s    \nbut its signature specifies\n    %s    \nThe names differ
 (Originally from FSComp.txt:160)
</summary>
</member>
<member name="M:FSComp.SR.ModuleContainsConstructorButDataFieldsDiffer(System.String,System.String)">
<summary>
 The module contains the constructor\n    %s    \nbut its signature specifies\n    %s    \nThe respective number of data fields differ
 (Originally from FSComp.txt:161)
</summary>
</member>
<member name="M:FSComp.SR.ModuleContainsConstructorButAccessibilityDiffers(System.String,System.String)">
<summary>
 The module contains the constructor\n    %s    \nbut its signature specifies\n    %s    \nthe accessibility specified in the signature is more than that specified in the implementation
 (Originally from FSComp.txt:163)
</summary>
</member>
<member name="M:FSComp.SR.InvalidRecursiveReferenceToAbstractSlot">
<summary>
 Invalid recursive reference to an abstract slot
 (Originally from FSComp.txt:972)
</summary>
</member>
<member name="M:FSComp.SR.FieldNotContainedTypesDiffer(System.String,System.String)">
<summary>
 The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nThe types differ
 (Originally from FSComp.txt:169)
</summary>
</member>
<member name="M:FSComp.SR.FieldNotContainedStaticsDiffer(System.String,System.String)">
<summary>
 The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nThe &apos;static&apos; modifiers differ
 (Originally from FSComp.txt:166)
</summary>
</member>
<member name="M:FSComp.SR.FieldNotContainedNamesDiffer(System.String,System.String)">
<summary>
 The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nThe names differ
 (Originally from FSComp.txt:164)
</summary>
</member>
<member name="M:FSComp.SR.FieldNotContainedMutablesDiffer(System.String,System.String)">
<summary>
 The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nThe &apos;mutable&apos; modifiers differ
 (Originally from FSComp.txt:167)
</summary>
</member>
<member name="M:FSComp.SR.FieldNotContainedLiteralsDiffer(System.String,System.String)">
<summary>
 The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nThe &apos;literal&apos; modifiers differ
 (Originally from FSComp.txt:168)
</summary>
</member>
<member name="M:FSComp.SR.FieldNotContainedAccessibilitiesDiffer(System.String,System.String)">
<summary>
 The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nthe accessibility specified in the signature is more than that specified in the implementation
 (Originally from FSComp.txt:165)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleSignaturesDiffer(System.String,System.String)">
<summary>
 The exception definitions are not compatible because the exception abbreviations in the signature and implementation differ. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s.
 (Originally from FSComp.txt:187)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleHiddenBySignature(System.String,System.String)">
<summary>
 The exception definitions are not compatible because a CLI exception mapping is being hidden by a signature. The exception mapping must be visible to other modules. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s
 (Originally from FSComp.txt:184)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleFieldOrderDiffers(System.String,System.String)">
<summary>
 The exception definitions are not compatible because the order of the fields is different in the signature and implementation. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s.
 (Originally from FSComp.txt:191)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleFieldInSigButNotImpl(System.String,System.String,System.String)">
<summary>
 The exception definitions are not compatible because the field &apos;%s&apos; was required by the signature but was not specified by the implementation. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s.
 (Originally from FSComp.txt:189)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleFieldInImplButNotSig(System.String,System.String,System.String)">
<summary>
 The exception definitions are not compatible because the field &apos;%s&apos; was present in the implementation but not in the signature. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s.
 (Originally from FSComp.txt:190)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleExceptionDeclarationsDiffer(System.String,System.String)">
<summary>
 The exception definitions are not compatible because the exception declarations differ. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s.
 (Originally from FSComp.txt:188)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleDotNetRepresentationsDiffer(System.String,System.String)">
<summary>
 The exception definitions are not compatible because the CLI representations differ. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s
 (Originally from FSComp.txt:185)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleAbbreviationHiddenBySignature(System.String,System.String)">
<summary>
 The exception definitions are not compatible because the exception abbreviation is being hidden by the signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s.
 (Originally from FSComp.txt:186)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the types have different base types
 (Originally from FSComp.txt:141)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleTypeIsHidden(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because a type representation is being hidden by a signature
 (Originally from FSComp.txt:147)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the types are of different kinds
 (Originally from FSComp.txt:148)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the signature says this type may use nulls as an extra value but the implementation does not
 (Originally from FSComp.txt:136)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleSignatureSaysNull(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the signature says this type may use nulls as a representation but the implementation does not
 (Originally from FSComp.txt:135)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the signature is an abstract class but the implementation is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the implementation.
 (Originally from FSComp.txt:140)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot(System.String,System.String,System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the signature defines the %s &apos;%s&apos; but the implementation does not (or does, but not in the same order)
 (Originally from FSComp.txt:143)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer(System.String,System.String,System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the signature declares a %s while the implementation declares a %s
 (Originally from FSComp.txt:157)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the signature has an abbreviation while the implementation does not
 (Originally from FSComp.txt:159)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the representations differ
 (Originally from FSComp.txt:150)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the respective type parameter counts differ
 (Originally from FSComp.txt:130)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleNumbersDiffer(System.String,System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the number of %ss differ
 (Originally from FSComp.txt:142)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleNamesDiffer(System.String,System.String,System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the names differ. The type is called &apos;%s&apos; in the signature file but &apos;%s&apos; in implementation.
 (Originally from FSComp.txt:129)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleMissingInterface(System.String,System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the signature requires that the type supports the interface %s but the interface has not been implemented
 (Originally from FSComp.txt:132)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplementationSealed(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the implementation type is sealed but the signature implies it is not. Consider adding the [&lt;Sealed&gt;] attribute to the signature.
 (Originally from FSComp.txt:137)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the implementation says this type may use nulls as an extra value but the signature does not
 (Originally from FSComp.txt:134)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplementationSaysNull(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the implementation says this type may use nulls as a representation but the signature does not
 (Originally from FSComp.txt:133)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the implementation type is not sealed but signature implies it is. Consider adding the [&lt;Sealed&gt;] attribute to the implementation.
 (Originally from FSComp.txt:138)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the implementation is an abstract class but the signature is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the signature.
 (Originally from FSComp.txt:139)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplDefinesStruct(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the implementation defines a struct but the signature defines a type with a hidden representation
 (Originally from FSComp.txt:145)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot(System.String,System.String,System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the implementation defines the %s &apos;%s&apos; but the signature does not (or does, but not in the same order)
 (Originally from FSComp.txt:144)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleILDiffer(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the IL representations differ
 (Originally from FSComp.txt:149)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleFieldWasPresent(System.String,System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the field %s was present in the implementation but not in the signature
 (Originally from FSComp.txt:151)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified(System.String,System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the field %s was required by the signature but was not specified by the implementation
 (Originally from FSComp.txt:153)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the order of the fields is different in the signature and implementation
 (Originally from FSComp.txt:152)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig(System.String,System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the field &apos;%s&apos; was present in the implementation but not in the signature. Struct types must now reveal their fields in the signature for the type, though the fields may still be labelled &apos;private&apos; or &apos;internal&apos;.
 (Originally from FSComp.txt:154)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because a CLI type representation is being hidden by a signature
 (Originally from FSComp.txt:146)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the accessibility specified in the signature is more than that specified in the implementation
 (Originally from FSComp.txt:131)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig(System.String,System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the abstract member &apos;%s&apos; was present in the implementation but not in the signature
 (Originally from FSComp.txt:156)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl(System.String,System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the abstract member &apos;%s&apos; was required by the signature but was not specified by the implementation
 (Originally from FSComp.txt:155)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because an abbreviation is being hidden by a signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature.
 (Originally from FSComp.txt:158)
</summary>
</member>
<member name="M:FSComp.SR.DefaultParameterValueNotAppropriateForArgument">
<summary>
 The default value does not have the same type as the argument. The DefaultParameterValue attribute and any Optional attribute will be ignored. Note: &apos;null&apos; needs to be annotated with the correct type, e.g. &apos;DefaultParameterValue(null:obj)&apos;.
 (Originally from FSComp.txt:1394)
</summary>
</member>
<member name="M:FSComp.SR.CallerMemberNameIsOverridden(System.String)">
<summary>
 The CallerMemberNameAttribute applied to parameter &apos;%s&apos; will have no effect. It is overridden by the CallerFilePathAttribute.
 (Originally from FSComp.txt:1389)
</summary>
</member>
<member name="M:FSIstrings.SR.stoppedDueToError">
<summary>
 Stopped due to error\n
 (Originally from Interactive/FSIstrings.txt:2)
</summary>
</member>
<member name="M:FSIstrings.SR.shadowCopyReferences(System.String)">
<summary>
 Prevents references from being locked by the F# Interactive process (%s by default)
 (Originally from Interactive/FSIstrings.txt:56)
</summary>
</member>
<member name="P:FSIstrings.SR.SwallowResourceText(System.Boolean)">
<summary>
 If set to true, then all error messages will just return the filled &apos;holes&apos; delimited by &apos;,,,&apos;s - this is for language-neutral testing (e.g. localization-invariant baselines).
</summary>
</member>
<member name="P:FSIstrings.SR.SwallowResourceText">
<summary>
 If set to true, then all error messages will just return the filled &apos;holes&apos; delimited by &apos;,,,&apos;s - this is for language-neutral testing (e.g. localization-invariant baselines).
</summary>
</member>
<member name="M:FSIstrings.SR.fsiUse">
<summary>
 Use the given file on startup as initial input
 (Originally from Interactive/FSIstrings.txt:11)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiUsage(System.String)">
<summary>
 Usage: %s &lt;options&gt; [script.fsx [&lt;arguments&gt;]]
 (Originally from Interactive/FSIstrings.txt:3)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiUnexpectedThreadAbortException">
<summary>
 - Unexpected ThreadAbortException (Ctrl-C) during event handling: Trying to restart...
 (Originally from Interactive/FSIstrings.txt:51)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiTurnedTimingOn">
<summary>
 --&gt; Timing now on
 (Originally from Interactive/FSIstrings.txt:49)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiTurnedTimingOff">
<summary>
 --&gt; Timing now off
 (Originally from Interactive/FSIstrings.txt:50)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiTimeInfoMainString(System.String,System.String,System.String)">
<summary>
 Real: %s, CPU: %s, GC %s
 (Originally from Interactive/FSIstrings.txt:25)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiTimeInfoGCGenerationLabelSomeShorthandForTheWordGeneration">
<summary>
 gen
 (Originally from Interactive/FSIstrings.txt:26)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiRemaining">
<summary>
 Treat remaining arguments as command line arguments, accessed using fsi.CommandLineArgs
 (Originally from Interactive/FSIstrings.txt:13)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiReadline(System.String)">
<summary>
 Support TAB completion in console (%s by default)
 (Originally from Interactive/FSIstrings.txt:18)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiQuiet">
<summary>
 Suppress fsi writing to stdout
 (Originally from Interactive/FSIstrings.txt:17)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiProductNameCommunity(System.String)">
<summary>
 F# Interactive for F# %s
 (Originally from Interactive/FSIstrings.txt:55)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiProductName(System.String)">
<summary>
 Microsoft (R) F# Interactive version %s
 (Originally from Interactive/FSIstrings.txt:54)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiOperationFailed">
<summary>
 Operation failed. The error text has been printed in the error stream. To return the corresponding FSharpDiagnostic use the EvalInteractionNonThrowing, EvalScriptNonThrowing or EvalExpressionNonThrowing
 (Originally from Interactive/FSIstrings.txt:58)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiOperationCouldNotBeCompleted">
<summary>
 Operation could not be completed due to earlier error
 (Originally from Interactive/FSIstrings.txt:57)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiMultiAssemblyEmitOption(System.String)">
<summary>
 Emit multiple assemblies (%s by default)
 (Originally from Interactive/FSIstrings.txt:59)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiMiscellaneous">
<summary>
 - MISCELLANEOUS -
 (Originally from Interactive/FSIstrings.txt:8)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiLoadingFilesPrefixText">
<summary>
 Loading
 (Originally from Interactive/FSIstrings.txt:40)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiLoad">
<summary>
 #load the given file on startup
 (Originally from Interactive/FSIstrings.txt:12)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiLineTooLong">
<summary>
 Warning: line too long, ignoring some characters\n
 (Originally from Interactive/FSIstrings.txt:24)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiLanguage">
<summary>
 - LANGUAGE -
 (Originally from Interactive/FSIstrings.txt:7)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiInvalidAssembly(System.String)">
<summary>
 &apos;%s&apos; is not a valid assembly name
 (Originally from Interactive/FSIstrings.txt:22)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiIntroTextHeader3(System.String)">
<summary>
       See &apos;%s&apos; for options
 (Originally from Interactive/FSIstrings.txt:39)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiIntroTextHeader2commandLine">
<summary>
   F# Interactive command line options:
 (Originally from Interactive/FSIstrings.txt:38)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiIntroTextHeader1directives">
<summary>
   F# Interactive directives:
 (Originally from Interactive/FSIstrings.txt:28)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiIntroTextHashtimeInfo">
<summary>
 Toggle timing on/off
 (Originally from Interactive/FSIstrings.txt:33)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiIntroTextHashrInfo">
<summary>
 Reference (dynamically load) the given DLL
 (Originally from Interactive/FSIstrings.txt:29)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiIntroTextHashquitInfo">
<summary>
 Exit
 (Originally from Interactive/FSIstrings.txt:36)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiIntroTextHashloadInfo">
<summary>
 Load the given file(s) as if compiled and referenced
 (Originally from Interactive/FSIstrings.txt:32)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiIntroTextHashhelpdocInfo">
<summary>
 Display documentation for an identifier, e.g. #help \&quot;List.map\&quot;;;
 (Originally from Interactive/FSIstrings.txt:35)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiIntroTextHashhelpInfo">
<summary>
 Display help
 (Originally from Interactive/FSIstrings.txt:34)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiIntroTextHashclearInfo">
<summary>
 Clear screen
 (Originally from Interactive/FSIstrings.txt:37)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiIntroTextHashIInfo">
<summary>
 Add the given search path for referenced DLLs
 (Originally from Interactive/FSIstrings.txt:30)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiIntroPackageSourceUriInfo">
<summary>
 Include package source uri when searching for packages
 (Originally from Interactive/FSIstrings.txt:31)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiInterrupt">
<summary>
 \n- Interrupt\n
 (Originally from Interactive/FSIstrings.txt:41)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiInputFiles">
<summary>
 - INPUT FILES -
 (Originally from Interactive/FSIstrings.txt:4)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiHelp">
<summary>
 Display this usage message (Short form: -?)
 (Originally from Interactive/FSIstrings.txt:14)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiGui(System.String)">
<summary>
 Execute interactions on a Windows Forms event loop (%s by default)
 (Originally from Interactive/FSIstrings.txt:16)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiFailedToResolveAssembly(System.String)">
<summary>
 Failed to resolve assembly &apos;%s&apos;
 (Originally from Interactive/FSIstrings.txt:52)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiExit">
<summary>
 \n- Exit...\n
 (Originally from Interactive/FSIstrings.txt:42)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiExec">
<summary>
 Exit fsi after loading the files or running the .fsx script given on the command line
 (Originally from Interactive/FSIstrings.txt:15)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiExceptionRaisedStartingServer(System.String)">
<summary>
 Exception raised when starting remoting server.\n%s
 (Originally from Interactive/FSIstrings.txt:10)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiExceptionDuringPrettyPrinting(System.String)">
<summary>
 \n\nException raised during pretty printing.\nPlease report this so it can be fixed.\nTrace: %s\n
 (Originally from Interactive/FSIstrings.txt:27)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiErrorsAndWarnings">
<summary>
 - ERRORS AND WARNINGS -
 (Originally from Interactive/FSIstrings.txt:6)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiEntryPointWontBeInvoked(System.String,System.String,System.String)">
<summary>
 Functions with [&lt;EntryPoint&gt;] are not invoked in FSI. &apos;%s&apos; was not invoked. Execute &apos;%s &lt;args&gt;&apos; in order to invoke &apos;%s&apos; with the appropriate string array of command line arguments.
 (Originally from Interactive/FSIstrings.txt:60)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiEmitDebugInfoInQuotations(System.String)">
<summary>
 Emit debug information in quotations (%s by default)
 (Originally from Interactive/FSIstrings.txt:19)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiDirectoryDoesNotExist(System.String)">
<summary>
 Directory &apos;%s&apos; doesn&apos;t exist
 (Originally from Interactive/FSIstrings.txt:23)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiDidAHashrWithStaleWarning(System.String)">
<summary>
 --&gt; Referenced &apos;%s&apos; (an assembly with a different timestamp has already been referenced from this location, reset fsi to load the updated assembly)
 (Originally from Interactive/FSIstrings.txt:47)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiDidAHashrWithLockWarning(System.String)">
<summary>
 --&gt; Referenced &apos;%s&apos; (file may be locked by F# Interactive process)
 (Originally from Interactive/FSIstrings.txt:46)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiDidAHashr(System.String)">
<summary>
 --&gt; Referenced &apos;%s&apos;
 (Originally from Interactive/FSIstrings.txt:45)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiDidAHashI(System.String)">
<summary>
 --&gt; Added &apos;%s&apos; to library include path
 (Originally from Interactive/FSIstrings.txt:48)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiDetailedHelpLink">
<summary>
 See https://learn.microsoft.com/dotnet/fsharp/language-reference/fsharp-interactive-options for more details.
 (Originally from Interactive/FSIstrings.txt:61)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiCouldNotInstallCtrlCHandler(System.String)">
<summary>
 Failed to install ctrl-c handler - Ctrl-C handling will not be available. Error was:\n\t%s
 (Originally from Interactive/FSIstrings.txt:44)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiConsoleProblem">
<summary>
 A problem occurred starting the F# Interactive process. This may be due to a known problem with background process console support for Unicode-enabled applications on some Windows systems. Try selecting Tools-&gt;Options-&gt;F# Interactive for Visual Studio and enter &apos;--fsi-server-no-unicode&apos;.
 (Originally from Interactive/FSIstrings.txt:21)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiCodeGeneration">
<summary>
 - CODE GENERATION -
 (Originally from Interactive/FSIstrings.txt:5)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiBindingSessionTo(System.String)">
<summary>
 Binding session to &apos;%s&apos;...
 (Originally from Interactive/FSIstrings.txt:53)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiBanner3">
<summary>
 For help type #help;;
 (Originally from Interactive/FSIstrings.txt:20)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiAdvanced">
<summary>
 - ADVANCED -
 (Originally from Interactive/FSIstrings.txt:9)
</summary>
</member>
<member name="M:FSIstrings.SR.fsiAbortingMainThread">
<summary>
 - Aborting main thread...
 (Originally from Interactive/FSIstrings.txt:43)
</summary>
</member>
<member name="P:UtilsStrings.SR.SwallowResourceText(System.Boolean)">
<summary>
 If set to true, then all error messages will just return the filled &apos;holes&apos; delimited by &apos;,,,&apos;s - this is for language-neutral testing (e.g. localization-invariant baselines).
</summary>
</member>
<member name="P:UtilsStrings.SR.SwallowResourceText">
<summary>
 If set to true, then all error messages will just return the filled &apos;holes&apos; delimited by &apos;,,,&apos;s - this is for language-neutral testing (e.g. localization-invariant baselines).
</summary>
</member>
<member name="M:UtilsStrings.SR.fSharpBannerVersion(System.String,System.String)">
<summary>
 %s for F# %s
 (Originally from Facilities/UtilsStrings.txt:2)
</summary>
</member>
<member name="M:UtilsStrings.SR.buildProductName(System.String)">
<summary>
 Microsoft (R) F# Compiler version %s
 (Originally from Facilities/UtilsStrings.txt:1)
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.unzip``2(System.Collections.Generic.List{System.Tuple{``0,``1}})">
<summary>
 Split an array of pairs into two arrays.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.zip``2(System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Combine the two arrays into an array of pairs. The two arrays must have equal lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised..
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.tryFindIndexi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.tryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.singleton``1(``0)">
<summary>
 Return an array containing the given element.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.scanBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.List{``0},``1)">
<summary>
 Like &lt;c&gt;foldBack&lt;/c&gt;, but return both the intermediary and final results.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.scan``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Collections.Generic.List{``1})">
<summary>
 Like &lt;c&gt;fold&lt;/c&gt;, but return the intermediary and final results.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.mapi2``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise.  The two input
 arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.iteri2``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Apply the given function to pair of elements drawn from matching indices in two arrays,
 also passing the index of the elements. The two arrays must have the same lengths,
 otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is raised.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.isEmpty``1(System.Collections.Generic.List{``0})">
<summary>
 Return True if the given array is empty, otherwise False.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.forall2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Test elements of the two arrays pairwise to see if all pairs of elements satisfy the given predicate.
 Raise &lt;c&gt;ArgumentException&lt;/c&gt; if the arrays have different lengths.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.foldBack2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1},``2)">
<summary>
 Apply a function to pairs of elements drawn from the two collections, right-to-left,
 threading an accumulator argument through the computation.  The two input
 arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.fold2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,System.Collections.Generic.List{``1},System.Collections.Generic.List{``2})">
<summary>
 Apply a function to pairs of elements drawn from the two collections,
 left-to-right, threading an accumulator argument
 through the computation.  The two input
 arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.reduceBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.List{``0})">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then
 computes &lt;c&gt;f i0 (...(f iN-1 iN))&lt;/c&gt;. Raises ArgumentException if the array has size zero.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.List{``0})">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt;
 then computes &lt;c&gt;f (... (f i0 i1)...) iN&lt;/c&gt;. Raises ArgumentException if the array has size zero.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.findIndexi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if
 none of the elements satisfy the predicate.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.findIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if
 none of the elements satisfy the predicate.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.exists2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Test elements of the two arrays pairwise to see if any pair of element satisfies the given predicate.
 Raise ArgumentException if the arrays have different lengths.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.toSeq``1(System.Collections.Generic.List{``0})">
<summary>
 Return a view of the array as an enumerable object.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.ofArray``1(``0[])">
<summary>
 Build a &lt;c&gt;ResizeArray&lt;/c&gt; from the given elements.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.toArray``1(System.Collections.Generic.List{``0})">
<summary>
 Return a fixed-length array containing the elements of the input &lt;c&gt;ResizeArray&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.sortBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
 Sort the elements using the key extractor and generic comparison on the keys.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.sort``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},System.Collections.Generic.List{``0})">
<summary>
 Sort the elements using the given comparison function.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.rev``1(System.Collections.Generic.List{``0})">
<summary>
 Return a new array with the elements in reverse order.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.tryPick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.List{``0})">
<summary>
 Apply the given function to successive elements, returning the first
 result where function returns Some(x) for some x.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.tryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Return the first element for which the given function returns True.
 Return None if no such element exists.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.find``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Return the first element for which the given function returns True.
 Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if no such element exists.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.List{``0})">
<summary>
 Apply the given function to each element of the array. Return
 the array comprised of the results &quot;x&quot; for each element where
 the function returns &lt;c&gt;Some(x)&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.partition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Split the collection into two collections, containing the
 elements for which the given predicate returns True and False
 respectively.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Return a new collection containing only the elements of the collection
 for which the given predicate returns True.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.forall``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Test if all elements of the array satisfy the given predicate.
 If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; and &quot;j0...jN&quot;
 then computes &lt;c&gt;p i0 &amp;&amp; ... &amp;&amp; p iN&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Test if any element of the array satisfies the given predicate.
 If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt;
 then computes &lt;c&gt;p i0 or ... or p iN&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.mapi``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},System.Collections.Generic.List{``0})">
<summary>
 Build a new array whose elements are the results of applying the given function
 to each of the elements of the array. The integer index passed to the
 function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.iteri``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.List{``0})">
<summary>
 Apply the given function to each element of the array.  The integer passed to the
 function indicates the index of element.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise.  The two input
 arrays must have the same lengths.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.iter2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Apply the given function to two arrays simultaneously. The
 two arrays must have the same lengths, otherwise an Invalid_argument exception is
 raised.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
 Build a new array whose elements are the results of applying the given function
 to each of the elements of the array.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.iter``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},System.Collections.Generic.List{``0})">
<summary>
 Apply the given function to each element of the array.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.List{``0},``1)">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then
 computes &lt;c&gt;f i0 (...(f iN s))&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Collections.Generic.List{``1})">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt;
 then computes &lt;c&gt;f (... (f s i0)...) iN&lt;/c&gt;
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Build an array from the given list.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.toList``1(System.Collections.Generic.List{``0})">
<summary>
 Build a list from the given array.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.blit``1(System.Collections.Generic.List{``0},System.Int32,System.Collections.Generic.List{``0},System.Int32,System.Int32)">
<summary>
 Read a range of elements from the first array and write them into the second.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.fill``1(System.Collections.Generic.List{``0},System.Int32,System.Int32,``0)">
<summary>
 Fill a range of the collection with the given element.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.copy``1(System.Collections.Generic.List{``0})">
<summary>
 Build a new array that contains the elements of the given array.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.sub``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
<summary>
 Build a new array that contains the given subrange specified by
 starting index and length.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.concat``1(Microsoft.FSharp.Collections.FSharpList{System.Collections.Generic.List{``0}})">
<summary>
 Build a new array that contains the elements of each of the given list of arrays.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.append``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})">
<summary>
 Build a new array that contains the elements of the first array followed by the elements of the second array.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.init``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 Create an array by calling the given generator on each index.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.create``1(System.Int32,``0)">
<summary>
 Create an array whose elements are all initially the given value.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.set``1(System.Collections.Generic.List{``0},System.Int32,``0)">
<summary>
 Set the value of an element in the collection. You can also use the syntax &lt;c&gt;arr.[idx] &lt;- e&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.get``1(System.Collections.Generic.List{``0},System.Int32)">
<summary>
 Fetch an element from the collection.  You can also use the syntax &lt;c&gt;arr.[idx]&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.length``1(System.Collections.Generic.List{``0})">
<summary>
 Return the length of the collection.  You can also use property &lt;c&gt;arr.Length&lt;/c&gt;.
</summary>
</member>
<member name="T:Internal.Utilities.ResizeArrayModule">
<summary>
 Generic operations on the type System.Collections.Generic.List, which is called ResizeArray in the F# libraries.
</summary>
</member>
<member name="M:Internal.Utilities.EditDistance.CalculateEditDistance(System.String,System.String)">
<summary>
 Calculates the edit distance between two strings.
 The edit distance is a metric that allows to measure the amount of difference between two strings
 and shows how many edit operations (insert, delete, substitution) are needed to transform one string into the other.
</summary>
</member>
<member name="M:Internal.Utilities.EditDistance.JaroWinklerDistance(System.String,System.String)">
<summary>
 Calculates the Jaro-Winkler edit distance between two strings.
 The edit distance is a metric that allows to measure the amount of similarity between two strings.
</summary>
</member>
<member name="T:Internal.Utilities.DependencyGraph.GraphBuilder`4">
<summary>
 This type can be used to chain together a series of dependent nodes when there is some kind of type hierarchy in the graph.
 That is when &apos;T represents some subset of &apos;Val (e.g. a sub type or a case in DU).
 It can also carry some state that is passed along the chain.
</summary>
</member>
<member name="T:Internal.Utilities.DependencyGraph">
<summary>
 This Dependency Graph provides a way to maintain an up-to-date but lazy set of dependent values.
 When changes are applied to the graph (either vertices change value or edges change), no computation is performed.
 Only when a value is requested it is lazily computed and thereafter stored until invalidated by further changes.
</summary>
</member>
<member name="T:Internal.Utilities.Library.LayeredMultiMap`2">
<summary>
 Immutable map collection, with explicit flattening to a backing dictionary
</summary>
</member>
<member name="T:Internal.Utilities.Library.IPartialEqualityComparer`1">
<summary>
 Interface that defines methods for comparing objects using partial equality relation
</summary>
</member>
<member name="T:Internal.Utilities.Library.LazyWithContext`2">
<summary>
 Just like &quot;Lazy&quot; but EVERY forcer must provide an instance of &quot;ctxt&quot;, e.g. to help track errors
 on forcing back to at least one sensible user location
</summary>
</member>
<member name="T:Internal.Utilities.Library.StampedDictionary`2">
<summary>
 A thread-safe lookup table which is assigning an auto-increment stamp with each insert
</summary>
</member>
<member name="T:Internal.Utilities.Library.MemoizationTable`2">
<summary>
 Memoize tables (all entries cached, never collected unless whole table is collected)
</summary>
</member>
<member name="T:Internal.Utilities.Library.UniqueStampGenerator`1">
<summary>
 Generates unique stamps
</summary>
</member>
<member name="T:Internal.Utilities.Library.Lock`1">
<summary>
 Encapsulates a lock associated with a particular token-type representing the acquisition of that lock.
</summary>
</member>
<member name="T:Internal.Utilities.Library.LockToken">
<summary>
 A base type for various types of tokens that must be passed when a lock is taken.
 Each different static lock should declare a new subtype of this type.
</summary>
</member>
<member name="T:Internal.Utilities.Library.AnyCallerThreadToken">
<summary>
 Represents a token that indicates execution on any of several potential user threads calling the F# compiler services.
</summary>
</member>
<member name="T:Internal.Utilities.Library.CompilationThreadToken">
<summary>
 Represents a token that indicates execution on the compilation thread, i.e.
   - we have full access to the (partially mutable) TAST and TcImports data structures
   - compiler execution may result in type provider invocations when resolving types and members
   - we can access various caches in the SourceCodeServices

 Like other execution tokens this should be passed via argument passing and not captured/stored beyond
 the lifetime of stack-based calls. This is not checked, it is a discipline within the compiler code.
</summary>
</member>
<member name="T:Internal.Utilities.Library.ExecutionToken">
<summary>
 Represents a permission active at this point in execution
</summary>
</member>
<member name="T:Internal.Utilities.Library.Cancellable`1">
<summary>
 Represents a synchronous, cold-start, cancellable computation with explicit representation of a cancelled result.

 A cancellable computation may be cancelled via a CancellationToken, which is propagated implicitly.
 If cancellation occurs, it is propagated as data rather than by raising an OperationCanceledException.
</summary>
</member>
<member name="M:Internal.Utilities.Library.NameMap.subfold2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}}},Microsoft.FSharp.Collections.FSharpMap{``0,``3},Microsoft.FSharp.Collections.FSharpMap{``0,``1},``2)">
<summary>
 For every entry in m2 find an entry in m1 and fold
</summary>
</member>
<member name="M:Internal.Utilities.Library.NameMap.union``2(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{``0},``1},System.Collections.Generic.IEnumerable{Microsoft.FSharp.Collections.FSharpMap{System.String,``0}})">
<summary>
 Union entries by identical key, using the provided function to union sets of values
</summary>
</member>
<member name="M:Internal.Utilities.Library.NameMap.layerAdditive``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Collections.FSharpList{``0}}},Microsoft.FSharp.Collections.FSharpMap{``2,``1},Microsoft.FSharp.Collections.FSharpMap{``2,Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
 Not a very useful function - only called in one place - should be changed
</summary>
</member>
<member name="M:Internal.Utilities.Library.IPartialEqualityComparer.partialDistinctBy``1(Internal.Utilities.Library.IPartialEqualityComparer{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Like Seq.distinctBy but only filters out duplicates for some of the elements
</summary>
</member>
<member name="T:Internal.Utilities.Library.IPartialEqualityComparer">
<summary>
 Interface that defines methods for comparing objects using partial equality relation
</summary>
</member>
<member name="T:Internal.Utilities.Library.Tables">
<summary>
 Intern tables to save space.
</summary>
</member>
<member name="M:Internal.Utilities.Library.LockAutoOpens.AssumeCompilationThreadWithoutEvidence">
<summary>
 Represents a place in the compiler codebase where we assume we are executing on a compilation thread
</summary>
</member>
<member name="M:Internal.Utilities.Library.LockAutoOpens.DoesNotRequireCompilerThreadTokenAndCouldPossiblyBeMadeConcurrent(Internal.Utilities.Library.CompilationThreadToken)">
<summary>
 Represents a place in the compiler codebase where we are passed a CompilationThreadToken unnecessarily.
 This represents code that may potentially not need to be executed on the compilation thread.
</summary>
</member>
<member name="M:Internal.Utilities.Library.LockAutoOpens.RequireCompilationThread(Internal.Utilities.Library.CompilationThreadToken)">
<summary>
 Represents a place where we are stating that execution on the compilation thread is required. The
 reason why will be documented in a comment in the code at the callsite.
</summary>
</member>
<member name="M:Internal.Utilities.Library.String.split(System.StringSplitOptions,System.String[],System.String)">
<summary>
 Splits a string into substrings based on the strings in the array separators
</summary>
</member>
<member name="M:Internal.Utilities.Library.ResizeArray.mapToSmallArrayChunks``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
 Split a large ResizeArray into a series of array chunks that are each under the Large Object Heap limit.
 This is done to help prevent a stop-the-world collection of the single large array, instead allowing for a greater
 probability of smaller collections. Stop-the-world is still possible, just less likely.
</summary>
</member>
<member name="M:Internal.Utilities.Library.ResizeArray.chunkBySize``2(System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
 Split a ResizeArray into an array of smaller chunks.
 This requires `items/chunkSize` Array copies of length `chunkSize` if `items/chunkSize % 0 = 0`,
 otherwise `items/chunkSize + 1` Array copies.
</summary>
</member>
<member name="M:Internal.Utilities.Library.Array.endsWith``1(``0[],``0[])">
<summary>
 Returns true if one array has trailing elements equal to another&apos;s.
</summary>
</member>
<member name="M:Internal.Utilities.Library.Array.startsWith``1(``0[],``0[])">
<summary>
 Returns true if one array has another as its subset from index 0.
</summary>
</member>
<member name="M:Internal.Utilities.Library.Array.isSubArray``1(``0[],``0[],System.Int32)">
<summary>
 Check if subArray is found in the wholeArray starting at the provided index
</summary>
</member>
<member name="M:Internal.Utilities.Library.Array.heads``1(``0[])">
<summary>
 Returns all heads of a given array.
</summary>
</member>
<member name="M:Internal.Utilities.Library.Array.areEqual``1(``0[],``0[])">
<summary>
 Optimized arrays equality. ~100x faster than `array1 = array2` on strings.
 ~2x faster for floats
 ~0.8x slower for ints
</summary>
</member>
<member name="M:Internal.Utilities.Library.Array.replace``1(System.Int32,``0,``0[])">
<summary>
 Returns a new array with an element replaced with a given value.
</summary>
</member>
<member name="M:Internal.Utilities.Library.Array.mapAsync``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},``0[])">
<summary>
 Async implementation of Array.map.
</summary>
</member>
<member name="M:Internal.Utilities.Library.Array.revInPlace``1(``0[])">
<summary>
 pass an array byref to reverse it in place
</summary>
</member>
<member name="M:Internal.Utilities.Library.PervasiveAutoOpens.Async.RunImmediate.Static``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
<summary>
 Runs the computation synchronously, always starting on the current thread.
</summary>
</member>
<member name="M:Internal.Utilities.Library.PervasiveAutoOpens.getHole``1(Microsoft.FSharp.Core.FSharpRef{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Get an initialization hole
</summary>
</member>
<member name="P:Internal.Utilities.Library.PervasiveAutoOpens.LOH_SIZE_THRESHOLD_BYTES">
<summary>
 Per the docs the threshold for the Large Object Heap is 85000 bytes: https://learn.microsoft.com/dotnet/standard/garbage-collection/large-object-heap#how-an-object-ends-up-on-the-large-object-heap-and-how-gc-handles-them
 We set the limit to be 80k to account for larger pointer sizes for when F# is running 64-bit.
</summary>
</member>
<member name="M:Internal.Utilities.Library.PervasiveAutoOpens.isSingleton``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Returns true if the list contains exactly 1 element. Otherwise false.
</summary>
</member>
<member name="M:Internal.Utilities.Library.PervasiveAutoOpens.isNilOrSingleton``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Returns true if the list has less than 2 elements. Otherwise false.
</summary>
</member>
<member name="M:Internal.Utilities.Library.PervasiveAutoOpens.op_GreaterGreaterGreaterAmp(System.Int32,System.Int32)">
<summary>
 Logical shift right treating int32 as unsigned integer.
 Code that uses this should probably be adjusted to use unsigned integer types.
</summary>
</member>
<member name="M:Internal.Utilities.Library.Cancellable.token">
<summary>
 Bind the cancellation token associated with the computation
</summary>
</member>
<member name="M:Internal.Utilities.Library.Cancellable.runWithoutCancellation``1(Internal.Utilities.Library.Cancellable{``0})">
<summary>
 Run the computation in a mode where it may not be cancelled. The computation never results in a
 ValueOrCancelled.Cancelled.
</summary>
</member>
<member name="M:Internal.Utilities.Library.Cancellable.run``1(System.Threading.CancellationToken,Internal.Utilities.Library.Cancellable{``0})">
<summary>
 Run a cancellable computation using the given cancellation token
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.DisposablesTracker.Register(System.IDisposable)">
<summary>
 Register some items to dispose
</summary>
</member>
<member name="T:Internal.Utilities.Library.Extras.DisposablesTracker">
<summary>
 Track a set of resources to cleanup
</summary>
</member>
<member name="T:Internal.Utilities.Library.Extras.cache`1">
<summary>
 Caches, mainly for free variables
</summary>
</member>
<member name="T:Internal.Utilities.Library.Extras.NonNullSlot`1">
<summary>
 In some cases we play games where we use &apos;null&apos; as a more efficient representation
 in F#. The functions below are used to give initial values to mutable fields.
 This is an unsafe trick, as it relies on the fact that the type of values
 being placed into the slot never utilizes &quot;null&quot; as a representation. To be used with
 with care.
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.StringBuilder.AppendString(System.Text.StringBuilder,System.String)">
<summary>
 Like Append, but returns unit
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.writeViaBuffer(System.IO.TextWriter,Microsoft.FSharp.Core.FSharpFunc{System.Text.StringBuilder,Microsoft.FSharp.Core.Unit})">
<summary>
 Writing to output stream via a string buffer.
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.buildString(Microsoft.FSharp.Core.FSharpFunc{System.Text.StringBuilder,Microsoft.FSharp.Core.Unit})">
<summary>
 Buffer printing utility
</summary>
</member>
<member name="T:Internal.Utilities.Library.Extras.ArrayParallel">
<summary>
 Specialized parallel functions for an array.
 Different from Array.Parallel as it will try to minimize the max degree of parallelism.
 Will flatten aggregate exceptions that contain one exception.
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.ListSet.setify``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Note: if duplicates appear, keep the ones toward the _front_ of the list
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.ListSet.intersect``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 NOTE: not tail recursive!
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.ListSet.subtract``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 NOTE: quadratic!
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.ListSet.findIndex``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},``1,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 NOTE: O(n)!
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.ListSet.insert``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},``0,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 NOTE: O(n)!
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.ListAssoc.tryFind``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},``0,Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
<summary>
 Treat a list of key-value pairs as a lookup collection.
 This function looks up a value based on a match from the supplied
 predicate function and returns None if value does not exist.
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.ListAssoc.find``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},``0,Microsoft.FSharp.Collections.FSharpList{System.Tuple{``1,``2}})">
<summary>
 Treat a list of key-value pairs as a lookup collection.
 This function looks up a value based on a match from the supplied predicate function.
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.Bits.b3(System.Int32)">
<summary>
 Get the most significant byte of a 32-bit integer
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.Bits.b2(System.Int32)">
<summary>
 Get the 3rd least significant byte of a 32-bit integer
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.Bits.b1(System.Int32)">
<summary>
 Get the 2nd least significant byte of a 32-bit integer
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.Bits.b0(System.Int32)">
<summary>
 Get the least significant byte of a 32-bit integer
</summary>
</member>
<member name="T:Internal.Utilities.Rational">
<summary>
 Rational arithmetic, used for exponents on units-of-measure
</summary>
</member>
<member name="M:Internal.Utilities.PathMapModule.applyDir(Internal.Utilities.PathMap,System.String)">
<summary>
 Map a directory name with its replacement.
 Prefixes are compared case sensitively.
</summary>
</member>
<member name="M:Internal.Utilities.PathMapModule.apply(Internal.Utilities.PathMap,System.String)">
<summary>
 Map a file path with its replacement.
 Prefixes are compared case sensitively.
</summary>
</member>
<member name="M:Internal.Utilities.PathMapModule.addMapping(System.String,System.String,Internal.Utilities.PathMap)">
<summary>
 Add a path mapping to the map.
</summary>
</member>
<member name="T:Internal.Utilities.Hashing.Md5StringHasher">
<summary>
 Tools for hashing things with MD5 into a string that can be used as a cache key.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.UnicodeTables.Interpret(System.Int32,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Interpret tables for a unicode lexer generated by &lt;c&gt;fslex.exe&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.UnicodeTables.Create(System.UInt16[][],System.UInt16[])">
<summary>
 Create the tables from raw data
</summary>
</member>
<member name="T:Internal.Utilities.Text.Lexing.UnicodeTables">
<summary>
 The type of tables for an unicode lexer generated by &lt;c&gt;fslex.exe&lt;/c&gt;.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.StartPos(Internal.Utilities.Text.Lexing.Position)">
<summary>
 The start position for the lexeme.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.IsPastEndOfStream(System.Boolean)">
<summary>
 True if the refill of the buffer ever failed , or if explicitly set to True.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.EndPos(Internal.Utilities.Text.Lexing.Position)">
<summary>
 The end position for the lexeme.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.StartPos">
<summary>
 The start position for the lexeme.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.ReportLibraryOnlyFeatures">
<summary>
 Determines if the parser can report FSharpCore library-only features.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.LexemeView">
<summary>
 The currently matched text as a Span, it is only valid until the lexer is advanced
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.LanguageVersion">
<summary>
 Get the language version being supported
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.IsPastEndOfStream">
<summary>
 True if the refill of the buffer ever failed , or if explicitly set to True.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.EndPos">
<summary>
 The end position for the lexeme.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.BufferLocalStore">
<summary>
 Dynamically typed, non-lexically scoped parameter table.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.SupportsFeature(FSharp.Compiler.Features.LanguageFeature)">
<summary>
 True if the specified language feature is supported.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.LexemeString(Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Fast helper to turn the matched characters into a string, avoiding an intermediate array.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.LexemeContains(`0)">
<summary>
 Determine if Lexeme contains a specific character
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.LexemeChar(System.Int32)">
<summary>
 Get single character of matched string
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.FromSourceText(System.Boolean,FSharp.Compiler.Features.LanguageVersion,Microsoft.FSharp.Core.FSharpOption{System.Boolean},FSharp.Compiler.Text.ISourceText)">
<summary>
 Create a lex buffer backed by source text.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.FromFunction(System.Boolean,FSharp.Compiler.Features.LanguageVersion,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{`0[],System.Int32,System.Int32},System.Int32})">
<summary>
 Create a lex buffer that reads character or byte inputs by using the given function.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.FromChars(System.Boolean,FSharp.Compiler.Features.LanguageVersion,Microsoft.FSharp.Core.FSharpOption{System.Boolean},System.Char[])">
<summary>
 Create a lex buffer suitable for Unicode lexing that reads characters from the given array.
 Important: does take ownership of the array.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.CheckLanguageFeatureAndRecover(FSharp.Compiler.Features.LanguageFeature,FSharp.Compiler.Text.Range)">
<summary>
 Logs a recoverable error if a language feature is unsupported, at the specified range.
</summary>
</member>
<member name="T:Internal.Utilities.Text.Lexing.LexBuffer`1">
<summary>
 Input buffers consumed by lexers generated by &lt;c&gt;fslex.exe&lt;/c&gt;.
 The type must be generic to match the code generated by FsLex and FsYacc (if you would like to
 fix this, please submit a PR to the FsLexYacc repository allowing for optional emit of a non-generic type reference).
</summary>
</member>
<member name="F:Internal.Utilities.Text.Lexing.Position.StartOfLineAbsoluteOffset">
<summary>
 Return absolute offset of the start of the line marked by the position.
</summary>
</member>
<member name="F:Internal.Utilities.Text.Lexing.Position.AbsoluteOffset">
<summary>
 The character number in the input stream.
</summary>
</member>
<member name="F:Internal.Utilities.Text.Lexing.Position.OriginalLine">
<summary>
 The line number for the position in the input stream, assuming fresh positions have been updated
 using for the new line.
</summary>
</member>
<member name="F:Internal.Utilities.Text.Lexing.Position.Line">
<summary>
 The line number in the input stream, assuming fresh positions have been updated
 for the new line by modifying the EndPos property of the LexBuffer.
</summary>
</member>
<member name="F:Internal.Utilities.Text.Lexing.Position.FileIndex">
<summary>
 The file index for the file associated with the input stream, use &lt;c&gt;fileOfFileIndex&lt;/c&gt; to decode
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.NextLine">
<summary>
 Given a position just beyond the end of a line, return a position at the start of the next line.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.Empty">
<summary>
 Get an arbitrary position, with the empty string as file name.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.ColumnMinusOne">
<summary>
 Same line, column -1.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.Column">
<summary>
 Return the column number marked by the position,
 i.e. the difference between the &lt;c&gt;AbsoluteOffset&lt;/c&gt; and the &lt;c&gt;StartOfLineAbsoluteOffset&lt;/c&gt;
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.Position.ShiftColumnBy(System.Int32)">
<summary>
 Gives a position shifted by specified number of characters.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.Position.EndOfToken(System.Int32)">
<summary>
 Given a position at the start of a token of length n, return a position just beyond the end of the token.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.Position.ApplyLineDirective(System.Int32,System.Int32)">
<summary>
 Apply a #line directive.
</summary>
</member>
<member name="T:Internal.Utilities.Text.Lexing.Position">
<summary>
 Position information stored for lexing tokens
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.tagOfErrorTerminal">
<summary>
 The tag of the error terminal.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.numTerminals">
<summary>
 The total number of terminals.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.parseError">
<summary>
 This function is used to hold the user specified &quot;parse_error&quot; or &quot;parse_error_rich&quot; functions.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.productionToNonTerminalTable">
<summary>
 This table is logically part of the Goto table.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.stateToProdIdxsTableRowOffsets">
<summary>
 The sparse table offsets for the productions active for each state.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.stateToProdIdxsTableElements">
<summary>
 The sparse table for the productions active for each state.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.sparseGotoTableRowOffsets">
<summary>
 The sparse goto table row offsets.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.gotos">
<summary>
 The sparse goto table.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.immediateActions">
<summary>
 The immediate action table.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.reductionSymbolCounts">
<summary>
 The number of symbols for each reduction.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.actionTableRowOffsets">
<summary>
 The sparse action table row offsets.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.actionTableElements">
<summary>
 The sparse action table elements.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.dataOfToken">
<summary>
 A function to compute the data carried by a token.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.tagOfToken">
<summary>
 A function to compute the tag of a token.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.endOfInputTag">
<summary>
 The token number indicating the end of input.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.reductions">
<summary>
 The reduction table.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.Tables`1.Interpret(Microsoft.FSharp.Core.FSharpFunc{Internal.Utilities.Text.Lexing.LexBuffer{System.Char},`0},Internal.Utilities.Text.Lexing.LexBuffer{System.Char},System.Int32)">
<summary>
 Interpret the parser table taking input from the given lexer, using the given lex buffer, and the given start state.
 Returns an object indicating the final synthesized value for the parse.
</summary>
</member>
<member name="T:Internal.Utilities.Text.Parsing.Tables`1">
<summary>
 Tables generated by fsyacc
 The type of the tables contained in a file produced by the &lt;c&gt;fsyacc.exe&lt;/c&gt; parser generator.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.StateStack">
<summary>
 The stack of state indexes active at the parse error .
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.ShiftTokens">
<summary>
 The token that would cause a shift at the parse error.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.ReducibleProductions">
<summary>
 The stack of productions that would be reduced at the parse error.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.ReduceTokens">
<summary>
 The tokens that would cause a reduction at the parse error.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.ParseState">
<summary>
 The state active at the parse error.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.Message">
<summary>
 The message associated with the parse error.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.CurrentToken">
<summary>
 The token that caused the parse error.
</summary>
</member>
<member name="T:Internal.Utilities.Text.Parsing.ParseErrorContext`1">
<summary>
 The context provided when a parse error occurs.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.IParseState.ResultStartPosition">
<summary>
 Get the start of the range of positions matched by the production.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.IParseState.ResultRange">
<summary>
 Get the full range of positions matched by the production.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.IParseState.ResultEndPosition">
<summary>
 Get the end of the range of positions matched by the production.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.IParseState.LexBuffer">
<summary>
 Return the LexBuffer for this parser instance.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.IParseState.RaiseError``1">
<summary>
 Raise an error in this parse context.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.IParseState.InputStartPosition(System.Int32)">
<summary>
 Get the start position for the terminal or non-terminal at a given index matched by the production.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.IParseState.InputRange(System.Int32)">
<summary>
 Get the start and end position for the terminal or non-terminal at a given index matched by the production.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.IParseState.InputEndPosition(System.Int32)">
<summary>
 Get the end position for the terminal or non-terminal at a given index matched by the production.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.IParseState.GetInput(System.Int32)">
<summary>
 Get the value produced by the terminal or non-terminal at the given position.
</summary>
</member>
<member name="T:Internal.Utilities.Text.Parsing.RecoverableParseError">
<summary>
 Indicates a parse error has occurred and parse recovery is in progress.
</summary>
</member>
<member name="T:Internal.Utilities.Text.Parsing.Accept">
<summary>
 Indicates an accept action has occurred.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.ParseHelpers.parse_error(System.String)">
<summary>
 The default implementation of the parse_error function.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.ParseHelpers.parse_error_rich``1">
<summary>
 The default implementation of the parse_error_rich function.
</summary>
</member>
<member name="T:Internal.Utilities.Text.Parsing.ParseHelpers">
<summary>
 Helpers used by generated parsers.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.HashMultiMap`2.Item(`0,`1)">
<summary>
 Lookup or set the given element in the table. Set replaces all existing bindings for a value with a single
 bindings. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if the element is not found.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.HashMultiMap`2.Item(`0)">
<summary>
 Lookup or set the given element in the table. Set replaces all existing bindings for a value with a single
 bindings. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if the element is not found.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.HashMultiMap`2.Count">
<summary>
 The total number of keys in the hash table.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.TryFind(`0)">
<summary>
 Lookup the given element in the table, returning the result as an Option.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Replace(`0,`1)">
<summary>
 Replace the latest binding if any for the given element.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Remove(`0)">
<summary>
 Remove the latest binding if any for the given element from the table.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Iterate(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.Unit}})">
<summary>
 Apply the given function to each binding in the hash table.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Fold``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},``0)">
<summary>
 Apply the given function to each element in the collection threading the accumulating parameter
 through the sequence of function applications.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.FindAll(`0)">
<summary>
 Find all bindings for the given element in the table, if any.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Copy">
<summary>
 Make a shallow copy of the collection.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.ContainsKey(`0)">
<summary>
 Test if the collection contains any bindings for the given element.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Clear">
<summary>
 Clear all elements from the collection.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Add(`0,`1)">
<summary>
 Add a binding for the element to the table.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.#ctor(System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}},System.Collections.Generic.IEqualityComparer{`0},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Build a map that contains the bindings of the given IEnumerable.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Create a new empty mutable HashMultiMap with an internal bucket array of the given approximate size
 and with the given key hash/equality functions.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.#ctor(System.Collections.Generic.IEqualityComparer{`0},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Create a new empty mutable HashMultiMap with the given key hash/equality functions.
</summary>
</member>
<member name="T:Internal.Utilities.Collections.HashMultiMap`2">
<summary>
 Hash tables, by default based on F# structural &quot;hash&quot; and (=) functions.
 The table may map a single key to multiple bindings.
</summary>
</member>
<member name="T:Internal.Utilities.Collections.Zmap`2">
<summary>
 Maps with a specific comparison function
</summary>
</member>
<member name="T:Internal.Utilities.Collections.Zset`1">
<summary>
 Sets with a specific comparison function
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`3.TryGetSimilarAny(`0,`1)">
<summary>
 Get the value for the given key or &lt;c&gt;None&lt;/c&gt; if not still valid. Skips `areSame` checking unless `areSimilar` is not provided.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`3.TryGetSimilar(`0,`1)">
<summary>
 Get the value for the given key or None, but only if entry is still valid. Skips `areSame` checking unless `areSimilar` is not provided.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`3.TryGetAny(`0,`1)">
<summary>
 Get the value for the given key or &lt;c&gt;None&lt;/c&gt; if not still valid.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`3.TryGet(`0,`1)">
<summary>
 Get the value for the given key or None, but only if entry is still valid
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`3.Set(`0,`1,`2)">
<summary>
 Set the given key.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`3.Resize(`0,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Resize
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`3.RemoveAnySimilar(`0,`1)">
<summary>
 Remove the given value from the mru cache.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`3.ContainsSimilarKey(`0,`1)">
<summary>
 Get the similar (subsumable) value for the given key or &lt;c&gt;None&lt;/c&gt; if not already available.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`3.Clear(`0)">
<summary>
 Clear out the cache.
</summary>
</member>
<member name="T:Internal.Utilities.Collections.MruCache`3">
<summary>
 Simple priority caching for a small number of key/value associations.
 This cache may age-out results that have been Set by the caller.
 Because of this, the caller must be able to tolerate values
 that aren&apos;t what was originally passed to the Set function.

 Concurrency: This collection is thread-safe, though concurrent use may result in different
 threads seeing different live sets of cached items.

  - areSimilar: Keep at most once association for two similar keys (as given by areSimilar)
</summary>
</member>
<member name="M:Internal.Utilities.Collections.AgedLookup`3.TryPeekKeyValue(`0,`1)">
<summary>
 Lookup the value without making it the most recent.
 Returns the original key value because the areSame function
 may have unified two different keys.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.AgedLookup`3.TryGetKeyValue(`0,`1)">
<summary>
 Lookup a value and make it the most recent.
 Returns the original key value because the areSame function
 may have unified two different keys.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.AgedLookup`3.TryGet(`0,`1)">
<summary>
 Lookup a value and make it the most recent. Return &lt;c&gt;None&lt;/c&gt; if it wasn&apos;t there.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.AgedLookup`3.Resize(`0,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Resize
</summary>
</member>
<member name="M:Internal.Utilities.Collections.AgedLookup`3.Remove(`0,`1)">
<summary>
 Remove the given value from the collection.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.AgedLookup`3.Put(`0,`1,`2)">
<summary>
 Add an element to the collection. Make it the most recent.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.AgedLookup`3.Clear(`0)">
<summary>
 Remove all elements.
</summary>
</member>
<member name="T:Internal.Utilities.Collections.AgedLookup`3">
<summary>
 Simple aging lookup table. When a member is accessed it&apos;s
 moved to the top of the list and when there are too many elements
 the least-recently-accessed element falls of the end.

  - areSimilar: Keep at most once association for two similar keys (as given by areSimilar)
</summary>
</member>
<member name="T:Internal.Utilities.Collections.QueueList`1">
<summary>
 Iterable functional collection with O(1) append-1 time. Useful for data structures where elements get added at the
 end but the collection must occasionally be iterated. Iteration is slower and may allocate because
 a suffix of elements is stored in reverse order.

 The type doesn&apos;t support structural hashing or comparison.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.LruCache`3.Count">
<summary>
 Gets the number of items in the cache
</summary>
</member>
<member name="M:Internal.Utilities.Collections.LruCache`3.GetAll(`0)">
<summary>
 Returns a list of version * value pairs for a given key. The strongly held value is first in the list.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.LruCache`3.GetAll(`0,`1)">
<summary>
 Returns an option of a value for given key and version, and also a list of all other versions for given key
</summary>
</member>
<member name="M:Internal.Utilities.Collections.LruCache`3.Clear(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean})">
<summary>
 Clear any keys that match the given predicate
</summary>
</member>
<member name="M:Internal.Utilities.Collections.LruCache`3.#ctor(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{`2,System.Boolean}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Internal.Utilities.Collections.CacheEvent,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.String,`0,`1},Microsoft.FSharp.Core.Unit}}})">
 <param name="keepStrongly">Maximum number of strongly held results to keep in the cache</param>
 <param name="keepWeakly">Maximum number of weakly held results to keep in the cache</param>
 <param name="requiredToKeep">A predicate that determines if a value should be kept strongly (no matter what)</param>
 <param name="event">An event that is called when an item is evicted, collected, weakened or strengthened</param>
</member>
<member name="T:Internal.Utilities.Collections.LruCache`3">
<summary>
 A cache where least recently used items are removed when the cache is full.

 It&apos;s also versioned, meaning each key can have multiple versions and only the latest one is kept strongly.
 Older versions are kept weakly and can be collected by GC.
</summary>
</member>
<member name="T:Internal.Utilities.Collections.AsyncMemoizeDisabled`3">
<summary>
 A drop-in replacement for AsyncMemoize that disables caching and just runs the computation every time.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.AsyncMemoize`3.#ctor(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <param name="keepStrongly">Maximum number of strongly held results to keep in the cache</param>
 <param name="keepWeakly">Maximum number of weakly held results to keep in the cache</param>
 <param name="name">Name of the cache - used in tracing messages</param>
 <param name="cancelUnawaitedJobs">Cancels a job when all the awaiting requests are canceled. If set to false, unawaited job will run to completion and it's result will be cached.</param>
 <param name="cancelDuplicateRunningJobs">If true, when a job is started, all other jobs with the same key will be canceled.</param>
</member>
<member name="T:Internal.Utilities.Collections.AsyncMemoize`3">
 <summary>
 A cache/memoization for computations that makes sure that the same computation will only be computed once even if it's needed
 at multiple places/times.

 Strongly holds at most one result per key.
 </summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Map`3.Item(`0)">
<summary>
 Lookup an element in the map. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if no binding
 exists in the map.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Map`3.IsEmpty">
<summary>
 Return True if there are no bindings in the map.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Map`3.Count">
<summary>
 The number of bindings in the map.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.TryFind(`0)">
<summary>
 Lookup an element in the map, returning a Some value if the element is in the domain 
 of the map and None if not.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.ToList">
<summary>
 The elements of the set as a list.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.ToArray">
<summary>
 The elements of the set as an array.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Remove(`0)">
<summary>
 Remove an element from the domain of the map.  No exception is raised if the element is not present.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Partition(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,System.Boolean}})">
<summary>
 Build two new maps, one containing the bindings for which the given predicate returns True,
 and another for the remaining bindings.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.MapRange``1(Microsoft.FSharp.Core.FSharpFunc{`1,``0})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Map``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,``0}})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The index passed to the
 function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Iterate(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.Unit}})">
<summary>
 Apply the given function to each binding in the dictionary.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.ForAll(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,System.Boolean}})">
<summary>
 Return True if the given predicate returns true for all of the
 bindings in the map. Always returns true if the map is empty.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.FoldSection``1(`0,`0,Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},``0)">
<summary>
 Given the start and end points of a key range,
 Fold over the bindings in the map that are in the range,
 and the end points are included if present (the range is considered a closed interval).
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.FoldAndMap``2(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``1,``0}}}},``0)">
<summary>
 Fold over the bindings in the map.  
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Fold``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},``0)">
<summary>
 Fold over the bindings in the map.  
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.First``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpOption{``0}}})">
<summary>
 Search the map looking for the first element where the given function returns a Some value.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Filter(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,System.Boolean}})">
<summary>
 Build a new map containing the bindings for which the given predicate returns True.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Exists(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,System.Boolean}})">
<summary>
 Return True if the given predicate returns true for one of the
 bindings in the map. Always returns false if the map is empty.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Empty(`2)">
<summary>
 The empty map, and use the given comparer comparison function for all operations associated
 with any maps built from this map.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Create(`2,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}})">
<summary>
 Build a map that contains the bindings of the given &lt;c&gt;IEnumerable&lt;/c&gt;
 and where comparison of elements is based on the given comparison function.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.ContainsKey(`0)">
<summary>
 Test is an element is in the domain of the map.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Add(`0,`1)">
<summary>
 Return a new map with the binding added to the given map.
</summary>
</member>
<member name="T:Internal.Utilities.Collections.Tagged.Map`3">
<summary>
 Immutable maps.  Keys are ordered by construction function specified
 when creating empty maps or by F# structural comparison if no
 construction function is specified.

 &lt;performance&gt; 
   Maps based on structural comparison are  
   efficient for small keys. They are not a suitable choice if keys are recursive data structures 
   or require non-structural comparison semantics.
 &lt;/performance&gt;
 Immutable maps.  A constraint tag carries information about the class of key-comparers being used.  
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.op_Subtraction(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Return a new set with the elements of the second set removed from the first.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.op_Addition(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Compute the union of the two sets.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Set`2.MinimumElement">
<summary>
 Returns the lowest element in the set according to the ordering being used for the set.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Set`2.MaximumElement">
<summary>
 Returns the highest element in the set according to the ordering being used for the set.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Set`2.IsEmpty">
<summary>
 A useful shortcut for &lt;c&gt;Set.isEmpty&lt;/c&gt;.  See the &lt;c&gt;Set&lt;/c&gt; module for further operations on sets.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Set`2.Count">
<summary>
 Return the number of elements in the set.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Set`2.Choose">
<summary>
 The number of elements in the set.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Union(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Compute the union of the two sets.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.ToList">
<summary>
 The elements of the set as a list.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.ToArray">
<summary>
 The elements of the set as an array.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Singleton(`1,`0)">
<summary>
 A singleton set based on the given comparison operator.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Remove(`0)">
<summary>
 A useful shortcut for &lt;c&gt;Set.remove&lt;/c&gt;.  Note this operation produces a new set
 and does not mutate the original set.  The new set will share many storage
 nodes with the original.  See the &lt;c&gt;Set&lt;/c&gt; module for further operations on sets.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Partition(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean})">
<summary>
 Build two new sets, one containing the elements for which the given predicate returns True,
 and another with the remaining elements.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Iterate(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.Unit})">
<summary>
 Apply the given function to each binding in the collection.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.IsSupersetOf(Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Evaluates to True if all elements of the first set are in the second.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.IsSubsetOf(Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Evaluates to True if all elements of the second set are in the first.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Intersection(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Compute the intersection of the two sets.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.ForAll(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean})">
<summary>
 Test if all elements of the collection satisfy the given predicate.
 If the input function is f and the elements are i0...iN and j0...jN then 
 computes p i0 &amp;&amp; ... &amp;&amp; p iN.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Fold``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0)">
<summary>
 Apply the given accumulating function to all the elements of the set.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Filter(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean})">
<summary>
 Return a new collection containing only the elements of the collection
 for which the given predicate returns True.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Exists(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean})">
<summary>
 Test if any element of the collection satisfies the given predicate.
 If the input function is f and the elements are i0...iN then computes 
 p i0 or ... or p iN.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Equality(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Compares two sets and returns True if they are equal or False otherwise.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Empty(`1)">
<summary>
 The empty set based on the given comparer.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Difference(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Return a new set with the elements of the second set removed from the first.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Create(`1,System.Collections.Generic.IEnumerable{`0})">
<summary>
 A set based on the given comparer containing the given initial elements.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Contains(`0)">
<summary>
 A useful shortcut for &lt;c&gt;Set.contains&lt;/c&gt;.  See the &lt;c&gt;Set&lt;/c&gt; module for further operations on sets.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Compare(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Compares a and b and returns 1 if a &gt; b, -1 if b &lt; a and 0 if a = b.       
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Add(`0)">
<summary>
 A useful shortcut for &lt;c&gt;Set.add&lt;/c&gt;.  Note this operation produces a new set
 and does not mutate the original set.  The new set will share many storage
 nodes with the original.  See the &lt;c&gt;Set&lt;/c&gt; module for further operations on sets.
</summary>
</member>
<member name="T:Internal.Utilities.Collections.Tagged.Set`2">
<summary>
 Immutable sets based on binary trees, default tag
 Immutable sets where a constraint tag carries information about the class of key-comparer being used.  
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Utils.shortPath(System.String)">
<summary>
 Return file name with one directory above it
</summary>
</member>
<member name="M:Internal.Utilities.TypeHashing.HashTypes.hashTyparDecls(FSharp.Compiler.TcGlobals.TcGlobals,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar})">
<summary>
 Hash type parameters
</summary>
</member>
<member name="M:Internal.Utilities.TypeHashing.HashTypes.hashTopType``1(FSharp.Compiler.TcGlobals.TcGlobals,System.Collections.Generic.IEnumerable{``0},FSharp.Compiler.TypedTree.TType,System.Collections.Generic.IEnumerable{System.ValueTuple{FSharp.Compiler.TypedTree.Typar,FSharp.Compiler.TypedTree.TyparConstraint}})">
<summary>
 Hash a single type used as the type of a member or value
</summary>
</member>
<member name="M:Internal.Utilities.TypeHashing.HashTypes.hashTType(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Hash a type, taking precedence into account to insert brackets where needed
</summary>
</member>
<member name="M:Internal.Utilities.TypeHashing.HashTypes.hashMeasure(FSharp.Compiler.TypedTree.Measure)">
<summary>
 Hash a unit of measure expression
</summary>
</member>
<member name="M:Internal.Utilities.TypeHashing.HashTypes.hashConstraints(FSharp.Compiler.TcGlobals.TcGlobals,System.Collections.Generic.IEnumerable{System.ValueTuple{FSharp.Compiler.TypedTree.Typar,FSharp.Compiler.TypedTree.TyparConstraint}})">
<summary>
 Hash type parameter constraints
</summary>
</member>
<member name="M:Internal.Utilities.TypeHashing.HashTypes.hashAttrib(FSharp.Compiler.TypedTree.Attrib)">
<summary>
 Hash an attribute &apos;Type(arg1, ..., argN)&apos;
</summary>
</member>
<member name="M:Internal.Utilities.TypeHashing.HashTypes.hashMemberFlags(FSharp.Compiler.Syntax.SynMemberFlags)">
<summary>
 Hash the flags of a member
</summary>
</member>
<member name="M:Internal.Utilities.TypeHashing.HashTypes.hashTyconRef(FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Hash a reference to a type
</summary>
</member>
<member name="M:Internal.Utilities.TypeHashing.HashTypes.hashStamp(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Get has for Stamp for TType_app tyconref and TType_var typar
</summary>
</member>
<member name="M:Continuation.concatenate``2(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{``0},``1},``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{``0},``1})">
<summary>
 Auxiliary function for `Continuation.sequence` that assumes the recursions return a &apos;T list.
 In the final continuation the `&apos;T list list` will first be concatenated into one list, before being passed to the (final) `continuation`.
</summary>
</member>
<member name="M:Continuation.sequence``2(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{``0},``1})">
<summary>
 This function sequences computations that have been expressed in continuation-passing style.
 Concretely, when &apos;T is `int` as an example, can be expressed in continuation-passing style as a function,
 taking as its input another function that is &quot;how to proceed with a computation given the value of the integer&quot;,
 and returning &quot;the result of that computation&quot;.
 That is, an integer is equivalently represented as a generic function (howToProceed : int -&gt; &apos;TReturn) -&gt; &apos;TReturn,
 and the effect of the function corresponding to the integer 3 is simply to apply the input `howToProceed` to the value 3.

 The motivation for Continuation.sequence is most easily understood when it is viewed without its second argument:
 it is a higher-order function that takes &quot;a list of &apos;T expressed in continuation-passing style&quot;, and returns &quot;a &apos;T list expressed in continuation-passing style&quot;.
 The resulting &quot;continuation-passing &apos;T list&quot; operates by chaining the input &apos;Ts together, and finally returning the result of continuing the computation after first sequencing the inputs.

 Crucially, this technique can be used to enable unbounded recursion:
 it constructs and invokes closures representing intermediate stages of the sequenced computation on the heap, rather than consuming space on the (more constrained) stack.
</summary>
</member>
<member name="M:FSharp.Compiler.Cancellable.UsingToken(System.Threading.CancellationToken)">
<summary>
 For use in testing only. Cancellable.token should be set only by the cancellable computation.
</summary>
</member>
<member name="P:FSharp.Compiler.Tainted`1.TypeProviderDesignation">
<summary>
 Test to report for the name of the type provider that produced the value
</summary>
</member>
<member name="P:FSharp.Compiler.Tainted`1.TypeProviderAssemblyRef">
<summary>
 The ILScopeRef of the runtime assembly reference for type provider that produced the value
</summary>
</member>
<member name="P:FSharp.Compiler.Tainted`1.TypeProvider">
<summary>
 A type provider that produced the value
</summary>
</member>
<member name="M:FSharp.Compiler.Tainted`1.PUntaintNoFailure``1(Microsoft.FSharp.Core.FSharpFunc{`0,``0})">
<summary>
 Apply an operation and &apos;untaint&apos; the result. This can be used if the return type
 is guaranteed not to be implemented by a type provider
</summary>
</member>
<member name="M:FSharp.Compiler.Tainted`1.PUntaint``1(Microsoft.FSharp.Core.FSharpFunc{`0,``0},FSharp.Compiler.Text.Range)">
<summary>
 Apply an operation and &apos;untaint&apos; the result. The result must be marshallable. Any exception will be attributed to the type provider with an error located at the given range
</summary>
</member>
<member name="M:FSharp.Compiler.Tainted`1.PApplyWithProvider``1(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{`0,Microsoft.FSharp.Core.CompilerServices.ITypeProvider},``0},FSharp.Compiler.Text.Range)">
<summary>
 Apply an operation. Any exception will be attributed to the type provider with an error located at the given range
</summary>
</member>
<member name="M:FSharp.Compiler.Tainted`1.PApplyOption``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpOption{``0}},FSharp.Compiler.Text.Range)">
<summary>
 Apply an operation that returns an option. Unwrap option. Any exception will be attributed to the type provider with an error located at the given range
</summary>
</member>
<member name="M:FSharp.Compiler.Tainted`1.PApplyNoFailure``1(Microsoft.FSharp.Core.FSharpFunc{`0,``0})">
<summary>
 Apply an operation. No exception may be raised by &apos;f&apos;
</summary>
</member>
<member name="M:FSharp.Compiler.Tainted`1.PApplyArray``1(Microsoft.FSharp.Core.FSharpFunc{`0,``0[]},System.String,FSharp.Compiler.Text.Range)">
<summary>
 Apply an operation that returns an array. Unwrap array. Any exception will be attributed to the type provider with an error located at the given range.  String is method name of thing-returning-array, to diagnostically attribute if it is null
</summary>
</member>
<member name="M:FSharp.Compiler.Tainted`1.PApply4``4(Microsoft.FSharp.Core.FSharpFunc{`0,System.Tuple{``0,``1,``2,``3}},FSharp.Compiler.Text.Range)">
<summary>
 Apply an operation. Any exception will be attributed to the type provider with an error located at the given range
</summary>
</member>
<member name="M:FSharp.Compiler.Tainted`1.PApply3``3(Microsoft.FSharp.Core.FSharpFunc{`0,System.Tuple{``0,``1,``2}},FSharp.Compiler.Text.Range)">
<summary>
 Apply an operation. Any exception will be attributed to the type provider with an error located at the given range
</summary>
</member>
<member name="M:FSharp.Compiler.Tainted`1.PApply2``2(Microsoft.FSharp.Core.FSharpFunc{`0,System.Tuple{``0,``1}},FSharp.Compiler.Text.Range)">
<summary>
 Apply an operation. Any exception will be attributed to the type provider with an error located at the given range
</summary>
</member>
<member name="M:FSharp.Compiler.Tainted`1.PApply``1(Microsoft.FSharp.Core.FSharpFunc{`0,``0},FSharp.Compiler.Text.Range)">
<summary>
 Apply an operation. Any exception will be attributed to the type provider with an error located at the given range
</summary>
</member>
<member name="M:FSharp.Compiler.Tainted`1.OfType``1">
<summary>
 Conditionally coerce the value
</summary>
</member>
<member name="M:FSharp.Compiler.Tainted`1.CreateAll(Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Core.CompilerServices.ITypeProvider,FSharp.Compiler.AbstractIL.IL.ILScopeRef}})">
<summary>
 Create an initial tainted value
</summary>
</member>
<member name="M:FSharp.Compiler.Tainted`1.Coerce``1(FSharp.Compiler.Text.Range)">
<summary>
 Assert that the value is of &apos;U and coerce the value.
 If coercion fails, the failure will be blamed on a type provider
</summary>
</member>
<member name="T:FSharp.Compiler.Tainted`1">
<summary>
 This struct wraps a value produced by a type provider to properly attribute any failures.
</summary>
</member>
<member name="M:FSharp.Compiler.TypeProviderError.WithContext(System.String,System.String)">
<summary>
 creates new instance of TypeProviderError with specified type\method names
</summary>
</member>
<member name="M:FSharp.Compiler.TypeProviderError.MapText(Microsoft.FSharp.Core.FSharpFunc{System.String,System.Tuple{System.Int32,System.String}},System.String,FSharp.Compiler.Text.Range)">
<summary>
 creates new instance of TypeProviderError based on current instance information(message)
</summary>
</member>
<member name="M:FSharp.Compiler.TypeProviderError.Iter(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypeProviderError,Microsoft.FSharp.Core.Unit})">
<summary>
 provides uniform way to process aggregated errors
</summary>
</member>
<member name="M:FSharp.Compiler.TypeProviderError.#ctor(System.Int32,System.String,FSharp.Compiler.Text.Range,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 creates new instance of TypeProviderError that represents collection of errors
</summary>
</member>
<member name="M:FSharp.Compiler.TypeProviderError.#ctor(System.Tuple{System.Int32,System.String},System.String,FSharp.Compiler.Text.Range)">
<summary>
 creates new instance of TypeProviderError that represents one error
</summary>
</member>
<member name="T:FSharp.Compiler.TypeProviderError">
<summary>
 Stores and transports aggregated list of errors reported by the type provider
</summary>
</member>
<member name="M:FSharp.Compiler.FxResolver.IsReferenceAssemblyPackDirectoryApprox(System.String)">
<summary>
 Determines if an assembly is in the core set of assemblies with high likelihood of
 being shared amongst a set of common scripting references
</summary>
</member>
<member name="M:FSharp.Compiler.FxResolver.GetTfmAndRid">
<summary>
 Gets the selected target framework moniker, e.g netcore3.0, net472, and the running rid of the current machine
</summary>
</member>
<member name="T:FSharp.Compiler.FxResolver">
<summary>
 Resolves the references for a chosen or currently-executing framework, for
   - script execution
   - script editing
   - script compilation
   - out-of-project sources editing
   - default references for fsc.exe
   - default references for fsi.exe
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerEnvironment.MustBeSingleFileProject(System.String)">
<summary>
 Whether or not this file should be a single-file project
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerEnvironment.IsScriptFile(System.String)">
<summary>
 A helpers for dealing with F# files.
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerEnvironment.IsCompilable(System.String)">
<summary>
 Whether or not this file is compilable
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerEnvironment.IsCheckerSupportedSubcategory(System.String)">
<summary>
 Return true if this is a subcategory of error or warning message that the language service can emit
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerEnvironment.GetDebuggerLanguageID">
<summary>
 Return the language ID, which is the expression evaluator id that the debugger will use.
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerEnvironment.GetConditionalDefinesForEditing(FSharp.Compiler.CodeAnalysis.FSharpParsingOptions)">
<summary>
 Return the compilation defines that should be used when editing the given file.
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerEnvironment.DefaultReferencesForOrphanSources(System.Boolean)">
<summary>
 These are the names of assemblies that should be referenced for .fs or .fsi files that
 are not associated with a project.
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerEnvironment.BinFolderOfDefaultFSharpCompiler(Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 The default location of FSharp.Core.dll and fsc.exe based on the version of fsc.exe that is running
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerEnvironment">
<summary>
 Information about the compilation environment
</summary>
</member>
<member name="M:FSharp.Compiler.IO.ByteStorage.FromMemoryAndCopy(System.ReadOnlyMemory{System.Byte},System.Boolean)">
<summary>
 Creates a ByteStorage that has a copy of the given Memory&lt;byte&gt;.
</summary>
</member>
<member name="M:FSharp.Compiler.IO.ByteStorage.FromByteMemoryAndCopy(FSharp.Compiler.IO.ReadOnlyByteMemory,System.Boolean)">
<summary>
 Creates a ByteStorage that has a copy of the given ByteMemory.
</summary>
</member>
<member name="M:FSharp.Compiler.IO.ByteStorage.FromByteMemory(FSharp.Compiler.IO.ReadOnlyByteMemory)">
<summary>
 Creates a ByteStorage whose backing bytes are the given ByteMemory. Does not make a copy.
</summary>
</member>
<member name="M:FSharp.Compiler.IO.ByteStorage.FromByteArrayAndCopy(System.Byte[],System.Boolean)">
<summary>
 Creates a ByteStorage that has a copy of the given byte array.
</summary>
</member>
<member name="M:FSharp.Compiler.IO.ByteStorage.FromByteArray(System.Byte[])">
<summary>
 Creates a ByteStorage whose backing bytes are the given byte array. Does not make a copy.
</summary>
</member>
<member name="T:FSharp.Compiler.IO.ByteBuffer">
<summary>
 Imperative buffers and streams of byte[]
 Not thread safe.
</summary>
</member>
<member name="M:FSharp.Compiler.IO.DefaultFileSystem.#ctor">
<summary>
 Create a default implementation of the file system
</summary>
</member>
<member name="T:FSharp.Compiler.IO.DefaultFileSystem">
<summary>
 Represents a default (memory-mapped) implementation of the file system
</summary>
</member>
<member name="M:FSharp.Compiler.IO.IFileSystem.OpenFileForWriteShim(System.String,Microsoft.FSharp.Core.FSharpOption{System.IO.FileMode},Microsoft.FSharp.Core.FSharpOption{System.IO.FileAccess},Microsoft.FSharp.Core.FSharpOption{System.IO.FileShare})">
<summary>
 Open the file for writing. Returns a Stream.
</summary>
</member>
<member name="M:FSharp.Compiler.IO.IFileSystem.OpenFileForReadShim(System.String,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Open the file for read, returns ByteMemory, uses either FileStream (for smaller files) or MemoryMappedFile (for potentially big files, such as dlls).
</summary>
</member>
<member name="M:FSharp.Compiler.IO.IFileSystem.NormalizePathShim(System.String)">
<summary>
 Removes relative parts from any full paths
</summary>
</member>
<member name="M:FSharp.Compiler.IO.IFileSystem.IsStableFileHeuristic(System.String)">
<summary>
 Used to determine if a file will not be subject to deletion during the lifetime of a typical client process.
</summary>
</member>
<member name="M:FSharp.Compiler.IO.IFileSystem.IsPathRootedShim(System.String)">
<summary>
 A shim over Path.IsPathRooted
</summary>
</member>
<member name="M:FSharp.Compiler.IO.IFileSystem.IsInvalidPathShim(System.String)">
<summary>
 A shim over Path.IsInvalidPath
</summary>
</member>
<member name="M:FSharp.Compiler.IO.IFileSystem.GetTempPathShim">
<summary>
 A shim over Path.GetTempPath
</summary>
</member>
<member name="M:FSharp.Compiler.IO.IFileSystem.GetLastWriteTimeShim(System.String)">
<summary>
 Utc time of the last modification
</summary>
</member>
<member name="M:FSharp.Compiler.IO.IFileSystem.GetFullPathShim(System.String)">
<summary>
 Take in a file name with an absolute path, and return the same file name
 but canonicalized with respect to extra path separators (e.g. C:\\\\foo.txt)
 and &apos;..&apos; portions
</summary>
</member>
<member name="M:FSharp.Compiler.IO.IFileSystem.GetFullFilePathInDirectoryShim(System.String,System.String)">
<summary>
 Take in a directory, filename, and return canonicalized path to the file name in directory.
 If file name path is rooted, ignores directory and returns file name path.
 Otherwise, combines directory with file name and gets full path via GetFullPathShim(string).
</summary>
</member>
<member name="M:FSharp.Compiler.IO.IFileSystem.GetDirectoryNameShim(System.String)">
<summary>
 A shim for getting directory name from path
</summary>
</member>
<member name="M:FSharp.Compiler.IO.IFileSystem.FileExistsShim(System.String)">
<summary>
 A shim over File.Exists
</summary>
</member>
<member name="M:FSharp.Compiler.IO.IFileSystem.FileDeleteShim(System.String)">
<summary>
 A shim over File.Delete
</summary>
</member>
<member name="M:FSharp.Compiler.IO.IFileSystem.EnumerateFilesShim(System.String,System.String)">
<summary>
 A shim over Directory.EnumerateFiles
</summary>
</member>
<member name="M:FSharp.Compiler.IO.IFileSystem.EnumerateDirectoriesShim(System.String)">
<summary>
 A shim over Directory.EnumerateDirectories
</summary>
</member>
<member name="M:FSharp.Compiler.IO.IFileSystem.DirectoryExistsShim(System.String)">
<summary>
 A shim over Directory.Exists
</summary>
</member>
<member name="M:FSharp.Compiler.IO.IFileSystem.DirectoryDeleteShim(System.String)">
<summary>
 A shim over Directory.Delete
</summary>
</member>
<member name="M:FSharp.Compiler.IO.IFileSystem.DirectoryCreateShim(System.String)">
<summary>
 A shim over Directory.Exists, but returns a string, the FullName of the resulting
 DirectoryInfo.
</summary>
</member>
<member name="M:FSharp.Compiler.IO.IFileSystem.ChangeExtensionShim(System.String,System.String)">
<summary>
 A shim over Path.ChangeExtension
</summary>
</member>
<member name="T:FSharp.Compiler.IO.IFileSystem">
<summary>
 Represents a shim for the file system
</summary>
</member>
<member name="T:FSharp.Compiler.IO.DefaultAssemblyLoader">
<summary>
 Default implementation for IAssemblyLoader
</summary>
</member>
<member name="M:FSharp.Compiler.IO.IAssemblyLoader.AssemblyLoadFrom(System.String)">
<summary>
 Used to load type providers and located assemblies in F# Interactive
</summary>
</member>
<member name="M:FSharp.Compiler.IO.IAssemblyLoader.AssemblyLoad(System.Reflection.AssemblyName)">
<summary>
 Used to load a dependency for F# Interactive and in an unused corner-case of type provider loading
</summary>
</member>
<member name="T:FSharp.Compiler.IO.IAssemblyLoader">
<summary>
 Type which we use to load assemblies.
</summary>
</member>
<member name="P:FSharp.Compiler.IO.ByteMemory.Empty">
<summary>
 Gets a ByteMemory object that is empty
</summary>
</member>
<member name="P:FSharp.Compiler.IO.ByteMemory.Empty">
<summary>
 Empty byte memory.
</summary>
</member>
<member name="M:FSharp.Compiler.IO.ByteMemory.FromUnsafePointer(System.IntPtr,System.Int32,System.Object)">
<summary>
 Creates a ByteMemory object that is backed by a raw pointer.
 Use with care.
</summary>
</member>
<member name="M:FSharp.Compiler.IO.ByteMemory.FromMemoryMappedFile(System.IO.MemoryMappedFiles.MemoryMappedFile)">
<summary>
 Create a ByteMemory object that has a backing memory mapped file.
</summary>
</member>
<member name="M:FSharp.Compiler.IO.ByteMemory.FromArray(System.Byte[])">
<summary>
 Creates a ByteMemory object that is backed by a byte array.
</summary>
</member>
<member name="M:FSharp.Compiler.IO.ByteMemory.FromArray(System.Byte[],System.Int32,System.Int32)">
<summary>
 Creates a ByteMemory object that is backed by a byte array with the specified offset and length.
</summary>
</member>
<member name="M:FSharp.Compiler.IO.ByteMemory.AsStream">
<summary>
 Get a stream representation of the backing memory.
 Disposing this will not free up any of the backing memory.
</summary>
</member>
<member name="M:FSharp.Compiler.IO.ByteMemory.AsReadOnlyStream">
<summary>
 Get a stream representation of the backing memory.
 Disposing this will not free up any of the backing memory.
 Stream cannot be written to.
</summary>
</member>
<member name="T:FSharp.Compiler.IO.ByteMemory">
<summary>
 A view over bytes.
 May be backed by managed or unmanaged memory, or memory mapped file.
</summary>
</member>
<member name="P:FSharp.Compiler.IO.FileSystemAutoOpens.FileSystem">
<summary>
 The global hook into the file system
</summary>
</member>
<member name="M:FSharp.Compiler.IO.FileSystemUtils.isDll(System.String)">
<summary>
 Checks whether file is dll (ends in .dll)
</summary>
</member>
<member name="M:FSharp.Compiler.IO.FileSystemUtils.trimQuotes(System.String)">
<summary>
 Trim the quotes and spaces from either end of a string
</summary>
</member>
<member name="M:FSharp.Compiler.IO.FileSystemUtils.fileNameWithoutExtensionWithValidate(System.Boolean,System.String)">
<summary>
 Get the file name without extension of the given path.
</summary>
</member>
<member name="M:FSharp.Compiler.IO.FileSystemUtils.fileNameOfPath(System.String)">
<summary>
 Get the file name of the given path.
</summary>
</member>
<member name="M:FSharp.Compiler.IO.FileSystemUtils.hasExtension(System.String)">
<summary>
 Return True if the path has a &quot;.&quot; extension.
</summary>
</member>
<member name="M:FSharp.Compiler.IO.FileSystemUtils.chopExtension(System.String)">
 <c>chopExtension f</c> removes the extension from the given
 file name. Raises <c>ArgumentException</c> if no extension is present.
</member>
<member name="M:FSharp.Compiler.IO.FileSystemUtils.checkSuffix(System.String,System.String)">
 <c>checkSuffix f s</c> returns True if file name "f" ends in suffix "s",
 e.g. checkSuffix "abc.fs" ".fs" returns true.
 Disregards casing, e.g. checkSuffix "abc.Fs" ".fs" returns true.
</member>
<member name="T:FSharp.Compiler.IO.FileSystemUtils">
<summary>
 Filesystem helpers
</summary>
</member>
<member name="T:FSharp.Compiler.IO.MemoryMappedFileExtensions">
<summary>
 MemoryMapped extensions
</summary>
</member>
<member name="M:FSharp.Compiler.IO.Bytes.blit(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
<summary>
 each int will be 0 &lt;= x &lt;= 255
</summary>
</member>
<member name="M:FSharp.Compiler.IO.Bytes.ofInt32Array(System.Int32[])">
<summary>
 each int must be 0 &lt;= x &lt;= 255
</summary>
</member>
<member name="M:FSharp.Compiler.IO.Bytes.get(System.Byte[],System.Int32)">
<summary>
 returned int will be 0 &lt;= x &lt;= 255
</summary>
</member>
<member name="P:FSharp.Compiler.Features.LanguageVersion.VersionText">
<summary>
 Get the text used to specify the version, several of which may map to the same version
</summary>
</member>
<member name="P:FSharp.Compiler.Features.LanguageVersion.ValidVersions">
<summary>
 Get the list of valid versions
</summary>
</member>
<member name="P:FSharp.Compiler.Features.LanguageVersion.ValidOptions">
<summary>
 Get the list of valid options
</summary>
</member>
<member name="P:FSharp.Compiler.Features.LanguageVersion.SpecifiedVersionString">
<summary>
 Get the specified LanguageVersion as a string
</summary>
</member>
<member name="P:FSharp.Compiler.Features.LanguageVersion.SpecifiedVersion">
<summary>
 Get the specified LanguageVersion
</summary>
</member>
<member name="P:FSharp.Compiler.Features.LanguageVersion.IsPreviewEnabled">
<summary>
 Has preview been explicitly specified
</summary>
</member>
<member name="M:FSharp.Compiler.Features.LanguageVersion.SupportsFeature(FSharp.Compiler.Features.LanguageFeature)">
<summary>
 Does the selected LanguageVersion support the specified feature
</summary>
</member>
<member name="M:FSharp.Compiler.Features.LanguageVersion.IsExplicitlySpecifiedAs50OrBefore">
<summary>
 Has been explicitly specified as 4.6, 4.7 or 5.0
</summary>
</member>
<member name="M:FSharp.Compiler.Features.LanguageVersion.GetFeatureVersionString(FSharp.Compiler.Features.LanguageFeature)">
<summary>
 Get a version string associated with the given feature.
</summary>
</member>
<member name="M:FSharp.Compiler.Features.LanguageVersion.GetFeatureString(FSharp.Compiler.Features.LanguageFeature)">
<summary>
 Get a string name for the given feature.
</summary>
</member>
<member name="M:FSharp.Compiler.Features.LanguageVersion.ContainsVersion(System.String)">
<summary>
 Get the list of valid versions
</summary>
</member>
<member name="M:FSharp.Compiler.Features.LanguageVersion.#ctor(System.String)">
<summary>
 Create a LanguageVersion management object
</summary>
</member>
<member name="T:FSharp.Compiler.Features.LanguageVersion">
<summary>
 LanguageVersion management
</summary>
</member>
<member name="T:FSharp.Compiler.Features.LanguageFeature.PreferExtensionMethodOverPlainProperty">
<summary>
 RFC-1137
</summary>
</member>
<member name="T:FSharp.Compiler.Features.LanguageFeature">
<summary>
 LanguageFeature enumeration
</summary>
</member>
<member name="T:FSharp.Compiler.Features">
<summary>
 Coordinating compiler operations - configuration, loading initial context, reporting errors etc.
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.CompilationGlobalsScope.#ctor">
<summary>
 When disposed, restores caller&apos;s diagnostics logger and build phase.
</summary>
</member>
<member name="T:FSharp.Compiler.DiagnosticsLogger.CompilationGlobalsScope">
<summary>
 This represents the global state established as each task function runs as part of the build.

 Use to reset error and warning handlers.
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.StackGuard.Guard``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},System.String,System.String,System.Int32)">
<summary>
 Execute the new function, on a new thread if necessary
</summary>
</member>
<member name="T:FSharp.Compiler.DiagnosticsLogger.SuppressLanguageFeatureCheck">
<summary>
 Indicates whether a language feature check should be skipped. Typically used in recursive functions
 where we don&apos;t want repeated recursive calls to raise the same diagnostic multiple times.
</summary>
</member>
<member name="T:FSharp.Compiler.DiagnosticsLogger.OperationResult`1">
<summary>
 The result type of a computational modality to collect warnings and possibly fail
</summary>
</member>
<member name="T:FSharp.Compiler.DiagnosticsLogger.DiagnosticsThreadStatics">
<summary>
 Thread statics for the installed diagnostic logger
</summary>
</member>
<member name="T:FSharp.Compiler.DiagnosticsLogger.CapturingDiagnosticsLogger">
<summary>
 Represents a DiagnosticsLogger that captures all diagnostics, optionally formatting them
 eagerly.
</summary>
</member>
<member name="P:FSharp.Compiler.DiagnosticsLogger.DiagnosticsLogger.ErrorCount">
<summary>
 Get the number of error diagnostics reported
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.DiagnosticsLogger.DiagnosticSink(FSharp.Compiler.DiagnosticsLogger.PhasedDiagnostic,FSharp.Compiler.Diagnostics.FSharpDiagnosticSeverity)">
<summary>
 Emit a diagnostic to the logger
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.DiagnosticsLogger.CheckForErrors">
<summary>
 Checks if ErrorCount &gt; 0
</summary>
</member>
<member name="T:FSharp.Compiler.DiagnosticsLogger.DiagnosticsLogger">
<summary>
 Represents a capability to log diagnostics
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.PhasedDiagnostic.Subcategory">
<summary>
 This is the textual subcategory to display in error and warning messages (shows only under --vserrors):

     file1.fs(72): subcategory warning FS0072: This is a warning message

</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.PhasedDiagnostic.IsSubcategoryOfCompile(System.String)">
<summary>
 Return true if the textual phase given is from the compile part of the build process.
 This set needs to be equal to the set of subcategories that the language service can produce.
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.PhasedDiagnostic.IsPhaseInCompile">
<summary>
 Return true if this phase is one that&apos;s known to be part of the &apos;compile&apos;. This is the initial phase of the entire compilation that
 the language service knows about.
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.PhasedDiagnostic.Create(System.Exception,FSharp.Compiler.DiagnosticsLogger.BuildPhase)">
<summary>
 Construct a phased error
</summary>
</member>
<member name="T:FSharp.Compiler.DiagnosticsLogger.BuildPhase">
<summary>
 Closed enumeration of build phases.
</summary>
</member>
<member name="T:FSharp.Compiler.DiagnosticsLogger.StopProcessingExiter">
<summary>
 An exiter that raises StopProcessingException if Exit is called, saving the exit code in ExitCode.
</summary>
</member>
<member name="T:FSharp.Compiler.DiagnosticsLogger.Exiter">
<summary>
 Represents an early exit from parsing, checking etc, for example because &apos;maxerrors&apos; has been reached.
</summary>
</member>
<member name="T:FSharp.Compiler.DiagnosticsLogger.DiagnosticStyle">
<summary>
 Represents the style being used to format errors
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.NormalizeErrorString(System.String)">
<summary>
 fixes given string by replacing all control chars with spaces.
 NOTE: newlines are recognized and replaced with stringThatIsAProxyForANewlineInFlatErrors (ASCII 29, the &apos;group separator&apos;),
 which is decoded by the IDE with &apos;NewlineifyErrorString&apos; back into newlines, so that multi-line errors can be displayed in QuickInfo
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.Iterate2D``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,FSharp.Compiler.DiagnosticsLogger.OperationResult{Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Stop on first error. Accumulate warnings and continue.
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.IterateD``1(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Compiler.DiagnosticsLogger.OperationResult{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Stop on first error. Accumulate warnings and continue.
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Compiler.DiagnosticsLogger.OperationResult{``1}},FSharp.Compiler.DiagnosticsLogger.OperationResult{``0})">
<summary>
 The bind in the monad. Stop on first error. Accumulate warnings and continue.
 &lt;remarks&gt;Not meant for direct usage. Used in other inlined functions&lt;/remarks&gt;
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.informationalWarning(System.Exception)">
<summary>
 Reports an informational diagnostic
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.error``1(System.Exception)">
<summary>
 Reports an error and raises a ReportedError exception
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.warning(System.Exception)">
<summary>
 Reports a warning diagnostic
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.errorR(System.Exception)">
<summary>
 Reports an error diagnostic and continues
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.UseTransformedDiagnosticsLogger(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.DiagnosticsLogger.DiagnosticsLogger,FSharp.Compiler.DiagnosticsLogger.DiagnosticsLogger})">
<summary>
 NOTE: The change will be undone when the returned &quot;unwind&quot; object disposes
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.UseBuildPhase(FSharp.Compiler.DiagnosticsLogger.BuildPhase)">
<summary>
 NOTE: The change will be undone when the returned &quot;unwind&quot; object disposes
</summary>
</member>
<member name="P:FSharp.Compiler.DiagnosticsLogger.AssertFalseDiagnosticsLogger">
<summary>
 Represents a DiagnosticsLogger that ignores diagnostics and asserts
</summary>
</member>
<member name="P:FSharp.Compiler.DiagnosticsLogger.DiscardErrorsLogger">
<summary>
 Represents a DiagnosticsLogger that discards diagnostics
</summary>
</member>
<member name="P:FSharp.Compiler.DiagnosticsLogger.QuitProcessExiter">
<summary>
 An exiter that quits the process if Exit is called.
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.ErrorEnabledWithLanguageFeature(System.Tuple{System.Int32,System.String},FSharp.Compiler.Text.Range,System.Boolean)">
<summary>
 Creates a DiagnosticEnabledWithLanguageFeature whose text comes via SR.*
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.ErrorWithSuggestions(System.Tuple{System.Int32,System.String},FSharp.Compiler.Text.Range,System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a DiagnosticWithSuggestions whose text comes via SR.*
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.Error(System.Tuple{System.Int32,System.String},FSharp.Compiler.Text.Range)">
<summary>
 Creates a diagnostic exception whose text comes via SR.*
</summary>
</member>
<member name="T:FSharp.Compiler.DiagnosticsLogger.DiagnosticEnabledWithLanguageFeature">
<summary>
 A diagnostic that is raised when enabled manually, or by default with a language feature
</summary>
</member>
<member name="T:FSharp.Compiler.DiagnosticsLogger.DiagnosticWithText">
<summary>
 Represents a diagnostic exception whose text comes via SR.*
</summary>
</member>
<member name="T:FSharp.Compiler.DiagnosticsLogger.StopProcessingExn">
<summary>
 Thrown when we stop processing the F# Interactive entry or #load.
</summary>
</member>
<member name="T:FSharp.Compiler.DiagnosticsLogger.ReportedError">
<summary>
 Thrown when immediate, local error recovery is not possible. This indicates
 we&apos;ve reported an error but need to make a non-local transfer of control.
 Error recovery may catch this and continue (see &apos;errorRecovery&apos;)

 The exception that caused the report is carried as data because in some
 situations (LazyWithContext) we may need to re-report the original error
 when a lazy thunk is re-evaluated.
</summary>
</member>
<member name="T:FSharp.Compiler.DiagnosticsLogger.WrappedError">
<summary>
 Thrown when we want to add some range information to a .NET exception
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.MultipleDiagnosticsLoggers.Sequential``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Control.FSharpAsync{``0}})">
<summary>
 Run computations sequentially starting immediately on the current thread.
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.MultipleDiagnosticsLoggers.Parallel``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Control.FSharpAsync{``0}})">
<summary>
 Run computations using Async.Parallel.
 Captures the diagnostics from each computation and commits them to the caller&apos;s logger preserving their order.
 When done, restores caller&apos;s build phase and diagnostics logger.
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.DiagnosticsLoggerExtensions.DiagnosticsLogger.ErrorRecoveryNoRange(FSharp.Compiler.DiagnosticsLogger.DiagnosticsLogger,System.Exception)">
<summary>
 Like ErrorRecover by no range is attached to System.Exception and ArgumentException.
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.DiagnosticsLoggerExtensions.DiagnosticsLogger.StopProcessingRecovery(FSharp.Compiler.DiagnosticsLogger.DiagnosticsLogger,System.Exception,FSharp.Compiler.Text.Range)">
<summary>
 Perform error recovery from an exception if possible, including catching StopProcessingExn
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.DiagnosticsLoggerExtensions.DiagnosticsLogger.ErrorRecovery(FSharp.Compiler.DiagnosticsLogger.DiagnosticsLogger,System.Exception,FSharp.Compiler.Text.Range)">
<summary>
 Perform error recovery from an exception if possible.
 - StopProcessingExn is not caught.
 - ReportedError is caught and ignored.
 - TargetInvocationException is unwrapped
 - If precisely a System.Exception or ArgumentException then the range is attached as InternalError.
 - Other exceptions are unchanged

 All are reported via the installed diagnostics logger
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.DiagnosticsLoggerExtensions.DiagnosticsLogger.SimulateError``1(FSharp.Compiler.DiagnosticsLogger.DiagnosticsLogger,FSharp.Compiler.DiagnosticsLogger.PhasedDiagnostic)">
<summary>
 Simulates a diagnostic. For test purposes only.
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.DiagnosticsLoggerExtensions.DiagnosticsLogger.Error``1(FSharp.Compiler.DiagnosticsLogger.DiagnosticsLogger,System.Exception)">
<summary>
 Report a diagnostic as an error and raise `ReportedError`
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.DiagnosticsLoggerExtensions.DiagnosticsLogger.Warning(FSharp.Compiler.DiagnosticsLogger.DiagnosticsLogger,System.Exception)">
<summary>
 Report a diagnostic as a warning and recover
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.DiagnosticsLoggerExtensions.DiagnosticsLogger.ErrorR(FSharp.Compiler.DiagnosticsLogger.DiagnosticsLogger,System.Exception)">
<summary>
 Report a diagnostic as an error and recover
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticsLogger.DiagnosticsLoggerExtensions.PreserveStackTrace``1(``0)">
<summary>
 Instruct the exception not to reset itself when thrown again.
</summary>
</member>
<member name="T:FSharp.Compiler.DiagnosticsLogger.BuildPhaseSubcategory">
<summary>
 Literal build phase subcategory strings.
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticResolutionHints.DemangleOperator(System.String)">
<summary>
 Demangles a suggestion
</summary>
</member>
<member name="M:FSharp.Compiler.DiagnosticResolutionHints.IsInEditDistanceProximity(System.String,System.String)">
<summary>
 We report a candidate if its edit distance is &lt;= the threshold.
 The threshold is set to about a quarter of the number of characters.
</summary>
</member>
<member name="T:FSharp.Compiler.DiagnosticResolutionHints">
<summary>
 Functions to format error message details
</summary>
</member>
<member name="T:FSharp.Compiler.Text.FormatOptions">
<summary>
 A record of options to control structural formatting.
 For F# Interactive properties matching those of this value can be accessed via the &apos;fsi&apos;
 value.

 Floating Point format given in the same format accepted by System.Double.ToString,
 e.g. f6 or g15.

 If ShowProperties is set the printing process will evaluate properties of the values being
 displayed.  This may cause additional computation.

 The ShowIEnumerable is set the printing process will force the evaluation of IEnumerable objects
 to a small, finite depth, as determined by the printing parameters.
 This may lead to additional computation being performed during printing.
</summary>
</member>
<member name="P:FSharp.Compiler.Text.IEnvironment.MaxRows">
<summary>
 The maximum number of rows for which to generate layout for table-like
 structures.  -1 if no maximum.
</summary>
</member>
<member name="P:FSharp.Compiler.Text.IEnvironment.MaxColumns">
<summary>
 The maximum number of elements for which to generate layout for
 list-like structures, or columns in table-like
 structures.  -1 if no maximum.
</summary>
</member>
<member name="M:FSharp.Compiler.Text.IEnvironment.GetLayout(System.Object)">
<summary>
 Return to the layout-generation
 environment to layout any otherwise uninterpreted object
</summary>
</member>
<member name="T:FSharp.Compiler.Text.Layout">
<summary>
 Data representing structured layouts of terms.
</summary>
</member>
<member name="P:FSharp.Compiler.Text.TaggedText.Text">
<summary>
 Gets the text
</summary>
</member>
<member name="P:FSharp.Compiler.Text.TaggedText.Tag">
<summary>
 Gets the tag
</summary>
</member>
<member name="M:FSharp.Compiler.Text.TaggedText.#ctor(FSharp.Compiler.Text.TextTag,System.String)">
<summary>
 Creates text with a tag
</summary>
</member>
<member name="T:FSharp.Compiler.Text.TaggedText">
<summary>
 Represents text with a tag
</summary>
</member>
<member name="T:FSharp.Compiler.Text.TextTag">
<summary>
 Represents the tag of some tagged text
</summary>
</member>
<member name="T:FSharp.Compiler.Text.Joint">
<summary>
 Data representing joints in structured layouts of terms.  The representation
 of this data type is only for the consumption of formatting engines.
</summary>
</member>
<member name="T:FSharp.Compiler.Text.Range01">
<summary>
 Represents a range using zero-based line counting (used by Visual Studio)
</summary>
</member>
<member name="T:FSharp.Compiler.Text.Position01">
<summary>
 Represents a position using zero-based line counting (used by Visual Studio)
</summary>
</member>
<member name="T:FSharp.Compiler.Text.Line0">
<summary>
 Represents a line number when using zero-based line counting (used by Visual Studio)
</summary>
</member>
<member name="T:FSharp.Compiler.Text.range">
<summary>
 Represents a range within a file
</summary>
</member>
<member name="P:FSharp.Compiler.Text.Range.Zero">
<summary>
 The range where all values are zero
</summary>
</member>
<member name="P:FSharp.Compiler.Text.Range.StartRange">
<summary>
 The empty range that is located at the start position of the range
</summary>
</member>
<member name="P:FSharp.Compiler.Text.Range.StartLine">
<summary>
 The start line of the range
</summary>
</member>
<member name="P:FSharp.Compiler.Text.Range.StartColumn">
<summary>
 The start column of the range
</summary>
</member>
<member name="P:FSharp.Compiler.Text.Range.Start">
<summary>
 The start position of the range
</summary>
</member>
<member name="P:FSharp.Compiler.Text.Range.NotedSourceConstruct">
<summary>
 When de-sugaring computation expressions we convert a debug point into a plain range, and then later
 recover that the range definitely indicates a debug point.
</summary>
</member>
<member name="P:FSharp.Compiler.Text.Range.IsSynthetic">
<summary>
 Synthetic marks ranges which are produced by intermediate compilation phases. This
 bit signifies that the range covers something that should not be visible to language
 service operations like dot-completion.
</summary>
</member>
<member name="P:FSharp.Compiler.Text.Range.FileName">
<summary>
 The file name for the file of the range
</summary>
</member>
<member name="P:FSharp.Compiler.Text.Range.FileIndex">
<summary>
 The file index for the range
</summary>
</member>
<member name="P:FSharp.Compiler.Text.Range.EndRange">
<summary>
 The empty range that is located at the end position of the range
</summary>
</member>
<member name="P:FSharp.Compiler.Text.Range.EndLine">
<summary>
 The line number for the end position of the range
</summary>
</member>
<member name="P:FSharp.Compiler.Text.Range.EndColumn">
<summary>
 The column number for the end position of the range
</summary>
</member>
<member name="P:FSharp.Compiler.Text.Range.End">
<summary>
 The end position of the range
</summary>
</member>
<member name="M:FSharp.Compiler.Text.Range.NoteSourceConstruct(FSharp.Compiler.Text.NotedSourceConstruct)">
<summary>
 Note that a range indicates a debug point
</summary>
</member>
<member name="M:FSharp.Compiler.Text.Range.MakeSynthetic">
<summary>
 Convert a range to be synthetic
</summary>
</member>
<member name="M:FSharp.Compiler.Text.Range.IsAdjacentTo(FSharp.Compiler.Text.Range)">
<summary>
 Check if the range is adjacent to another range
</summary>
</member>
<member name="T:FSharp.Compiler.Text.Range">
<summary>
 Represents a range within a file
</summary>
</member>
<member name="T:FSharp.Compiler.Text.pos">
<summary>
 Represents a position in a file
</summary>
</member>
<member name="P:FSharp.Compiler.Text.Position.Line">
<summary>
 The line number for the position
</summary>
</member>
<member name="P:FSharp.Compiler.Text.Position.EncodingSize">
<summary>
 The maximum number of bits needed to store an encoded position 
</summary>
</member>
<member name="P:FSharp.Compiler.Text.Position.Encoding">
<summary>
 The encoding of the position as a 64-bit integer
</summary>
</member>
<member name="P:FSharp.Compiler.Text.Position.Column">
<summary>
 The column number for the position
</summary>
</member>
<member name="M:FSharp.Compiler.Text.Position.IsAdjacentTo(FSharp.Compiler.Text.Position)">
<summary>
 Check if the position is adjacent to another position
</summary>
</member>
<member name="M:FSharp.Compiler.Text.Position.Decode(System.Int64)">
<summary>
 Decode a position fro a 64-bit integer
</summary>
</member>
<member name="T:FSharp.Compiler.Text.Position">
<summary>
 Represents a position in a file
</summary>
</member>
<member name="T:FSharp.Compiler.Text.NotedSourceConstruct.DelayOrQuoteOrRun">
<summary>
 Notes that a range is related to an implied &quot;Delay&quot;m &quot;Quote&quot; or &quot;Run&quot; at the entry to a computation expression. This doesn&apos;t
 apply to the &quot;Delay&quot; calls added for try/with, try/finally, while or for constructs.
</summary>
</member>
<member name="T:FSharp.Compiler.Text.NotedSourceConstruct.Combine">
<summary>
 Notes that a range is related to a sequential &quot;a; b&quot; translated to a &quot;Combine&quot; call in a computation expression

 This doesn&apos;t include &quot;expr; cexpr&quot; sequentials where the &quot;expr&quot; is a side-effecting simple statement
 This does include &quot;expr; cexpr&quot; sequentials where the &quot;expr&quot; is interpreted as an implicit yield + Combine call
</summary>
</member>
<member name="T:FSharp.Compiler.Text.NotedSourceConstruct.With">
<summary>
 Notes that a range is related to a &quot;with&quot; in a &quot;try/with&quot; in a computation, list, array or sequence expression
</summary>
</member>
<member name="T:FSharp.Compiler.Text.NotedSourceConstruct.Finally">
<summary>
 Notes that a range is related to a &quot;finally&quot; in a &quot;try/finally&quot; in a computation, list, array or sequence expression
</summary>
</member>
<member name="T:FSharp.Compiler.Text.NotedSourceConstruct.Binding">
<summary>
 Notes that a range is related to a &quot;let&quot; or other binding range in a computation, list, array or sequence expression
</summary>
</member>
<member name="T:FSharp.Compiler.Text.NotedSourceConstruct.Try">
<summary>
 Notes that a range is related to a &quot;try&quot; in a &quot;try/with&quot; in a computation, list, array or sequence expression
</summary>
</member>
<member name="T:FSharp.Compiler.Text.NotedSourceConstruct.InOrTo">
<summary>
 Notes that a range is related to a &quot;in&quot; in a &quot;for .. in ... do&quot; or &quot;to&quot; in &quot;for .. = .. to .. do&quot; in a computation, list, array or sequence expression
</summary>
</member>
<member name="T:FSharp.Compiler.Text.NotedSourceConstruct.For">
<summary>
 Notes that a range is related to a &quot;for&quot; in &quot;for .. do&quot; in a computation, list, array or sequence expression
</summary>
</member>
<member name="T:FSharp.Compiler.Text.NotedSourceConstruct.While">
<summary>
 Notes that a range is related to a &quot;while&quot; in &quot;while .. do&quot; in a computation, list, array or sequence expression
</summary>
</member>
<member name="T:FSharp.Compiler.Text.FileIndex">
<summary>
 An index into a global tables of filenames
</summary>
</member>
<member name="T:FSharp.Compiler.Text.LayoutRenderer`2">
<summary>
 Render a Layout yielding an &apos;a using a &apos;b (hidden state) type
</summary>
</member>
<member name="T:FSharp.Compiler.Text.NavigableTaggedText">
<summary>
 An enhancement to TaggedText in the TaggedText layouts generated by FSharp.Compiler.Service
</summary>
</member>
<member name="T:FSharp.Compiler.Text.ISourceTextNew">
<summary>
 Just like ISourceText, but with a checksum. Added as a separate type to avoid breaking changes.
</summary>
</member>
<member name="P:FSharp.Compiler.Text.ISourceText.Length">
<summary>
 Gets the total length of the input in characters
</summary>
</member>
<member name="P:FSharp.Compiler.Text.ISourceText.Item(System.Int32)">
<summary>
 Gets a character in an input based on an index of characters from the start of the file
</summary>
</member>
<member name="M:FSharp.Compiler.Text.ISourceText.SubTextEquals(System.String,System.Int32)">
<summary>
 Checks if a section of the input is equal to the given string
</summary>
</member>
<member name="M:FSharp.Compiler.Text.ISourceText.GetSubTextString(System.Int32,System.Int32)">
<summary>
 Gets a section of the input
</summary>
</member>
<member name="M:FSharp.Compiler.Text.ISourceText.GetSubTextFromRange(FSharp.Compiler.Text.Range)">
<summary>
 Gets a section of the input based on a given range.
 &lt;exception cref=&quot;System.ArgumentException&quot;&gt;Throws an exception when the input range is outside the file boundaries.&lt;/exception&gt;
</summary>
</member>
<member name="M:FSharp.Compiler.Text.ISourceText.GetLineString(System.Int32)">
<summary>
 Gets a line of an input by index
</summary>
</member>
<member name="M:FSharp.Compiler.Text.ISourceText.GetLineCount">
<summary>
 Gets the count of lines in the input
</summary>
</member>
<member name="M:FSharp.Compiler.Text.ISourceText.GetLastCharacterPosition">
<summary>
 Gets the last character position in the input, returning line and column
</summary>
</member>
<member name="M:FSharp.Compiler.Text.ISourceText.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
<summary>
 Copies a section of the input to the given destination ad the given index
</summary>
</member>
<member name="M:FSharp.Compiler.Text.ISourceText.ContentEquals(FSharp.Compiler.Text.ISourceText)">
<summary>
 Checks if one input is equal to another
</summary>
</member>
<member name="T:FSharp.Compiler.Text.ISourceText">
<summary>
 Represents an input to the F# compiler
</summary>
</member>
<member name="M:FSharp.Compiler.Text.Display.layout_to_string(FSharp.Compiler.Text.FormatOptions,FSharp.Compiler.Text.Layout)">
<summary>
 Convert any value to a layout using the given formatting options.  The
 layout can then be processed using formatting display engines such as
 those in the Layout module.  any_to_string and output_any are
 built using any_to_layout with default format options.
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.unfoldL``2(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Compiler.Text.Layout},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``0,``1}}},``1,System.Int32)">
<summary>
 For limiting layout of list-like sequences (lists,arrays,etc).
 unfold a list of items using (project and z) making layout list via itemL.
 If reach maxLength (before exhausting) then truncate.
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.tagAttrL(System.String,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,System.String}},FSharp.Compiler.Text.Layout)">
<summary>
 See tagL
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.listL``1(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Compiler.Text.Layout},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Layout like an F# list.
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.optionL``1(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Compiler.Text.Layout},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Layout like an F# option.
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.aboveListL(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Text.Layout})">
<summary>
 Layout list vertically.
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.aboveL(FSharp.Compiler.Text.Layout,FSharp.Compiler.Text.Layout)">
<summary>
 Layout two vertically.
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.tupleL(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Text.Layout})">
<summary>
 Form tuple of layouts.
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.braceL(FSharp.Compiler.Text.Layout)">
<summary>
 Wrap braces around layout.
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.squareBracketL(FSharp.Compiler.Text.Layout)">
<summary>
 Wrap square brackets around layout.
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.bracketL(FSharp.Compiler.Text.Layout)">
<summary>
 Wrap round brackets around Layout.
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.sepListL(FSharp.Compiler.Text.Layout,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Text.Layout})">
<summary>
 Join layouts into a list separated using the given Layout.
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.semiListL(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Text.Layout})">
<summary>
 Join layouts into a semi-colon separated list.
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.spaceListL(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Text.Layout})">
<summary>
 Join layouts into a space separated list.
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.commaListL(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Text.Layout})">
<summary>
 Join layouts into a comma separated list.
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.op_AtAtMinusMinusMinusMinus(FSharp.Compiler.Text.Layout,FSharp.Compiler.Text.Layout)">
<summary>
 Join broken with ident=4
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.op_AtAtMinusMinusMinus(FSharp.Compiler.Text.Layout,FSharp.Compiler.Text.Layout)">
<summary>
 Join broken with ident=3
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.op_AtAtMinusMinus(FSharp.Compiler.Text.Layout,FSharp.Compiler.Text.Layout)">
<summary>
 Join broken with ident=2
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.op_AtAtMinus(FSharp.Compiler.Text.Layout,FSharp.Compiler.Text.Layout)">
<summary>
 Join broken with ident=1
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.op_AtAt(FSharp.Compiler.Text.Layout,FSharp.Compiler.Text.Layout)">
<summary>
 Join broken with ident=0
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.op_MinusMinusMinusMinusMinus(FSharp.Compiler.Text.Layout,FSharp.Compiler.Text.Layout)">
<summary>
 optional break, indent=4
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.op_MinusMinusMinusMinus(FSharp.Compiler.Text.Layout,FSharp.Compiler.Text.Layout)">
<summary>
 optional break, indent=3
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.op_MinusMinusMinus(FSharp.Compiler.Text.Layout,FSharp.Compiler.Text.Layout)">
<summary>
 Join, possible break with indent=2
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.op_MinusMinus(FSharp.Compiler.Text.Layout,FSharp.Compiler.Text.Layout)">
<summary>
 Join, possible break with indent=1
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.op_PlusPlus(FSharp.Compiler.Text.Layout,FSharp.Compiler.Text.Layout)">
<summary>
 Join, possible break with indent=0
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.op_HatHat(FSharp.Compiler.Text.Layout,FSharp.Compiler.Text.Layout)">
<summary>
 Join, unbreakable.
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.leftL(FSharp.Compiler.Text.TaggedText)">
<summary>
 An string which is left  parenthesis (no space on the right).
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.rightL(FSharp.Compiler.Text.TaggedText)">
<summary>
 An string which is right parenthesis (no space on the left).
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.sepL(FSharp.Compiler.Text.TaggedText)">
<summary>
 An string which requires no spaces either side.
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.wordL(FSharp.Compiler.Text.TaggedText)">
<summary>
 An string leaf
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.objL(System.Object)">
<summary>
 An uninterpreted leaf, to be interpreted into a string
 by the layout engine. This allows leaf layouts for numbers, strings and
 other atoms to be customized according to culture.
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.endsWithL(System.String,FSharp.Compiler.Text.Layout)">
<summary>
 Check if the last character in the layout is the given character
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutModule.isEmptyL(FSharp.Compiler.Text.Layout)">
<summary>
 Is it the empty layout?
</summary>
</member>
<member name="P:FSharp.Compiler.Text.LayoutModule.emptyL">
<summary>
 The empty layout
</summary>
</member>
<member name="T:FSharp.Compiler.Text.LayoutModule">
<summary>
 A layout is a sequence of strings which have been joined together.
 The strings are classified as words, separators and left and right parenthesis.
 This classification determines where spaces are inserted.
 A joint is either unbreakable, breakable or broken.
 If a joint is broken the RHS layout occurs on the next line with optional indentation.
 A layout can be squashed to for given width which forces breaks as required.
</summary>
</member>
<member name="M:FSharp.Compiler.Text.Line.toZ(System.Int32)">
<summary>
 Convert a line number from one-based line counting (used internally in the F# compiler and in F# error messages) to zero-based line counting (used by Visual Studio)
</summary>
</member>
<member name="M:FSharp.Compiler.Text.Line.fromZ(System.Int32)">
<summary>
 Convert a line number from zero-based line counting (used by Visual Studio) to one-based line counting (used internally in the F# compiler and in F# error messages) 
</summary>
</member>
<member name="T:FSharp.Compiler.Text.Line">
<summary>
 Functions related to converting between lines indexed at 0 and 1
</summary>
</member>
<member name="P:FSharp.Compiler.Text.RangeModule.comparer">
<summary>
 Equality comparer for range.
</summary>
</member>
<member name="M:FSharp.Compiler.Text.RangeModule.toFileZ(FSharp.Compiler.Text.Range)">
<summary>
 Convert a range from one-based line counting (used internally in the F# compiler and in F# error messages) to zero-based line counting (used by Visual Studio)
</summary>
</member>
<member name="M:FSharp.Compiler.Text.RangeModule.toZ(FSharp.Compiler.Text.Range)">
<summary>
 Convert a range from one-based line counting (used internally in the F# compiler and in F# error messages) to zero-based line counting (used by Visual Studio)
</summary>
</member>
<member name="M:FSharp.Compiler.Text.RangeModule.stringOfRange(FSharp.Compiler.Text.Range)">
<summary>
 Convert a range to a string
</summary>
</member>
<member name="P:FSharp.Compiler.Text.RangeModule.rangeCmdArgs">
<summary>
 A range associated with a dummy file for the command line arguments
</summary>
</member>
<member name="P:FSharp.Compiler.Text.RangeModule.rangeStartup">
<summary>
 A range associated with a dummy file called &quot;startup&quot;
</summary>
</member>
<member name="P:FSharp.Compiler.Text.RangeModule.range0">
<summary>
 The zero range
</summary>
</member>
<member name="M:FSharp.Compiler.Text.RangeModule.rangeN(System.String,System.Int32)">
<summary>
 Make a dummy range for a file
</summary>
</member>
<member name="M:FSharp.Compiler.Text.RangeModule.rangeBeforePos(FSharp.Compiler.Text.Range,FSharp.Compiler.Text.Position)">
<summary>
 Test to see if a range occurs fully before a position
</summary>
</member>
<member name="M:FSharp.Compiler.Text.RangeModule.rangeContainsPos(FSharp.Compiler.Text.Range,FSharp.Compiler.Text.Position)">
<summary>
 Test to see if a range contains a position
</summary>
</member>
<member name="M:FSharp.Compiler.Text.RangeModule.rangeContainsRange(FSharp.Compiler.Text.Range,FSharp.Compiler.Text.Range)">
<summary>
 Test to see if one range contains another range
</summary>
</member>
<member name="M:FSharp.Compiler.Text.RangeModule.unionRanges(FSharp.Compiler.Text.Range,FSharp.Compiler.Text.Range)">
<summary>
 Union two ranges, taking their first occurring start position and last occurring end position
</summary>
</member>
<member name="M:FSharp.Compiler.Text.RangeModule.outputRange(System.IO.TextWriter,FSharp.Compiler.Text.Range)">
<summary>
 Output a range
</summary>
</member>
<member name="P:FSharp.Compiler.Text.RangeModule.rangeOrder">
<summary>
 Order ranges (file, then start pos, then end pos)
</summary>
</member>
<member name="M:FSharp.Compiler.Text.RangeModule.trimRangeToLine(FSharp.Compiler.Text.Range)">
<summary>
 Reduce a range so it only covers a line
</summary>
</member>
<member name="M:FSharp.Compiler.Text.RangeModule.mkFirstLineOfFile(System.String)">
<summary>
 Make a range for the first non-whitespace line of the file if any. Otherwise use line 1 chars 0-80.
 This involves reading the file.
</summary>
</member>
<member name="M:FSharp.Compiler.Text.RangeModule.mkRange(System.String,FSharp.Compiler.Text.Position,FSharp.Compiler.Text.Position)">
<summary>
 This view hides the use of file indexes and just uses filenames 
</summary>
</member>
<member name="M:FSharp.Compiler.Text.RangeModule.mkFileIndexRange(System.Int32,FSharp.Compiler.Text.Position,FSharp.Compiler.Text.Position)">
<summary>
 This view of range marks uses file indexes explicitly 
</summary>
</member>
<member name="P:FSharp.Compiler.Text.RangeModule.posOrder">
<summary>
 Ordering on positions
</summary>
</member>
<member name="M:FSharp.Compiler.Text.FileIndexModule.fileOfFileIndex(System.Int32)">
<summary>
 Convert an index into a file path
</summary>
</member>
<member name="M:FSharp.Compiler.Text.FileIndexModule.fileIndexOfFile(System.String)">
<summary>
 Convert a file path to an index
</summary>
</member>
<member name="P:FSharp.Compiler.Text.PositionModule.pos0">
<summary>
 The zero position
</summary>
</member>
<member name="M:FSharp.Compiler.Text.PositionModule.stringOfPos(FSharp.Compiler.Text.Position)">
<summary>
 Convert a position to a string
</summary>
</member>
<member name="M:FSharp.Compiler.Text.PositionModule.outputPos(System.IO.TextWriter,FSharp.Compiler.Text.Position)">
<summary>
 Output a position
</summary>
</member>
<member name="M:FSharp.Compiler.Text.PositionModule.toZ(FSharp.Compiler.Text.Position)">
<summary>
 Convert a position from one-based line counting (used internally in the F# compiler and in F# error messages) to zero-based line counting (used by Visual Studio)
</summary>
</member>
<member name="M:FSharp.Compiler.Text.PositionModule.fromZ(System.Int32,System.Int32)">
<summary>
 Convert a position from zero-based line counting (used by Visual Studio) to one-based line counting (used internally in the F# compiler and in F# error messages) 
</summary>
</member>
<member name="M:FSharp.Compiler.Text.PositionModule.posGeq(FSharp.Compiler.Text.Position,FSharp.Compiler.Text.Position)">
<summary>
 Compare positions for greater-than-or-equal-to
</summary>
</member>
<member name="M:FSharp.Compiler.Text.PositionModule.posEq(FSharp.Compiler.Text.Position,FSharp.Compiler.Text.Position)">
<summary>
 Compare positions for equality
</summary>
</member>
<member name="M:FSharp.Compiler.Text.PositionModule.posGt(FSharp.Compiler.Text.Position,FSharp.Compiler.Text.Position)">
<summary>
 Compare positions for greater-than
</summary>
</member>
<member name="M:FSharp.Compiler.Text.PositionModule.posLt(FSharp.Compiler.Text.Position,FSharp.Compiler.Text.Position)">
<summary>
 Compare positions for less-than
</summary>
</member>
<member name="M:FSharp.Compiler.Text.PositionModule.mkPos(System.Int32,System.Int32)">
<summary>
 Create a position for the given line and column
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutRender.taggedTextListR(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Text.TaggedText,Microsoft.FSharp.Core.Unit})">
<summary>
 Render layout to collector of TaggedText
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutRender.bufferR(System.Text.StringBuilder)">
<summary>
 Render layout to StringBuilder
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutRender.channelR(System.IO.TextWriter)">
<summary>
 Render layout to channel
</summary>
</member>
<member name="P:FSharp.Compiler.Text.LayoutRender.stringR">
<summary>
 Render layout to string
</summary>
</member>
<member name="M:FSharp.Compiler.Text.LayoutRender.renderL``2(FSharp.Compiler.Text.LayoutRenderer{``0,``1},FSharp.Compiler.Text.Layout)">
<summary>
 Run a render on a Layout
</summary>
</member>
<member name="M:FSharp.Compiler.Text.SourceText.ofString(System.String)">
<summary>
 Creates an ISourceText object from the given string
</summary>
</member>
<member name="T:FSharp.Compiler.Text.SourceText">
<summary>
 Functions related to ISourceText objects
</summary>
</member>
<member name="P:FSharp.Compiler.BuildGraph.GraphNode`1.IsComputing">
<summary>
 Return &apos;true&apos; if the computation is in-progress.
</summary>
</member>
<member name="P:FSharp.Compiler.BuildGraph.GraphNode`1.HasValue">
<summary>
 Return &apos;true&apos; if the computation has already been computed.
</summary>
</member>
<member name="M:FSharp.Compiler.BuildGraph.GraphNode`1.TryPeekValue">
<summary>
 Return &apos;Some&apos; if the computation has already been computed, else None if
 the computation is in-progress or has not yet been started.
</summary>
</member>
<member name="M:FSharp.Compiler.BuildGraph.GraphNode`1.GetOrComputeValue">
<summary>
 Return NodeCode which, when executed, will get the value of the computation if already computed, or
 await an existing in-progress computation for the node if one exists, or else will synchronously
 start the computation on the current thread.
</summary>
</member>
<member name="M:FSharp.Compiler.BuildGraph.GraphNode`1.FromResult(`0)">
<summary>
 Creates a GraphNode with given result already cached.
</summary>
</member>
<member name="M:FSharp.Compiler.BuildGraph.GraphNode`1.#ctor(Microsoft.FSharp.Control.FSharpAsync{`0})">
<summary>
 - computation - The computation code to run.
</summary>
</member>
<member name="T:FSharp.Compiler.BuildGraph.GraphNode`1">
<summary>
 Evaluate the computation, allowing asynchronous waits on existing ongoing evaluations of the
 same node, and strongly cache the result.

 Once the result has been cached, the computation function will also be removed, or &apos;null&apos;ed out,
 as to prevent any references captured by the computation from being strongly held.
</summary>
</member>
<member name="M:FSharp.Compiler.BuildGraph.GraphNode.SetPreferredUILang(Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Allows to specify the language for error messages
</summary>
</member>
<member name="T:FSharp.Compiler.BuildGraph.GraphNode">
<summary>
 Contains helpers related to the build graph
</summary>
</member>
<member name="M:FSharp.Compiler.UnicodeLexing.StreamReaderAsLexbuf(System.Boolean,FSharp.Compiler.Features.LanguageVersion,Microsoft.FSharp.Core.FSharpOption{System.Boolean},System.IO.StreamReader)">
<summary>
 Will not dispose of the stream reader.
</summary>
</member>
<member name="M:FSharp.Compiler.Xml.IXmlDocumentationInfoLoader.TryLoad(System.String)">
<summary>
 Try to get the XmlDocumentationInfo for a file
</summary>
</member>
<member name="T:FSharp.Compiler.Xml.IXmlDocumentationInfoLoader">
<summary>
 Represents a capability to access XmlDoc files
</summary>
</member>
<member name="M:FSharp.Compiler.Xml.XmlDocumentationInfo.TryGetXmlDocBySig(System.String)">
<summary>
 Look up an item in the XmlDoc file
</summary>
</member>
<member name="M:FSharp.Compiler.Xml.XmlDocumentationInfo.TryCreateFromFile(System.String)">
<summary>
 Create an XmlDocumentationInfo from a file
</summary>
</member>
<member name="T:FSharp.Compiler.Xml.XmlDocumentationInfo">
<summary>
 Represents access to an XmlDoc file
</summary>
</member>
<member name="P:FSharp.Compiler.Xml.PreXmlDoc.Range">
<summary>
 Get the overall range of the PreXmlDoc
</summary>
</member>
<member name="P:FSharp.Compiler.Xml.PreXmlDoc.IsEmpty">
<summary>
 Indicates if the PreXmlDoc is non-empty
</summary>
</member>
<member name="P:FSharp.Compiler.Xml.PreXmlDoc.Empty">
<summary>
 Get the empty PreXmlDoc
</summary>
</member>
<member name="M:FSharp.Compiler.Xml.PreXmlDoc.ToXmlDoc(System.Boolean,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.String}})">
<summary>
 Process and check the PreXmlDoc, checking with respect to the given parameter names
</summary>
</member>
<member name="M:FSharp.Compiler.Xml.PreXmlDoc.Merge(FSharp.Compiler.Xml.PreXmlDoc,FSharp.Compiler.Xml.PreXmlDoc)">
<summary>
 Merge two PreXmlDoc
</summary>
</member>
<member name="M:FSharp.Compiler.Xml.PreXmlDoc.MarkAsInvalid">
<summary>
 Mark the PreXmlDoc as invalid
</summary>
</member>
<member name="M:FSharp.Compiler.Xml.PreXmlDoc.Create(System.String[],FSharp.Compiler.Text.Range)">
<summary>
 Create a PreXmlDoc from a collection of unprocessed lines
</summary>
</member>
<member name="T:FSharp.Compiler.Xml.PreXmlDoc">
<summary>
 Represents the XmlDoc fragments as collected from the lexer during parsing
</summary>
</member>
<member name="M:FSharp.Compiler.Xml.XmlDocCollector.LinesBefore(FSharp.Compiler.Text.Position)">
<summary>
 Get the documentation lines before the given point
</summary>
</member>
<member name="M:FSharp.Compiler.Xml.XmlDocCollector.HasComments(FSharp.Compiler.Text.Position)">
<summary>
 Indicates it the given point has XmlDoc comments
</summary>
</member>
<member name="M:FSharp.Compiler.Xml.XmlDocCollector.CheckInvalidXmlDocPositions">
<summary>
 Check if XmlDoc comments are at invalid positions, and if so report them
</summary>
</member>
<member name="M:FSharp.Compiler.Xml.XmlDocCollector.AddXmlDocLine(System.String,FSharp.Compiler.Text.Range)">
<summary>
 Add a line of XmlDoc text
</summary>
</member>
<member name="M:FSharp.Compiler.Xml.XmlDocCollector.AddGrabPointDelayed(FSharp.Compiler.Text.Position)">
<summary>
 Indicate the next XmlDoc will act as a point where prior XmlDoc are collected
</summary>
</member>
<member name="M:FSharp.Compiler.Xml.XmlDocCollector.AddGrabPoint(FSharp.Compiler.Text.Position)">
<summary>
 Add a point where prior XmlDoc are collected
</summary>
</member>
<member name="M:FSharp.Compiler.Xml.XmlDocCollector.#ctor">
<summary>
 Create a fresh XmlDocCollector
</summary>
</member>
<member name="T:FSharp.Compiler.Xml.XmlDocCollector">
<summary>
 Used to collect XML documentation during lexing and parsing.
</summary>
</member>
<member name="P:FSharp.Compiler.Xml.XmlDoc.UnprocessedLines">
<summary>
 Get the lines before insertion of implicit summary tags and encoding
</summary>
</member>
<member name="P:FSharp.Compiler.Xml.XmlDoc.Range">
<summary>
 Indicates the overall original source range of the XmlDoc
</summary>
</member>
<member name="P:FSharp.Compiler.Xml.XmlDoc.NonEmpty">
<summary>
 Indicates if the XmlDoc is non-empty
</summary>
</member>
<member name="P:FSharp.Compiler.Xml.XmlDoc.IsEmpty">
<summary>
 Indicates if the XmlDoc is empty
</summary>
</member>
<member name="P:FSharp.Compiler.Xml.XmlDoc.Empty">
<summary>
 Get the empty XmlDoc
</summary>
</member>
<member name="M:FSharp.Compiler.Xml.XmlDoc.Merge(FSharp.Compiler.Xml.XmlDoc,FSharp.Compiler.Xml.XmlDoc)">
<summary>
 Merge two XML documentation
</summary>
</member>
<member name="M:FSharp.Compiler.Xml.XmlDoc.GetXmlText">
<summary>
 Get the elaborated XML documentation as XML text
</summary>
</member>
<member name="M:FSharp.Compiler.Xml.XmlDoc.GetElaboratedXmlLines">
<summary>
 Get the lines after insertion of implicit summary tags and encoding
</summary>
</member>
<member name="M:FSharp.Compiler.Xml.XmlDoc.Check(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.String}})">
<summary>
 Check the XML documentation
</summary>
</member>
<member name="T:FSharp.Compiler.Xml.XmlDoc">
<summary>
 Represents collected XmlDoc lines
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynTypeConstraintWhereTyparNotSupportsNullTrivia.NotRange">
<summary>
 The syntax range of `not`
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynTypeConstraintWhereTyparNotSupportsNullTrivia.ColonRange">
<summary>
 The syntax range of `:`
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynTypeConstraintWhereTyparNotSupportsNullTrivia">
<summary>
 Represents additional information for SynTypeConstraint.WhereTyparNotSupportsNull
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynMeasureConstantTrivia">
<summary>
 Represents additional information for SynConst.Measure
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynTyparDeclTrivia.AmpersandRanges">
<summary>
 The syntax ranges of the `&amp;` tokens
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynTyparDeclTrivia">
<summary>
 Represents additional information for SynTyparDecl
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynMemberSigMemberTrivia.GetSetKeywords">
<summary>
 The syntax range of &apos;get, set&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynMemberSigMemberTrivia">
<summary>
 Represents additional information for SynMemberSig.Member
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynBindingReturnInfoTrivia.ColonRange">
<summary>
 The syntax range of the `:` token
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynBindingReturnInfoTrivia">
<summary>
 Represents additional information for SynBindingReturnInfo
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynTypeWithNullTrivia.BarRange">
<summary>
 The syntax range of the `|` token
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynTypeWithNullTrivia">
<summary>
 Represents additional information for SynType.WithNull
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynTypeOrTrivia.OrKeyword">
<summary>
 The syntax range of the `or` keyword
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynTypeOrTrivia">
<summary>
 Represents additional information for SynType.Or
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynFieldTrivia.MutableKeyword">
<summary>
 The syntax range of the `mutable` keyword
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynFieldTrivia.LeadingKeyword">
<summary>
 Used leading keyword of SynField
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynFieldTrivia">
<summary>
 Represents additional information for SynField
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynMemberDefnInheritTrivia">
<summary>
 Represents additional information for SynMemberDefn.Inherit
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynMemberDefnAbstractSlotTrivia.GetSetKeywords">
<summary>
 The syntax range of &apos;get, set&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynMemberDefnAbstractSlotTrivia">
<summary>
  Represents additional information for SynMemberDefn.AbstractSlot
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynMemberDefnAutoPropertyTrivia.GetSetKeywords">
<summary>
 The syntax range of &apos;get, set&apos;
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynMemberDefnAutoPropertyTrivia.EqualsRange">
<summary>
 The syntax range of the `=` token
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynMemberDefnAutoPropertyTrivia.WithKeyword">
<summary>
 The syntax range of the `with` keyword
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynMemberDefnAutoPropertyTrivia.LeadingKeyword">
<summary>
 Used leading keyword of AutoProperty
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynMemberDefnAutoPropertyTrivia">
<summary>
 Represents additional information for SynMemberDefn.AutoProperty
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.GetSetKeywords">
<summary>
 Represents additional information for `get, set` syntax
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynArgPatsNamePatPairsTrivia.ParenRange">
<summary>
 The syntax range from the beginning of the `(` token till the end of the `)` token.
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynArgPatsNamePatPairsTrivia">
<summary>
 Represents additional information for SynArgPats.NamePatPairs
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynMemberDefnImplicitCtorTrivia.AsKeyword">
<summary>
 The syntax range of the `as` keyword
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynMemberDefnImplicitCtorTrivia">
<summary>
 Represents additional information for SynMemberDefn.ImplicitCtor
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynMemberGetSetTrivia.SetKeyword">
<summary>
 The syntax range of the `set` keyword
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynMemberGetSetTrivia.AndKeyword">
<summary>
 The syntax range of the `and` keyword
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynMemberGetSetTrivia.GetKeyword">
<summary>
 The syntax range of the `get` keyword
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynMemberGetSetTrivia.WithKeyword">
<summary>
 The syntax range of the `with` keyword
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynMemberGetSetTrivia.InlineKeyword">
<summary>
 The syntax range of the `inline` keyword
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynMemberGetSetTrivia">
<summary>
 Represents additional information for SynMemberDefn.GetSetMember
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynTypeFunTrivia.ArrowRange">
<summary>
 The syntax range of the `-&gt;` token.
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynTypeFunTrivia">
<summary>
 Represents additional information for SynType.Fun
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynValSigTrivia.EqualsRange">
<summary>
 The syntax range of the `=` token.
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynValSigTrivia.WithKeyword">
<summary>
 The syntax range of the `with` keyword
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynValSigTrivia.InlineKeyword">
<summary>
 The syntax range of the `inline` keyword
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynValSigTrivia.LeadingKeyword">
<summary>
 Used leading keyword of SynValSig
 In most cases this will be `val`,
 but in case of `SynMemberDefn.AutoProperty` or `SynMemberDefn.AbstractSlot` it could be something else.
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynValSigTrivia">
<summary>
 Represents additional information for SynValSig
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynModuleOrNamespaceSigTrivia.LeadingKeyword">
<summary>
 The syntax range of the `module` or `namespace` keyword
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynModuleOrNamespaceSigTrivia">
<summary>
 Represents additional information for SynModuleOrNamespaceSig
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynModuleOrNamespaceTrivia.LeadingKeyword">
<summary>
 The syntax range of the `module` or `namespace` keyword
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynModuleOrNamespaceTrivia">
<summary>
 Represents additional information for SynModuleOrNamespace
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynModuleOrNamespaceLeadingKeyword">
<summary>
 Represents the leading keyword in a SynModuleOrNamespace or SynModuleOrNamespaceSig
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynModuleSigDeclNestedModuleTrivia.EqualsRange">
<summary>
 The syntax range of the `=` token.
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynModuleSigDeclNestedModuleTrivia.ModuleKeyword">
<summary>
 The syntax range of the `module` keyword
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynModuleSigDeclNestedModuleTrivia">
<summary>
 Represents additional information for SynModuleSigDecl.NestedModule
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynModuleDeclNestedModuleTrivia.EqualsRange">
<summary>
 The syntax range of the `=` token.
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynModuleDeclNestedModuleTrivia.ModuleKeyword">
<summary>
 The syntax range of the `module` keyword
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynModuleDeclNestedModuleTrivia">
<summary>
 Represents additional information for SynModuleDecl.NestedModule
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprAndBangTrivia.InKeyword">
<summary>
 The syntax range of the `in` keyword.
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprAndBangTrivia.EqualsRange">
<summary>
 The syntax range of the `=` token.
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprAndBangTrivia.AndBangKeyword">
<summary>
 The syntax range of the `and!` keyword
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynExprAndBangTrivia">
<summary>
 Represents additional information for SynExprAndBang
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynBindingTrivia.EqualsRange">
<summary>
 The syntax range of the `=` token.
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynBindingTrivia.InlineKeyword">
<summary>
 The syntax range of the `inline` keyword
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynBindingTrivia.LeadingKeyword">
<summary>
 Used leading keyword of SynBinding
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynBindingTrivia">
<summary>
 Represents additional information for SynBinding
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynLeadingKeyword">
<summary>
 Represents the leading keyword in a SynBinding or SynValSig
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynTypeDefnSigTrivia.WithKeyword">
<summary>
 The syntax range of the `with` keyword
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynTypeDefnSigTrivia.EqualsRange">
<summary>
 The syntax range of the `=` token.
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynTypeDefnSigTrivia.LeadingKeyword">
<summary>
 The syntax range of the `type` or `and` keyword.
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynTypeDefnSigTrivia">
<summary>
 Represents additional information for SynTypeDefnSig
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynTypeDefnTrivia.WithKeyword">
<summary>
 The syntax range of the `with` keyword
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynTypeDefnTrivia.EqualsRange">
<summary>
 The syntax range of the `=` token.
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynTypeDefnTrivia.LeadingKeyword">
<summary>
 The syntax range of the `type` or `and` keyword.
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynTypeDefnTrivia">
<summary>
 Represents additional information for SynTypeDefn
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynTypeDefnLeadingKeyword.Synthetic">
<summary>
 Produced during type checking, should not be used in actual parsed trees.
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynTypeDefnLeadingKeyword.StaticType">
<summary>
 Can happen in SynMemberDefn.NestedType or SynMemberSig.NestedType
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynTypeDefnLeadingKeyword">
<summary>
 Represents the leading keyword in a SynTypeDefn or SynTypeDefnSig
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynPatListConsTrivia.ColonColonRange">
<summary>
 The syntax range of the `::` token.
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynPatListConsTrivia">
<summary>
 Represents additional information for SynPat.Cons
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynPatOrTrivia.BarRange">
<summary>
 The syntax range of the `|` token.
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynPatOrTrivia">
<summary>
 Represents additional information for SynPat.Or
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynUnionCaseTrivia.BarRange">
<summary>
 The syntax range of the `|` token.
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynUnionCaseTrivia">
<summary>
 Represents additional information for SynUnionCase
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynEnumCaseTrivia.EqualsRange">
<summary>
 The syntax range of the `=` token.
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynEnumCaseTrivia.BarRange">
<summary>
 The syntax range of the `|` token.
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynEnumCaseTrivia">
<summary>
 Represents additional information for
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynMatchClauseTrivia.BarRange">
<summary>
 The syntax range of the `|` token.
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynMatchClauseTrivia.ArrowRange">
<summary>
 The syntax range of the `-&gt;` token.
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynMatchClauseTrivia">
<summary>
 Represents additional information for SynMatchClause
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprSequentialTrivia.SeparatorRange">
<summary>
 The syntax range of the `;` token.
 Could also be the `then` keyword.
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynExprSequentialTrivia">
<summary>
 Represents additional information for SynExpr.Sequential
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprAnonRecdTrivia.OpeningBraceRange">
<summary>
 The syntax range of the `{|` token.
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynExprAnonRecdTrivia">
<summary>
 Represents additional information for SynExpr.AnonRecd
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprYieldOrReturnFromTrivia.YieldOrReturnFromKeyword">
<summary>
 The syntax range of the `yield!` or `return!` keyword.
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynExprYieldOrReturnFromTrivia">
<summary>
 Represents additional information for SynExpr.YieldOrReturnFrom
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprYieldOrReturnTrivia.YieldOrReturnKeyword">
<summary>
 The syntax range of the `yield` or `return` keyword.
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynExprYieldOrReturnTrivia">
<summary>
 Represents additional information for SynExpr.YieldOrReturn
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprDoBangTrivia.DoBangKeyword">
<summary>
 The syntax range of the `do!` keyword
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynExprDoBangTrivia">
<summary>
 Represents additional information for SynExpr.DoBang
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprMatchBangTrivia.WithKeyword">
<summary>
 The syntax range of the `with` keyword
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprMatchBangTrivia.MatchBangKeyword">
<summary>
 The syntax range of the `match!` keyword
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynExprMatchBangTrivia">
<summary>
 Represents additional information for SynExpr.MatchBang
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprMatchTrivia.WithKeyword">
<summary>
 The syntax range of the `with` keyword
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprMatchTrivia.MatchKeyword">
<summary>
 The syntax range of the `match` keyword
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynExprMatchTrivia">
<summary>
 Represents additional information for SynExpr.Match
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprLetOrUseBangTrivia.EqualsRange">
<summary>
 The syntax range of the `=` token.
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprLetOrUseBangTrivia.LetOrUseBangKeyword">
<summary>
 The syntax range of the `let!` or `use!` keyword.
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynExprLetOrUseBangTrivia">
<summary>
 Represents additional information for SynExpr.LetOrUseBang
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprLetOrUseTrivia.InKeyword">
<summary>
 The syntax range of the `in` keyword.
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprLetOrUseTrivia.LetOrUseKeyword">
<summary>
 The syntax range of the `let` or `use` keyword.
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynExprLetOrUseTrivia">
<summary>
 Represents additional information for SynExpr.LetOrUse
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynExprDotLambdaTrivia">
<summary>
 Represents additional information for SynExpr.DotLambda
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprLambdaTrivia.ArrowRange">
<summary>
 The syntax range of the `-&gt;` token.
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynExprLambdaTrivia">
<summary>
 Represents additional information for SynExpr.Lambda
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprIfThenElseTrivia.IfToThenRange">
<summary>
 The syntax range from the beginning of the `if` keyword till the end of the `then` keyword.
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprIfThenElseTrivia.ElseKeyword">
<summary>
 The syntax range of the `else` keyword.
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprIfThenElseTrivia.ThenKeyword">
<summary>
 The syntax range of the `then` keyword.
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprIfThenElseTrivia.IsElif">
<summary>
 Indicates if the `elif` keyword was used
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprIfThenElseTrivia.IfKeyword">
<summary>
 The syntax range of the `if` keyword.
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynExprIfThenElseTrivia">
<summary>
 Represents additional information for SynExpr.IfThenElse
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprTryFinallyTrivia.FinallyKeyword">
<summary>
 The syntax range of the `finally` keyword
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprTryFinallyTrivia.TryKeyword">
<summary>
 The syntax range of the `try` keyword.
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynExprTryFinallyTrivia">
<summary>
 Represents additional information for SynExpr.TryFinally
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprTryWithTrivia.WithToEndRange">
<summary>
 The syntax range from the beginning of the `with` keyword till the end of the TryWith expression.
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprTryWithTrivia.WithKeyword">
<summary>
 The syntax range of the `with` keyword
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprTryWithTrivia.TryToWithRange">
<summary>
 The syntax range from the beginning of the `try` keyword till the end of the `with` keyword.
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.SynExprTryWithTrivia.TryKeyword">
<summary>
 The syntax range of the `try` keyword.
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.SynExprTryWithTrivia">
<summary>
 Represents additional information for SynExpr.TryWith
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.ParsedSigFileInputTrivia.CodeComments">
<summary>
 Represent code comments found in the source file
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.ParsedSigFileInputTrivia.ConditionalDirectives">
<summary>
 Preprocessor directives of type #if, #else or #endif
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.ParsedSigFileInputTrivia">
<summary>
 Represents additional information for ParsedSigFileInputTrivia
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.ParsedImplFileInputTrivia.CodeComments">
<summary>
 Represent code comments found in the source file
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTrivia.ParsedImplFileInputTrivia.ConditionalDirectives">
<summary>
 Preprocessor directives of type #if, #else or #endif
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.ParsedImplFileInputTrivia">
<summary>
 Represents additional information for ParsedImplFileInput
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.IdentTrivia.HasParenthesis">
<summary>
 The ident had parenthesis
 Example: let (|Odd|Even|) = ...
 The active pattern ident will be &quot;|Odd|Even|&quot;, while originally there were parenthesis.
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.IdentTrivia.OriginalNotationWithParen">
<summary>
 The ident originally had a different notation and parenthesis
 Example: let (&gt;=&gt;) a b = ...
 The operator ident will be compiled into &quot;op_GreaterEqualsGreater&quot;, while the original notation was &quot;&gt;=&gt;&quot; and had parenthesis
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTrivia.IdentTrivia.OriginalNotation">
<summary>
 The ident originally had a different notation.
 Example: a + b
 The operator ident will be compiled into &quot;op_Addition&quot;, while the original notation was &quot;+&quot;
</summary>
</member>
<member name="M:FSharp.Compiler.SyntaxTreeOps.addEmptyMatchClause(FSharp.Compiler.Text.Range,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SynMatchClause})">
<summary>
 Adds SynPat.Or pattern for unfinished empty clause above
</summary>
</member>
<member name="M:FSharp.Compiler.SyntaxTreeOps.|Get_OrSet_Ident|_|(FSharp.Compiler.Syntax.Ident)">
<summary>
 Generated get_XYZ or set_XYZ ident text
</summary>
</member>
<member name="M:FSharp.Compiler.SyntaxTreeOps.|SynPipeRight3|_|(FSharp.Compiler.Syntax.SynExpr)">
<summary>
 &apos;e1 |||&gt; e2&apos;
</summary>
</member>
<member name="M:FSharp.Compiler.SyntaxTreeOps.|SynPipeRight2|_|(FSharp.Compiler.Syntax.SynExpr)">
<summary>
 &apos;e1 ||&gt; e2&apos;
</summary>
</member>
<member name="M:FSharp.Compiler.SyntaxTreeOps.|SynPipeRight|_|(FSharp.Compiler.Syntax.SynExpr)">
<summary>
 &apos;e1 |&gt; e2&apos;
</summary>
</member>
<member name="M:FSharp.Compiler.SyntaxTreeOps.|SynOrElse|_|(FSharp.Compiler.Syntax.SynExpr)">
<summary>
 &apos;e1 || e2&apos;
</summary>
</member>
<member name="M:FSharp.Compiler.SyntaxTreeOps.|SynAndAlso|_|(FSharp.Compiler.Syntax.SynExpr)">
<summary>
 &apos;e1 &amp;&amp; e2&apos;
</summary>
</member>
<member name="M:FSharp.Compiler.SyntaxTreeOps.PushCurriedPatternsToExpr(FSharp.Compiler.SyntaxTreeOps.SynArgNameGenerator,FSharp.Compiler.Text.Range,System.Boolean,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SynPat},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.Text.Range},FSharp.Compiler.Syntax.SynExpr)">
<summary>
 &quot;fun (UnionCase x) (UnionCase y) -&gt; body&quot;
       ==&gt;
   &quot;fun tmp1 tmp2 -&gt;
        let (UnionCase x) = tmp1 in
        let (UnionCase y) = tmp2 in
        body&quot;
</summary>
</member>
<member name="M:FSharp.Compiler.SyntaxTreeOps.SimplePatOfPat(FSharp.Compiler.SyntaxTreeOps.SynArgNameGenerator,FSharp.Compiler.Syntax.SynPat)">
<summary>
 Push non-simple parts of a patten match over onto the r.h.s. of a lambda.
 Return a simple pattern and a function to build a match on the r.h.s. if the pattern is complex
</summary>
</member>
<member name="M:FSharp.Compiler.SyntaxTreeOps.|SynPatForNullaryArgs|_|(FSharp.Compiler.Syntax.SynPat)">
<summary>
 Recognize the &apos;()&apos; in &apos;new()&apos;
</summary>
</member>
<member name="M:FSharp.Compiler.SyntaxTreeOps.IsControlFlowExpression(FSharp.Compiler.Syntax.SynExpr)">
<summary>
 This affects placement of debug points
</summary>
</member>
<member name="M:FSharp.Compiler.SyntaxTreeOps.|LongOrSingleIdent|_|(FSharp.Compiler.Syntax.SynExpr)">
<summary>
 Match a long identifier, including the case for single identifiers which gets a more optimized node in the syntax tree.
</summary>
</member>
<member name="M:FSharp.Compiler.SyntaxTreeOps.SynInfo.InferSynValData(Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.Syntax.SynMemberFlags},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.Syntax.SynPat},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.Syntax.SynReturnInfo},FSharp.Compiler.Syntax.SynExpr)">
<summary>
 Infer the syntactic information for a &apos;let&apos; or &apos;member&apos; definition, based on the argument pattern,
 any declared return information (e.g. .NET attributes on the return element), and the r.h.s. expression
 in the case of &apos;let&apos; definitions.
</summary>
</member>
<member name="M:FSharp.Compiler.SyntaxTreeOps.SynInfo.AdjustMemberArgs``1(FSharp.Compiler.Syntax.SynMemberKind,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
 Transform a property declared using &apos;[static] member P = expr&apos; to a method taking a &quot;unit&quot; argument.
 This is similar to IncorporateEmptyTupledArgForPropertyGetter, but applies to member definitions
 rather than member signatures.
</summary>
</member>
<member name="M:FSharp.Compiler.SyntaxTreeOps.SynInfo.AdjustArgsForUnitElimination(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SynArgInfo}})">
<summary>
 Make sure only a solitary unit argument has unit elimination
</summary>
</member>
<member name="M:FSharp.Compiler.SyntaxTreeOps.SynInfo.InferSynArgInfoFromPat(FSharp.Compiler.Syntax.SynPat)">
<summary>
 Infer the syntactic argument info for one or more arguments a pattern.
</summary>
</member>
<member name="M:FSharp.Compiler.SyntaxTreeOps.SynInfo.InferSynArgInfoFromSimplePats(FSharp.Compiler.Syntax.SynSimplePats)">
<summary>
 Infer the syntactic argument info for one or more arguments one or more simple patterns.
</summary>
</member>
<member name="M:FSharp.Compiler.SyntaxTreeOps.SynInfo.InferSynArgInfoFromSimplePat(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SynAttributeList},FSharp.Compiler.Syntax.SynSimplePat)">
<summary>
 Infer the syntactic argument info for a single argument from a simple pattern.
</summary>
</member>
<member name="M:FSharp.Compiler.SyntaxTreeOps.SynInfo.AttribsOfArgData(FSharp.Compiler.Syntax.SynArgInfo)">
<summary>
 Get the argument attributes from the syntactic information for an argument.
</summary>
</member>
<member name="M:FSharp.Compiler.SyntaxTreeOps.SynInfo.AritiesOfArgs(FSharp.Compiler.Syntax.SynValInfo)">
<summary>
 Get the argument counts for each curried argument group. Used in some adhoc places in tc.fs.
</summary>
</member>
<member name="M:FSharp.Compiler.SyntaxTreeOps.SynInfo.IncorporateSetterArg(FSharp.Compiler.Syntax.SynValInfo)">
<summary>
 Add a parameter entry to the syntactic value information to represent the value argument for a property setter. This is
 used for the implicit value argument in property setter signature specifications.
</summary>
</member>
<member name="M:FSharp.Compiler.SyntaxTreeOps.SynInfo.IncorporateSelfArg(FSharp.Compiler.Syntax.SynValInfo)">
<summary>
 Add a parameter entry to the syntactic value information to represent the &apos;this&apos; argument. This is
 used for the implicit &apos;this&apos; argument in member signature specifications.
</summary>
</member>
<member name="M:FSharp.Compiler.SyntaxTreeOps.SynInfo.IncorporateEmptyTupledArgForPropertyGetter(FSharp.Compiler.Syntax.SynValInfo)">
<summary>
 Add a parameter entry to the syntactic value information to represent the &apos;()&apos; argument to a property getter. This is
 used for the implicit &apos;()&apos; argument in property getter signature specifications.
</summary>
</member>
<member name="M:FSharp.Compiler.SyntaxTreeOps.SynInfo.HasOptionalArgs(FSharp.Compiler.Syntax.SynValInfo)">
<summary>
 Check if there are any optional arguments in the syntactic argument information. Used when adjusting the
 types of optional arguments for function and member signatures.
</summary>
</member>
<member name="M:FSharp.Compiler.SyntaxTreeOps.SynInfo.IsOptionalArg(FSharp.Compiler.Syntax.SynArgInfo)">
<summary>
 Check if one particular argument is an optional argument. Used when adjusting the
 types of optional arguments for function and member signatures.
</summary>
</member>
<member name="M:FSharp.Compiler.SyntaxTreeOps.SynInfo.HasNoArgs(FSharp.Compiler.Syntax.SynValInfo)">
<summary>
 Determine if a syntactic information represents a member without arguments (which is implicitly a property getter)
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTreeOps.SynInfo.selfMetadata">
<summary>
 The &apos;argument&apos; information for the &apos;this&apos;/&apos;self&apos; parameter in the cases where it is not given explicitly
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTreeOps.SynInfo.unnamedRetVal">
<summary>
 The &apos;argument&apos; information for a return value where no attributes are given for the return value (the normal case)
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTreeOps.SynInfo.unitArgData">
<summary>
 The argument information for a &apos;()&apos; argument
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTreeOps.SynInfo.unnamedTopArg">
<summary>
 The argument information for a curried argument without a name
</summary>
</member>
<member name="P:FSharp.Compiler.SyntaxTreeOps.SynInfo.unnamedTopArg1">
<summary>
 The argument information for an argument without a name
</summary>
</member>
<member name="T:FSharp.Compiler.SyntaxTreeOps.SynInfo">
<summary>
 Operations related to the syntactic analysis of arguments of value, function and member definitions and signatures.
</summary>
</member>
<member name="M:FSharp.Compiler.ParseHelpers.adjustHatPrefixToTyparLookup(FSharp.Compiler.Text.Range,FSharp.Compiler.Syntax.SynExpr)">
<summary>
 Incorporate a &apos;^&apos; for an qualified access to a generic type parameter
</summary>
</member>
<member name="T:FSharp.Compiler.ParseHelpers.SyntaxError">
<summary>
 The error raised by the parse_error_rich function, which is called by the parser engine
 when a syntax error occurs. The first object is the ParseErrorContext which contains a dump of
 information about the grammar at the point where the error occurred, e.g. what tokens
 are valid to shift next at that point in the grammar. This information is processed in CompileOps.fs.
</summary>
</member>
<member name="M:FSharp.Compiler.PPParser.token_to_string(FSharp.Compiler.PPParser.token)">
<summary>
 This function gets the name of a token as a string
</summary>
</member>
<member name="M:FSharp.Compiler.PPParser.prodIdxToNonTerminal(System.Int32)">
<summary>
 This function maps production indexes returned in syntax errors to strings representing the non terminal that would be produced by that production
</summary>
</member>
<member name="M:FSharp.Compiler.PPParser.tokenTagToTokenId(System.Int32)">
<summary>
 This function maps integer indexes to symbolic token ids
</summary>
</member>
<member name="M:FSharp.Compiler.PPParser.tagOfToken(FSharp.Compiler.PPParser.token)">
<summary>
 This function maps tokens to integer indexes
</summary>
</member>
<member name="M:FSharp.Compiler.Parser.token_to_string(FSharp.Compiler.Parser.token)">
<summary>
 This function gets the name of a token as a string
</summary>
</member>
<member name="M:FSharp.Compiler.Parser.prodIdxToNonTerminal(System.Int32)">
<summary>
 This function maps production indexes returned in syntax errors to strings representing the non terminal that would be produced by that production
</summary>
</member>
<member name="M:FSharp.Compiler.Parser.tokenTagToTokenId(System.Int32)">
<summary>
 This function maps integer indexes to symbolic token ids
</summary>
</member>
<member name="M:FSharp.Compiler.Parser.tagOfToken(FSharp.Compiler.Parser.token)">
<summary>
 This function maps tokens to integer indexes
</summary>
</member>
<member name="T:FSharp.Compiler.Lexhelp.BlockCommentArgs">
<summary>
 Used in lex.fsl to represent the state of a block comment
</summary>
</member>
<member name="T:FSharp.Compiler.Lexhelp.SingleLineCommentArgs">
<summary>
 Used in lex.fsl to represent the state of a single line comment
</summary>
</member>
<member name="T:FSharp.Compiler.Lexhelp.LexerStringArgs">
<summary>
 Used in lex.fsl to represent the state of a string literal
</summary>
</member>
<member name="T:FSharp.Compiler.Lexhelp.LexArgs">
<summary>
 The context applicable to all lexing functions (tokens, strings etc.)
</summary>
</member>
<member name="T:FSharp.Compiler.Lexhelp.IndentationAwareSyntaxStatus">
<summary>
 Lexer args: status of #light processing.  Mutated when a #light
 directive is processed. This alters the behaviour of the lexfilter.
</summary>
</member>
<member name="P:FSharp.Compiler.Lexhelp.StringCapacity">
<summary>
 Arbitrary value
</summary>
</member>
<member name="M:FSharp.Compiler.PPLexer.rest(Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Rule rest
</summary>
</member>
<member name="M:FSharp.Compiler.PPLexer.tokenstream(FSharp.Compiler.Lexhelp.LexArgs,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Rule tokenstream
</summary>
</member>
<member name="M:FSharp.Compiler.Lexer.mlOnly(FSharp.Compiler.Text.Range,FSharp.Compiler.Lexhelp.LexArgs,System.Boolean,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Rule mlOnly
</summary>
</member>
<member name="M:FSharp.Compiler.Lexer.tripleQuoteStringInComment(System.Int32,FSharp.Compiler.Text.Range,FSharp.Compiler.Lexhelp.LexArgs,System.Boolean,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Rule tripleQuoteStringInComment
</summary>
</member>
<member name="M:FSharp.Compiler.Lexer.verbatimStringInComment(System.Int32,FSharp.Compiler.Text.Range,FSharp.Compiler.Lexhelp.LexArgs,System.Boolean,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Rule verbatimStringInComment
</summary>
</member>
<member name="M:FSharp.Compiler.Lexer.stringInComment(System.Int32,FSharp.Compiler.Text.Range,FSharp.Compiler.Lexhelp.LexArgs,System.Boolean,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Rule stringInComment
</summary>
</member>
<member name="M:FSharp.Compiler.Lexer.comment(System.Tuple{System.Int32,FSharp.Compiler.Text.Range,FSharp.Compiler.Lexhelp.LexArgs},System.Boolean,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Rule comment
</summary>
</member>
<member name="M:FSharp.Compiler.Lexer.singleLineComment(System.Tuple{Microsoft.FSharp.Core.FSharpOption{System.Tuple{FSharp.Compiler.Text.Range,System.Text.StringBuilder}},System.Int32,FSharp.Compiler.Text.Range,FSharp.Compiler.Text.Range,FSharp.Compiler.Lexhelp.LexArgs},System.Boolean,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Rule singleLineComment
</summary>
</member>
<member name="M:FSharp.Compiler.Lexer.extendedInterpolatedString(System.Tuple{FSharp.Compiler.IO.ByteBuffer,FSharp.Compiler.Lexhelp.LexerStringFinisher,FSharp.Compiler.Text.Range,FSharp.Compiler.ParseHelpers.LexerStringKind,FSharp.Compiler.Lexhelp.LexArgs},System.Boolean,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Rule extendedInterpolatedString
</summary>
</member>
<member name="M:FSharp.Compiler.Lexer.tripleQuoteString(System.Tuple{FSharp.Compiler.IO.ByteBuffer,FSharp.Compiler.Lexhelp.LexerStringFinisher,FSharp.Compiler.Text.Range,FSharp.Compiler.ParseHelpers.LexerStringKind,FSharp.Compiler.Lexhelp.LexArgs},System.Boolean,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Rule tripleQuoteString
</summary>
</member>
<member name="M:FSharp.Compiler.Lexer.verbatimString(System.Tuple{FSharp.Compiler.IO.ByteBuffer,FSharp.Compiler.Lexhelp.LexerStringFinisher,FSharp.Compiler.Text.Range,FSharp.Compiler.ParseHelpers.LexerStringKind,FSharp.Compiler.Lexhelp.LexArgs},System.Boolean,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Rule verbatimString
</summary>
</member>
<member name="M:FSharp.Compiler.Lexer.singleQuoteString(System.Tuple{FSharp.Compiler.IO.ByteBuffer,FSharp.Compiler.Lexhelp.LexerStringFinisher,FSharp.Compiler.Text.Range,FSharp.Compiler.ParseHelpers.LexerStringKind,FSharp.Compiler.Lexhelp.LexArgs},System.Boolean,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Rule singleQuoteString
</summary>
</member>
<member name="M:FSharp.Compiler.Lexer.endline(FSharp.Compiler.ParseHelpers.LexerEndlineContinuation,FSharp.Compiler.Lexhelp.LexArgs,System.Boolean,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Rule endline
</summary>
</member>
<member name="M:FSharp.Compiler.Lexer.ifdefSkip(System.Int32,FSharp.Compiler.Text.Range,FSharp.Compiler.Lexhelp.LexArgs,System.Boolean,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Rule ifdefSkip
</summary>
</member>
<member name="M:FSharp.Compiler.Lexer.token(FSharp.Compiler.Lexhelp.LexArgs,System.Boolean,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Rule token
</summary>
</member>
<member name="P:FSharp.Compiler.LexFilter.LexFilter.LexBuffer">
<summary>
 The LexBuffer associated with the filter
</summary>
</member>
<member name="M:FSharp.Compiler.LexFilter.LexFilter.GetToken">
<summary>
 Get the next token
</summary>
</member>
<member name="M:FSharp.Compiler.LexFilter.LexFilter.#ctor(FSharp.Compiler.Lexhelp.IndentationAwareSyntaxStatus,System.Boolean,Microsoft.FSharp.Core.FSharpFunc{Internal.Utilities.Text.Lexing.LexBuffer{System.Char},FSharp.Compiler.Parser.token},Internal.Utilities.Text.Lexing.LexBuffer{System.Char},System.Boolean)">
<summary>
 Create a lex filter
</summary>
</member>
<member name="T:FSharp.Compiler.LexFilter.LexFilter">
<summary>
 A stateful filter over the token stream that adjusts it for indentation-aware syntax rules
 Process the token stream prior to parsing. Implements the offside rule and other lexical transformations.
</summary>
</member>
<member name="M:FSharp.Compiler.LexFilter.|TyparsCloseOp|_|(System.String)">
<summary>
 Match the close of &apos;&gt;&apos; of a set of type parameters.
 This is done for tokens such as &apos;&gt;&gt;&apos; by smashing the token
</summary>
</member>
<member name="T:FSharp.Compiler.LexFilter">
<summary>
 LexFilter - process the token stream prior to parsing.
 Implements the offside rule and a couple of other lexical transformations.
</summary>
</member>
<member name="M:FSharp.Compiler.Tainted.GetHashCodeTainted``1(FSharp.Compiler.Tainted{``0})">
<summary>
 Compute the hash value for the tainted value
</summary>
</member>
<member name="M:FSharp.Compiler.Tainted.EqTainted``1(FSharp.Compiler.Tainted{``0},FSharp.Compiler.Tainted{``0})">
<summary>
 Test whether the tainted value equals given value. Type providers are ignored (equal tainted values produced by different type providers are equal)
 Failure in call to equality operation will be blamed on type provider of first operand
</summary>
</member>
<member name="M:FSharp.Compiler.Tainted.Eq``1(FSharp.Compiler.Tainted{``0},``0)">
<summary>
 Test whether the tainted value equals given value.
 Failure in call to equality operation will be blamed on type provider of first operand
</summary>
</member>
<member name="M:FSharp.Compiler.Tainted.|Null|NonNull|``1(FSharp.Compiler.Tainted{``0})">
<summary>
 Test whether the tainted value is null
</summary>
</member>
<member name="P:FSharp.Compiler.TypeProviders.ProvidedAssemblyStaticLinkingMap.ILTypeMap">
<summary>
 The table of remappings from type names in the provided assembly to type
 names in the statically linked, embedded assembly.
</summary>
</member>
<member name="M:FSharp.Compiler.TypeProviders.ProvidedAssemblyStaticLinkingMap.CreateNew">
<summary>
 Create a new static linking map, ready to populate with data.
</summary>
</member>
<member name="T:FSharp.Compiler.TypeProviders.ProvidedAssemblyStaticLinkingMap">
<summary>
 The table of information recording remappings from type names in the provided assembly to type
 names in the statically linked, embedded assembly, plus what types are nested in side what types.
</summary>
</member>
<member name="T:FSharp.Compiler.TypeProviders.ProviderGeneratedType">
<summary>
 Represents the remapping information for a generated provided type and its nested types.

 There is one overall tree for each root &apos;type X = ... type generation expr...&apos; specification.
</summary>
</member>
<member name="P:FSharp.Compiler.TypeProviders.ProvidedExpr.UnderlyingExpressionString">
<summary>
 Convert the expression to a string for diagnostics
</summary>
</member>
<member name="M:FSharp.Compiler.TypeProviders.ProvidedTypeContext.RemapTyconRefs(Microsoft.FSharp.Core.FSharpFunc{System.Object,System.Object})">
<summary>
 Map the TyconRef objects, if any
</summary>
</member>
<member name="T:FSharp.Compiler.TypeProviders.ProvidedTypeContext">
<summary>
 The context used to interpret information in the closure of System.Type, System.MethodInfo and other
 info objects coming from the type provider.

 At the moment this is the &quot;Type --&gt; ILTypeRef&quot; and &quot;Type --&gt; Tycon&quot; remapping
 context for generated types (it is empty for erased types). This is computed from
 while processing the [&lt;Generate&gt;] declaration related to the type.

 Immutable (after type generation for a [&lt;Generate&gt;] declaration populates the dictionaries).

 The &apos;obj&apos; values are all TyconRef, but obj is used due to a forward reference being required. Not particularly
 pleasant, but better than intertwining the whole &quot;ProvidedType&quot; with the TAST structure.
</summary>
</member>
<member name="P:FSharp.Compiler.TypeProviders.ResolutionEnvironment.TemporaryFolder">
<summary>
 The folder for temporary files
</summary>
</member>
<member name="P:FSharp.Compiler.TypeProviders.ResolutionEnvironment.GetReferencedAssemblies">
<summary>
 All referenced assemblies, including the type provider itself, and possibly other type providers.
</summary>
</member>
<member name="P:FSharp.Compiler.TypeProviders.ResolutionEnvironment.ShowResolutionMessages">
<summary>
 Whether or not the --showextensionresolution flag was supplied to the compiler.
</summary>
</member>
<member name="P:FSharp.Compiler.TypeProviders.ResolutionEnvironment.OutputFile">
<summary>
 Output file name
</summary>
</member>
<member name="P:FSharp.Compiler.TypeProviders.ResolutionEnvironment.ResolutionFolder">
<summary>
 The folder from which an extension provider is resolving from. This is typically the project folder.
</summary>
</member>
<member name="T:FSharp.Compiler.TypeProviders.ResolutionEnvironment">
<summary>
 Carries information about the type provider resolution environment.
</summary>
</member>
<member name="M:FSharp.Compiler.TypeProviders.IsGeneratedTypeDirectReference(FSharp.Compiler.Tainted{FSharp.Compiler.TypeProviders.ProvidedType},FSharp.Compiler.Text.Range)">
<summary>
 Check if this is a direct reference to a non-embedded generated type. This is not permitted at any name resolution.
 We check by seeing if the type is absent from the remapping context.
</summary>
</member>
<member name="M:FSharp.Compiler.TypeProviders.GetOriginalILTypeRefOfProvidedType(FSharp.Compiler.Tainted{FSharp.Compiler.TypeProviders.ProvidedType},FSharp.Compiler.Text.Range)">
<summary>
 Get the ILTypeRef for the provided type (including for nested types). Do not take into account
 any type relocations or static linking for generated types.
</summary>
</member>
<member name="M:FSharp.Compiler.TypeProviders.GetILTypeRefOfProvidedType(FSharp.Compiler.Tainted{FSharp.Compiler.TypeProviders.ProvidedType},FSharp.Compiler.Text.Range)">
<summary>
 Get the ILTypeRef for the provided type (including for nested types). Take into account
 any type relocations or static linking for generated types.
</summary>
</member>
<member name="M:FSharp.Compiler.TypeProviders.GetFSharpPathToProvidedType(FSharp.Compiler.Tainted{FSharp.Compiler.TypeProviders.ProvidedType},FSharp.Compiler.Text.Range)">
<summary>
 Decompose the enclosing name of a type (including any class nestings) into a list of parts.
 e.g. System.Object -&gt; [&quot;System&quot;; &quot;Object&quot;]
</summary>
</member>
<member name="M:FSharp.Compiler.TypeProviders.GetProvidedNamespaceAsPath(FSharp.Compiler.Text.Range,FSharp.Compiler.Tainted{Microsoft.FSharp.Core.CompilerServices.ITypeProvider},System.String)">
<summary>
 Get the parts of a .NET namespace. Special rules: null means global, empty is not allowed.
</summary>
</member>
<member name="M:FSharp.Compiler.TypeProviders.TryLinkProvidedType(FSharp.Compiler.Tainted{Microsoft.FSharp.Core.CompilerServices.ITypeProvider},System.String[],System.String,FSharp.Compiler.Text.Range)">
<summary>
 Try to resolve a type in the given extension type resolver
</summary>
</member>
<member name="M:FSharp.Compiler.TypeProviders.TryResolveProvidedType(FSharp.Compiler.Tainted{Microsoft.FSharp.Core.CompilerServices.ITypeProvider},FSharp.Compiler.Text.Range,System.String[],System.String)">
<summary>
 Try to resolve a type in the given extension type resolver
</summary>
</member>
<member name="M:FSharp.Compiler.TypeProviders.TryApplyProvidedMethod(FSharp.Compiler.Tainted{FSharp.Compiler.TypeProviders.ProvidedMethodBase},System.Object[],FSharp.Compiler.Text.Range)">
<summary>
 Try to apply a provided method to the given static arguments.
</summary>
</member>
<member name="M:FSharp.Compiler.TypeProviders.TryApplyProvidedType(FSharp.Compiler.Tainted{FSharp.Compiler.TypeProviders.ProvidedType},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.String}},System.Object[],FSharp.Compiler.Text.Range)">
<summary>
 Try to apply a provided type to the given static arguments. If successful also return a function
 to check the type name is as expected (this function is called by the caller of TryApplyProvidedType
 after other checks are made).
</summary>
</member>
<member name="M:FSharp.Compiler.TypeProviders.ValidateProvidedTypeAfterStaticInstantiation(FSharp.Compiler.Text.Range,FSharp.Compiler.Tainted{FSharp.Compiler.TypeProviders.ProvidedType},System.String[],System.String)">
<summary>
 Validate that the given provided type meets some of the rules for F# provided types
</summary>
</member>
<member name="M:FSharp.Compiler.TypeProviders.GetInvokerExpression(Microsoft.FSharp.Core.CompilerServices.ITypeProvider,FSharp.Compiler.TypeProviders.ProvidedMethodBase,FSharp.Compiler.TypeProviders.ProvidedVar[])">
<summary>
 Get the provided expression for a particular use of a method.
</summary>
</member>
<member name="M:FSharp.Compiler.TypeProviders.DisplayNameOfTypeProvider(FSharp.Compiler.Tainted{Microsoft.FSharp.Core.CompilerServices.ITypeProvider},FSharp.Compiler.Text.Range)">
<summary>
 Given an extension type resolver, supply a human-readable name suitable for error messages.
</summary>
</member>
<member name="M:FSharp.Compiler.TypeProviders.GetTypeProvidersOfAssembly(System.String,FSharp.Compiler.AbstractIL.IL.ILScopeRef,System.String,FSharp.Compiler.TypeProviders.ResolutionEnvironment,System.Boolean,System.Boolean,Microsoft.FSharp.Core.FSharpFunc{System.String,System.Boolean},System.Version,Microsoft.FSharp.Collections.FSharpList{System.String},FSharp.Compiler.Text.Range)">
<summary>
 Find and instantiate the set of ITypeProvider components for the given assembly reference
</summary>
</member>
<member name="M:FSharp.Compiler.TypeProviders.toolingCompatiblePaths">
<summary>
 Get the list of relative paths searched for type provider design-time components
</summary>
</member>
<member name="T:FSharp.Compiler.TypeProviders.ProvidedTypeResolutionNoRange">
<summary>
 Raised when an type provider has thrown an exception.
</summary>
</member>
<member name="T:FSharp.Compiler.TypeProviders.ProvidedTypeResolution">
<summary>
 Raised when a type provider has thrown an exception.
</summary>
</member>
<member name="T:FSharp.Compiler.QuotationPickler.NamedTypeData.Named">
<summary>
 Indicates an F# 3.0+ reference to a named type in an assembly loaded by name
</summary>
</member>
<member name="T:FSharp.Compiler.QuotationPickler.NamedTypeData.Idx">
<summary>
 Indicates an F# 4.0+ reference into the supplied table of type definition references, ultimately resolved by TypeRef/TypeDef data
</summary>
</member>
<member name="T:FSharp.Compiler.QuotationPickler">
<summary>
 Code to pickle out quotations in the quotation binary format.
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerGlobalState.CompilerGlobalState.StableNameGenerator">
<summary>
 A global generator of stable compiler generated names
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerGlobalState.CompilerGlobalState.NiceNameGenerator">
<summary>
 A global generator of compiler generated names
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerGlobalState.CompilerGlobalState.IlxGenNiceNameGenerator">
<summary>
 A name generator used by IlxGen for static fields, some generated arguments and other things.
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerGlobalState.StableNiceNameGenerator">
<summary>
 Generates compiler-generated names marked up with a source code location, but if given the same unique value then
 return precisely the same name. Each name generated also includes the StartLine number of the range passed in
 at the point of first generation.

 This type may be accessed concurrently, though in practice it is only used from the compilation thread.
 It is made concurrency-safe since a global instance of the type is allocated in tast.fs.
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerGlobalState.NiceNameGenerator">
<summary>
 Generates compiler-generated names. Each name generated also includes the StartLine number of the range passed in
 at the point of first generation.

 This type may be accessed concurrently, though in practice it is only used from the compilation thread.
 It is made concurrency-safe since a global instance of the type is allocated in tast.fs, and it is good
 policy to make all globally-allocated objects concurrency safe in case future versions of the compiler
 are used to host multiple concurrent instances of compilation.
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerGlobalState.newStamp">
<summary>
 Unique name generator for stamps attached to to val_specs, tycon_specs etc.
 Concurrency-safe
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerGlobalState.newUnique">
<summary>
 Concurrency-safe
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerGlobalState">
<summary>
 Defines the global environment for all type checking.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Construct.NewVal(System.String,FSharp.Compiler.Text.Range,Microsoft.FSharp.Core.FSharpOption{System.String},FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.ValMutability,System.Boolean,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.ValReprInfo},FSharp.Compiler.TypedTree.Accessibility,FSharp.Compiler.TypedTree.ValRecursiveScopeInfo,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.ValMemberInfo},FSharp.Compiler.TypedTree.ValBaseOrThisInfo,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Attrib},FSharp.Compiler.TypedTree.ValInline,FSharp.Compiler.Xml.XmlDoc,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.Const},FSharp.Compiler.TypedTree.ParentRef)">
<summary>
 Create a new Val node
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Construct.NewUnionCase(FSharp.Compiler.Syntax.Ident,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.RecdField},FSharp.Compiler.TypedTree.TType,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Attrib},FSharp.Compiler.Xml.XmlDoc,FSharp.Compiler.TypedTree.Accessibility)">
<summary>
 Create a new union case node
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Construct.NewTypar(FSharp.Compiler.TypedTree.TyparKind,FSharp.Compiler.TypedTree.TyparRigidity,FSharp.Compiler.Syntax.SynTypar,System.Boolean,FSharp.Compiler.TypedTree.TyparDynamicReq,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Attrib},System.Boolean,System.Boolean)">
<summary>
 Create a new type parameter node
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Construct.NewTycon(Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.CompilationPath},System.String,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.Accessibility,FSharp.Compiler.TypedTree.Accessibility,FSharp.Compiler.TypedTree.TyparKind,Internal.Utilities.Library.LazyWithContext{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},FSharp.Compiler.Text.Range},FSharp.Compiler.Xml.XmlDoc,System.Boolean,System.Boolean,System.Boolean,Internal.Utilities.Library.Extras.MaybeLazy{FSharp.Compiler.TypedTree.ModuleOrNamespaceType})">
<summary>
 Create a new type definition node
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Construct.NewRigidTypar(System.String,FSharp.Compiler.Text.Range)">
<summary>
 Create a new type parameter node for a declared type parameter
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Construct.NewRecdField(System.Boolean,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.Const},FSharp.Compiler.Syntax.Ident,System.Boolean,FSharp.Compiler.TypedTree.TType,System.Boolean,System.Boolean,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Attrib},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Attrib},FSharp.Compiler.Xml.XmlDoc,FSharp.Compiler.TypedTree.Accessibility,System.Boolean)">
<summary>
 Create a new TAST RecdField node for an F# class, struct or record field
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Construct.NewProvidedTyconRepr(FSharp.Compiler.TypeProviders.ResolutionEnvironment,FSharp.Compiler.Tainted{FSharp.Compiler.TypeProviders.ProvidedType},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Tainted{FSharp.Compiler.TypeProviders.ProvidedType},FSharp.Compiler.TypedTree.TType},System.Boolean,FSharp.Compiler.Text.Range)">
<summary>
 Create a new node for the representation information for a provided type definition
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Construct.NewProvidedTycon(FSharp.Compiler.TypeProviders.ResolutionEnvironment,FSharp.Compiler.Tainted{FSharp.Compiler.TypeProviders.ProvidedType},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Tainted{FSharp.Compiler.TypeProviders.ProvidedType},FSharp.Compiler.TypedTree.TType},System.Boolean,FSharp.Compiler.Text.Range,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.Accessibility},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.CompilationPath})">
<summary>
 Create a new entity node for a provided type definition
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Construct.NewModuleOrNamespaceType(FSharp.Compiler.TypedTree.ModuleOrNamespaceKind,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Entity},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Val})">
<summary>
 Create a new node for the contents of a module or namespace
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Construct.NewModuleOrNamespace(Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.CompilationPath},FSharp.Compiler.TypedTree.Accessibility,FSharp.Compiler.Syntax.Ident,FSharp.Compiler.Xml.XmlDoc,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Attrib},Internal.Utilities.Library.Extras.MaybeLazy{FSharp.Compiler.TypedTree.ModuleOrNamespaceType})">
<summary>
 Create a new entity node for a module or namespace
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Construct.NewModifiedVal(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.Val,FSharp.Compiler.TypedTree.Val},FSharp.Compiler.TypedTree.Val)">
<summary>
 Create a Val based on an existing one using the function &apos;f&apos;.
 We require that we be given the parent for the new Val.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Construct.NewModifiedTycon(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.Entity,FSharp.Compiler.TypedTree.Entity},FSharp.Compiler.TypedTree.Entity)">
<summary>
 Create a tycon based on an existing one using the function &apos;f&apos;.
 We require that we be given the new parent for the new tycon.
 We pass the new tycon to &apos;f&apos; in case it needs to reparent the
 contents of the tycon.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Construct.NewModifiedModuleOrNamespace(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.ModuleOrNamespaceType,FSharp.Compiler.TypedTree.ModuleOrNamespaceType},FSharp.Compiler.TypedTree.Entity)">
<summary>
 Create a module Tycon based on an existing one using the function &apos;f&apos;.
 We require that we be given the parent for the new module.
 We pass the new module to &apos;f&apos; in case it needs to reparent the
 contents of the module.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Construct.NewILTycon(Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.CompilationPath},System.String,FSharp.Compiler.Text.Range,Internal.Utilities.Library.LazyWithContext{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},FSharp.Compiler.Text.Range},FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILTypeDef},FSharp.Compiler.AbstractIL.IL.ILTypeDef,Internal.Utilities.Library.Extras.MaybeLazy{FSharp.Compiler.TypedTree.ModuleOrNamespaceType})">
<summary>
 Create a new type definition node for a .NET type definition
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Construct.NewFreeVarsCache``1">
<summary>
 Create a new unfilled cache for free variable calculations
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Construct.NewExn(Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.CompilationPath},FSharp.Compiler.Syntax.Ident,FSharp.Compiler.TypedTree.Accessibility,FSharp.Compiler.TypedTree.ExceptionInfo,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Attrib},FSharp.Compiler.Xml.XmlDoc)">
<summary>
 Create a new TAST Entity node for an F# exception definition
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Construct.NewEmptyModuleOrNamespaceType(FSharp.Compiler.TypedTree.ModuleOrNamespaceKind)">
<summary>
 Create a new node for an empty module or namespace contents
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Construct.NewEmptyFSharpTyconData(FSharp.Compiler.TypedTree.FSharpTyconKind)">
<summary>
 Create a new node for an empty F# tycon data
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Construct.NewClonedTycon(FSharp.Compiler.TypedTree.Entity)">
<summary>
 Create a new type definition node by cloning an existing one
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Construct.NewClonedModuleOrNamespace(FSharp.Compiler.TypedTree.Entity)">
<summary>
 Create a new module or namespace node by cloning an existing one
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Construct.NewCcuContents(FSharp.Compiler.AbstractIL.IL.ILScopeRef,FSharp.Compiler.Text.Range,System.String,FSharp.Compiler.TypedTree.ModuleOrNamespaceType)">
<summary>
 Create the new contents of an overall assembly
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Construct.MakeUnionRepr(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.UnionCase})">
<summary>
 Create a node for a union type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Construct.MakeUnionCases(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.UnionCase})">
<summary>
 Create the union case tables for a union type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Construct.MakeRecdFieldsTable(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.RecdField})">
<summary>
 Create the field tables for a record or class type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Construct.KeyTyconByDecodedName``1(System.String,``0)">
<summary>
 Key a Tycon or TyconRef by decoded name
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Construct.KeyTyconByAccessNames``1(System.String,``0)">
<summary>
 Key a Tycon or TyconRef by both mangled type demangled name.
 Generic types can be accessed either by &apos;List&apos; or &apos;List`1&apos;.
 This lists both keys.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Construct.ComputeDefinitionLocationOfProvidedItem``1(FSharp.Compiler.Tainted{``0})">
<summary>
 Compute the definition location of a provided item
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Construct">
<summary>
 A set of static methods for constructing types.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.FreeVars.FreeTyvars">
<summary>
 See FreeTyvars above.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.FreeVars.FreeUnionCases">
<summary>
 The summary of union constructors used in the expression. These may be
 marked &apos;internal&apos; or &apos;private&apos; type we have to check various conditions associated with that.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.FreeVars.FreeRecdFields">
<summary>
 The summary of fields used in the expression. These may be made private by a signature
 or marked &apos;internal&apos; or &apos;private&apos; type we have to check various conditions associated with that.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.FreeVars.FreeLocalTyconReprs">
<summary>
 The summary of locally defined tycon representations used in the expression. These may be made private by a signature
 or marked &apos;internal&apos; or &apos;private&apos; type we have to check various conditions associated with that.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.FreeVars.UsesUnboundRethrow">
<summary>
 Indicates if the expression contains a call to rethrow that is not bound under a (try-)with branch.
 Rethrow may only occur in such locations.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.FreeVars.UsesMethodLocalConstructs">
<summary>
 Indicates if the expression contains a call to a protected member or a base call.
 Calls to protected members type direct calls to super classes can&apos;t escape, also code can&apos;t be inlined
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.FreeVars.FreeLocals">
<summary>
 The summary of locally defined variables used in the expression. These may be hidden at let bindings etc.
 or made private by a signature or marked &apos;internal&apos; or &apos;private&apos;, type we have to check various conditions associated with that.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.FreeVars">
<summary>
 Represents the set of free variables in an expression
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.FreeVarsCache">
<summary>
 Represents an amortized computation of the free variables in an expression
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.FreeTyvars.FreeTypars">
<summary>
 The summary of type parameters used in the expression. These may not escape the enclosing generic construct
 type we have to check various conditions associated with that.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.FreeTyvars.FreeTraitSolutions">
<summary>
 The summary of values used as trait solutions
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.FreeTyvars.FreeTycons">
<summary>
 The summary of locally defined type definitions used in the expression. These may be made private by a signature
 type we have to check various conditions associated with that.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.FreeTyvars">
<summary>
 Represents a set of &apos;free&apos; type-related elements, including named types, trait solutions, union cases and
 record fields.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.FreeUnionCases">
<summary>
 Represents a set of &apos;free&apos; union cases. Used to collect the union cases referred to from an expression.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.FreeRecdFields">
<summary>
 Represents a set of &apos;free&apos; record field definitions. Used to collect the record field definitions referred to
 from an expression.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.FreeTycons">
<summary>
 Represents a set of &apos;free&apos; named type definitions. Used to collect the named type definitions referred to
 from a type or expression. Computed type cached by later phases (never cached type checking). Cached
 in expressions. Not pickled.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.FreeTypars">
<summary>
 Represents a set of free type parameters. Computed type cached by later phases
 (never cached type checking). Cached in expressions. Not pickled.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.FreeLocals">
<summary>
 Represents a set of free local values. Computed type cached by later phases
 (never cached type checking). Cached in expressions. Not pickled.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.PickledCcuInfo">
<summary>
 Represents the information saved in the assembly signature data resource for an F# assembly
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.CcuResolutionResult">
<summary>
 The result of attempting to resolve an assembly name to a full ccu.
 UnresolvedCcu will contain the name of the assembly that could not be resolved.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuThunk.target">
<summary>
 ccu.target is null when a reference is missing in the transitive closure of static references that
 may potentially be required for the metadata of referenced DLLs.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuThunk.UsesFSharp20PlusQuotations(System.Boolean)">
<summary>
 Indicates that this DLL uses F# 2.0+ quotation literals somewhere. This is used to implement a restriction on static linking.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuThunk.UsesFSharp20PlusQuotations">
<summary>
 Indicates that this DLL uses F# 2.0+ quotation literals somewhere. This is used to implement a restriction on static linking.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuThunk.TypeForwarders">
<summary>
 The table of type forwarders for this assembly
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuThunk.Stamp">
<summary>
 A unique stamp for this assembly
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuThunk.SourceCodeDirectory">
<summary>
 A hint as to where does the code for the CCU live (e.g what was the tcConfig.implicitIncludeDir at compilation time for this DLL?)
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuThunk.RootTypeAndExceptionDefinitions">
<summary>
 The table of type definitions at the &quot;root&quot; of the assembly
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuThunk.RootModulesAndNamespaces">
<summary>
 The table of modules type namespaces at the &quot;root&quot; of the assembly
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuThunk.QualifiedName">
<summary>
 The fully qualified assembly reference string to refer to this assembly. This is persisted in quotations
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuThunk.IsUnresolvedReference">
<summary>
 Indicates if this assembly reference is unresolved
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuThunk.IsProviderGenerated">
<summary>
 Is this a provider-injected assembly
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuThunk.IsFSharp">
<summary>
 Indicates that this DLL was compiled using the F# compiler type has F# metadata
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuThunk.ILScopeRef">
<summary>
 Holds the data indicating how this assembly/module is referenced from the code being compiled.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuThunk.FileName">
<summary>
 Holds the file name for the assembly, if any
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuThunk.Deref">
<summary>
 Dereference the assembly reference
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuThunk.Contents">
<summary>
 A handle to the full specification of the contents of the module contained in this ccu
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuThunk.AssemblyName">
<summary>
 The short name of the assembly being referenced
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.CcuThunk.TryGetILModuleDef">
<summary>
 Try to get the .NET Assembly, if known. May not be present for `IsFSharp` for
 in-memory cross-project references
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.CcuThunk.TryForward(System.String[],System.String)">
<summary>
 Try to resolve a path into the CCU by referencing the .NET/CLI type forwarder table of the CCU
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.CcuThunk.MemberSignatureEquality(FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.TType)">
<summary>
 Used to make forward calls into the type/assembly loader when comparing member signatures during linking
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.CcuThunk.ImportProvidedType(FSharp.Compiler.Tainted{FSharp.Compiler.TypeProviders.ProvidedType})">
<summary>
 Used to make &apos;forward&apos; calls into the loader during linking
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.CcuThunk.Fixup(FSharp.Compiler.TypedTree.CcuThunk)">
<summary>
 Fixup a CCU to have the given contents
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.CcuThunk.EnsureDerefable(System.String[])">
<summary>
 Ensure the ccu is derefable in advance. Supply a path to attach to any resulting error message.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.CcuThunk.CreateDelayed(System.String)">
<summary>
 Create a CCU with the given name but where the contents have not yet been specified
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.CcuThunk.Create(System.String,FSharp.Compiler.TypedTree.CcuData)">
<summary>
 Create a CCU with the given name type contents
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.CcuThunk.CloneWithFinalizedContents(FSharp.Compiler.TypedTree.Entity)">
<summary>
 Used at the end of compiling an assembly to get a frozen, final stable CCU
 for the compilation which we no longer mutate.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.CcuThunk">
<summary>
 A relinkable handle to the contents of a compilation unit. Relinking is performed by mutation.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.CcuTypeForwarderTable">
<summary>
 Represents a table of .NET CLI type forwarders for an assembly
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuData.TypeForwarders">
<summary>
 The table of .NET CLI type forwarders for this assembly
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuData.MemberSignatureEquality">
<summary>
 A helper function used to link method signatures using type equality. This is effectively a forward call to the type equality
 logic in tastops.fs
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuData.TryGetILModuleDef">
<summary>
 A helper function used to link method signatures using type equality. This is effectively a forward call to the type equality
 logic in tastops.fs
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuData.Contents">
<summary>
 A handle to the full specification of the contents of the module contained in this ccu
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuData.UsesFSharp20PlusQuotations">
<summary>
 Indicates that this DLL uses pre-F#-4.0 quotation literals somewhere. This is used to implement a restriction on static linking
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuData.ImportProvidedType">
<summary>
 A helper function used to link method signatures using type equality. This is effectively a forward call to the type equality
 logic in tastops.fs
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuData.InvalidateEvent">
<summary>
 Triggered when the contents of the CCU are invalidated
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuData.IsProviderGenerated">
<summary>
 Is the CCu an assembly injected by a type provider
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuData.IsFSharp">
<summary>
 Indicates that this DLL was compiled using the F# compiler type has F# metadata
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuData.SourceCodeDirectory">
<summary>
 A hint as to where does the code for the CCU live (e.g what was the tcConfig.implicitIncludeDir at compilation time for this DLL?)
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuData.QualifiedName">
<summary>
 The fully qualified assembly reference string to refer to this assembly. This is persisted in quotations
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuData.Stamp">
<summary>
 A unique stamp for this DLL
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuData.ILScopeRef">
<summary>
 Holds the data indicating how this assembly/module is referenced from the code being compiled.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.CcuData.FileName">
<summary>
 Holds the file name for the DLL, if any
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.CheckedAssemblyAfterOptimization">
<summary>
 Represents a complete typechecked assembly, made up of multiple implementation files.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.CheckedImplFileAfterOptimization">
<summary>
 Represents checked file, after optimization, equipped with the ability to do further optimization of expressions.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.CheckedImplFile">
<summary>
 Represents a complete typechecked implementation file, including its inferred or explicit signature.

 CheckedImplFile (qualifiedNameOfFile, pragmas, signature, contents, hasExplicitEntryPoint, isScript, anonRecdTypeInfo)
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ModuleOrNamespaceBinding.Module">
<summary>
 The moduleOrNamespace represents the signature of the module.
 The moduleOrNamespaceContents contains the definitions of the module.
 The same set of entities are bound in the ModuleOrNamespace as in the ModuleOrNamespaceContents.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ModuleOrNamespaceBinding">
<summary>
 A named module-or-namespace-fragment definition
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ModuleOrNamespaceContents.TMDefRec">
<summary>
 Indicates the module fragment is a &apos;rec&apos; or &apos;non-rec&apos; definition of types type modules
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ModuleOrNamespaceContents.TMDefDo">
<summary>
 Indicates the module fragment is an evaluation of expression for side-effects
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ModuleOrNamespaceContents.TMDefLet">
<summary>
 Indicates the module fragment is a &apos;let&apos; definition
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ModuleOrNamespaceContents.TMDefOpens">
<summary>
 Indicates the given &apos;open&apos; declarations are active
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ModuleOrNamespaceContents.TMDefs">
<summary>
 Indicates the module fragment is made of several module fragments in succession
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ModuleOrNamespaceContents">
<summary>
 The contents of a module-or-namespace-fragment definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.OpenDeclaration.IsOwnNamespace">
<summary>
 If it&apos;s `namespace Xxx.Yyy` declaration.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.OpenDeclaration.AppliedScope">
<summary>
 Scope in which open declaration is visible.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.OpenDeclaration.Types">
<summary>
 Types whose static content is opened with this declaration.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.OpenDeclaration.Modules">
<summary>
 Modules or namespaces which is opened with this declaration.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.OpenDeclaration.Range">
<summary>
 Full range of the open declaration.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.OpenDeclaration.Target">
<summary>
 Syntax after &apos;open&apos; as it&apos;s presented in source code.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.OpenDeclaration.Create(FSharp.Compiler.Syntax.SynOpenDeclTarget,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.EntityRef},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.Text.Range,System.Boolean)">
<summary>
 Create a new instance of OpenDeclaration.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.OpenDeclaration">
<summary>
 Represents open declaration statement.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.SlotParam">
<summary>
 Represents a parameter to an abstract method slot.

 TSlotParam(nm, ty, inFlag, outFlag, optionalFlag, attribs)
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.SlotSig.Name">
<summary>
 The name of the method
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.SlotSig.MethodTypars">
<summary>
 The method type parameters of the slot
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.SlotSig.FormalReturnType">
<summary>
 The formal return type of the slot (regardless of the type or method instantiation)
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.SlotSig.FormalParams">
<summary>
 The formal parameters of the slot (regardless of the type or method instantiation)
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.SlotSig.DeclaringType">
<summary>
 The (instantiated) type which the slot is logically a part of
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.SlotSig.ClassTypars">
<summary>
 The class type parameters of the slot
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.SlotSig">
<summary>
 Represents an abstract method slot, or delegate signature.

 TSlotSig(methodName, declaringType, declaringTypeParameters, methodTypeParameters, slotParameters, returnTy)
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ObjExprMethod">
<summary>
 A representation of a method in an object expression.

 TObjExprMethod(slotsig, attribs, methTyparsOfOverridingMethod, methodParams, methodBodyExpr, m)
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.StaticOptimization.TTyconIsStruct">
<summary>
 Indicates the static optimization applies when a type is a struct
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.StaticOptimization.TTyconEqualsTycon">
<summary>
 Indicates the static optimization applies when a type equality holds
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.StaticOptimization">
<summary>
 Represents the kind of an F# core library static optimization construct
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ValUseFlag.VSlotDirectCall">
<summary>
 A call to a base method, e.g. &apos;base.OnPaint(args)&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ValUseFlag.CtorValUsedAsSelfInit">
<summary>
 A call to a constructor, e.g. &apos;new C() = new C(3)&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ValUseFlag.CtorValUsedAsSuperInit">
<summary>
 A call to a constructor, e.g. &apos;inherit C()&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ValUseFlag.NormalValUse">
<summary>
 A normal use of a value
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ValUseFlag.PossibleConstrainedCall">
<summary>
 Indicates a use of a value represents a call to a method that may require
 a .NET 2.0 constrained call. A constrained call is only used for calls where
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ValUseFlag">
<summary>
 Indicates how a value, function or member is being used at a particular usage point.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.SequentialOpKind.ThenDoSeq">
<summary>
 let res = a in b;res
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.SequentialOpKind.NormalSeq">
<summary>
 a ; b
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.SequentialOpKind">
<summary>
 Represents the kind of sequential operation, i.e. &quot;normal&quot; or &quot;to a before returning b&quot;
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.LValueOperation.LByrefSet">
<summary>
 In C syntax this is: *localv_ptr = e
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.LValueOperation.LSet">
<summary>
 In C syntax this is: localv = e, note == *(&amp;localv) = e == LAddrOf; LByrefSet
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.LValueOperation.LByrefGet">
<summary>
 In C syntax this is: *localv_ptr
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.LValueOperation.LAddrOf">
<summary>
 In C syntax this is: &amp;localv
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.LValueOperation">
<summary>
 Indicates what kind of pointer operation this is.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ForLoopStyle.CSharpForLoopUp">
<summary>
 Evaluate start once type end multiple times, loop up
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ForLoopStyle.FSharpForLoopDown">
<summary>
 Evaluate start type end once, loop down
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ForLoopStyle.FSharpForLoopUp">
<summary>
 Evaluate start type end once, loop up
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ForLoopStyle">
<summary>
 Represents the kind of looping operation.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.SpecialWhileLoopMarker.WhileLoopForCompiledForEachExprMarker">
<summary>
 Marks the compiled form of a &apos;for ... in ... do &apos; expression
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.SpecialWhileLoopMarker">
<summary>
 Represents the kind of looping operation.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ConstrainedCallInfo">
<summary>
 If this is Some ty then it indicates that a .NET 2.0 constrained call is required, with the given type as the
 static type of the object argument.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.RecordConstructionInfo.RecdExpr">
<summary>
 Normal record construction
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.RecordConstructionInfo.RecdExprIsObjInit">
<summary>
 We&apos;re in an explicit constructor. The purpose of the record expression is to
 fill in the fields of a pre-created but uninitialized object
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.RecordConstructionInfo">
<summary>
 Represents the kind of record construction operation.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.ILCall">
<summary>
 IL method calls.
     isProperty -- used for quotation reflection, property getters &amp; setters
     noTailCall - DllImport? if so don&apos;t tailcall
     retTypes -- the types of pushed values, if any
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.LValueOp">
<summary>
 Operation nodes representing C-style operations on byrefs type mutable vals (l-values)
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.TraitCall">
<summary>
 Pseudo method calls. This is used for overloaded operations like op_Addition.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.Label">
<summary>
 Used for state machine compilation
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.Goto">
<summary>
 Used for state machine compilation
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.Return">
<summary>
 Used for state machine compilation
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.Reraise">
<summary>
 Represents a &quot;rethrow&quot; operation. May not be rebound, or used outside of try-finally, expecting a unit argument
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.Coerce">
<summary>
 Conversion node, compiled via type-directed translation or to box/unbox
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.RefAddrGet">
<summary>
 Generate a ldflda on an &apos;a ref.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.ILAsm">
<summary>
 IL assembly code - type list are the types pushed on the stack
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.TupleFieldGet">
<summary>
 An operation representing a field-get from an F# tuple value.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.ExnFieldSet">
<summary>
 An operation representing a field-set on an F# exception value.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.ExnFieldGet">
<summary>
 An operation representing a field-get from an F# exception value.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.UnionCaseFieldSet">
<summary>
 An operation representing a field-get from a union value. The value is not assumed to have been proven to be of the corresponding union case.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.UnionCaseFieldGetAddr">
<summary>
 An operation representing a field-get from a union value, where that value has been proven to be of the corresponding union case.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.UnionCaseFieldGet">
<summary>
 An operation representing a field-get from a union value, where that value has been proven to be of the corresponding union case.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.UnionCaseProof">
<summary>
 An operation representing a coercion that proves a union value is of a particular union case. This is not a test, its
 simply added proof to enable us to generate verifiable code for field access on union types
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.UnionCaseTagGet">
<summary>
 An operation representing getting an integer tag for a union value representing the union case number
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.ValFieldGetAddr">
<summary>
 An operation representing getting the address of a record field
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.ValFieldGet">
<summary>
 An operation representing getting a record or class field
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.ValFieldSet">
<summary>
 An operation representing setting a record or class field
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.Recd">
<summary>
 Construct a record or object-model value. The ValRef is for self-referential class constructors, otherwise
 it indicates that we&apos;re in a constructor type the purpose of the expression is to
 fill in the fields of a pre-created but uninitialized object, type to assign the initialized
 version of the object into the optional mutable cell pointed to be the given value.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.TryFinally">
<summary>
 An operation representing a lambda-encoded try/finally
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.TryWith">
<summary>
 An operation representing a lambda-encoded try/with
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.IntegerForLoop">
<summary>
 An operation representing a lambda-encoded integer for-loop
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.While">
<summary>
 An operation representing a lambda-encoded while loop. The special while loop marker is used to mark compilations of &apos;foreach&apos; expressions
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.UInt16s">
<summary>
 Constant uint16 arrays (used for parser tables)
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.Bytes">
<summary>
 Constant byte arrays (used for parser tables type other embedded data)
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.Array">
<summary>
 An operation representing the creation of an array value
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.AnonRecdGet">
<summary>
 An operation representing the get of a property from an anonymous record
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.AnonRecd">
<summary>
 An operation representing the creation of an anonymous record
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.Tuple">
<summary>
 An operation representing the creation of a tuple value
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.ExnConstr">
<summary>
 An operation representing the creation of an exception value using an F# exception declaration
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TOp.UnionCase">
<summary>
 An operation representing the creation of a union value of the particular union case
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Expr.DebugPoint">
<summary>
 Indicates a debug point should be placed prior to the expression.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Expr.Link">
<summary>
 An instance of a link node occurs for every use of a recursively bound variable. When type-checking
 the recursive bindings a dummy expression is stored in the mutable reference cell.
 After type checking the bindings this is replaced by a use of the variable, perhaps at an
 appropriate type instantiation. These are immediately eliminated on subsequent rewrites.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Expr.TyChoose">
<summary>
 Indicates a free choice of typars that arises due to
 minimization of polymorphism at let-rec bindings. These are
 resolved to a concrete instantiation on subsequent rewrites.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Expr.WitnessArg">
<summary>
 Used in quotation generation to indicate a witness argument, spliced into a quotation literal.

 For example:

     let inline f x = &lt;@ sin x @&gt;

 needs to pass a witness argument to `sin x`, captured from the surrounding context, for the witness-passing
 version of the code.  Thus the QuotationTranslation type IlxGen makes the generated code as follows:

  f(x) { return Deserialize(&lt;@ sin _spliceHole @&gt;, [| x |]) }

  f$W(witnessForSin, x) { return Deserialize(&lt;@ sin$W _spliceHole1 _spliceHole2 @&gt;, [| WitnessArg(witnessForSin), x |]) }

 where _spliceHole1 will be the location of the witness argument in the quotation data, type
 witnessArg is the lambda for the witness

</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Expr.Quote">
<summary>
 Indicates the expression is a quoted expression tree.

</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Expr.Op">
<summary>
 An intrinsic applied to some (strictly evaluated) arguments
 A few of intrinsics (TOp_try, TOp.While, TOp.IntegerForLoop) expect arguments kept in a normal form involving lambdas
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Expr.StaticOptimization">
<summary>
 If we statically know some information then in many cases we can use a more optimized expression
 This is primarily used by terms in the standard library, particularly those implementing overloaded
 operators.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Expr.Match">
<summary>
 Matches are a more complicated form of &quot;let&quot; with multiple possible destinations
 type possibly multiple ways to get to each destination.
 The first range is that of the expression being matched, which is used
 as the range for all the decision making type binding that happens during the decision tree
 execution.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Expr.Let">
<summary>
 Bind a value.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Expr.LetRec">
<summary>
 Bind a recursive set of values.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Expr.App">
<summary>
 Applications.
 Applications combine type type term applications, type are normalized so
 that sequential applications are combined, so &quot;(f x y)&quot; becomes &quot;f [[x];[y]]&quot;.
 The type attached to the function is the formal function type, used to ensure we don&apos;t build application
 nodes that over-apply when instantiating at function types.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Expr.TyLambda">
<summary>
 Type lambdas. These are used for the r.h.s. of polymorphic &apos;let&apos; bindings type
 for expressions that implement first-class polymorphic values.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Expr.Lambda">
<summary>
 Lambda expressions.
 Why multiple vspecs? A Expr.Lambda taking multiple arguments really accepts a tuple.
 But it is in a convenient form to be compile accepting multiple
 arguments, e.g. if compiled as a toplevel static method.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Expr.Sequential">
<summary>
 Sequence expressions, used for &quot;a;b&quot;, &quot;let a = e in b;a&quot; type &quot;a then b&quot; (the last an OO constructor).
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Expr.Val">
<summary>
 Reference a value. The flag is only relevant if the value is an object model member
 type indicates base calls type special uses of object constructors.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Expr.Const">
<summary>
 A constant expression.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Expr.Range">
<summary>
 Get the mark/range/position information from an expression
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Expr">
<summary>
 Represents an expression in the typed abstract syntax
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparReprInfo">
<summary>
 Records the extra metadata stored about typars for type parameters
 compiled as &quot;real&quot; IL type parameters, specifically for values with
 ValReprInfo. Any information here is propagated from signature through
 to the compiled code.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ArgReprInfo.OtherRange">
<summary>
 The range of the signature/implementation counterpart to this argument, if any
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ArgReprInfo.Name">
<summary>
 The name for the argument at this position, if any
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ArgReprInfo.Attribs">
<summary>
 The attributes for the argument
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ArgReprInfo">
<summary>
 Records the &quot;extra information&quot; for an argument compiled as a real
 method argument, specifically the argument name type attributes.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ValReprInfo.ValReprInfo">
<summary>
 ValReprInfo (typars, args, result)
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValReprInfo.TotalArgCount">
<summary>
 Get the total number of arguments
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValReprInfo.NumTypars">
<summary>
 Get the number of type parameters of the value
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValReprInfo.NumCurriedArgs">
<summary>
 Get the number of curried arguments of the value
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValReprInfo.KindsOfTypars">
<summary>
 Get the kind of each type parameter
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValReprInfo.HasNoArgs">
<summary>
 Indicates if the value has no arguments - neither type parameters nor value arguments
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValReprInfo.AritiesOfArgs">
<summary>
 Get the number of tupled arguments in each curried argument position
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValReprInfo.ArgInfos">
<summary>
 Get the extra information about the arguments for the value
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ValReprInfo">
<summary>
 Records the &quot;extra information&quot; for a value compiled as a method (rather
 than a closure or a local), including argument names, attributes etc.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ActivePatternElemRef.CaseIndex">
<summary>
 Get the index of the active pattern element within the overall active pattern
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ActivePatternElemRef.ActivePatternVal">
<summary>
 Get a reference to the value for the active pattern being referred to
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ActivePatternElemRef.ActivePatternRetKind">
<summary>
 Get a reference to the value for the active pattern being referred to
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ActivePatternElemRef.ActivePatternInfo">
<summary>
 Get the full information about the active pattern being referred to
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ActivePatternElemRef">
<summary>
 Represents a reference to an active pattern element. The
 integer indicates which choice in the target set is being selected by this item.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Binding.Var">
<summary>
 The value being bound
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Binding.Expr">
<summary>
 The expression the value is being bound to
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Binding.DebugPoint">
<summary>
 The information about whether to emit a sequence point for the binding
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Binding">
<summary>
 A binding of a variable to an expression, as in a `let` binding or similar
  -- val: The value being bound
  -- expr: The expression to execute to get the value
  -- debugPoint: The debug point for the binding
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Bindings">
<summary>
 A collection of simultaneous bindings
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.DecisionTreeTarget">
<summary>
 A target of a decision tree. Can be thought of as a little function, though is compiled as a local block.
   -- boundVals - The values bound at the target, matching the valuesin the TDSuccess
   -- targetExpr - The expression to evaluate if we branch to the target
   -- debugPoint - The debug point for the target
   -- isStateVarFlags - Indicates which, if any, of the values are represents as state machine variables
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.DecisionTreeTest.Error">
<summary>
 Used in error recovery
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.DecisionTreeTest.ActivePatternCase">
<summary>
 Test.ActivePatternCase(activePatExpr, activePatResTys, activePatRetKind, activePatIdentity, idx, activePatInfo)

 Run the active pattern type bind a successful result to a
 variable in the remaining tree.
     activePatExpr -- The active pattern function being called, perhaps applied to some active pattern parameters.
     activePatResTys -- The result types (case types) of the active pattern.
     activePatRetKind -- Indicating what is returning from the active pattern
     activePatIdentity -- The value type the types it is applied to. If there are any active pattern parameters then this is empty.
     idx -- The case number of the active pattern which the test relates to.
     activePatternInfo -- The extracted info for the active pattern.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.DecisionTreeTest.IsInst">
<summary>
 IsInst(source, target)

 Test if the input to a decision tree is an instance of the given type
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.DecisionTreeTest.IsNull">
<summary>
 Test if the input to a decision tree is null
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.DecisionTreeTest.Const">
<summary>
 Test if the input to a decision tree is the given constant value
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.DecisionTreeTest.ArrayLength">
<summary>
 Test if the input to a decision tree is an array of the given length
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.DecisionTreeTest.UnionCase">
<summary>
 Test if the input to a decision tree matches the given union case
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ActivePatternReturnKind.Boolean">
<summary>
 Returning bool
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ActivePatternReturnKind.StructTypeWrapper">
<summary>
 Returning `_ voption`
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ActivePatternReturnKind.RefTypeWrapper">
<summary>
 Returning `_ option` or `Choice&lt;_, _, .., _&gt;`
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ActivePatternReturnKind">
<summary>
 Indicating what is returning from an AP
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.DecisionTreeCase.Discriminator">
<summary>
 Get the discriminator associated with the case
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.DecisionTreeCase.CaseTree">
<summary>
 Get the decision tree or a successful test
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.DecisionTreeCase">
<summary>
 Represents a test type a subsequent decision tree
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.DecisionTree.TDBind">
<summary>
 TDBind(binding, body)

 Bind the given value through the remaining cases of the dtree.
 These arise from active patterns type some optimizations to prevent
 repeated computations in decision trees.
    binding -- the value type the expression it is bound to
    body -- the rest of the decision tree
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.DecisionTree.TDSuccess">
<summary>
 TDSuccess(results, targets)

 Indicates the decision tree has terminated with success, transferring control to the given target with the given parameters.
    results -- the expressions to be bound to the variables at the target
    target -- the target number for the continuation
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.DecisionTree.TDSwitch">
<summary>
 TDSwitch(input, cases, default, range)

 Indicates a decision point in a decision tree.
    input -- The expression being tested. If switching over a struct union this
             must be the address of the expression being tested.
    cases -- The list of tests type their subsequent decision trees
    default -- The default decision tree, if any
    range -- (precise documentation needed)
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.DecisionTree">
<summary>
 Decision trees. Pattern matching has been compiled down to
 a decision tree by this point. The right-hand-sides (actions) of
 a decision tree by this point. The right-hand-sides (actions) of
 the decision tree are labelled by integers that are unique for that
 particular tree.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Const">
<summary>
 Constants in expressions
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.AttribNamedArg">
<summary>
 AttribNamedArg(name, type, isField, value)
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.AttribExpr.AttribExpr">
<summary>
 AttribExpr(source, evaluated)
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.AttribExpr">
<summary>
 We keep both source expression type evaluated expression around to help intellisense type signature printing
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Attrib">
<summary>
 Attrib(tyconRef, kind, unnamedArgs, propVal, appliedToAGetterOrSetter, targetsOpt, range)
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.AttribKind.FSAttrib">
<summary>
 Indicates an attribute refers to a type defined in an imported F# assembly
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.AttribKind.ILAttrib">
<summary>
 Indicates an attribute refers to a type defined in an imported .NET assembly
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Measure.RationalPower">
<summary>
 Raising a measure to a rational power
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Measure.One">
<summary>
 The unit of measure &apos;1&apos;, e.g. float = float&lt;1&gt;
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Measure.Inv">
<summary>
 An inverse of a units of measure expression
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Measure.Prod">
<summary>
 A product of two units of measure
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Measure.Const">
<summary>
 A constant, leaf unit-of-measure such as &apos;kg&apos; or &apos;m&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Measure.Var">
<summary>
 A variable unit-of-measure
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Measure">
<summary>
 Represents a unit of measure in the typed AST
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TupInfo.Const">
<summary>
 Some constant, e.g. true or false for tupInfo
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.AnonRecdTypeInfo.ILTypeRef">
<summary>
 Get the ILTypeRef for the generated type implied by the anonymous type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.AnonRecdTypeInfo.DisplayNameCoreByIdx(System.Int32)">
<summary>
 Get the core of the display name for one of the fields of the anonymous record, by index
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.AnonRecdTypeInfo.DisplayNameByIdx(System.Int32)">
<summary>
 Get the display name for one of the fields of the anonymous record, by index
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.AnonRecdTypeInfo.Create(FSharp.Compiler.TypedTree.CcuThunk,FSharp.Compiler.TypedTree.TupInfo,FSharp.Compiler.Syntax.Ident[])">
<summary>
 Create an AnonRecdTypeInfo from the basic data
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.AnonRecdTypeInfo">
<summary>
 Represents the information identifying an anonymous record
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TType.TType_measure">
<summary>
 Indicates the type is a unit-of-measure expression being used as an argument to a type or member
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TType.TType_var">
<summary>
 Indicates the type is a variable type, whether declared, generalized or an inference type parameter

 &apos;flags&apos; is a placeholder for future features, in particular nullness analysis
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TType.TType_ucase">
<summary>
 Indicates the type is a non-F#-visible type representing a &quot;proof&quot; that a union value belongs to a particular union case
 These types are not user-visible type will never appear as an inferred type. They are the types given to
 the temporaries arising out of pattern matching on union values.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TType.TType_fun">
<summary>
 Indicates the type is a function type.

 &apos;flags&apos; is a placeholder for future features, in particular nullness analysis.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TType.TType_tuple">
<summary>
 Indicates the type is a tuple type. elementTypes must be of length 2 or greater.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TType.TType_anon">
<summary>
 Indicates the type is an anonymous record type whose compiled representation is located in the given assembly
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TType.TType_app">
<summary>
 Indicates the type is built from a named type and a number of type arguments.

 &apos;flags&apos; is a placeholder for future features, in particular nullness analysis
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TType.TType_forall">
<summary>
 Indicates the type is a universal type, only used for types of values type members
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.TType.GetAssemblyName">
<summary>
 For now, used only as a discriminant in error message.
 See https://github.com/dotnet/fsharp/issues/2561
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TType">
<summary>
 Represents a type in the typed abstract syntax
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.NullnessInfo.AmbivalentToNull">
<summary>
 we know we don&apos;t care
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.NullnessInfo.WithoutNull">
<summary>
 we know that there is no extra null value in the type
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.NullnessInfo.WithNull">
<summary>
 we know that there is an extra null value in the type
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdFieldRef.TyconRef">
<summary>
 Get a reference to the type containing this record field
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdFieldRef.Tycon">
<summary>
 Get the Entity for the type containing this record field
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdFieldRef.TryRecdField">
<summary>
 Try to dereference the reference
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdFieldRef.SigRange">
<summary>
 Get the signature range of the record field
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdFieldRef.RecdField">
<summary>
 Dereference the reference
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdFieldRef.Range">
<summary>
 Get the declaration range of the record field
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdFieldRef.PropertyAttribs">
<summary>
 Get the attributes associated with the compiled property of the record field
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdFieldRef.FieldName">
<summary>
 Get the name of the field
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdFieldRef.DisplayName">
<summary>
 Get the name of the field, with backticks added for non-identifier names
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdFieldRef.DefinitionRange">
<summary>
 Get the definition range of the record field
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.RecdFieldRef">
<summary>
 Represents a reference to a field in a record, class or struct
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCaseRef.UnionCase">
<summary>
 Dereference the reference to the union case
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCaseRef.TyconRef">
<summary>
 Get a reference to the type containing this union case
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCaseRef.Tycon">
<summary>
 Get the Entity for the type containing this union case
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCaseRef.TryUnionCase">
<summary>
 Try to dereference the reference
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCaseRef.SigRange">
<summary>
 Get the signature range of the union case
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCaseRef.ReturnType">
<summary>
 Get the resulting type of the union case
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCaseRef.Range">
<summary>
 Get the range of the union case
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCaseRef.Index">
<summary>
 Get the index of the union case amongst the cases
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCaseRef.DefinitionRange">
<summary>
 Get the definition range of the union case
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCaseRef.CaseName">
<summary>
 Get the name of this union case
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCaseRef.Attribs">
<summary>
 Get the attributes associated with the union case
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCaseRef.AllFieldsAsList">
<summary>
 Get the fields of the union case
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.UnionCaseRef.FieldByIndex(System.Int32)">
<summary>
 Get a field of the union case by index
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.UnionCaseRef">
<summary>
 Represents a reference to a case of a union type
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.nlr">
<summary>
 Indicates a reference to something bound in another CCU
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.binding">
<summary>
 Indicates a reference to something bound in this CCU
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.XmlDocSig">
<summary>
 Get or set the signature for the value&apos;s XML documentation
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.XmlDoc">
<summary>
 Get the declared documentation for the value
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.ValReprInfo">
<summary>
 Records the &quot;extra information&quot; for a value compiled as a method.

 This indicates the number of arguments in each position for a curried function.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.Type">
<summary>
 The type of the value. May be a TType_forall for a generic value.
 May be a type variable or type containing type variables during type inference.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.TryDeref">
<summary>
 Dereference the ValRef to a Val option.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.TryDeclaringEntity">
<summary>
 The parent type or module, if any (ParentNone for expression bindings type parameters)
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.TauType">
<summary>
 Get the type of the value after removing any generic type parameters
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.Stamp">
<summary>
 A unique stamp within the context of this invocation of the compiler process
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.ShouldInline">
<summary>
 Indicates whether the inline declaration for the value indicate that the value should be inlined?
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.ReflectedDefinition">
<summary>
 The quotation expression associated with a value given the [&lt;ReflectedDefinition&gt;] tag
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.RecursiveValInfo">
<summary>
 Get the information about a recursive value used during type inference
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.PublicPath">
<summary>
 Get the public path to the value, if any? Should be set if type only if
 IsMemberOrModuleBinding is set.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.PropertyName">
<summary>
 Get the name of the value, assuming it is compiled as a property.
   - If this is a property then this is &apos;Foo&apos;
   - If this is an implementation of an abstract slot then this is the name of the property implemented by the abstract slot
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.PermitsExplicitTypeInstantiation">
<summary>
 Indicates if this value allows the use of an explicit type instantiation (i.e. does it itself have explicit type arguments,
 or does it have a signature?)
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.NumObjArgs">
<summary>
 Get the number of &apos;this&apos;/&apos;self&apos; object arguments for the member. Instance extension members return &apos;1&apos;.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.MemberInfo">
<summary>
 Is this a member, if so some more data about the member.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.MemberApparentEntity">
<summary>
 Get the apparent parent entity for a member
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.MakesNoCriticalTailcalls">
<summary>
 Indicates if this is inferred to be a method or function that definitely makes no critical tailcalls?
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.LiteralValue">
<summary>
 The value of a value or member marked with [&lt;LiteralAttribute&gt;]
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.IsTypeFunction">
<summary>
  Indicates if this value was declared to be a type function, e.g. &quot;let f&lt;&apos;a&gt; = typeof&lt;&apos;a&gt;&quot;
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.IsPropertySetterMethod">
<summary>
 Indicates whether this value represents a property setter.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.IsPropertyGetterMethod">
<summary>
 Indicates whether this value represents a property getter.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.IsOverrideOrExplicitImpl">
<summary>
 Indicates if this value was a member declared &apos;override&apos; or an implementation of an interface slot
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.IsMutable">
<summary>
 Indicates if this value is declared &apos;mutable&apos;
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.IsModuleBinding">
<summary>
 Indicates if this is an F#-defined value in a module, or an extension member, but excluding compiler generated bindings from optimizations
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.IsMemberThisVal">
<summary>
 Indicates if this is a &apos;this&apos; value for a member?
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.IsMemberOrModuleBinding">
<summary>
 Is this a member definition or module definition?
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.IsMember">
<summary>
 Indicates if this is a member
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.IsInstanceMember">
<summary>
 Indicates if this is an F#-defined instance member.

 Note, the value may still be (a) an extension member or (b) type abstract slot without
 a true body. These cases are often causes of bugs in the compiler.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.IsIncrClassGeneratedMember">
<summary>
 Indicates if this is a member generated from the de-sugaring of &apos;let&apos; function bindings in the implicit class syntax?
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.IsIncrClassConstructor">
<summary>
 Indicates if this is a constructor member generated from the de-sugaring of implicit constructor for a class type?
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.IsImplied">
<summary>
 Determines if the values is implied by another construct, e.g. a `IsA` property is implied by the union case for A
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.IsExtensionMember">
<summary>
 Indicates if this is an F#-defined extension member
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.IsDispatchSlot">
<summary>
 Indicates if this member is an F#-defined dispatch slot.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.IsCtorThisVal">
<summary>
 Indicates if this is a &apos;this&apos; value for an implicit ctor?
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.IsConstructor">
<summary>
 Indicates if this is an F#-defined &apos;new&apos; constructor member
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.IsCompilerGenerated">
<summary>
 Indicates whether this value was generated by the compiler.

 Note: this is true for the overrides generated by hash/compare augmentations
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.IsCompiledAsTopLevel">
<summary>
 Is this represented as a &quot;top level&quot; static binding (i.e. a static field, static member,
 instance member), rather than an &quot;inner&quot; binding that may result in a closure.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.IsBaseVal">
<summary>
 Indicates if this is a &apos;base&apos; value?
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.InlineInfo">
<summary>
 Get the inline declaration on the value
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.InlineIfLambda">
<summary>
 Get the inline declaration on a parameter or other non-function-declaration value, used for optimization
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.ImplementedSlotSigs">
<summary>
 Gets the dispatch slots implemented by this method, either 0 or 1
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.GeneralizedType">
<summary>
 Get the type of the value including any generic type parameters
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.DisplayNameCoreMangled">
<summary>
 The display name of the value or method but without operator names decompiled type without backticks etc.

 This is very close to LogicalName except that properties have get_ removed and
 interface implementation methods report the name of the implemented method.

 Note: avoid using this, we would like to remove it. All uses should be code-reviewed and
 gradually eliminated in favour of DisplayName, DisplayNameCore or LogicalName.

 Note: here &quot;Core&quot; means &quot;without added backticks or parens&quot;
 Note: here &quot;Mangled&quot; means &quot;op_Addition&quot;

   - If this is a property                      --&gt; Foo
   - If this is an implementation of an abstract slot then this is the name of the method implemented by the abstract slot
   - If this is an active pattern               --&gt; |A|_|
   - If this is an operator                     --&gt; op_Addition
   - If this is an identifier needing backticks --&gt; A-B
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.DisplayNameCore">
<summary>
 The display name of the value or method with operator names decompiled but without backticks etc.

 Note: here &quot;Core&quot; means &quot;without added backticks or parens&quot;
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.DisplayName">
<summary>
 The full text for the value to show in error messages type to use in code.
 This includes backticks, parens etc.

   - If this is a property                      --&gt; Foo
   - If this is an implementation of an abstract slot then this is the name of the method implemented by the abstract slot
   - If this is an active pattern               --&gt; (|A|_|)
   - If this is an operator                     --&gt; (+)
   - If this is an identifier needing backticks --&gt; ``A-B``
   - If this is a base value  --&gt; base
   - If this is a value named ``base`` --&gt; ``base``
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.Deref">
<summary>
 Dereference the ValRef to a Val.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.DeclaringEntity">
<summary>
 Get the actual parent entity for the value (a module or a type), i.e. the entity under which the
 value will appear in compiled code. For extension members this is the module where the extension member
 is declared.

 This may fail for expression-bound values and parameters.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.CompiledName">
<summary>
 The name of the method in compiled code (with some exceptions where ilxgen.fs decides not to use a method impl)
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.BaseOrThisInfo">
<summary>
 Indicates if this is a &apos;base&apos; or &apos;this&apos; value?
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.Attribs">
<summary>
 Get the declared attributes for the value
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.ApparentEnclosingEntity">
<summary>
 Get the apparent parent entity for the value, i.e. the entity under with which the
 value is associated. For extension members this is the nominal type the member extends.
 For other values it is just the actual parent.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValRef.Accessibility">
<summary>
 Get the value representing the accessibility of an F# type definition or module.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ValRef">
<summary>
 References are either local or nonlocal
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyconRef">
<summary>
 Represents a type definition reference in the typed abstract syntax.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ModuleOrNamespaceRef">
<summary>
 Represents a module-or-namespace reference in the typed abstract syntax.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.nlr">
<summary>
 Indicates a reference to something bound in another CCU
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.binding">
<summary>
 Indicates a reference to something bound in this CCU
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.XmlDocSig">
<summary>
 The XML documentation sig-string of the entity, if any, to use to lookup an .xml doc file. This also acts
 as a cache for this sig-string computation.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.XmlDoc">
<summary>
 The XML documentation of the entity, if any. If the entity is backed by provided metadata
 then this _does_ include this documentation. If the entity is backed by Abstract IL metadata
 or comes from another F# assembly then it does not (because the documentation will get read from
 an XML file).
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.UnionTypeInfo">
<summary>
 Get the union cases type other union-type information for a type, if any
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.UnionCasesAsList">
<summary>
 Get the union cases for a type, if any, as a list
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.UnionCasesArray">
<summary>
 Get the union cases for a type, if any
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.TypeReprInfo">
<summary>
 The information about the r.h.s. of a type definition, if any. For example, the r.h.s. of a union or record type.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.TypeReprAccessibility">
<summary>
 Get the value representing the accessibility of the r.h.s. of an F# type definition.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.TypeOrMeasureKind">
<summary>
 The kind of the type definition - is it a measure definition or a type definition?
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.TypeContents">
<summary>
 The logical contents of the entity when it is a type definition.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.TypeAbbrev">
<summary>
 Indicates if this entity is an F# type abbreviation definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.TyparsNoRange">
<summary>
 Get the type parameters for an entity that is a type declaration, otherwise return the empty list.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.TryIsReadOnly">
<summary>
 The on-demand analysis about whether the entity has the IsReadOnly attribute
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.TryIsByRefLike">
<summary>
 The on-demand analysis about whether the entity has the IsByRefLike attribute
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.TryIsAssumedReadOnly">
<summary>
 The on-demand analysis about whether the entity is assumed to be a readonly struct
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.TryDeref">
<summary>
 Dereference the TyconRef to a Tycon option.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.TrueInstanceFieldsAsList">
<summary>
 Get a list of all instance fields for F#-defined record, struct type class fields in this type definition,
 excluding compiler-generate fields.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.TrueFieldsAsList">
<summary>
 Get a list of all fields for F#-defined record, struct type class fields in this type definition,
 including static fields, but excluding compiler-generate fields.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.Stamp">
<summary>
 A unique stamp for this module, namespace or type definition within the context of this compilation.
 Note that because of signatures, there are situations where in a single compilation the &quot;same&quot;
 module, namespace or type may have two distinct Entity objects that have distinct stamps.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.SigRange">
<summary>
 The signature definition location of the namespace, module or type
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.ResolvedTarget">
<summary>
 The resolved target of the reference
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.Range">
<summary>
 The code location where the module, namespace or type is defined.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.PublicPath">
<summary>
 Get a blob of data indicating how this type is nested in other namespaces, modules or types.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.PreEstablishedHasDefaultConstructor">
<summary>
 Indicates if we have pre-determined that a type definition has a default constructor.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.ModuleOrNamespaceType">
<summary>
 The logical contents of the entity when it is a module or namespace fragment.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.MembersOfFSharpTyconSorted">
<summary>
 Gets the immediate members of an F# type definition, excluding compiler-generated ones.
 Note: result is alphabetically sorted, then for each name the results are in declaration order
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.MembersOfFSharpTyconByName">
<summary>
 Gets all immediate members of an F# type definition keyed by name, including compiler-generated ones.
 Note: result is a indexed table, type for each name the results are in reverse declaration order
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.LogicalName">
<summary>
 The name of the namespace, module or type, possibly with mangling, e.g. List`1, List or FailureException
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsUnionTycon">
<summary>
 Indicate if this is a type whose r.h.s. is known to be a union type definition.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsTypeAbbrev">
<summary>
 Indicates if this entity is an F# type abbreviation definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsStructOrEnumTycon">
<summary>
 Indicates if this is a struct or enum type definition, i.e. a value type definition, including struct records and unions
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsStaticInstantiationTycon">
<summary>
 Indicates if the entity is an erased provided type definition that incorporates a static instantiation (type therefore in some sense compiler generated)
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsResolved">
<summary>
 Indicates if the reference has been resolved
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsRecordTycon">
<summary>
 Indicates if this is an F# type definition whose r.h.s. is known to be a record type definition.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsProvidedNamespace">
<summary>
 Indicates if the entity is a provided namespace fragment
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsProvidedGeneratedTycon">
<summary>
 Indicates if the entity is a generated provided type definition, i.e. not erased.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsProvidedErasedTycon">
<summary>
 Indicates if the entity is an erased provided type definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsProvided">
<summary>
 Indicates if the entity is a provided namespace fragment
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsPrefixDisplay">
<summary>
 Indicates the type prefers the &quot;tycon&lt;a, b&gt;&quot; syntax for display etc.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsNamespace">
<summary>
 Indicates if the entity is a namespace
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsModuleOrNamespace">
<summary>
 Indicates the &quot;tycon blob&quot; is actually a module
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsModule">
<summary>
 Indicates if the entity is an F# module definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsMeasureableReprTycon">
<summary>
 Indicates if this is an F# type definition which is one of the special types in FSharp.Core.dll like &apos;float&lt;_&gt;&apos; which
 defines a measure type with a relation to an existing non-measure type as a representation.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsLocalRef">
<summary>
 Indicates if the reference is a local reference
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsILTycon">
<summary>
 Indicate if this is a type definition backed by Abstract IL metadata.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsILStructOrEnumTycon">
<summary>
 Indicates if this is a .NET-defined struct or enum type definition, i.e. a value type definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsILEnumTycon">
<summary>
 Indicates if this is a .NET-defined enum type definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsHiddenReprTycon">
<summary>
 Indicates if this is an F# type definition whose r.h.s. definition is unknown (i.e. a traditional ML &apos;abstract&apos; type in a signature,
 which in F# is called a &apos;unknown representation&apos; type).
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsFSharpStructOrEnumTycon">
<summary>
 Indicates if this is an F#-defined value type definition, including struct records and unions
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsFSharpObjectModelTycon">
<summary>
 Indicates if this is an F# type definition known to be an F# class, interface, struct,
 delegate or enum. This isn&apos;t generally a particularly useful thing to know,
 it is better to use more specific predicates.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsFSharpInterfaceTycon">
<summary>
 Indicates if this is an F#-defined interface type definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsFSharpException">
<summary>
 Indicates if the entity represents an F# exception declaration.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsFSharpEnumTycon">
<summary>
 Indicates if this is an F#-defined enum type definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsFSharpDelegateTycon">
<summary>
 Indicates if this is an F#-defined delegate type definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsErased">
<summary>
 Indicates if the entity is erased, either a measure definition, or an erased provided type definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsEnumTycon">
<summary>
 Indicates if this is an enum type definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.IsAsmReprTycon">
<summary>
 Indicates if this is an F# type definition which is one of the special types in FSharp.Core.dll which uses
 an assembly-code representation for the type, e.g. the primitive array type constructor.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.ImmediateInterfacesOfFSharpTycon">
<summary>
 Gets the immediate interface definitions of an F# type definition. Further interfaces may be supported through class type interface inheritance.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.ImmediateInterfaceTypesOfFSharpTycon">
<summary>
 Gets the immediate interface types of an F# type definition. Further interfaces may be supported through class type interface inheritance.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.Id">
<summary>
 The identifier at the point of declaration of the type definition.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.ILTyconRawMetadata">
<summary>
 Get the Abstract IL metadata for this type definition, assuming it is backed by Abstract IL metadata.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.ILTyconInfo">
<summary>
 Get the Abstract IL scope, nesting type metadata for this
 type definition, assuming it is backed by Abstract IL metadata.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.HasSelfReferentialConstructor">
<summary>
 Indicates if we have pre-determined that a type definition has a self-referential constructor using &apos;as x&apos;
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.GeneratedHashAndEqualsWithComparerValues">
<summary>
 Gets any implicit hash/equals (with comparer argument) methods added to an F# record, union or struct type definition.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.GeneratedHashAndEqualsValues">
<summary>
 Gets any implicit hash/equals methods added to an F# record, union or struct type definition.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.GeneratedCompareToWithComparerValues">
<summary>
 Gets any implicit CompareTo (with comparer argument) methods added to an F# record, union or struct type definition.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.GeneratedCompareToValues">
<summary>
 Gets any implicit CompareTo methods added to an F# record, union or struct type definition.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.FSharpTyconRepresentationData">
<summary>
 Get the blob of information associated with an F# object-model type definition, i.e. class, interface, struct etc.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.ExceptionInfo">
<summary>
 The information about the r.h.s. of an F# exception definition, if any.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.DisplayNameWithStaticParametersAndUnderscoreTypars">
<summary>
 The display name of the namespace, module or type with &lt;_, _, _&gt; added for generic types, including static parameters

 Backticks are added implicitly for entities with non-identifier names
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.DisplayNameWithStaticParameters">
<summary>
 The display name of the namespace, module or type, e.g. List instead of List`1, including static parameters

 Backticks are added implicitly for entities with non-identifier names
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.DisplayNameCore">
<summary>
 The display name of the namespace, module or type, e.g. List instead of List`1, not including static parameters

 No backticks are added for entities with non-identifier names
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.DisplayName">
<summary>
 The display name of the namespace, module or type, e.g. List instead of List`1, not including static parameters

 Backticks are added implicitly for entities with non-identifier names
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.Deref">
<summary>
 Dereference the TyconRef to a Tycon. Amortize the cost of doing this.
 This path should not allocate in the amortized case
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.DemangledModuleOrNamespaceName">
<summary>
 Demangle the module name, if FSharpModuleWithSuffix is used
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.DefinitionRange">
<summary>
 The implementation definition location of the namespace, module or type
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.CompiledRepresentationForNamedType">
<summary>
 Gets the data indicating the compiled representation of a named type or module in terms of Abstract IL data structures.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.CompiledRepresentation">
<summary>
 Gets the data indicating the compiled representation of a type or module in terms of Abstract IL data structures.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.CompiledReprCache">
<summary>
 Get the cache of the compiled ILTypeRef representation of this module or type.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.CompiledName">
<summary>
 The compiled name of the namespace, module or type, e.g. FSharpList`1, ListModule or FailureException
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.CompilationPathOpt">
<summary>
 Get a blob of data indicating how this type is nested inside other namespaces, modules type types.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.CompilationPath">
<summary>
 Get a blob of data indicating how this type is nested inside other namespaces, modules type types.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.CanDeref">
<summary>
 Is the destination assembly available?
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.Attribs">
<summary>
 The F#-defined custom attributes of the entity, if any. If the entity is backed by Abstract IL or provided metadata
 then this does not include any attributes from those sources.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.AllInstanceFieldsAsList">
<summary>
 Get a list of all instance fields for F#-defined record, struct type class fields in this type definition.
 including hidden fields from the compilation of implicit class constructions.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.AllFieldsAsList">
<summary>
 Get a list of fields for all the F#-defined record, struct type class fields in this type definition, including
 static fields, &apos;val&apos; declarations type hidden fields from the compilation of implicit class constructions.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.AllFieldsArray">
<summary>
 Get an array of fields for all the F#-defined record, struct type class fields in this type definition, including
 static fields, &apos;val&apos; declarations type hidden fields from the compilation of implicit class constructions.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.AllFieldTable">
<summary>
 Get a table of fields for all the F#-defined record, struct type class fields in this type definition, including
 static fields, &apos;val&apos; declarations type hidden fields from the compilation of implicit class constructions.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityRef.Accessibility">
<summary>
 Get the value representing the accessibility of an F# type definition or module.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.EntityRef.Typars(FSharp.Compiler.Text.Range)">
<summary>
 Get the type parameters for an entity that is a type declaration, otherwise return the empty list.

 Lazy because it may read metadata, must provide a context &quot;range&quot; in case error occurs reading metadata.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.EntityRef.SetIsReadOnly(System.Boolean)">
<summary>
 Set the on-demand analysis about whether the entity has the IsReadOnly attribute
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.EntityRef.SetIsByRefLike(System.Boolean)">
<summary>
 Set the on-demand analysis about whether the entity has the IsByRefLike attribute
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.EntityRef.SetIsAssumedReadOnly(System.Boolean)">
<summary>
 Set the on-demand analysis about whether the entity is assumed to be a readonly struct
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.EntityRef.Resolve(System.Boolean)">
<summary>
 Resolve the reference
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.EntityRef.GetUnionCaseByName(System.String)">
<summary>
 Get a union case of a type by name
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.EntityRef.GetFieldByName(System.String)">
<summary>
 Get a field by name.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.EntityRef.GetFieldByIndex(System.Int32)">
<summary>
 Get a field by index in definition order
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.NonLocalEntityRef.Path">
<summary>
 Get the path into the CCU referenced by the nonlocal reference.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.NonLocalEntityRef.LastItemMangledName">
<summary>
 Get the mangled name of the last item in the path of the nonlocal reference.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.NonLocalEntityRef.EnclosingMangledPath">
<summary>
 Get the all-but-last names of the path of the nonlocal reference.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.NonLocalEntityRef.Deref">
<summary>
 Dereference the nonlocal reference, type raise an error if this fails.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.NonLocalEntityRef.Ccu">
<summary>
 Get the CCU referenced by the nonlocal reference.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.NonLocalEntityRef.AssemblyName">
<summary>
 Get the name of the assembly referenced by the nonlocal reference.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.NonLocalEntityRef.TryDerefEntityPathViaProvidedType(FSharp.Compiler.TypedTree.CcuThunk,System.String[],System.Int32,FSharp.Compiler.TypedTree.Entity)">
<summary>
 Try to find the entity corresponding to the given path, using type-providers to link the data
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.NonLocalEntityRef.TryDerefEntityPath(FSharp.Compiler.TypedTree.CcuThunk,System.String[],System.Int32,FSharp.Compiler.TypedTree.Entity)">
<summary>
 Try to find the entity corresponding to the given path in the given CCU
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.NonLocalEntityRef.TryDeref(System.Boolean)">
<summary>
 Try to link a non-local entity reference to an actual entity
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.NonLocalEntityRef">
<summary>
 Represents an index into the namespace/module structure of an assembly
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ValPublicPath">
<summary>
 Represents the path information for a reference to a value or member in another assembly, disassociated
 from any particular reference.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.NonLocalValOrMemberRef.ItemKey">
<summary>
 The name of the value, or the full signature of the member
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.NonLocalValOrMemberRef.EnclosingEntity">
<summary>
 A reference to the entity containing the value or member. This will always be a non-local reference
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.NonLocalValOrMemberRef.DebugText">
<summary>
 For debugging
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.NonLocalValOrMemberRef.Ccu">
<summary>
 Get the thunk for the assembly referred to
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.NonLocalValOrMemberRef.AssemblyName">
<summary>
 Get the name of the assembly referred to
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.NonLocalValOrMemberRef.ToString">
<summary>
 For debugging
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValMemberInfo.IsImplemented">
<summary>
 Gets updated with &apos;true&apos; if an abstract slot is implemented in the file being typechecked. Internal only.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValMemberInfo.ImplementedSlotSigs">
<summary>
 Updated with the full implemented slotsig after interface implementation relation is checked
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValMemberInfo.ApparentEnclosingEntity">
<summary>
 The parent type. For an extension member this is the type being extended
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ValMemberInfo">
<summary>
 Represents the extra information stored for a member
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.val_flags">
<summary>
 See vflags section further below for encoding/decodings here
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.val_stamp">
<summary>
 Mutable for unpickle linkage
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.val_range">
<summary>
 Mutable for unpickle linkage
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.val_logical_name">
<summary>
 Mutable for unpickle linkage
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.XmlDocSig(System.String)">
<summary>
Get the signature for the value&apos;s XML documentation
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.XmlDocSig">
<summary>
Get the signature for the value&apos;s XML documentation
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.XmlDoc">
<summary>
 Get the declared documentation for the value
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.ValReprInfoForDisplay">
<summary>
 Records the &quot;extra information&quot; for display purposes for expression-level function definitions
 that may be compiled as closures (that is are not necessarily compiled as top-level methods).
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.ValReprInfo">
<summary>
 Records the &quot;extra information&quot; for a value compiled as a method.

 This indicates the number of arguments in each position for a curried
 functions, type relates to the F# spec for arity analysis.
 For module-defined values, the currying is based
 on the number of lambdas, type in each position the elements are
 based on attempting to deconstruct the type of the argument as a
 tuple-type.

 The field is mutable because arities for recursive
 values are only inferred after the r.h.s. is analyzed, but the
 value itself is created before the r.h.s. is analyzed.

 TLR also sets this for inner bindings that it wants to
 represent as &quot;top level&quot; bindings.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.Type">
<summary>
 The type of the value.
 May be a TType_forall for a generic value.
 May be a type variable or type containing type variables during type inference.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.Typars">
<summary>
 Get the generic type parameters for the value
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.TryDeclaringEntity">
<summary>
 The parent type or module, if any (None for expression bindings type parameters)
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.TauType">
<summary>
 Get the type of the value after removing any generic type parameters
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.Stamp">
<summary>
 A unique stamp within the context of this invocation of the compiler process
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.SigRange">
<summary>
 Range of the definition (signature) of the value, used by Visual Studio
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.ShouldInline">
<summary>
 Indicates whether the inline declaration for the value indicates that the value should be inlined.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.ReflectedDefinition">
<summary>
 The quotation expression associated with a value given the [&lt;ReflectedDefinition&gt;] tag
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.RecursiveValInfo">
<summary>
 Get the information about the value used during type inference
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.Range">
<summary>
 The place where the value was defined.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.PublicPath">
<summary>
 Get the public path to the value, if any? Should be set if type only if
 IsMemberOrModuleBinding is set.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.PropertyName">
<summary>
 The name of the property.
 - If this is a property then this is &apos;Foo&apos;
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.PermitsExplicitTypeInstantiation">
<summary>
 Indicates if this value allows the use of an explicit type instantiation (i.e. does it itself have explicit type arguments,
 or does it have a signature?)
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.NumObjArgs">
<summary>
 Get the number of &apos;this&apos;/&apos;self&apos; object arguments for the member. Instance extension members return &apos;1&apos;.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.MemberInfo">
<summary>
 Is this a member, if so some more data about the member.

 Note, the value may still be (a) an extension member or (b) type abstract slot without
 a true body. These cases are often causes of bugs in the compiler.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.MemberApparentEntity">
<summary>
 Get the apparent parent entity for a member
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.MakesNoCriticalTailcalls">
<summary>
 Indicates if this is inferred to be a method or function that definitely makes no critical tailcalls?
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.LogicalName">
<summary>
 The name of the method.
   - If this is a property then this is &apos;get_Foo&apos; or &apos;set_Foo&apos;
   - If this is an implementation of an abstract slot then this is the name of the method implemented by the abstract slot
   - If this is an extension member then this will be the simple name
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.LiteralValue">
<summary>
 The value of a value or member marked with [&lt;LiteralAttribute&gt;]
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.IsOverrideOrExplicitImpl">
<summary>
 Indicates if this value was a member declared &apos;override&apos; or an implementation of an interface slot
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.IsMutable">
<summary>
 Indicates if this is declared &apos;mutable&apos;
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.IsModuleBinding">
<summary>
 Indicates if this is an F#-defined value in a module, or an extension member, but excluding compiler generated bindings from optimizations
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.IsMemberThisVal">
<summary>
 Indicates if this is a &apos;this&apos; value for a member?
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.IsMemberOrModuleBinding">
<summary>
 Is this a member definition or module definition?
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.IsMember">
<summary>
 Indicates if this is a member
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.IsLinked">
<summary>
 Indicates if a value is linked to backing data yet. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.IsIntrinsicMember">
<summary>
 Indicates if this is a member, excluding extension members
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.IsInstanceMember">
<summary>
 Indicates if this is an F#-defined instance member.

 Note, the value may still be (a) an extension member or (b) type abstract slot without
 a true body. These cases are often causes of bugs in the compiler.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.IsIncrClassGeneratedMember">
<summary>
 Indicates if this is a member generated from the de-sugaring of &apos;let&apos; function bindings in the implicit class syntax?
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.IsIncrClassConstructor">
<summary>
 Indicates if this is a constructor member generated from the de-sugaring of implicit constructor for a class type?
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.IsImplied">
<summary>
 Determines if the values is implied by another construct, e.g. a `IsA` property is implied by the union case for A
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.IsFixed">
<summary>
 Indicates if the value is pinned/fixed
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.IsExtensionMember">
<summary>
 Indicates if this is an F#-defined extension member
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.IsDispatchSlot">
<summary>
 Indicates if this member is an F#-defined dispatch slot.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.IsCtorThisVal">
<summary>
 Indicates if this is a &apos;this&apos; value for an implicit ctor?
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.IsConstructor">
<summary>
 Indicates if this is an F#-defined &apos;new&apos; constructor member
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.IsCompilerGenerated">
<summary>
 Indicates whether this value was generated by the compiler.

 Note: this is true for the overrides generated by hash/compare augmentations
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.IsCompiledIntoModule">
<summary>
 Indicates if this is something compiled into a module, i.e. a user-defined value, an extension member or a compiler-generated value
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.IsCompiledAsTopLevel">
<summary>
 Is this represented as a &quot;top level&quot; static binding (i.e. a static field, static member,
 instance member), rather than an &quot;inner&quot; binding that may result in a closure.

 This is implied by IsMemberOrModuleBinding, however not vice versa, for two reasons.
 Some optimizations mutate this value when they decide to change the representation of a
 binding to be IsCompiledAsTopLevel. Second, even immediately after type checking we expect
 some non-module, non-member bindings to be marked IsCompiledAsTopLevel, e.g. &apos;y&apos; in
 &apos;let x = let y = 1 in y + y&apos; (NOTE: check this, don&apos;t take it as gospel)
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.IsCompiledAsStaticPropertyWithoutField">
<summary>
 Indicates if the backing field for a static value is suppressed.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.IsClassConstructor">
<summary>
 Indicates if this is a compiler-generated class constructor member
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.IsBaseVal">
<summary>
 Indicates if this is a &apos;base&apos; value?
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.InlineInfo">
<summary>
 Get the inline declaration on the value
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.InlineIfLambda">
<summary>
 Get the inline declaration on a parameter or other non-function-declaration value, used for optimization
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.ImplementedSlotSigs">
<summary>
 Gets the dispatch slots implemented by this method
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.IgnoresByrefScope">
<summary>
 Indicates if the value will ignore byref scoping rules
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.HasSignatureFile">
<summary>
 Indicates if the value has a signature file counterpart
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.HasBeenReferenced">
<summary>
 Indicates if this is ever referenced?
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.GetterOrSetterIsCompilerGenerated">
<summary>
 Indicates that this value&apos;s getter or setter are generated by the compiler
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.GeneralizedType">
<summary>
 Get the type of the value including any generic type parameters
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.DisplayNameCoreMangled">
<summary>
 The display name of the value or method but without operator names decompiled type without backticks etc.

 This is very close to LogicalName except that properties have get_ removed and
 interface implementation methods report the name of the implemented method.

 Note: avoid using this, we would like to remove it. All uses should be code-reviewed and
 gradually eliminated in favour of DisplayName, DisplayNameCore or LogicalName.

 Note: here &quot;Core&quot; means &quot;without added backticks or parens&quot;
 Note: here &quot;Mangled&quot; means &quot;op_Addition&quot;

   - If this is a property                      --&gt; Foo
   - If this is an implementation of an abstract slot then this is the name of the method implemented by the abstract slot
   - If this is an active pattern               --&gt; |A|_|
   - If this is an operator                     --&gt; op_Addition
   - If this is an identifier needing backticks --&gt; A-B
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.DisplayNameCore">
<summary>
 The display name of the value or method with operator names decompiled but without backticks etc.

 Note: here &quot;Core&quot; means &quot;without added backticks or parens&quot;
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.DisplayName">
<summary>
 The full text for the value to show in error messages type to use in code.
 This includes backticks, parens etc.

   - If this is a property                      --&gt; Foo
   - If this is an implementation of an abstract slot then this is the name of the method implemented by the abstract slot
   - If this is an active pattern               --&gt; (|A|_|)
   - If this is an operator                     --&gt; (+)
   - If this is an identifier needing backticks --&gt; ``A-B``
   - If this is a base value  --&gt; base
   - If this is a value named ``base`` --&gt; ``base``
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.DefinitionRange">
<summary>
 Range of the definition (implementation) of the value, used by Visual Studio
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.DeclaringEntity">
<summary>
 Get the actual parent entity for the value (a module or a type), i.e. the entity under which the
 value will appear in compiled code. For extension members this is the module where the extension member
 is declared.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.BaseOrThisInfo">
<summary>
 Indicates if this is a &apos;base&apos; or &apos;this&apos; value?
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.Attribs">
<summary>
 Get the declared attributes for the value
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.ArgReprInfoForDisplay">
<summary>
 Records the &quot;extra information&quot; for parameters in implementation files if we&apos;ve been able to correlate
 them with lambda arguments.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.ApparentEnclosingEntity">
<summary>
 Get the apparent parent entity for the value, i.e. the entity under with which the
 value is associated. For extension members this is the nominal type the member extends.
 For other values it is just the actual parent.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Val.Accessibility">
<summary>
 How visible is this value, function or member?
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Val.SetData(FSharp.Compiler.TypedTree.Val)">
<summary>
 Set all the data on a value
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Val.NewUnlinked">
<summary>
 Create a new value with empty, unlinked data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Val.New(FSharp.Compiler.TypedTree.Val)">
<summary>
 Create a new value with the given backing data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Val.Link(FSharp.Compiler.TypedTree.Val)">
<summary>
 Link a value based on empty, unlinked data to the given data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Val.GetLinkagePartialKey">
<summary>
 The partial information used to index the methods of all those in a ModuleOrNamespace.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Val.GetLinkageFullKey">
<summary>
 The full information used to identify a specific overloaded method amongst all those in a ModuleOrNamespace.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Val.CompiledName(Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.CompilerGlobalState.CompilerGlobalState})">
<summary>
 The name of the method in compiled code (with some exceptions where ilxgen.fs decides not to use a method impl)
   - If this is a property then this is &apos;get_Foo&apos; or &apos;set_Foo&apos;
   - If this is an implementation of an abstract slot then this may be a mangled name
   - If this is an extension member then this will be a mangled name
   - If this is an operator then this is &apos;op_Addition&apos;
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValOptionalData.val_attribs">
<summary>
 Custom attributes attached to the value. These contain references to other values (i.e. constructors in types). Mutable to fixup
 these value references after copying a collection of values.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValOptionalData.val_xmldocsig">
<summary>
 XML documentation signature for the value
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValOptionalData.val_member_info">
<summary>
 Is the value actually an instance method/property/event that augments
 a type, type if so what name does it take in the IL?
 MUTABILITY: for unpickle linkage
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValOptionalData.val_other_xmldoc">
<summary>
 the signature xml doc for an item in an implementation file.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValOptionalData.val_xmldoc">
<summary>
 XML documentation attached to a value.
 MUTABILITY: for unpickle linkage
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValOptionalData.val_access">
<summary>
 How visible is this?
 MUTABILITY: for unpickle linkage
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValOptionalData.arg_repr_info_for_display">
<summary>
 Records the &quot;extra information&quot; for parameters in implementation files if we&apos;ve been able to correlate
 them with lambda arguments.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValOptionalData.val_repr_info_for_display">
<summary>
 Records the &quot;extra information&quot; for display purposes for expression-level function definitions
 that may be compiled as closures (that is are not necessarily compiled as top-level methods).
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValOptionalData.val_repr_info">
<summary>
 Records the &quot;extra information&quot; for a value compiled as a method (rather
 than a closure or a local), including argument names, attributes etc.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValOptionalData.val_defn">
<summary>
 What is the original, unoptimized, closed-term definition, if any?
 Used to implement [&lt;ReflectedDefinition&gt;]
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValOptionalData.val_other_range">
<summary>
 If this field is populated, this is the implementation range for an item in a signature, otherwise it is
 the signature range for an item in an implementation
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValOptionalData.val_compiled_name">
<summary>
 MUTABILITY: for unpickle linkage
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValLinkageFullKey.TypeForLinkage">
<summary>
 The full type of the value for the purposes of linking. May be None for non-members, since they can&apos;t be overloaded.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValLinkageFullKey.PartialKey">
<summary>
 The partial information used to index the value in a ModuleOrNamespace.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ValLinkageFullKey">
<summary>
 The full information used to identify a specific overloaded method
 amongst all those in a ModuleOrNamespace.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValLinkagePartialKey.TotalArgCount">
<summary>
 Indicates the total argument count of the member.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValLinkagePartialKey.LogicalName">
<summary>
 Indicates the logical name of the member.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValLinkagePartialKey.MemberIsOverride">
<summary>
 Indicates if the member is an override.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValLinkagePartialKey.MemberParentMangledName">
<summary>
 The name of the type with which the member is associated. None for non-member values.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ValLinkagePartialKey">
<summary>
 The partial information used to index the methods of all those in a ModuleOrNamespace.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TraitConstraintSln.BuiltInSln">
<summary>
 Indicates a trait is solved by a &apos;fake&apos; instance of an operator, like &apos;+&apos; on integers
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TraitConstraintSln.ClosedExprSln">
<summary>
 ClosedExprSln expr

 Indicates a trait is solved by an erased provided expression
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TraitConstraintSln.ILMethSln">
<summary>
 ILMethSln(ty, extOpt, ilMethodRef, minst)

 Indicates a trait is solved by a .NET method.
    ty -- the type type its instantiation
    extOpt -- information about an extension member, if any
    ilMethodRef -- the method that solves the trait constraint
    minst -- the generic method instantiation
    staticTyOpt -- the static type governing a static virtual call, if any
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TraitConstraintSln.FSAnonRecdFieldSln">
<summary>
 Indicates a trait is solved by an F# anonymous record field.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TraitConstraintSln.FSRecdFieldSln">
<summary>
 FSRecdFieldSln(tinst, rfref, isSetProp)

 Indicates a trait is solved by an F# record field.
    tinst -- the instantiation of the declaring type
    rfref -- the reference to the record field
    isSetProp -- indicates if this is a set of a record field
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TraitConstraintSln.FSMethSln">
<summary>
 FSMethSln(ty, vref, minst)

 Indicates a trait is solved by an F# method.
    ty -- the type type its instantiation
    vref -- the method that solves the trait constraint
    staticTyOpt -- the static type governing a static virtual call, if any
    minst -- the generic method instantiation
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TraitConstraintSln">
<summary>
 Represents the solution of a member constraint during inference.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TraitConstraintInfo.TTrait">
<summary>
 Indicates the signature of a member constraint. Contains a mutable solution cell
 to store the inferred solution of the constraint. And a mutable source cell to store
 the name of the type or member that defined the constraint.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TraitConstraintInfo.Solution(Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.TraitConstraintSln})">
<summary>
 Get or set the solution of the member constraint during inference
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TraitConstraintInfo.SupportTypes">
<summary>
 Get the types that may provide solutions for the traits
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TraitConstraintInfo.Solution">
<summary>
 Get or set the solution of the member constraint during inference
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TraitConstraintInfo.MemberLogicalName">
<summary>
 Get the member name associated with the member constraint.  For preop
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TraitConstraintInfo.MemberFlags">
<summary>
 Get the member flags associated with the member constraint.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TraitConstraintInfo.CompiledReturnType">
<summary>
 Get the return type recorded in the member constraint.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TraitConstraintInfo.CompiledObjectAndArgumentTypes">
<summary>
 Get the raw object and argument types recorded in the member constraint. This includes the object instance type
 instance members. This may be empty for property traits e.g.
      &quot;(static member Zero: ^T)&quot;
 or unit-taking methods
      &quot;(static member get_Zero: unit -&gt; ^T)&quot;
 See also extension members GetCompiledArgumentTypes and GetLogicalArgumentTypes
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.TraitConstraintInfo.WithMemberKind(FSharp.Compiler.Syntax.SynMemberKind)">
<summary>
 The member kind is irrelevant to the logical properties of a trait. However it adjusts
 the extension property MemberDisplayNameCore
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TraitConstraintInfo">
<summary>
 The specification of a member constraint that must be solved
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TraitWitnessInfo.ReturnType">
<summary>
 Get the return type recorded in the member constraint.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TraitWitnessInfo.MemberName">
<summary>
 Get the member name associated with the member constraint.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparConstraint.AllowsRefStruct">
<summary>
 An anti-constraint indicating that ref structs (e.g. Span&lt;&gt;) are allowed here
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparConstraint.IsUnmanaged">
<summary>
 A constraint that a type is .NET unmanaged type
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparConstraint.IsDelegate">
<summary>
 A constraint that a type is a delegate from the given tuple of args to the given return type
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparConstraint.SupportsEquality">
<summary>
 A constraint that a type does not have the Equality(false) attribute, or is not a structural type with this attribute, with special rules for some known structural container types
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparConstraint.SupportsComparison">
<summary>
 A constraint that a type implements IComparable, with special rules for some known structural container types
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparConstraint.IsEnum">
<summary>
 A constraint that a type is an enum with the given underlying
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparConstraint.RequiresDefaultConstructor">
<summary>
 A constraint that a type has a parameterless constructor
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparConstraint.SimpleChoice">
<summary>
 A constraint that a type is a simple choice between one of the given ground types. Only arises from &apos;printf&apos; format strings. See format.fs
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparConstraint.IsReferenceType">
<summary>
 A constraint that a type is a reference type
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparConstraint.IsNonNullableStruct">
<summary>
 A constraint that a type is a non-Nullable value type
 These are part of .NET&apos;s model of generic constraints, type in order to
 generate verifiable code we must attach them to F# generalized type variables as well.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparConstraint.MayResolveMember">
<summary>
 A constraint that a type has a member with the given signature
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparConstraint.NotSupportsNull">
<summary>
 A constraint that a type doesn&apos;t support nullness
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparConstraint.SupportsNull">
<summary>
 A constraint that a type has a &apos;null&apos; value
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparConstraint.DefaultsTo">
<summary>
 A constraint for a default value for an inference type variable should it be neither generalized nor solved
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparConstraint.CoercesTo">
<summary>
 A constraint that a type is a subtype of the given type
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparConstraint">
<summary>
 Represents a constraint on a type parameter or type
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.typar_opt_data">
<summary>
 The optional data for the type parameter
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.typar_astype">
<summary>
 A cached TAST type used when this type variable is used as type.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.typar_solution">
<summary>
 An inferred equivalence for a type inference variable.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.typar_stamp">
<summary>
 The unique stamp of the type parameter
 MUTABILITY: for linking when unpickling
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.typar_flags">
<summary>
 The flag data for the type parameter
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.typar_id">
<summary>
 MUTABILITY: we set the names of generalized inference type parameters to make the look nice for IL code generation
 The identifier for the type parameter
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.XmlDoc">
<summary>
 Get the XML documentation for the type parameter
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.StaticReq">
<summary>
 Indicates if the type variable has a static &quot;head type&quot; requirement, i.e. ^a variables used in FSharp.Core type member constraints.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.Stamp">
<summary>
 The unique stamp of the type parameter
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.Solution">
<summary>
 The inferred equivalence for the type inference variable, if any.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.Rigidity">
<summary>
 Indicates if the type variable can be solved or given new constraints. The status of a type variable
 generally always evolves towards being either rigid or solved.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.Range">
<summary>
 The range of the identifier for the type parameter definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.Name">
<summary>
 The name of the type parameter
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.Kind">
<summary>
 Indicates whether a type variable can be instantiated by types or units-of-measure.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.IsSolved">
<summary>
 Indicates if a type variable has been solved.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.IsLinked">
<summary>
 Indicates if a type variable has been linked. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.IsFromError">
<summary>
 Indicates if the type inference variable was generated after an error when type checking expressions or patterns
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.IsErased">
<summary>
 Indicates whether a type variable is erased in compiled .NET IL code, i.e. whether it is a unit-of-measure variable
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.IsCompilerGenerated">
<summary>
 Indicates if the type variable is compiler generated, i.e. is an implicit type inference variable
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.IsCompatFlex">
<summary>
 Indicates that whether this type parameter is a compat-flex type parameter (i.e. where &quot;expr :&gt; tp&quot; only emits an optional warning)
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.Id">
<summary>
 The identifier for a type parameter definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.ILName">
<summary>
 Get the IL name of the type parameter
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.EqualityConditionalOn">
<summary>
 Indicates that whether or not a generic type definition satisfies the equality constraint is dependent on whether this type variable satisfies the equality constraint.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.DynamicReq">
<summary>
 Indicates if a type parameter is needed at runtime type may not be eliminated
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.DisplayName">
<summary>
 Indicates the display name of a type variable
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.Constraints">
<summary>
 The inferred constraints for the type inference variable, if any
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.ComparisonConditionalOn">
<summary>
 Indicates that whether or not a generic type definition satisfies the comparison constraint is dependent on whether this type variable satisfies the comparison constraint.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Typar.Attribs">
<summary>
 The declared attributes of the type parameter. Empty for type inference variables type parameters from .NET.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Typar.SetSupportsNullFlex(System.Boolean)">
<summary>
 Set whether this type parameter is flexible for &apos;supports null&apos; constraint, e.g. in the case of assignment to a mutable value
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Typar.SetStaticReq(FSharp.Compiler.Syntax.TyparStaticReq)">
<summary>
 Sets whether a type variable has a static requirement
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Typar.SetRigidity(FSharp.Compiler.TypedTree.TyparRigidity)">
<summary>
 Sets the rigidity of a type variable
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Typar.SetIsCompatFlex(System.Boolean)">
<summary>
 Set whether this type parameter is a compat-flex type parameter (i.e. where &quot;expr :&gt; tp&quot; only emits an optional warning)
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Typar.SetIdent(FSharp.Compiler.Syntax.Ident)">
<summary>
 Sets the identifier associated with a type variable
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Typar.SetILName(Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Set the IL name of the type parameter
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Typar.SetEqualityDependsOn(System.Boolean)">
<summary>
 Sets whether the equality constraint of a type definition depends on this type variable
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Typar.SetDynamicReq(FSharp.Compiler.TypedTree.TyparDynamicReq)">
<summary>
 Sets whether a type variable is required at runtime
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Typar.SetConstraints(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TyparConstraint})">
<summary>
 Adjusts the constraints associated with a type variable
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Typar.SetCompilerGenerated(System.Boolean)">
<summary>
 Sets whether a type variable is compiler generated
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Typar.SetComparisonDependsOn(System.Boolean)">
<summary>
 Sets whether the comparison constraint of a type definition depends on this type variable
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Typar.SetAttribs(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Attrib})">
<summary>
 Set the attributes on the type parameter
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Typar.NewUnlinked">
<summary>
 Creates a type variable that contains empty data, type is not yet linked. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Typar.New(FSharp.Compiler.TypedTree.Typar)">
<summary>
 Creates a type variable based on the given data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Typar.MarkAsContravariant">
<summary>
 Marks the typar as being contravariant
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Typar.Link(FSharp.Compiler.TypedTree.Typar)">
<summary>
 Links a previously unlinked type variable to the given data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Typar.AsType(FSharp.Compiler.TypedTree.Nullness)">
<summary>
 Links a previously unlinked type variable to the given data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Typar">
<summary>
 A declared generic type/measure parameter, or a type/measure inference variable.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyparOptionalData.typar_is_contravariant">
<summary>
 Set to true if the typar is contravariant, i.e. declared as &lt;in T&gt; in C#
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyparOptionalData.typar_attribs">
<summary>
 The declared attributes of the type parameter. Empty for type inference variables.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyparOptionalData.typar_constraints">
<summary>
 The inferred constraints for the type parameter or inference variable.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyparOptionalData.typar_xmldoc">
<summary>
 The documentation for the type parameter. Empty for inference variables.
 MUTABILITY: for linking when unpickling
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyparOptionalData.typar_il_name">
<summary>
 MUTABILITY: we set the names of generalized inference type parameters to make the look nice for IL code generation
 The storage for the IL name for the type parameter.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparOptionalData">
<summary>
 Represents less-frequently-required data about a type parameter of type inference variable
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Accessibility.TAccess">
<summary>
 Indicates the construct can only be accessed from any code in the given type constructor, module or assembly. [] indicates global scope.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Accessibility.ToString">
<summary>
 Readable rendering of Accessibility
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Accessibility">
<summary>
 Represents the constraint on access for a construct
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Tycon">
<summary>
 Represents a type or exception definition in the typed AST
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ModuleOrNamespace">
<summary>
 Represents a module or namespace definition in the typed AST
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ModuleOrNamespaceType.TypesByDemangledNameAndArity">
<summary>
 Get a table of types defined within this module, namespace or type. The
 table is indexed by both name type generic arity. This means that for generic
 types &quot;List`1&quot;, the entry (List, 1) will be present.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ModuleOrNamespaceType.TypesByAccessNames">
<summary>
 Get a table of types defined within this module, namespace or type. The
 table is indexed by both name and, for generic types, also by mangled name.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ModuleOrNamespaceType.TypeDefinitions">
<summary>
 Get a list of types defined within this module, namespace or type.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ModuleOrNamespaceType.TypeAndExceptionDefinitions">
<summary>
 Get a list of type type exception definitions defined within this module, namespace or type.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ModuleOrNamespaceType.ModulesAndNamespacesByDemangledName">
<summary>
 Get a table of nested module type namespace fragments indexed by demangled name (so &apos;ListModule&apos; becomes &apos;List&apos;)
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ModuleOrNamespaceType.ModuleOrNamespaceKind">
<summary>
 Namespace or module-compiled-as-type?
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ModuleOrNamespaceType.ModuleAndNamespaceDefinitions">
<summary>
 Get a list of module type namespace definitions defined within this module, namespace or type.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ModuleOrNamespaceType.ExceptionDefinitionsByDemangledName">
<summary>
 Get a table of F# exception definitions indexed by demangled name, so &apos;FailureException&apos; is indexed by &apos;Failure&apos;
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ModuleOrNamespaceType.ExceptionDefinitions">
<summary>
 Get a list of F# exception definitions defined within this module, namespace or type.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ModuleOrNamespaceType.AllValsByLogicalName">
<summary>
 Get a table of values indexed by logical name
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ModuleOrNamespaceType.AllValsAndMembersByPartialLinkageKey">
<summary>
 Get a table of values type members indexed by partial linkage key, which includes name, the mangled name of the parent type (if any),
 type the method argument count (if any).
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ModuleOrNamespaceType.AllValsAndMembersByLogicalNameUncached">
<summary>
 Compute a table of values type members indexed by logical name.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ModuleOrNamespaceType.AllValsAndMembers">
<summary>
 Values, including members in F# types in this module-or-namespace-fragment.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ModuleOrNamespaceType.AllEntitiesByLogicalMangledName">
<summary>
 Get a table of entities indexed by both logical name
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ModuleOrNamespaceType.AllEntitiesByCompiledAndLogicalMangledNames">
<summary>
 Get a table of entities indexed by both logical type compiled names
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ModuleOrNamespaceType.AllEntities">
<summary>
 Type, mapping mangled name to Tycon, e.g.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ModuleOrNamespaceType.ActivePatternElemRefLookupTable">
<summary>
 Get a table of the active patterns defined in this module.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.ModuleOrNamespaceType.TryLinkVal(FSharp.Compiler.TypedTree.CcuThunk,FSharp.Compiler.TypedTree.ValLinkageFullKey)">
<summary>
 Try to find the member with the given linkage key in the given module.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.ModuleOrNamespaceType.AddVal(FSharp.Compiler.TypedTree.Val)">
<summary>
 Return a new module or namespace type with a value added.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.ModuleOrNamespaceType.AddProvidedTypeEntity(FSharp.Compiler.TypedTree.Entity)">
<summary>
 Mutation used in hosting scenarios to hold the hosted types in this module or namespace
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.ModuleOrNamespaceType.AddModuleOrNamespaceByMutation(FSharp.Compiler.TypedTree.Entity)">
<summary>
 Mutation used during compilation of FSharp.Core.dll
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.ModuleOrNamespaceType.AddEntity(FSharp.Compiler.TypedTree.Entity)">
<summary>
 Return a new module or namespace type with an entity added.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ModuleOrNamespaceType">
<summary>
 Represents the contents of of a module of namespace
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ExceptionInfo.TExnNone">
<summary>
 Indicates that an exception is abstract, i.e. is in a signature file, type we do not know the representation
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ExceptionInfo.TExnFresh">
<summary>
 Indicates that an exception carries the given record of values
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ExceptionInfo.TExnAsmRepr">
<summary>
 Indicates that an exception is shorthand for the given .NET exception type
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ExceptionInfo.TExnAbbrevRepr">
<summary>
 Indicates that an exception is an abbreviation for the given exception
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ExceptionInfo">
<summary>
 Represents the implementation of an F# exception definition.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.rfield_other_range">
<summary>
 If this field is populated, this is the implementation range for an item in a signature, otherwise it is
 the signature range for an item in an implementation
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.rfield_id">
<summary>
 Name/declaration-location of the field
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.rfield_fattribs">
<summary>
 Attributes attached to generated field
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.rfield_pattribs">
<summary>
 Attributes attached to generated property
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.rfield_access">
<summary>
  Indicates the declared visibility of the field, not taking signatures into account
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.rfield_const">
<summary>
 The default initialization info, for static literals
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.rfield_secret">
<summary>
 Indicates a compiler generated field, not visible to Intellisense or name resolution
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.rfield_volatile">
<summary>
 Indicates a volatile field
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.rfield_static">
<summary>
 Indicates a static field
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.rfield_type">
<summary>
 The type of the field, w.r.t. the generic parameters of the enclosing type constructor
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.rfield_xmldocsig">
<summary>
 XML Documentation signature for the field
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.rfield_otherxmldoc">
<summary>
 Documentation for the field from signature file
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.rfield_xmldoc">
<summary>
 Documentation for the field
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.rfield_mutable">
<summary>
 Is the field declared mutable in F#?
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.XmlDocSig(System.String)">
<summary>
 Get or set the XML documentation signature for the field
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.XmlDocSig">
<summary>
 Get or set the XML documentation signature for the field
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.XmlDoc">
<summary>
 XML Documentation signature for the field
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.SigRange">
<summary>
 Get the signature location of the field
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.Range">
<summary>
 Get the declaration location of the field
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.PropertyAttribs">
<summary>
 Attributes attached to generated property
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.LogicalName">
<summary>
 Name of the field
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.LiteralValue">
<summary>
 The default initialization info, for static literals
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.IsZeroInit">
<summary>
 Indicates if the field is zero-initialized
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.IsVolatile">
<summary>
 Indicates a volatile field
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.IsStatic">
<summary>
 Indicates a static field
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.IsMutable">
<summary>
 Is the field declared mutable in F#?
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.IsCompilerGenerated">
<summary>
 Indicates a compiler generated field, not visible to Intellisense or name resolution
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.Id">
<summary>
 Name/declaration-location of the field
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.FormalType">
<summary>
 The type of the field, w.r.t. the generic parameters of the enclosing type constructor
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.FieldAttribs">
<summary>
 Attributes attached to generated field
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.DisplayNameCore">
<summary>
 Name of the field. For fields this is the same as the logical name.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.DisplayName">
<summary>
 Name of the field
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.DefinitionRange">
<summary>
 Get the definition location of the field
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.RecdField.Accessibility">
<summary>
  Indicates the declared visibility of the field, not taking signatures into account
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.RecdField">
<summary>
 Represents a class, struct, record or exception field in an F# type, exception or union-case definition.
 This may represent a &quot;field&quot; in either a struct, class, record or union.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCase.Attribs">
<summary>
 Attributes, attached to the generated static method to make instances of the case
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCase.Accessibility">
<summary>
  Indicates the declared visibility of the union constructor, not taking signatures into account
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCase.OtherRangeOpt">
<summary>
 If this field is populated, this is the implementation range for an item in a signature, otherwise it is
 the signature range for an item in an implementation
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCase.Id">
<summary>
 Name/range of the case
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCase.XmlDocSig">
<summary>
 XML documentation signature for the case
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCase.OtherXmlDoc">
<summary>
 Documentation for the case from signature file
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCase.OwnXmlDoc">
<summary>
 Documentation for the case
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCase.ReturnType">
<summary>
 Return type constructed by the case. Normally exactly the type of the enclosing type, sometimes an abbreviation of it
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCase.FieldTable">
<summary>
 Data carried by the case.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCase.SigRange">
<summary>
 Get the signature location of the union case
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCase.RecdFieldsArray">
<summary>
 Get the full array of fields of the union case
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCase.RecdFields">
<summary>
 Get the full list of fields of the union case
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCase.Range">
<summary>
 Get the declaration location of the union case
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCase.LogicalName">
<summary>
 Get the logical name of the union case
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCase.IsNullary">
<summary>
 Indicates if the union case has no fields
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCase.DisplayNameCore">
<summary>
 Get the core of the display name of the union case

 Backticks and parens are not added for non-identifiers.

 Note logical names op_Nil type op_ColonColon become [] and :: respectively.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCase.DisplayName">
<summary>
 Get the display name of the union case

 Backticks are added for non-identifiers.

 Note logical names op_Nil and op_ColonColon become ([]) and (::) respectively.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCase.DefinitionRange">
<summary>
 Get the definition location of the union case
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.UnionCase.CompiledName">
<summary>
 Get the name of the case in generated IL code.
 Note logical names `op_Nil` type `op_ColonColon` become `Empty` type `Cons` respectively.
 This is because this is how ILX union code gen expects to see them.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.UnionCase.GetFieldByName(System.String)">
<summary>
 Get a field of the union case by name
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.UnionCase.GetFieldByIndex(System.Int32)">
<summary>
 Get a field of the union case by position
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.UnionCase">
<summary>
 Represents a union case in an F# type definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyconUnionData.CompiledRepresentation">
<summary>
 The ILX data structure representing the discriminated union.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyconUnionData.CasesTable">
<summary>
 The cases contained in the discriminated union.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyconUnionData.UnionCasesAsList">
<summary>
 Get the union cases as a list
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyconUnionData">
<summary>
 Represents the union cases type related information in an F# type definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyconUnionCases.CasesByName">
<summary>
 The cases of the discriminated union, indexed by name.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyconUnionCases.CasesByIndex">
<summary>
 The cases of the discriminated union, in declaration order.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyconUnionCases.UnionCasesAsList">
<summary>
 Get the union cases as a list
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.TyconUnionCases.GetUnionCaseByIndex(System.Int32)">
<summary>
 Get a union case by index
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyconUnionCases">
<summary>
 Represents union cases in an F# type definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyconRecdFields.FieldsByName">
<summary>
 The fields of the record, indexed by name.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyconRecdFields.FieldsByIndex">
<summary>
 The fields of the record, in declaration order.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyconRecdFields.TrueInstanceFieldsAsList">
<summary>
 Get all non-compiler-generated instance fields as a list
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyconRecdFields.TrueFieldsAsList">
<summary>
 Get all non-compiler-generated fields as a list
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyconRecdFields.AllFieldsAsList">
<summary>
 Get all the fields as a list
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.TyconRecdFields.FieldByName(System.String)">
<summary>
 Get a field by name
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.TyconRecdFields.FieldByIndex(System.Int32)">
<summary>
 Get a field by index
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyconRecdFields">
<summary>
 Represents record fields in an F# type definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.FSharpTyconData.fsobjmodel_rfields">
<summary>
 The fields of the class, struct or enum
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.FSharpTyconData.fsobjmodel_vslots">
<summary>
 The declared abstract slots of the class, interface or struct
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.FSharpTyconData.fsobjmodel_kind">
<summary>
 Indicates whether the type declaration is an F# class, interface, enum, delegate or struct
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.FSharpTyconData.fsobjmodel_cases">
<summary>
 Indicates the cases of a union type
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.FSharpTyconData">
<summary>
 Represents member values type class fields relating to the F# object model
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.FSharpTyconKind.TFSharpEnum">
<summary>
 Indicates the type is an F#-declared enumeration
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.FSharpTyconKind.TFSharpDelegate">
<summary>
 Indicates the type is an F#-declared delegate with the given Invoke signature
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.FSharpTyconKind.TFSharpStruct">
<summary>
 Indicates the type is an F#-declared struct
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.FSharpTyconKind.TFSharpInterface">
<summary>
 Indicates the type is an F#-declared interface
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.FSharpTyconKind.TFSharpClass">
<summary>
 Indicates the type is an F#-declared class (also used for units-of-measure)
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.FSharpTyconKind.TFSharpUnion">
<summary>
 Indicates the type is an F#-declared union
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.FSharpTyconKind.TFSharpRecord">
<summary>
 Indicates the type is an F#-declared record
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TProvidedTypeInfo.IsSuppressRelocate">
<summary>
 Indicates the type is generated, but type-relocation is suppressed
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TProvidedTypeInfo.IsErased">
<summary>
 Indicates the type is erased
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TProvidedTypeInfo.IsDelegate">
<summary>
 A flag read from the provided type type used to compute basic properties of the type definition.
 Reading is delayed, since it looks at the .BaseType
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TProvidedTypeInfo.UnderlyingTypeOfEnum">
<summary>
 A type read from the provided type type used to compute basic properties of the type definition.
 Reading is delayed, since it does an import on the underlying type
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TProvidedTypeInfo.IsEnum">
<summary>
 A flag read eagerly from the provided type type used to compute basic properties of the type definition.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TProvidedTypeInfo.IsStructOrEnum">
<summary>
 A flag read eagerly from the provided type type used to compute basic properties of the type definition.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TProvidedTypeInfo.IsInterface">
<summary>
 A flag read eagerly from the provided type type used to compute basic properties of the type definition.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TProvidedTypeInfo.IsAbstract">
<summary>
 A flag read eagerly from the provided type type used to compute basic properties of the type definition.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TProvidedTypeInfo.IsSealed">
<summary>
 A flag read eagerly from the provided type type used to compute basic properties of the type definition.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TProvidedTypeInfo.IsClass">
<summary>
 A flag read eagerly from the provided type type used to compute basic properties of the type definition.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TProvidedTypeInfo.LazyBaseType">
<summary>
 The base type of the type. We use it to compute the compiled representation of the type for erased types.
 Reading is delayed, since it does an import on the underlying type
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TProvidedTypeInfo.ProvidedType">
<summary>
 The underlying System.Type (wrapped as a ProvidedType to make sure we don&apos;t call random things on
 System.Type, type wrapped as Tainted to make sure we track which provider this came from, for reporting
 error messages)
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TProvidedTypeInfo.ResolutionEnvironment">
<summary>
 The parameters given to the provider that provided to this type.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TProvidedTypeInfo.IsGenerated">
<summary>
 Indicates if the provided type is generated, i.e. not erased
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.TProvidedTypeInfo.BaseTypeForErased(FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Gets the base type of an erased provided type
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TProvidedTypeInfo">
<summary>
 The information kept about a provided type
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyconRepresentation.TNoRepr">
<summary>
 The &apos;NoRepr&apos; value here has four meanings:
     (1) it indicates &apos;not yet known&apos; during the first 2 phases of establishing type definitions
     (2) it indicates &apos;no representation&apos;, i.e. &apos;type X&apos; in signatures
     (3) it is the setting used for exception definitions (!)
     (4) it is the setting used for modules type namespaces.

 It would be better to separate the &quot;not yet known&quot; type other cases out.
 The information for exception definitions should be folded into here.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyconRepresentation.TProvidedNamespaceRepr">
<summary>
 Indicates the representation information for a provided namespace.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyconRepresentation.TProvidedTypeRepr">
<summary>
 TProvidedTypeRepr

 Indicates the representation information for a provided type.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyconRepresentation.TMeasureableRepr">
<summary>
 Indicates the type is parameterized on a measure (e.g. float&lt;_&gt;) but erases to some other type (e.g. float)
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyconRepresentation.TAsmRepr">
<summary>
 Indicates the type is implemented as IL assembly code using the given closed Abstract IL type
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyconRepresentation.TILObjectRepr">
<summary>
 Indicates the type is a type from a .NET assembly without F# metadata.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyconRepresentation.TFSharpTyconRepr">
<summary>
 Indicates the type is a class, struct, enum, delegate or interface
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyconRepresentation">
<summary>
 The information for the contents of a type. Also used for a provided namespace.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyconAugmentation.tcaug_abstract">
<summary>
 Set to true if the type is determined to be abstract
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyconAugmentation.tcaug_closed">
<summary>
 Set to true at the end of the scope where proper augmentations are allowed
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyconAugmentation.tcaug_super">
<summary>
 Super type, if any
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyconAugmentation.tcaug_interfaces">
<summary>
 Interface implementations - boolean indicates compiler-generated
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyconAugmentation.tcaug_adhoc">
<summary>
 Properties, methods etc. as lookup table
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyconAugmentation.tcaug_adhoc_list">
<summary>
 Properties, methods etc. in declaration order. The boolean flag for each indicates if the
 member is known to be an explicit interface implementation. This must be computed and
 saved prior to remapping assembly information.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyconAugmentation.tcaug_hasObjectGetHashCode">
<summary>
 True if the type defined an Object.GetHashCode method. In this
 case we give a warning if we auto-generate a hash method since the semantics may not match up
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyconAugmentation.tcaug_hash_and_equals_withc">
<summary>
 This is the value implementing the auto-generated equality
 semantics if any. It is not present if the type defines its own implementation
 of IStructuralEquatable or if the type doesn&apos;t override Object.Equals implicitly.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyconAugmentation.tcaug_equals">
<summary>
 This is the value implementing the auto-generated equality
 semantics if any. It is not present if the type defines its own implementation
 of Object.Equals or if the type doesn&apos;t override Object.Equals implicitly.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyconAugmentation.tcaug_compare_withc">
<summary>
 This is the value implementing the auto-generated comparison
 semantics if any. It is not present if the type defines its own implementation
 of IStructuralComparable or if the type doesn&apos;t implement IComparable implicitly.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyconAugmentation.tcaug_compare">
<summary>
 This is the value implementing the auto-generated comparison
 semantics if any. It is not present if the type defines its own implementation
 of IComparable or if the type doesn&apos;t implement IComparable implicitly.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.CompiledTypeRepr.ILAsmOpen">
<summary>
 An AbstractIL type representation that may include type variables
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.CompiledTypeRepr.ILAsmNamed">
<summary>
 An AbstractIL type representation that is just the name of a type.

 CompiledTypeRepr.ILAsmNamed (ilTypeRef, ilBoxity, ilTypeOpt)

 The ilTypeOpt is present for non-generic types. It is an ILType corresponding to the first two elements of the case. This
 prevents reallocation of the ILType each time we need to generate it. For generic types, it is None.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.CompiledTypeRepr">
<summary>
 Specifies the compiled representations of type type exception definitions. Basically
 just an ILTypeRef. Computed type cached by later phases. Stored in
 type type exception definitions. Not pickled. Store an optional ILType object for
 non-generic types.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ParentRef">
<summary>
 Represents the declaring entity of a type definition, if any
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.entity_il_repr_cache">
<summary>
 Used during codegen to hold the ILX representation indicating how to access the type
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.entity_cpath">
<summary>
 The stable path to the type, e.g. Microsoft.FSharp.Core.FSharpFunc`2
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.entity_pubpath">
<summary>
 The stable path to the type, e.g. Microsoft.FSharp.Core.FSharpFunc`2
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.entity_modul_type">
<summary>
 This field is used when the &apos;tycon&apos; is really a module definition. It holds statically nested type definitions type nested modules
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.entity_tycon_tcaug">
<summary>
 The methods type properties of the type
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.entity_tycon_repr">
<summary>
 The declared representation of the type, i.e. record, union, class etc.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.entity_attribs">
<summary>
 The declared attributes for the type
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.entity_range">
<summary>
 The declaration location for the type constructor
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.entity_logical_name">
<summary>
 The name of the type, possibly with `n mangling
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.entity_stamp">
<summary>
 The unique stamp of the &quot;tycon blob&quot;. Note the same tycon in signature type implementation get different stamps
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.entity_typars">
<summary>
 The declared type parameters of the type
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.XmlDocSig(System.String)">
<summary>
 The XML documentation sig-string of the entity, if any, to use to lookup an .xml doc file. This also acts
 as a cache for this sig-string computation.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.XmlDocSig">
<summary>
 The XML documentation sig-string of the entity, if any, to use to lookup an .xml doc file. This also acts
 as a cache for this sig-string computation.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.XmlDoc">
<summary>
 The XML documentation of the entity, if any. If the entity is backed by provided metadata
 then this _does_ include this documentation. If the entity is backed by Abstract IL metadata
 or comes from another F# assembly then it does not (because the documentation will get read from
 an XML file).
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.UnionTypeInfo">
<summary>
 Get the union cases type other union-type information for a type, if any
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.UnionCasesAsList">
<summary>
 Get the union cases for a type, if any, as a list
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.UnionCasesArray">
<summary>
 Get the union cases for a type, if any
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.TypeReprInfo">
<summary>
 The information about the r.h.s. of a type definition, if any. For example, the r.h.s. of a union or record type.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.TypeReprAccessibility">
<summary>
 Get the value representing the accessibility of the r.h.s. of an F# type definition.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.TypeOrMeasureKind">
<summary>
 The kind of the type definition - is it a measure definition or a type definition?
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.TypeContents">
<summary>
 The logical contents of the entity when it is a type definition.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.TypeAbbrev">
<summary>
 Get the type abbreviated by this type definition, if it is an F# type abbreviation definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.TyparsNoRange">
<summary>
 Get the type parameters for an entity that is a type declaration, otherwise return the empty list.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.TryIsReadOnly">
<summary>
 These two bits represents the on-demand analysis about whether the entity has the IsReadOnly attribute
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.TryIsByRefLike">
<summary>
 The on-demand analysis about whether the entity has the IsByRefLike attribute
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.TryIsAssumedReadOnly">
<summary>
 These two bits represents the on-demand analysis about whether the entity is assumed to be a readonly struct
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.TrueInstanceFieldsAsList">
<summary>
 Get a list of all instance fields for F#-defined record, struct type class fields in this type definition,
 excluding compiler-generate fields.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.TrueFieldsAsList">
<summary>
 Get a list of all fields for F#-defined record, struct type class fields in this type definition,
 including static fields, but excluding compiler-generate fields.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.Stamp">
<summary>
 A unique stamp for this module, namespace or type definition within the context of this compilation.
 Note that because of signatures, there are situations where in a single compilation the &quot;same&quot;
 module, namespace or type may have two distinct Entity objects that have distinct stamps.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.Range">
<summary>
 The code location where the module, namespace or type is defined.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.PublicPath">
<summary>
 Get a blob of data indicating how this type is nested in other namespaces, modules or types.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.PreEstablishedHasDefaultConstructor">
<summary>
 Indicates if we have pre-determined that a type definition has a default constructor.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.ModuleOrNamespaceType">
<summary>
 The logical contents of the entity when it is a module or namespace fragment.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.MembersOfFSharpTyconSorted">
<summary>
 Gets the immediate members of an F# type definition, excluding compiler-generated ones.
 Note: result is alphabetically sorted, then for each name the results are in declaration order
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.MembersOfFSharpTyconByName">
<summary>
 Gets all immediate members of an F# type definition keyed by name, including compiler-generated ones.
 Note: result is a indexed table, type for each name the results are in reverse declaration order
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.LogicalName">
<summary>
 The name of the namespace, module or type, possibly with mangling, e.g. List`1, List or FailureException
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsUnionTycon">
<summary>
 Indicate if this is a type whose r.h.s. is known to be a union type definition.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsTypeAbbrev">
<summary>
 Indicates if this entity is an F# type abbreviation definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsStructRecordOrUnionTycon">
<summary>
 Indicates if this is an F# type definition whose r.h.s. is known to be a record type definition that is a value type.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsStructOrEnumTycon">
<summary>
 Indicates if this is a struct or enum type definition, i.e. a value type definition, including struct records and unions
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsRecordTycon">
<summary>
 Indicates if this is an F# type definition whose r.h.s. is known to be a record type definition.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsProvidedNamespace">
<summary>
 Indicates if the entity is a provided namespace fragment
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsProvidedGeneratedTycon">
<summary>
 Indicates if the entity is a generated provided type definition, i.e. not erased.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsProvidedErasedTycon">
<summary>
 Indicates if the entity is an erased provided type definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsProvided">
<summary>
 Indicates if the entity is a provided type or namespace definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsPrefixDisplay">
<summary>
 Indicates the type prefers the &quot;tycon&lt;a, b&gt;&quot; syntax for display etc.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsNamespace">
<summary>
 Indicates if the entity is a namespace
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsModuleOrNamespace">
<summary>
 Indicates the Entity is actually a module or namespace, not a type definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsModule">
<summary>
 Indicates if the entity is an F# module definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsMeasureableReprTycon">
<summary>
 Indicates if this is an F# type definition which is one of the special types in FSharp.Core.dll like &apos;float&lt;_&gt;&apos; which
 defines a measure type with a relation to an existing non-measure type as a representation.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsLinked">
<summary>
 Indicates if the entity is linked to backing data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsImplicitNamespace">
<summary>
 Indicates if the entity has an implicit namespace
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsILTycon">
<summary>
 Indicate if this is a type definition backed by Abstract IL metadata.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsILStructOrEnumTycon">
<summary>
 Indicates if this is a .NET-defined struct or enum type definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsILEnumTycon">
<summary>
 Indicates if this is a .NET-defined enum type definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsHiddenReprTycon">
<summary>
 Indicates if this is an F# type definition whose r.h.s. definition is unknown (i.e. a traditional ML &apos;abstract&apos; type in a signature,
 which in F# is called a &apos;unknown representation&apos; type).
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsFSharpStructOrEnumTycon">
<summary>
 Indicates if this is an F#-defined value type definition, including struct records and unions
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsFSharpObjectModelTycon">
<summary>
 Indicates if this is an F# type definition known to be an F# class, interface, struct,
 delegate or enum. This isn&apos;t generally a particularly useful thing to know,
 it is better to use more specific predicates.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsFSharpInterfaceTycon">
<summary>
 Indicates if this is an F#-defined interface type definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsFSharpException">
<summary>
 Indicates if the entity represents an F# exception declaration.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsFSharpEnumTycon">
<summary>
 Indicates if this is an F#-defined enum type definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsFSharpDelegateTycon">
<summary>
 Indicates if this is an F#-defined delegate type definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsFSharpClassTycon">
<summary>
 Indicates if this is an F#-defined class type definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsErased">
<summary>
 Indicates if the entity is erased, either a measure definition, or an erased provided type definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsEnumTycon">
<summary>
 Indicates if this is an enum type definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.IsAsmReprTycon">
<summary>
 Indicates if this is an F# type definition which is one of the special types in FSharp.Core.dll which uses
 an assembly-code representation for the type, e.g. the primitive array type constructor.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.ImmediateInterfacesOfFSharpTycon">
<summary>
 Gets the immediate interface definitions of an F# type definition. Further interfaces may be supported through class type interface inheritance.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.ImmediateInterfaceTypesOfFSharpTycon">
<summary>
 Gets the immediate interface types of an F# type definition. Further interfaces may be supported through class type interface inheritance.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.Id">
<summary>
 The identifier at the point of declaration of the type definition.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.ILTyconRawMetadata">
<summary>
 Get the Abstract IL metadata for this type definition, assuming it is backed by Abstract IL metadata.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.ILTyconInfo">
<summary>
 Get the Abstract IL scope, nesting type metadata for this
 type definition, assuming it is backed by Abstract IL metadata.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.HasSignatureFile">
<summary>
 Indicates if the value has a signature file counterpart
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.HasSelfReferentialConstructor">
<summary>
 Indicates if we have pre-determined that a type definition has a self-referential constructor using &apos;as x&apos;
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.GeneratedHashAndEqualsWithComparerValues">
<summary>
 Gets any implicit hash/equals (with comparer argument) methods added to an F# record, union or struct type definition.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.GeneratedHashAndEqualsValues">
<summary>
 Gets any implicit hash/equals methods added to an F# record, union or struct type definition.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.GeneratedCompareToWithComparerValues">
<summary>
 Gets any implicit CompareTo (with comparer argument) methods added to an F# record, union or struct type definition.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.GeneratedCompareToValues">
<summary>
 Gets any implicit CompareTo methods added to an F# record, union or struct type definition.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.FSharpTyconRepresentationData">
<summary>
 Get the blob of information associated with an F# object-model type definition, i.e. class, interface, struct etc.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.ExceptionInfo">
<summary>
 The information about the r.h.s. of an F# exception definition, if any.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.DisplayNameWithStaticParametersAndUnderscoreTypars">
<summary>
 The display name of the namespace, module or type with &lt;_, _, _&gt; added for generic types, plus static parameters if any
 For modules the Module suffix is removed if FSharpModuleWithSuffix is used.

 Backticks are added implicitly for entities with non-identifier names
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.DisplayNameWithStaticParameters">
<summary>
 The display name of the namespace, module or type, e.g. List instead of List`1, including static parameters if any
 For modules the Module suffix is removed if FSharpModuleWithSuffix is used.

 Backticks are added implicitly for entities with non-identifier names
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.DisplayNameCore">
<summary>
 The display name of the namespace, module or type, e.g. List instead of List`1, type no static parameters.
 For modules the Module suffix is removed if FSharpModuleWithSuffix is used.

 No backticks are added for entities with non-identifier names
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.DisplayName">
<summary>
 The display name of the namespace, module or type, e.g. List instead of List`1, type no static parameters
 For modules the Module suffix is removed if FSharpModuleWithSuffix is used.

 Backticks are added implicitly for entities with non-identifier names
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.DemangledModuleOrNamespaceName">
<summary>
 Demangle the module name, if FSharpModuleWithSuffix is used
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.DefinitionRange">
<summary>
 The range in the implementation, adjusted for an item in a signature
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.CompiledRepresentationForNamedType">
<summary>
 Gets the data indicating the compiled representation of a named type or module in terms of Abstract IL data structures.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.CompiledRepresentation">
<summary>
 Gets the data indicating the compiled representation of a type or module in terms of Abstract IL data structures.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.CompiledReprCache">
<summary>
 Get the cache of the compiled ILTypeRef representation of this module or type.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.CompiledName">
<summary>
 The compiled name of the namespace, module or type, e.g. FSharpList`1, ListModule or FailureException
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.CompilationPathOpt">
<summary>
 Get a blob of data indicating how this type is nested inside other namespaces, modules type types.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.CompilationPath">
<summary>
 Get a blob of data indicating how this type is nested inside other namespaces, modules type types.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.Attribs">
<summary>
 The F#-defined custom attributes of the entity, if any. If the entity is backed by Abstract IL or provided metadata
 then this does not include any attributes from those sources.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.AllInstanceFieldsAsList">
<summary>
 Get a list of all instance fields for F#-defined record, struct type class fields in this type definition.
 including hidden fields from the compilation of implicit class constructions.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.AllGeneratedInterfaceImplsAndOverrides">
<summary>
 Gets all implicit hash/equals/compare methods added to an F# record, union or struct type definition.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.AllFieldsAsList">
<summary>
 Get a list of fields for all the F#-defined record, struct type class fields in this type definition, including
 static fields, &apos;val&apos; declarations type hidden fields from the compilation of implicit class constructions.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.AllFieldsArray">
<summary>
 Get an array of fields for all the F#-defined record, struct type class fields in this type definition, including
 static fields, &apos;val&apos; declarations type hidden fields from the compilation of implicit class constructions.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.AllFieldTable">
<summary>
 Get a table of fields for all the F#-defined record, struct type class fields in this type definition, including
 static fields, &apos;val&apos; declarations type hidden fields from the compilation of implicit class constructions.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.Entity.Accessibility">
<summary>
 Get the value representing the accessibility of an F# type definition or module.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Entity.Typars(FSharp.Compiler.Text.Range)">
<summary>
 Get the type parameters for an entity that is a type declaration, otherwise return the empty list.

 Lazy because it may read metadata, must provide a context &quot;range&quot; in case error occurs reading metadata.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Entity.SetIsStructRecordOrUnion(System.Boolean)">
<summary>
 Sets the structness of a record or union type definition
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Entity.SetIsReadOnly(System.Boolean)">
<summary>
 Set the on-demand analysis about whether the entity has the IsReadOnly attribute
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Entity.SetIsByRefLike(System.Boolean)">
<summary>
 Set the on-demand analysis about whether the entity has the IsByRefLike attribute
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Entity.SetIsAssumedReadOnly(System.Boolean)">
<summary>
 Set the on-demand analysis about whether the entity is assumed to be a readonly struct
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Entity.SetAttribs(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Attrib})">
<summary>
 Set the custom attributes on an F# type definition.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Entity.NewUnlinked">
<summary>
 Create a new entity with empty, unlinked data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Entity.New``1(``0,FSharp.Compiler.TypedTree.Entity)">
<summary>
 Create a new entity with the given backing data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Entity.Link(FSharp.Compiler.TypedTree.Entity)">
<summary>
 Link an entity based on empty, unlinked data to the given data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Entity.GetUnionCaseByName(System.String)">
<summary>
 Get a union case of a type by name
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Entity.GetFieldByName(System.String)">
<summary>
 Get a field by name.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.Entity.GetFieldByIndex(System.Int32)">
<summary>
 Get a field by index in definition order
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.Entity">
<summary>
 Represents a type definition, exception definition, module definition or namespace definition.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityOptionalData.entity_exn_info">
<summary>
 Field used when the &apos;tycon&apos; is really an exception definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityOptionalData.entity_accessibility">
<summary>
 Indicates how visible is the entity is.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityOptionalData.entity_tycon_repr_accessibility">
<summary>
 The declared accessibility of the representation, not taking signatures into account
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityOptionalData.entity_tycon_abbrev">
<summary>
 If non-None, indicates the type is an abbreviation for another type.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityOptionalData.entity_xmldocsig">
<summary>
 The XML document signature for this entity
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityOptionalData.entity_other_xmldoc">
<summary>
 the signature xml doc for an item in an implementation file.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityOptionalData.entity_xmldoc">
<summary>
 The declared documentation for the type or module
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityOptionalData.entity_other_range">
<summary>
 If this field is populated, this is the implementation range for an item in a signature, otherwise it is
 the signature range for an item in an implementation
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityOptionalData.entity_compiled_name">
<summary>
 The name of the type, possibly with `n mangling
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.CompilationPath.DemangleEntityName(System.String,FSharp.Compiler.TypedTree.ModuleOrNamespaceKind)">
<summary>
 String &apos;Module&apos; off an F# module name, if FSharpModuleWithSuffix is used
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.CompilationPath">
<summary>
 The information ILXGEN needs about the location of an item
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.SyntaxAccess">
<summary>
 Represents the specified visibility of the accessibility -- used to ensure IL visibility
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.PublicPath">
<summary>
 A public path records where a construct lives within the global namespace
 of a CCU.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ModuleOrNamespaceKind.Namespace.isExplicit">
<summary>
 Indicates that the sourcecode had a namespace.
 If false, this namespace was implicitly constructed during type checking.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ModuleOrNamespaceKind.Namespace">
<summary>
 Indicates that a &apos;module&apos; is really a namespace
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ModuleOrNamespaceKind.ModuleOrType">
<summary>
 Indicates that a module is compiled to a class with the same name as the original module
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ModuleOrNamespaceKind.FSharpModuleWithSuffix">
<summary>
 Indicates that a module is compiled to a class with the &quot;Module&quot; suffix added.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityFlags.TryIsReadOnly">
<summary>
 These two bits represents the on-demand analysis about whether the entity has the IsReadOnly attribute
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityFlags.TryIsByRefLike">
<summary>
 These two bits represents the on-demand analysis about whether the entity has the IsByRefLike attribute
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityFlags.TryIsAssumedReadOnly">
<summary>
 These two bits represents the on-demand analysis about whether the entity is assumed to be a readonly struct
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityFlags.ReservedBitForPickleFormatTyconReprFlag">
<summary>
 This bit is reserved for us in the pickle format, see pickle.fs, it&apos;s being listed here to stop it ever being used for anything else
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityFlags.PickledBits">
<summary>
 Get the flags as included in the F# binary metadata
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityFlags.IsStructRecordOrUnionType">
<summary>
 This bit represents a F# record that is a value type, or a struct record.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityFlags.IsPrefixDisplay">
<summary>
 Indicates the type prefers the &quot;tycon&lt;a, b&gt;&quot; syntax for display etc.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.EntityFlags.IsModuleOrNamespace">
<summary>
 Indicates the Entity is actually a module or namespace, not a type definition
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.EntityFlags.WithIsReadOnly(System.Boolean)">
<summary>
 Adjust the on-demand analysis about whether the entity has the IsReadOnly attribute
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.EntityFlags.WithIsByRefLike(System.Boolean)">
<summary>
 Adjust the on-demand analysis about whether the entity has the IsByRefLike attribute
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTree.EntityFlags.WithIsAssumedReadOnly(System.Boolean)">
<summary>
 Adjust the on-demand analysis about whether the entity is assumed to be a readonly struct
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.EntityFlags">
<summary>
 Encode entity flags into a bit field. We leave lots of space to allow for future expansion.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyparFlags.StaticReq">
<summary>
 Indicates if the type variable has a static &quot;head type&quot; requirement, i.e. ^a variables used in FSharp.Core type member constraints.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyparFlags.Rigidity">
<summary>
 Indicates if the type variable can be solved or given new constraints. The status of a type variable
 generally always evolves towards being either rigid or solved.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyparFlags.PickledBits">
<summary>
 Get the flags as included in the F# binary metadata. We pickle this as int64 to allow for future expansion
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyparFlags.Kind">
<summary>
 Indicates whether a type variable can be instantiated by types or units-of-measure.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyparFlags.IsSupportsNullFlex">
<summary>
 Indicates whether this type parameter is flexible for &apos;supports null&apos; constraint, e.g. in the case of assignment to a mutable value
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyparFlags.IsFromError">
<summary>
 Indicates if the type inference variable was generated after an error when type checking expressions or patterns
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyparFlags.IsCompilerGenerated">
<summary>
 Indicates if the type variable is compiler generated, i.e. is an implicit type inference variable
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyparFlags.IsCompatFlex">
<summary>
 Indicates that whether this type parameter is a compat-flex type parameter (i.e. where &quot;expr :&gt; tp&quot; only emits an optional warning)
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyparFlags.EqualityConditionalOn">
<summary>
 Indicates that whether or not a generic type definition satisfies the equality constraint is dependent on whether this type variable satisfies the equality constraint.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyparFlags.DynamicReq">
<summary>
 Indicates if a type parameter is needed at runtime type may not be eliminated
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.TyparFlags.ComparisonConditionalOn">
<summary>
 Indicates that whether or not a generic type definition satisfies the comparison constraint is dependent on whether this type variable satisfies the comparison constraint.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparFlags">
<summary>
 Encode typar flags into a bit field
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparRigidity.Anon">
<summary>
 Indicates the type parameter derives from an &apos;_&apos; anonymous type
 For units-of-measure, we give a warning if this gets solved to &apos;1&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparRigidity.Flexible">
<summary>
 Indicates the type parameter is an inference variable may be solved
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparRigidity.WarnIfNotRigid">
<summary>
 Indicates we give a warning if the type parameter is ever solved
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparRigidity.WillBeRigid">
<summary>
 Indicates the type parameter can&apos;t be solved, but the variable is not set to &quot;rigid&quot; until after inference is complete
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparRigidity.Rigid">
<summary>
 Indicates the type parameter can&apos;t be solved
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparRigidity">
<summary>
 Indicates if the type variable can be solved or given new constraints. The status of a type variable
 evolves towards being either rigid or solved.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparKind">
<summary>
 Represents the kind of a type parameter
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValFlags.PickledBits">
<summary>
 Get the flags as included in the F# binary metadata
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ValFlags">
<summary>
 Flags on values
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ValBaseOrThisInfo.MemberThisVal">
<summary>
 Indicates the &apos;this&apos; value specified in a memberm e.g. &apos;x&apos; in &apos;member x.M() = 1&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ValBaseOrThisInfo.NormalVal">
<summary>
 Indicates a normal value
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ValBaseOrThisInfo.BaseVal">
<summary>
 Indicates the value called &apos;base&apos; available for calling base class members
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ValBaseOrThisInfo.CtorThisVal">
<summary>
 Indicates a ref-cell holding &apos;this&apos; or the implicit &apos;this&apos; used throughout an
 implicit constructor to access type set values
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparDynamicReq.Yes">
<summary>
 Indicates the type parameter is needed at runtime type may not be eliminated
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparDynamicReq.No">
<summary>
 Indicates the type parameter is not needed at runtime type may be eliminated
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.TyparDynamicReq">
<summary>
 Indicates if a type parameter is needed at runtime type may not be eliminated
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ValRecursiveScopeInfo.ValNotInRecScope">
<summary>
 The normal value for this flag when the value is not within its recursive scope
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ValRecursiveScopeInfo.ValInRecScope">
<summary>
 Set while the value is within its recursive scope. The flag indicates if the value has been eagerly generalized type accepts generic-recursive calls
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ValRecursiveScopeInfo">
<summary>
 A flag associated with values that indicates whether the recursive scope of the value is currently being processed, type
 if the value has been generalized or not as yet.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ValInline.Never">
<summary>
 Indicates the value must never be inlined by the optimizer
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ValInline.Optional">
<summary>
 Indicates the value may optionally be inlined by the optimizer
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree.ValInline.Always">
<summary>
 Indicates the value is inlined but the .NET IL code for the function still exists, e.g. to satisfy interfaces on objects, but that it is also always inlined
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.ValInline.ShouldInline">
<summary>
 Returns true if the implementation of a value must always be inlined
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTree.WellKnownNames.CopyOfStruct">
<summary>
 Special name for the defensive copy of a struct, we use it in situations like when we get an address of a field in ax-assembly scenario.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTree">
<summary>
 Defines the typed abstract syntax intermediate representation used throughout the F# compiler.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeBasics.accessSubstPaths(FSharp.Compiler.TypedTree.CompilationPath,FSharp.Compiler.TypedTree.CompilationPath,FSharp.Compiler.TypedTree.Accessibility)">
<summary>
 Given (newPath, oldPath) replace oldPath by newPath in the TAccess.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeBasics.primValRefEq(System.Boolean,FSharp.Compiler.TypedTree.CcuThunk,FSharp.Compiler.TypedTree.ValRef,FSharp.Compiler.TypedTree.ValRef)">
<summary>
 Primitive routine to compare two ValRef&apos;s for equality. On the whole value identity is not particularly
 significant in F#. However it is significant for
    (a) Active Patterns
    (b) detecting uses of &quot;special known values&quot; from FSharp.Core.dll, such as &apos;seq&apos;
        and quotation splicing

 Note this routine doesn&apos;t take type forwarding into account
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeBasics.primUnionCaseRefEq(System.Boolean,FSharp.Compiler.TypedTree.CcuThunk,FSharp.Compiler.TypedTree.UnionCaseRef,FSharp.Compiler.TypedTree.UnionCaseRef)">
<summary>
 Primitive routine to compare two UnionCaseRef&apos;s for equality
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeBasics.primEntityRefEq(System.Boolean,FSharp.Compiler.TypedTree.CcuThunk,FSharp.Compiler.TypedTree.EntityRef,FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Primitive routine to compare two EntityRef&apos;s for equality
 This takes into account the possibility that they may have type forwarders
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeBasics.fslibEntityRefEq(FSharp.Compiler.TypedTree.CcuThunk,FSharp.Compiler.TypedTree.EntityRef,FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Compare two EntityRef&apos;s for equality when compiling fslib (FSharp.Core.dll)
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeBasics.nonLocalRefDefinitelyNotEq(FSharp.Compiler.TypedTree.NonLocalEntityRef,FSharp.Compiler.TypedTree.NonLocalEntityRef)">
<summary>
 This predicate tests if non-local resolution paths are definitely known to resolve
 to different entities. All references with different named paths always resolve to
 different entities. Two references with the same named paths may resolve to the same
 entities even if they reference through different CCUs, because one reference
 may be forwarded to another via a .NET TypeForwarder.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeBasics.rescopePubPath(FSharp.Compiler.TypedTree.CcuThunk,FSharp.Compiler.TypedTree.PublicPath)">
<summary>
 From Ref_private to Ref_nonlocal when exporting data.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeBasics.rescopePubPathToParent(FSharp.Compiler.TypedTree.CcuThunk,FSharp.Compiler.TypedTree.PublicPath)">
<summary>
 From Ref_private to Ref_nonlocal when exporting data.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeBasics.|AbbrevOrAppTy|_|(FSharp.Compiler.TypedTree.TType)">
<summary>
 Detect a use of a nominal type, including type abbreviations.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeBasics.mkModuleUnionCaseRef(FSharp.Compiler.TypedTree.EntityRef,FSharp.Compiler.TypedTree.Entity,FSharp.Compiler.TypedTree.UnionCase)">
<summary>
 Make a reference to a union case for type in a module or namespace
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeBasics.|ValDeref|(FSharp.Compiler.TypedTree.ValRef)">
<summary>
 For dereferencing in the middle of a pattern
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeBasics.ccuEq(FSharp.Compiler.TypedTree.CcuThunk,FSharp.Compiler.TypedTree.CcuThunk)">
<summary>
 Equality on CCU references, implemented as reference equality except when unresolved
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeBasics.valEq(FSharp.Compiler.TypedTree.Val,FSharp.Compiler.TypedTree.Val)">
<summary>
 Equality on value specs, implemented as reference equality
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeBasics.typarRefEq(FSharp.Compiler.TypedTree.Typar,FSharp.Compiler.TypedTree.Typar)">
<summary>
 Equality on type variables, implemented as reference equality. This should be equivalent to using typarEq.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeBasics.ValReprInfo">
<summary>
 Metadata on values (names of arguments etc.
</summary>
</member>
<member name="M:FSharp.Compiler.TcGlobals.TcGlobals.memoize_file(System.Int32)">
<summary>
 Memoization table to help minimize the number of ILSourceDocument objects we create
</summary>
</member>
<member name="P:FSharp.Compiler.TcGlobals.TcGlobals.isInteractive">
<summary>
 Are we assuming all code gen is for F# interactive, with no static linking
</summary>
</member>
<member name="P:FSharp.Compiler.TcGlobals.TcGlobals.isArrayEmptyAvailable">
<summary>
 Indicates if we can use System.Array.Empty when emitting IL for empty array literals
</summary>
</member>
<member name="P:FSharp.Compiler.TcGlobals.TcGlobals.generateWitnesses">
<summary>
 Indicates if we are generating witness arguments for SRTP constraints. Only done if the FSharp.Core
 supports witness arguments.
</summary>
</member>
<member name="M:FSharp.Compiler.TcGlobals.TcGlobals.TryMakeOperatorAsBuiltInWitnessInfo``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TcGlobals.TcGlobals,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.TType,System.Boolean}},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TcGlobals.TcGlobals,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.TType,System.Boolean}},FSharp.Compiler.TypedTree.TraitConstraintInfo,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Find an FSharp.Core operator that corresponds to a trait witness
</summary>
</member>
<member name="M:FSharp.Compiler.TcGlobals.TcGlobals.MakeBuiltInWitnessInfo(FSharp.Compiler.TypedTree.TraitConstraintInfo)">
<summary>
 Find an FSharp.Core LanguagePrimitives dynamic function that corresponds to a trait witness, e.g.
 AdditionDynamic for op_Addition.  Also work out the type instantiation of the dynamic function.
</summary>
</member>
<member name="P:FSharp.Compiler.TcGlobals.BuiltinAttribInfo.DebugText">
<summary>
 For debugging
</summary>
</member>
<member name="M:FSharp.Compiler.TcGlobals.BuiltinAttribInfo.ToString">
<summary>
 For debugging
</summary>
</member>
<member name="P:FSharp.Compiler.TcGlobals.IntrinsicValRef.DebugText">
<summary>
 For debugging
</summary>
</member>
<member name="M:FSharp.Compiler.TcGlobals.IntrinsicValRef.ToString">
<summary>
 For debugging
</summary>
</member>
<member name="T:FSharp.Compiler.TcGlobals.IntrinsicValRef">
<summary>
 Represents an intrinsic value from FSharp.Core known to the compiler
</summary>
</member>
<member name="T:FSharp.Compiler.TcGlobals.CompilationMode">
<summary>
 Signals how checker/compiler was invoked - from FSC task/process (a one-off compilation), from tooling or from interactive session.
 This is used to determine if we want to use certain features in the pipeline, for example, type subsumption cache is only used in one-off compilation now.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.TraitWitnessInfoHashMap`1">
<summary>
 An immutable mapping from witnesses to some data.

 Note: this uses an immutable HashMap/Dictionary with an IEqualityComparer that captures TcGlobals, see EmptyTraitWitnessInfoHashMap
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.Loop">
<summary>
 An expression representing the overall loop.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.Body">
<summary>
 An expression representing the loop body.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.Elem">
<summary>
 An expression representing the current loop element.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.Idx">
<summary>
 An expression representing the loop&apos;s current iteration index.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.Count">
<summary>
 An expression holding the loop&apos;s iteration count.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.TypeDefMetadata">
<summary>
 Represents metadata extracted from a nominal type
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.ExprFolder`1">
<summary>
 A set of function parameters (visitor) for folding over expressions
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreeOps.SignatureHidingInfo.Empty">
<summary>
 The empty table representing no hiding
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.SignatureHidingInfo">
<summary>
 A set of tables summarizing the items hidden by a signature
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreeOps.SignatureRepackageInfo.RepackagedEntities">
<summary>
 The list of corresponding modules, namespaces and type definitions
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreeOps.SignatureRepackageInfo.RepackagedVals">
<summary>
 The list of corresponding values
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreeOps.SignatureRepackageInfo.Empty">
<summary>
 The empty table
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.SignatureRepackageInfo">
<summary>
 The remapping that corresponds to a module meeting its signature
 and also report the set of tycons, tycon representations and values hidden in the process.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.ValCopyFlag.OnlyCloneExprVals">
<summary>
 OnlyCloneExprVals is a nasty setting to reuse the cloning logic in a mode where all
 Tycon and &quot;module/member&quot; Val objects keep their identity, but the Val objects for all Expr bindings
 are cloned. This is used to &apos;fixup&apos; the TAST created by tlr.fs

 This is a fragile mode of use. It&apos;s not really clear why TLR needs to create a &quot;bad&quot; expression tree that
 reuses Val objects as multiple value bindings, and its been the cause of several subtle bugs.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.ValCopyFlag">
<summary>
 Indicate what should happen to value definitions when copying expressions
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.AllowTypeDirectedDetupling">
<summary>
 A flag to govern whether ValReprInfo inference should be type-directed or syntax-directed when
 inferring from a lambda expression.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreeOps.DisplayEnv.showDocumentation">
<summary>
 If set, signatures will be rendered with XML documentation comments for members if they exist
 Defaults to false, expected use cases include things like signature file generation.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.GenericParameterStyle.Suffix">
<summary>
 Force the suffix style: int List
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.GenericParameterStyle.Prefix">
<summary>
 Force the prefix style: List&lt;int&gt;
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.GenericParameterStyle.Implicit">
<summary>
 Use the IsPrefixDisplay member of the TyCon to determine the style
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.GenericParameterStyle">
<summary>
 Describes how generic type parameters in a type will be formatted during printing
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.FreeVarOptions.WithTemplateReplacement(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.EntityRef,System.Boolean},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar})">
<summary>
 During backend code generation of state machines, register a template replacement for struct types.
 This may introduce new free variables related to the instantiation of the struct type.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.FreeVarOptions">
<summary>
 Represents the options to activate when collecting free variables
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.Remap">
<summary>
 Represents a combination of substitutions/instantiations where things replace other things during remapping
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.ValRemap">
<summary>
 Represents an instantiation where value references replace other value references
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.TyconRefRemap">
<summary>
 Represents an instantiation where type definition references replace other type definition references
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.TyparInstantiation">
<summary>
 Represents an instantiation where types replace type parameters
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreeOps.TyconRefMultiMap`1.Empty">
<summary>
 The empty map
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.TyconRefMultiMap`1.OfList(Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Compiler.TypedTree.EntityRef,`0}})">
<summary>
 Make a new map, containing a entries for the given type definitions
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.TyconRefMultiMap`1.Find(FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Fetch the entries for the given type definition
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.TyconRefMultiMap`1.Add(FSharp.Compiler.TypedTree.EntityRef,`0)">
<summary>
 Make a new map, containing a new entry for the given type definition
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.TyconRefMultiMap`1">
<summary>
 Maps TyconRef to list of T based on stamp keys
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreeOps.TyconRefMap`1.Item(FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Get the entry for the given type definition
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreeOps.TyconRefMap`1.IsEmpty">
<summary>
 Determine if the map is empty
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreeOps.TyconRefMap`1.Empty">
<summary>
 The empty map
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.TyconRefMap`1.TryFind(FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Try to find the entry for the given type definition
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.TyconRefMap`1.Remove(FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Remove the entry for the given type definition, if any
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.TyconRefMap`1.OfList(Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Compiler.TypedTree.EntityRef,`0}})">
<summary>
 Make a new map, containing entries for the given type definitions
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.TyconRefMap`1.ContainsKey(FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Determine is the map contains an entry for the given type definition
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.TyconRefMap`1.Add(FSharp.Compiler.TypedTree.EntityRef,`0)">
<summary>
 Make a new map, containing a new entry for the given type definition
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.TyconRefMap`1">
<summary>
 Maps TyconRef to T based on stamp keys
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreeOps.TyparMap`1.Item(FSharp.Compiler.TypedTree.Typar)">
<summary>
 Get the entry for the given type parameter
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreeOps.TyparMap`1.Empty">
<summary>
 The empty map
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.TyparMap`1.TryFind(FSharp.Compiler.TypedTree.Typar)">
<summary>
 Try to find the entry for the given type parameter
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.TyparMap`1.ContainsKey(FSharp.Compiler.TypedTree.Typar)">
<summary>
 Determine is the map contains an entry for the given type parameter
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.TyparMap`1.Add(FSharp.Compiler.TypedTree.Typar,`0)">
<summary>
 Make a new map, containing a new entry for the given type parameter
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.TyparMap`1">
<summary>
 Maps type parameters to entries based on stamp keys
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.ValMultiMap`1">
<summary>
 Maps Val&apos;s to list of T based on stamp keys
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.ValHash`1">
<summary>
 Mutable data structure mapping Val&apos;s to T based on stamp keys
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.ValMap`1">
<summary>
 Maps Val to T, based on stamps
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.GeneralizedType">
<summary>
 GeneralizedType (generalizedTypars, tauTy)

    generalizedTypars -- the truly generalized type parameters
    tauTy  --  the body of the generalized type. A &apos;tau&apos; type is one with its type parameters stripped off.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.MatchBuilder.CloseTargets">
<summary>
 Finish the targets
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.MatchBuilder.Close(FSharp.Compiler.TypedTree.DecisionTree,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Build the overall expression
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.MatchBuilder.AddTarget(FSharp.Compiler.TypedTree.DecisionTreeTarget)">
<summary>
 Add a new destination target
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.MatchBuilder.AddResultTarget(FSharp.Compiler.TypedTree.Expr)">
<summary>
 Add a new destination target that is an expression result
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.MatchBuilder.#ctor(FSharp.Compiler.Syntax.DebugPointAtBinding,FSharp.Compiler.Text.Range)">
<summary>
 Create a new builder
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.MatchBuilder">
<summary>
 Build decision trees imperatively
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isTyparOrderMismatch(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.ArgReprInfo}}})">
<summary>
 Check if the order of defined typars is different from the order of used typars in the curried arguments.
 If this is the case, a generated signature would require explicit typars.
 See https://github.com/dotnet/fsharp/issues/15175
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.updateSeqTypeIsPrefix(FSharp.Compiler.TypedTree.Entity)">
<summary>
 Updates the IsPrefixDisplay to false for the Microsoft.FSharp.Collections.seq`1 entity
 Meant to be called with the FSharp.Core module spec right after it was unpickled.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.serializeEntity(System.String,FSharp.Compiler.TypedTree.Entity)">
<summary>
 Serialize an entity to a very basic json structure.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.tryAddExtensionAttributeIfNotAlreadyPresentForType(FSharp.Compiler.TcGlobals.TcGlobals,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Attrib},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.Attrib}},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.Attrib}},Microsoft.FSharp.Core.FSharpRef{FSharp.Compiler.TypedTree.ModuleOrNamespaceType},FSharp.Compiler.TypedTree.Entity)">
<summary>
 Add an System.Runtime.CompilerServices.ExtensionAttribute to the type Entity if found via predicate and not already present.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.tryAddExtensionAttributeIfNotAlreadyPresentForModule(FSharp.Compiler.TcGlobals.TcGlobals,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Attrib},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.Attrib}},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.Attrib}},FSharp.Compiler.TypedTree.Entity)">
<summary>
 Add an System.Runtime.CompilerServices.ExtensionAttribute to the module Entity if found via predicate and not already present.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|EmptyModuleOrNamespaces|_|(FSharp.Compiler.TypedTree.ModuleOrNamespaceContents)">
<summary>
 Matches a ModuleOrNamespaceContents that is empty from a signature printing point of view.
 Signatures printed via the typed tree in NicePrint don&apos;t print TMDefOpens or TMDefDo.
 This will match anything that does not have any types or bindings.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.TraitConstraintInfo.GetWitnessInfo(FSharp.Compiler.TypedTree.TraitConstraintInfo)">
<summary>
 Get the key associated with the member constraint.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.TraitConstraintInfo.get_MemberDisplayNameCore(FSharp.Compiler.TypedTree.TraitConstraintInfo)">
<summary>
 Get the name of the trait for textual call.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.TraitConstraintInfo.GetLogicalArgumentTypes(FSharp.Compiler.TypedTree.TraitConstraintInfo,FSharp.Compiler.TcGlobals.TcGlobals)">
<summary>
 Get the argument types when the trait is used as a first-class value &quot;^T.TraitName&quot; which can then be applied
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.TraitConstraintInfo.GetCompiledArgumentTypes(FSharp.Compiler.TypedTree.TraitConstraintInfo)">
<summary>
 Get the argument types recorded in the member constraint suitable for building a TypedTree call.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isFSharpExceptionTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Indicates if an F# type is the type associated with an F# exception declaration
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|Seq|_|(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Detect a &apos;seq { ... }&apos; expression
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|SeqEmpty|_|(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Detect a &apos;Seq.empty&apos; implicit in the implied &apos;else&apos; branch of an &apos;if .. then&apos; in a seq { ... }
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|SeqDelay|_|(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Detect the outer &apos;Seq.delay&apos; added for a construct &apos;seq { ... }&apos;
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|SeqForEach|_|(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Detect the de-sugared form of a &apos;for x in collection do ..&apos; within a &apos;seq { ... }&apos;
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|SeqUsing|_|(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Detect the de-sugared form of a &apos;use x = ..&apos; within a &apos;seq { ... }&apos;
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|SeqTryFinally|_|(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Detect the de-sugared form of a &apos;try .. finally .. &apos; within a &apos;seq { ... }&apos;
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|SeqWhile|_|(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Detect the de-sugared form of a &apos;while gd do expr&apos; within a &apos;seq { ... }&apos;
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|SeqAppend|_|(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Detect the de-sugared form of a &apos;expr; expr&apos; within a &apos;seq { ... }&apos;
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|SeqYield|_|(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Detect the de-sugared form of a &apos;yield x&apos; within a &apos;seq { ... }&apos;
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.ComputeUseMethodImpl(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Val)">
<summary>
 Determine if a value is a method implementing an interface dispatch slot using a private method impl
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|IfThenElseExpr|_|(FSharp.Compiler.TypedTree.Expr)">
<summary>
 Match an if...then...else expression or the result of &quot;a &amp;&amp; b&quot; or &quot;a || b&quot;
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.TryBindTyconRefAttribute``1(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,FSharp.Compiler.TcGlobals.BuiltinAttribInfo,FSharp.Compiler.TypedTree.EntityRef,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILAttribElem},Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,FSharp.Compiler.AbstractIL.IL.ILType,System.Boolean,FSharp.Compiler.AbstractIL.IL.ILAttribElem}}},Microsoft.FSharp.Core.FSharpOption{``0}},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.Attrib,Microsoft.FSharp.Core.FSharpOption{``0}},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpOption{System.Object}},Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,Microsoft.FSharp.Core.FSharpOption{System.Object}}}},Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Shared helper for binding attributes
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isReturnsResumableCodeTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 The delegate type ResumableCode, or any function returning this a delegate type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isResumableCodeTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Any delegate type with ResumableCode attribute, or any function returning such a delegate type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkLabelled(FSharp.Compiler.Text.Range,System.Int32,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Add a label to use as the target for a goto
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|TryFinallyExpr|_|(FSharp.Compiler.TypedTree.Expr)">
<summary>
 Recognise a try-finally expression
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|TryWithExpr|_|(FSharp.Compiler.TypedTree.Expr)">
<summary>
 Recognise a try-with expression
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|IntegerForLoopExpr|_|(FSharp.Compiler.TypedTree.Expr)">
<summary>
 Recognise an integer for-loop expression
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|WhileExpr|_|(FSharp.Compiler.TypedTree.Expr)">
<summary>
 Recognise a while expression
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|ResumeAtExpr|_|(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Recognise a &apos;__resumeAt&apos; expression
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|DebugPointExpr|_|(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Recognise a &apos;__debugPoint&apos; expression
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|SequentialResumableCode|_|(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Recognise a sequential or binding construct in a resumable code
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|StructStateMachineExpr|_|(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Recognise a &apos;__stateMachine&apos; expression
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|ResumableEntryMatchExpr|_|(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Recognise a &apos;match __resumableEntry() with ...&apos; expression
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|IfUseResumableStateMachinesExpr|_|(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Match &apos;if __useResumableCode then ... else ...&apos; expressions
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|DelegateInvokeExpr|_|(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Match a .Invoke on a delegate
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|NewDelegateExpr|_|(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Match expressions that represent the creation of an instance of an F# delegate value
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|ValApp|_|(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.ValRef,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Match expressions that are an application of a particular F# function value
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.EmptyTraitWitnessInfoHashMap``1(FSharp.Compiler.TcGlobals.TcGlobals)">
<summary>
 Create an empty immutable mapping from witnesses to some data
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkOptimizedRangeLoop(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,FSharp.Compiler.Text.Range,FSharp.Compiler.Text.Range,FSharp.Compiler.Syntax.DebugPointAtWhile,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Expr,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.Expr,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.Expr,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Expr}},FSharp.Compiler.TypedTree.Expr},FSharp.Compiler.TypedTree.Expr}})">
<summary>
 Makes an optimized while-loop for a range expression with the given integral start, step, and finish:

 start..step..finish

 The buildLoop function enables using the precomputed iteration count in an optional initialization step before the loop is executed.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|IntegralRange|_|(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Matches if the given expression is an application
 of the range or range-step operator on an integral type
 and returns the type, start, step, and finish if so.

 start..finish

 start..step..finish
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|SpecialComparableHeadType|_|(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determines types that are potentially known to satisfy the &apos;comparable&apos; constraint and returns
 a set of residual types that must also satisfy the constraint
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.ActivePatternInfo.OverallType(FSharp.Compiler.Syntax.PrettyNaming.ActivePatternInfo,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.TypedTree.ActivePatternReturnKind)">
<summary>
 Get the overall type for a function that implements the active pattern
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.ActivePatternInfo.ResultType(FSharp.Compiler.Syntax.PrettyNaming.ActivePatternInfo,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.TypedTree.ActivePatternReturnKind)">
<summary>
 Get the result type for the active pattern
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.ActivePatternInfo.DisplayNameByIdx(FSharp.Compiler.Syntax.PrettyNaming.ActivePatternInfo,System.Int32)">
<summary>
 Get the display name for one of the cases of the active pattern, by index
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.ActivePatternInfo.DisplayNameCoreByIdx(FSharp.Compiler.Syntax.PrettyNaming.ActivePatternInfo,System.Int32)">
<summary>
 Get the core of the display name for one of the cases of the active pattern, by index
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkFastForLoop(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Syntax.DebugPointAtFor,FSharp.Compiler.Syntax.DebugPointAtInOrTo,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.Val,FSharp.Compiler.TypedTree.Expr,System.Boolean,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Build for loops
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isSpanLikeTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Check if the type is a byref-like but not a byref.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.TryDecodeTypeProviderAssemblyAttr(FSharp.Compiler.AbstractIL.IL.ILAttribute)">
<summary>
 returns Some(assemblyName) for success
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.TryFindAttributeUsageAttribute(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Try to find the AttributeUsage attribute, looking for the value of the AllowMultiple named parameter
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.TyconRefHasAttributeByName(FSharp.Compiler.Text.Range,System.String,FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Try to find an attribute with a specific full name on a type definition
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.TyconRefHasAttribute(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,FSharp.Compiler.TcGlobals.BuiltinAttribInfo,FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Try to find a specific attribute on a type definition
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.TryFindTyconRefBoolAttribute(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,FSharp.Compiler.TcGlobals.BuiltinAttribInfo,FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Try to find a specific attribute on a type definition, where the attribute accepts a bool argument.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.TryFindTyconRefStringAttribute(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,FSharp.Compiler.TcGlobals.BuiltinAttribInfo,FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Try to find a specific attribute on a type definition, where the attribute accepts a string argument.

 This is used to detect the &apos;DefaultMemberAttribute&apos; and &apos;ConditionalAttribute&apos; attributes (on type definitions)
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.tryMkCallCoreFunctionAsBuiltInWitness(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TcGlobals.IntrinsicValRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Expr},FSharp.Compiler.Text.Range)">
<summary>
 Use an operator as a witness
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.tryMkCallBuiltInWitness(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TraitConstraintInfo,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Expr},FSharp.Compiler.Text.Range)">
<summary>
 Use a witness in BuiltInWitnesses
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkCall_sprintf(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.Expr,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Expr})">
<summary>
 Make a call to the &apos;isprintf&apos; function for string interpolation
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkTypedOne(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Makes an expression holding a constant 1 value of the given numeric type.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkTypedZero(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Makes an expression holding a constant 0 value of the given numeric type.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkCompGenThenDoSequential(FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Expr)">
<summary>
 This is used for tacking on code _after_ the expression. The SuppressStmt
 setting is used for debug points, suppressing the debug points for the statement if possible.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkCompGenSequential(FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Expr)">
<summary>
 This is used for tacking on code _before_ the expression. The SuppressStmt
 setting is used for debug points, suppressing the debug points for the statement if possible.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkNone(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.Text.Range)">
<summary>
 Create the expression &apos;None&apos; for an option-type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkSome(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.Text.Range)">
<summary>
 Create the expression &apos;Some(expr)&apos;
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkCons(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Create the expression &apos;headExpr:: tailExpr&apos;
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkNil(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Create the expression &apos;[]&apos; for a list type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkValueNone(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.Text.Range)">
<summary>
 Create the struct expression &apos;ValueNone&apos; for an voption type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkValueSome(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.Text.Range)">
<summary>
 Create the expression &apos;ValueSome(expr)&apos;
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkAnySomeCase(FSharp.Compiler.TcGlobals.TcGlobals,System.Boolean)">
<summary>
 Create the struct union case &apos;Some&apos; or &apos;ValueSome(expr)&apos; for a voption type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkValueSomeCase(FSharp.Compiler.TcGlobals.TcGlobals)">
<summary>
 Create the struct union case &apos;ValueSome(expr)&apos; for a voption type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkValueNoneCase(FSharp.Compiler.TcGlobals.TcGlobals)">
<summary>
 Create the struct union case &apos;ValueNone&apos; for a voption type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkSomeCase(FSharp.Compiler.TcGlobals.TcGlobals)">
<summary>
 Create the union case &apos;Some(expr)&apos; for an option type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkNoneCase(FSharp.Compiler.TcGlobals.TcGlobals)">
<summary>
 Create the union case &apos;None&apos; for an option type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkNullableTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Create the Nullable type for a given element type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkValueOptionTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Create the voption type for a given element type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkOptionTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Create the option type for a given element type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkListTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Create the list type for a given element type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkIEnumeratorTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Create the IEnumerator type for a given element type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkSeqTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Create the IEnumerable (seq) type for a given element type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkRefCellTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Create the FSharpRef type for a given element type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.destRefCellTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Get the element type of an FSharpRef type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isRefCellTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Check if a type is an FSharpRef type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.GetDisallowedNullness(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 A type coming via interop from C# can be holding a nullness combination not supported in F#.
 Prime example are APIs marked as T|null applied to structs, tuples and anons.
 Unsupported values can also be nested within generic type arguments, e.g. a List&lt;Tuple&lt;string,T|null&gt;&gt; applied to an anon.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|ByrefTy|_|(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Matches any byref type, yielding the target type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|StripNullableTy|(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 An active pattern to transform System.Nullable types to their input, otherwise leave the input unchanged
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|NullableTy|_|(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 An active pattern to match System.Nullable types
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|AppTy|_|(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 An active pattern to determine if a type is a nominal type, possibly instantiated
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.StripSelfRefCell(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.ValBaseOrThisInfo,FSharp.Compiler.TypedTree.TType)">
<summary>
 For &quot;type Class as self&quot;, &apos;self&apos; is fixed up after initialization. To support this,
 it is converted behind the scenes to a ref. This function strips off the ref and
 returns the underlying type.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isStructRecordOrUnionTyconTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is a struct, record or union type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isNumericType(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is a numeric type type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isNonDecimalNumericType(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is a non-decimal numeric type type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isDecimalTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is a decimal type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isFpTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is a floating point type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isIntegerTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is an integer type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isUnsignedIntegerTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is an unsigned integer type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isSignedIntegerTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is a signed integer type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isEnumTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is an enum type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isClassTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is a class type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isUnmanagedTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is an unmanaged type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isReferenceTyparTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is a variable type with the &apos;: not struct&apos; constraint.

 Note, isRefTy does not include type parameters with the &apos;: not struct&apos; constraint
 This predicate is used to detect those type parameters.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isNonNullableStructTyparTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is a variable type with the &apos;: struct&apos; constraint.

 Note, isStructTy does not include type parameters with the &apos;: struct&apos; constraint
 This predicate is used to detect those type parameters.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isStructTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is a struct type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isStructTyconRef(FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Determine if TyconRef is to a struct type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.normalizeEnumTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 If the input type is an enum type, then convert to its underlying type, otherwise return the input type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.underlyingTypeOfEnumTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine the underlying type of an enum type (normally int32)
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isComInteropTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is a ComInterop type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isSealedTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is a sealed type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isForallFunctionTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is a function (including generic). Not the same as isFunTy.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isRefTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is a reference type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isInterfaceTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is an interface type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isFSharpDelegateTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is a delegate type defined in F#
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isDelegateTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is a delegate type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isInterfaceTyconRef(FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Determine if a reference to a type definition is an interface type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.rankOfArrayTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Get the rank of an array type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.destArrayTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Get the element type of an array type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isVoidTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is the System.Void type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isValueTypeTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is the System.ValueType type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isObjTyWithoutNull(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is a strictly non-nullable System.Object type. If nullness checking is disabled, this returns false.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isObjNullTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is the (System.Object | null) type. Allows either nullness if null checking is disabled.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isObjTyAnyNullness(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is the System.Object type with any nullness qualifier
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isUnitTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is the F# unit type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.rankOfArrayTyconRef(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Determine the rank of one of the artificial type definitions used for array types
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isArrayTyconRef(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Check if a type definition is one of the artificial type definitions used for array types of different ranks
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkArrayTy(FSharp.Compiler.TcGlobals.TcGlobals,System.Int32,FSharp.Compiler.TypedTree.Nullness,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.Text.Range)">
<summary>
 Build an array type of the given rank
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.destListTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Get the element type of an F# list type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.destArrayTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Get the element type of an array type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isArray1DTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is a single-dimensional array type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isArrayTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is any kind of array type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isILAppTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is a nominal .NET type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isListTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is an F# list type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isStringTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is the System.String type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.metadataOfTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Extract metadata from a type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.metadataOfTycon(FSharp.Compiler.TypedTree.Entity)">
<summary>
 Extract metadata from a type definition
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkPrintfFormatTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.TType)">
<summary>
 Build an PrintFormat type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkLazyTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Build an Lazy type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkIObserverType(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Build an IObserver type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkIObservableType(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Build an IObservable type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkIEventType(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.TType)">
<summary>
 Build an IEvent type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.destIDelegateEventType(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Take apart an IDelegateEvent type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isIDelegateEventType(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is an IDelegateEvent type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.tryDestLinqExpressionTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Try to take apart a System.Linq.Expression type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.destLinqExpressionTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Take apart a System.Linq.Expression type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isLinqExpressionTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is a System.Linq.Expression type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.destNullableTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Take apart a System.Nullable type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.tryDestNullableTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Try to take apart a System.Nullable type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isNullableTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine is a type is a System.Nullable type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.destChoiceTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType,System.Int32)">
<summary>
 Try to take apart an Choice type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.tryDestChoiceTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType,System.Int32)">
<summary>
 Take apart an Choice type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.destValueOptionTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Try to take apart an option type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.tryDestOptionTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Try to take apart an option type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.destOptionTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Take apart an option type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isChoiceTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is an Choice type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isOptionTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is an option type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isValueOptionTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is a value option type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isBoolTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type is a bool type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkArrayType(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Build a single-dimensional array type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkVoidPtrTy(FSharp.Compiler.TcGlobals.TcGlobals)">
<summary>
 Build a &apos;voidptr&apos; type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkNativePtrTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Build a nativeptr type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.FoldExpr``1(FSharp.Compiler.TypedTreeOps.ExprFolder{``0},``0,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Fold over all the expressions in an expression
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.FoldImplFile``1(FSharp.Compiler.TypedTreeOps.ExprFolder{``0},``0,FSharp.Compiler.TypedTree.CheckedImplFile)">
<summary>
 Fold over all the expressions in an implementation file
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.ExprFolder0``1">
<summary>
 The empty set of actions for folding over expressions
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.JoinTyparStaticReq(FSharp.Compiler.Syntax.TyparStaticReq,FSharp.Compiler.Syntax.TyparStaticReq)">
<summary>
 Combine two static-resolution requirements on a type parameter
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.MakeFSharpDelegateInvokeAndTryBetaReduce(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.Text.Range)">
<summary>
 Make a delegate invoke expression for an F# delegate type, doing beta reduction by introducing let-bindings
 if the delegate expression is a construction of a delegate.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.MakeApplicationAndBetaReduce(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType}},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Expr},FSharp.Compiler.Text.Range)">
<summary>
 Make an application expression, doing beta reduction by introducing let-bindings
 if the function expression is a construction of a lambda
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.AdjustArityOfLambdaBody(FSharp.Compiler.TcGlobals.TcGlobals,System.Int32,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Val},FSharp.Compiler.TypedTree.Expr)">
<summary>
 Given a lambda expression, adjust it to have be one or two lambda expressions (fun a -&gt; (fun b -&gt; ...))
 where the first has the given arguments.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.MultiLambdaToTupledLambda(FSharp.Compiler.TcGlobals.TcGlobals,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Val},FSharp.Compiler.TypedTree.Expr)">
<summary>
 Given a lambda expression taking multiple variables, build a corresponding lambda taking a tuple
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.IterateRecursiveFixups(FSharp.Compiler.TcGlobals.TcGlobals,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.Val},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.Val},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.Expr,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Expr},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.Expr,Microsoft.FSharp.Core.Unit}}}},FSharp.Compiler.TypedTree.Expr,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Expr},FSharp.Compiler.TypedTree.Expr)">
<summary>
  Work out what things on the right-han-side of a &apos;let rec&apos; recursive binding need to be fixed up
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.primMkMatch(FSharp.Compiler.Syntax.DebugPointAtBinding,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.DecisionTree,FSharp.Compiler.TypedTree.DecisionTreeTarget[],FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Make a &apos;match&apos; expression without applying any peep-hole optimizations.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkAndSimplifyMatch(FSharp.Compiler.Syntax.DebugPointAtBinding,FSharp.Compiler.Text.Range,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.DecisionTree,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.DecisionTreeTarget})">
<summary>
 Make a &apos;match&apos; expression applying some peep-hole optimizations along the way, e.g to
 pre-decide the branch taken at compile-time.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.accTargetsOfDecisionTree(FSharp.Compiler.TypedTree.DecisionTree,Microsoft.FSharp.Collections.FSharpList{System.Int32})">
<summary>
  Accumulate the targets actually used in a decision graph (for reporting warnings)
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkRecdFieldGet(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.RecdFieldRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.Text.Range)">
<summary>
 Build an expression representing the read of an instance class or record field.
 First take the address of the record expression if it is a struct.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkValAddr(FSharp.Compiler.Text.Range,System.Boolean,FSharp.Compiler.TypedTree.ValRef)">
<summary>
 Build an expression to take the address of a local
 &amp;localv
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkAddrGet(FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.ValRef)">
<summary>
 Build an expression to dereference a local pointer
 *localv_ptr
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkAddrSet(FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.ValRef,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Build an expression to mutate the contents of a local pointer
  *localv_ptr = e
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkValSet(FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.ValRef,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Build an expression to mutate a local
   localv &lt;- e
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkTyAppExpr(FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType})">
<summary>
 Build the application of a generic construct to a set of type arguments.
 Reduce the application via substitution if the function value is a typed lambda expression.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkApps(FSharp.Compiler.TcGlobals.TcGlobals,System.Tuple{FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType}},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Expr},FSharp.Compiler.Text.Range)">
<summary>
 Build the application of a (possibly generic, possibly curried) function value to a set of type and expression arguments.
 Reduce the application via let-bindings if the function value is a lambda expression.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.primMkApp(FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Expr},FSharp.Compiler.Text.Range)">
<summary>
 Build the application of a (possibly generic, possibly curried) function value to a set of type and expression arguments
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.remarkExpr(FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Adjust marks in expressions, replacing all marks by the given mark.
 Used when inlining.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.IsHiddenRecdField(Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Compiler.TypedTreeOps.Remap,FSharp.Compiler.TypedTreeOps.SignatureHidingInfo}},FSharp.Compiler.TypedTree.RecdFieldRef)">
<summary>
 Determine if a record field is hidden by a signature
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.IsHiddenVal(Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Compiler.TypedTreeOps.Remap,FSharp.Compiler.TypedTreeOps.SignatureHidingInfo}},FSharp.Compiler.TypedTree.Val)">
<summary>
 Determine if a member, function or value is hidden by a signature
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.IsHiddenTyconRepr(Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Compiler.TypedTreeOps.Remap,FSharp.Compiler.TypedTreeOps.SignatureHidingInfo}},FSharp.Compiler.TypedTree.Entity)">
<summary>
 Determine if the representation of a type definition is hidden by a signature
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.IsHiddenTycon(Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Compiler.TypedTreeOps.Remap,FSharp.Compiler.TypedTreeOps.SignatureHidingInfo}},FSharp.Compiler.TypedTree.Entity)">
<summary>
 Determine if a type definition is hidden by a signature
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.DoRemapVal(Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Compiler.TypedTreeOps.Remap,FSharp.Compiler.TypedTreeOps.SignatureHidingInfo}},FSharp.Compiler.TypedTree.Val)">
<summary>
 Get the value including fsi remapping
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.DoRemapTycon(Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Compiler.TypedTreeOps.Remap,FSharp.Compiler.TypedTreeOps.SignatureHidingInfo}},FSharp.Compiler.TypedTree.Entity)">
<summary>
 Get the value including fsi remapping
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.ApplyExportRemappingToEntity(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTreeOps.Remap,FSharp.Compiler.TypedTree.Entity)">
<summary>
 Make a remapping table for viewing a module or namespace &apos;from the outside&apos;
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.MakeExportRemapping(FSharp.Compiler.TypedTree.CcuThunk,FSharp.Compiler.TypedTree.Entity)">
<summary>
 Make the substitution (remapping) table for viewing a module or namespace &apos;from the outside&apos;

 Given the top-most signatures constrains the public compilation units
 of an assembly, compute a remapping that converts local references to non-local references.
 This remapping must be applied to all pickled expressions and types
 exported from the assembly.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.tryRescopeVal(FSharp.Compiler.TypedTree.CcuThunk,FSharp.Compiler.TypedTreeOps.Remap,FSharp.Compiler.TypedTree.Val)">
<summary>
 Given a value definition, try to produce a reference to that value. Fails for local values.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.tryRescopeEntity(FSharp.Compiler.TypedTree.CcuThunk,FSharp.Compiler.TypedTree.Entity)">
<summary>
 Given a namespace, module or type definition, try to produce a reference to that entity.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.wrapModuleOrNamespaceType(FSharp.Compiler.Syntax.Ident,FSharp.Compiler.TypedTree.CompilationPath,FSharp.Compiler.TypedTree.ModuleOrNamespaceType)">
<summary>
 Wrap one module or namespace definition in a &apos;module M = ..&apos; outer wrapper
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.wrapModuleOrNamespaceTypeInNamespace(FSharp.Compiler.Syntax.Ident,FSharp.Compiler.TypedTree.CompilationPath,FSharp.Compiler.TypedTree.ModuleOrNamespaceType)">
<summary>
 Wrap one module or namespace definition in a &apos;namespace N&apos; outer wrapper
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.wrapModuleOrNamespaceContentsInNamespace(System.Boolean,FSharp.Compiler.Syntax.Ident,FSharp.Compiler.TypedTree.CompilationPath,FSharp.Compiler.TypedTree.ModuleOrNamespaceContents)">
<summary>
 Wrap one module or namespace implementation in a &apos;namespace N&apos; outer wrapper
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.ComputeImplementationHidingInfoAtAssemblyBoundary(FSharp.Compiler.TypedTree.ModuleOrNamespaceContents,FSharp.Compiler.TypedTreeOps.SignatureHidingInfo)">
<summary>
 Compute the hiding information that corresponds to the hiding applied at an assembly boundary
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.ComputeSignatureHidingInfoAtAssemblyBoundary(FSharp.Compiler.TypedTree.ModuleOrNamespaceType,FSharp.Compiler.TypedTreeOps.SignatureHidingInfo)">
<summary>
 Compute the hiding information that corresponds to the hiding applied at an assembly boundary
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.ComputeRemappingFromInferredSignatureToExplicitSignature(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.ModuleOrNamespaceType,FSharp.Compiler.TypedTree.ModuleOrNamespaceType)">
<summary>
 Compute the remapping information implied by an explicit signature being given for an inferred signature
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.ComputeRemappingFromImplementationToSignature(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.ModuleOrNamespaceContents,FSharp.Compiler.TypedTree.ModuleOrNamespaceType)">
<summary>
 Compute the remapping information implied by a signature being inferred for a particular implementation
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.instExpr(FSharp.Compiler.TcGlobals.TcGlobals,Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Compiler.TypedTree.Typar,FSharp.Compiler.TypedTree.TType}},FSharp.Compiler.TypedTree.Expr)">
<summary>
 Instantiate the generic type parameters in an expression, building a new one
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.instSlotSig(Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Compiler.TypedTree.Typar,FSharp.Compiler.TypedTree.TType}},FSharp.Compiler.TypedTree.SlotSig)">
<summary>
 Instantiate the generic type parameters in a method slot signature, building a new one
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.copySlotSig(FSharp.Compiler.TypedTree.SlotSig)">
<summary>
 Copy a method slot signature, including new generic type parameters if the slot signature represents a generic method
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.copyImplFile(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTreeOps.ValCopyFlag,FSharp.Compiler.TypedTree.CheckedImplFile)">
<summary>
 Copy an entire implementation file using the given copying flags
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.copyExpr(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTreeOps.ValCopyFlag,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Copy an entire expression using the given copying flags
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.copyModuleOrNamespaceType(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTreeOps.ValCopyFlag,FSharp.Compiler.TypedTree.ModuleOrNamespaceType)">
<summary>
 Copy an entire module or namespace type using the given copying flags
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.remapPossibleForallTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTreeOps.Remap,FSharp.Compiler.TypedTree.TType)">
<summary>
 Remap a (possible generic) type using the given remapping substitution
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.remapAttrib(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTreeOps.Remap,FSharp.Compiler.TypedTree.Attrib)">
<summary>
 Remap an attribute using the given remapping substitution
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.remapExpr(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTreeOps.ValCopyFlag,FSharp.Compiler.TypedTreeOps.Remap,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Remap an expression using the given remapping substitution
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.remapValRef(FSharp.Compiler.TypedTreeOps.Remap,FSharp.Compiler.TypedTree.ValRef)">
<summary>
 Remap a reference to a value using the given remapping substitution
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.remapRecdFieldRef(FSharp.Compiler.TypedTreeOps.TyconRefMap{FSharp.Compiler.TypedTree.EntityRef},FSharp.Compiler.TypedTree.RecdFieldRef)">
<summary>
 Remap a reference to a record field using the given remapping substitution
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.remapUnionCaseRef(FSharp.Compiler.TypedTreeOps.TyconRefMap{FSharp.Compiler.TypedTree.EntityRef},FSharp.Compiler.TypedTree.UnionCaseRef)">
<summary>
 Remap a reference to a union case using the given remapping substitution
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.remapTyconRef(FSharp.Compiler.TypedTreeOps.TyconRefMap{FSharp.Compiler.TypedTree.EntityRef},FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Remap a reference to a type definition using the given remapping substitution
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.ClearValReprInfo(FSharp.Compiler.TypedTree.Val)">
<summary>
 Mutate a value to indicate it should be considered a local rather than a module-bound definition
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.InferValReprInfoOfBinding(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTreeOps.AllowTypeDirectedDetupling,FSharp.Compiler.TypedTree.Val,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Given a lambda binding, extract the ValReprInfo for its arguments and other details
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.InferValReprInfoOfExpr(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTreeOps.AllowTypeDirectedDetupling,FSharp.Compiler.TypedTree.TType,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Attrib}}},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Attrib},FSharp.Compiler.TypedTree.Expr)">
<summary>
 Given a lambda expression, extract the ValReprInfo for its arguments and other details
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.stripTopLambda(FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType)">
<summary>
 Given a (curried) lambda expression, pull off its arguments
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.tyOfExpr(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Compute the type of an expression from the expression itself
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.freeVarsAllPublic(FSharp.Compiler.TypedTree.FreeVars)">
<summary>
 Check if a set of free variables are all public
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.freeTyvarsAllPublic(FSharp.Compiler.TypedTree.FreeTyvars)">
<summary>
 Check if a set of free type variables are all public
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.freeInBindingRhs(FSharp.Compiler.TypedTreeOps.FreeVarOptions,FSharp.Compiler.TypedTree.Binding)">
<summary>
 Get the free variables in the right hand side of a binding.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.freeInExpr(FSharp.Compiler.TypedTreeOps.FreeVarOptions,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Get the free variables in an expression.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.accFreeInExpr(FSharp.Compiler.TypedTreeOps.FreeVarOptions,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.FreeVars)">
<summary>
 Get the free variables in an expression with accumulator
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.freeInModuleOrNamespace(FSharp.Compiler.TypedTreeOps.FreeVarOptions,FSharp.Compiler.TypedTree.ModuleOrNamespaceContents)">
<summary>
 Get the free variables in a module definition.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.qualifiedMangledNameOfTyconRef(FSharp.Compiler.TypedTree.EntityRef,System.String)">
<summary>
 A unique qualified name for each type definition, used to qualify the names of interface implementation methods
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.fullDisplayTextOfModRef(FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Return the full text for an item as we want it displayed to the user as a fully qualified entity
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.CountEnclosingTyparsOfActualParentOfVal(FSharp.Compiler.TypedTree.Val)">
<summary>
 Count the number of type parameters on the enclosing type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.PartitionValRefTypars(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.ValRef)">
<summary>
 Returns (parentTypars,memberParentTypars,memberMethodTypars,memberToParentInst,tinst)
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.PartitionValTypars(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Val)">
<summary>
 Returns (parentTypars,memberParentTypars,memberMethodTypars,memberToParentInst,tinst)
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.PartitionValTyparsForApparentEnclosingType(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Val)">
<summary>
 Returns (parentTypars,memberParentTypars,memberMethodTypars,memberToParentInst,tinst)
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.tryNiceEntityRefOfTy(FSharp.Compiler.TypedTree.TType)">
<summary>
 Try to get a TyconRef for a type without erasing type abbreviations
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.stripExnEqns(FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 See through F# exception abbreviations
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.stripTyEqnsA(FSharp.Compiler.TcGlobals.TcGlobals,System.Boolean,FSharp.Compiler.TypedTree.TType)">
<summary>
 set bool to &apos;true&apos; to allow shortcutting of type parameter equation chains during stripping
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.generalizeTypars(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar})">
<summary>
 From typars to types
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.valRefEq(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.ValRef,FSharp.Compiler.TypedTree.ValRef)">
<summary>
 Equality for value references
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.tyconRefEq(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.EntityRef,FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Equality for type definition references
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreeOps.typarOrder">
<summary>
 An ordering for type parameters, based on stamp
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreeOps.recdFieldRefOrder">
<summary>
 An ordering for record fields, based on stamp
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreeOps.tyconOrder">
<summary>
 An ordering for type definitions, based on stamp
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreeOps.valOrder">
<summary>
 An ordering for value definitions, based on stamp
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkExprAddrOfExpr(FSharp.Compiler.TcGlobals.TcGlobals,System.Boolean,System.Boolean,FSharp.Compiler.TypedTreeOps.Mutates,FSharp.Compiler.TypedTree.Expr,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.ValRef},FSharp.Compiler.Text.Range)">
<summary>
 Take the address of an expression, or force it into a mutable local. Any allocated
 mutable local may need to be kept alive over a larger expression, hence we return
 a wrapping function that wraps &quot;let mutable loc = Expr in ...&quot; around a larger
 expression.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkExprAddrOfExprAux(FSharp.Compiler.TcGlobals.TcGlobals,System.Boolean,System.Boolean,FSharp.Compiler.TypedTreeOps.Mutates,FSharp.Compiler.TypedTree.Expr,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.ValRef},FSharp.Compiler.Text.Range)">
<summary>
 Helper to take the address of an expression
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkDerefAddrExpr(FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Helper to create an expression that dereferences an address.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.convertToTypeWithMetadataIfPossible(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 If it is a tuple type, ensure it&apos;s outermost type is a .NET tuple type, otherwise leave unchanged
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.evalAnonInfoIsStruct(FSharp.Compiler.TypedTree.AnonRecdTypeInfo)">
<summary>
 Evaluate the AnonRecdTypeInfo to work out if it is a struct or a ref.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.evalTupInfoIsStruct(FSharp.Compiler.TypedTree.TupInfo)">
<summary>
 Evaluate the TupInfo to work out if it is a struct or a ref.  Currently this is very simple
 but TupInfo may later be used carry variables that infer structness.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkGetTupleItemN(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,System.Int32,FSharp.Compiler.AbstractIL.IL.ILType,System.Boolean,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType)">
<summary>
 Make a TAST expression representing getting an item from a tuple
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkCompiledTuple(FSharp.Compiler.TcGlobals.TcGlobals,System.Boolean,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Expr},FSharp.Compiler.Text.Range)">
<summary>
 Convert from F# tuple creation expression to .NET tuple creation expressions
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkCompiledTupleTy(FSharp.Compiler.TcGlobals.TcGlobals,System.Boolean,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType})">
<summary>
 Convert from F# tuple types to .NET tuple types.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkCompiledTupleTyconRef(FSharp.Compiler.TcGlobals.TcGlobals,System.Boolean,System.Int32)">
<summary>
 Get a TyconRef for a .NET tuple type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isCompiledTupleTyconRef(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Check if a TyconRef is for a .NET tuple type. Currently this includes Tuple`1 even though
 that&apos; not really part of the target set of TyconRef used to represent F# tuples.
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreeOps.goodTupleFields">
<summary>
 The number of fields in the largest tuple before we start encoding, i.e. 7
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreeOps.maxTuple">
<summary>
 The largest tuple before we start encoding, i.e. 7
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkArrayElemAddress(FSharp.Compiler.TcGlobals.TcGlobals,System.Boolean,FSharp.Compiler.AbstractIL.IL.ILReadonly,System.Boolean,FSharp.Compiler.AbstractIL.IL.ILArrayShape,FSharp.Compiler.TypedTree.TType,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Expr},FSharp.Compiler.Text.Range)">
<summary>
 Make an expression that gets the address of an element in an array
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkExnCaseFieldSet(FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.EntityRef,System.Int32,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.Text.Range)">
<summary>
 Make an expression that sets an instance field in an F# exception value
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkExnCaseFieldGet(FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.EntityRef,System.Int32,FSharp.Compiler.Text.Range)">
<summary>
 Make an expression that gets an instance field from an F# exception value
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkUnionCaseFieldGetUnproven(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.UnionCaseRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},System.Int32,FSharp.Compiler.Text.Range)">
<summary>
 Like mkUnionCaseFieldGetUnprovenViaExprAddr, but for struct-unions, the input should be a copy of the expression.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkUnionCaseFieldSet(FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.UnionCaseRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},System.Int32,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.Text.Range)">
<summary>
 Build a &apos;TOp.UnionCaseFieldSet&apos; expression. For ref-unions, the input expression has &apos;TType_ucase&apos;, which is
 an F# compiler internal &quot;type&quot; corresponding to the union case. For struct-unions,
 the input should be the address of the expression.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkUnionCaseFieldGetUnprovenViaExprAddr(FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.UnionCaseRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},System.Int32,FSharp.Compiler.Text.Range)">
<summary>
 Build a &apos;TOp.UnionCaseFieldGetAddr&apos; expression for a field of a union when we&apos;ve already determined the value to be a particular union case. For ref-unions,
 the input expression has &apos;TType_ucase&apos;, which is an F# compiler internal &quot;type&quot; corresponding to the union case. For struct-unions,
 the input should be the address of the expression.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkUnionCaseFieldGetAddrProvenViaExprAddr(System.Boolean,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.UnionCaseRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},System.Int32,FSharp.Compiler.Text.Range)">
<summary>
 Build a &apos;TOp.UnionCaseFieldGetAddr&apos; expression for a field of a union when we&apos;ve already determined the value to be a particular union case. For ref-unions,
 the input expression has &apos;TType_ucase&apos;, which is an F# compiler internal &quot;type&quot; corresponding to the union case. For struct-unions,
 the input should be the address of the expression.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkUnionCaseFieldGetProvenViaExprAddr(FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.UnionCaseRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},System.Int32,FSharp.Compiler.Text.Range)">
<summary>
 Build a &apos;TOp.UnionCaseFieldGet&apos; expression for something we&apos;ve already determined to be a particular union case. For ref-unions,
 the input expression has &apos;TType_ucase&apos;, which is an F# compiler internal &quot;type&quot; corresponding to the union case. For struct-unions,
 the input should be the address of the expression.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkUnionCaseProof(FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.UnionCaseRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.Text.Range)">
<summary>
 Make a &apos;TOp.UnionCaseProof&apos; expression, which proves a union value is over a particular case (used only for ref-unions, not struct-unions)
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkUnionCaseTest(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.UnionCaseRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.Text.Range)">
<summary>
 Make an expression which tests that a union value is of a particular union case.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkUnionCaseTagGetViaExprAddr(FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.EntityRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.Text.Range)">
<summary>
 Make an expression that gets the tag of a union value (via the address of the value if it is a struct)
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkRecdFieldSetViaExprAddr(FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.RecdFieldRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.Text.Range)">
<summary>
 Make an expression that sets an instance the field of a record or class (via the address of the value if it is a struct)
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkStaticRecdFieldGetAddr(System.Boolean,FSharp.Compiler.TypedTree.RecdFieldRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.Text.Range)">
<summary>
 Make an expression that gets the address of a static field in a record or class
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkStaticRecdFieldSet(FSharp.Compiler.TypedTree.RecdFieldRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.Text.Range)">
<summary>
 Make an expression that sets a static field in a record or class
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkStaticRecdFieldGet(FSharp.Compiler.TypedTree.RecdFieldRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.Text.Range)">
<summary>
 Make an expression that gets a static field from a record or class
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkRecdFieldGetAddrViaExprAddr(System.Boolean,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.RecdFieldRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.Text.Range)">
<summary>
 Make an expression that gets the address of an instance field from a record or class (via the address of the value if it is a struct)
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkRecdFieldGetViaExprAddr(FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.RecdFieldRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.Text.Range)">
<summary>
 Make an expression that gets an instance field from a record or class (via the address of the value if it is a struct)
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkAnonRecdFieldGetViaExprAddr(FSharp.Compiler.TypedTree.AnonRecdTypeInfo,FSharp.Compiler.TypedTree.Expr,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},System.Int32,FSharp.Compiler.Text.Range)">
<summary>
 Make an expression that gets an item from an anonymous record (via the address of the value if it is a struct)
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkAnonRecdFieldGet(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.AnonRecdTypeInfo,FSharp.Compiler.TypedTree.Expr,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},System.Int32,FSharp.Compiler.Text.Range)">
<summary>
 Make an expression that gets an item from an anonymous record
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkTupleFieldGet(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TupInfo,FSharp.Compiler.TypedTree.Expr,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},System.Int32,FSharp.Compiler.Text.Range)">
<summary>
 Make an expression that gets an item from a tuple
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkReraiseLibCall(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.Text.Range)">
<summary>
 Make an expression that re-raises an exception via a library call
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkReraise(FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Make an expression that re-raises an exception
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkCoerceExpr(FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Make an expression that coerces one expression to another type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkAsmExpr(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILInstr},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Expr},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.Text.Range)">
<summary>
 Make an expression that is IL assembly code
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkExnExpr(FSharp.Compiler.TypedTree.EntityRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Expr},FSharp.Compiler.Text.Range)">
<summary>
 Make an expression that constructs an exception value
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkUnionCaseExpr(FSharp.Compiler.TypedTree.UnionCaseRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Expr},FSharp.Compiler.Text.Range)">
<summary>
 Make an expression that constructs a union case, e.g. &apos;Some(expr)&apos;
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkOutByrefTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Make an out-byref type with an out kind parameter
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkInByrefTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Make a in-byref type with a in kind parameter
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkByrefTyWithInference(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.TType)">
<summary>
 Make a byref type with a in/out kind inference parameter
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkByrefTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Make a byref type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkLazyOr(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Make the expression corresponding to &apos;expr1 || expr2&apos;
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkLazyAnd(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Make the expression corresponding to &apos;expr1 &amp;&amp; expr2&apos;
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.isBeingGeneralized(FSharp.Compiler.TypedTree.Typar,FSharp.Compiler.TypedTreeOps.GeneralizedType)">
<summary>
 Test if the type parameter is one of those being generalized by a type scheme.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkGenericBindRhs(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},FSharp.Compiler.TypedTreeOps.GeneralizedType,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Make the right-hand side of a generalized binding, incorporating the generalized generic parameters from the type
 scheme into the right-hand side as type generalizations.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkLetRecBinds(FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Binding},FSharp.Compiler.TypedTree.Expr)">
<summary>
 Make a let-rec expression that locally binds values to expressions where self-reference back to the values is possible.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkInvisibleBinds(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Val},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Expr})">
<summary>
 Make a set of bindings that bind values to expressions in an &quot;invisible&quot; way.
 Invisible bindings are not given a sequence point and should not have side effects.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkInvisibleBind(FSharp.Compiler.TypedTree.Val,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Make a binding that binds a value to an expression in an &quot;invisible&quot; way.
 Invisible bindings are not given a sequence point and should not have side effects.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkInvisibleLet(FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.Val,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Make a let-expression that locally binds a value to an expression in an &quot;invisible&quot; way.
 Invisible bindings are not given a sequence point and should not have side effects.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkCompGenLetMutableIn(FSharp.Compiler.Text.Range,System.String,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.Expr,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{FSharp.Compiler.TypedTree.Val,FSharp.Compiler.TypedTree.Expr},FSharp.Compiler.TypedTree.Expr})">
<summary>
 Make a mutable let-expression that locally binds a compiler-generated value to an expression, where the expression
 is returned by the given continuation. Compiler-generated bindings do not give rise to a sequence point in debugging.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkCompGenLetIn(FSharp.Compiler.Text.Range,System.String,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.Expr,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{FSharp.Compiler.TypedTree.Val,FSharp.Compiler.TypedTree.Expr},FSharp.Compiler.TypedTree.Expr})">
<summary>
 Make a let-expression that locally binds a compiler-generated value to an expression, where the expression
 is returned by the given continuation. Compiler-generated bindings do not give rise to a sequence point in debugging.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkCompGenLet(FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.Val,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Make a let-expression that locally binds a compiler-generated value to an expression.
 Compiler-generated bindings do not give rise to a sequence point in debugging.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkCompGenBinds(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Val},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Expr})">
<summary>
 Make a set of bindings that bind compiler generated values to corresponding expressions.
 Compiler-generated bindings do not give rise to a sequence point in debugging.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkMultiLambdaBind(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Val,FSharp.Compiler.Syntax.DebugPointAtBinding,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Val}},FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType)">
<summary>
 Make a binding that binds a function value to a lambda taking multiple arguments
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkLet(FSharp.Compiler.Syntax.DebugPointAtBinding,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.Val,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Build a user-level let expression
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkLetsFromBindings(FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Binding},FSharp.Compiler.TypedTree.Expr)">
<summary>
 Build a user-level value sequence of let bindings
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkLetsBind(FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Binding},FSharp.Compiler.TypedTree.Expr)">
<summary>
 Build a user-level value sequence of let bindings
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkLetBind(FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.Binding,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Build a user-level let-binding
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkBind(FSharp.Compiler.Syntax.DebugPointAtBinding,FSharp.Compiler.TypedTree.Val,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Build a user-level value binding
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkTryFinally(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.Syntax.DebugPointAtTry,FSharp.Compiler.Syntax.DebugPointAtFinally)">
<summary>
 Build a &apos;try/finally&apos; expression
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkTryWith(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Val,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Val,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.Syntax.DebugPointAtTry,FSharp.Compiler.Syntax.DebugPointAtWith)">
<summary>
 Build a &apos;try/with&apos; expression
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkIntegerForLoop(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Syntax.DebugPointAtFor,FSharp.Compiler.Syntax.DebugPointAtInOrTo,FSharp.Compiler.TypedTree.Val,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.ForLoopStyle,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.Text.Range)">
<summary>
 Build a &apos;for&apos; loop expression
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkWhile(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Syntax.DebugPointAtWhile,FSharp.Compiler.TypedTree.SpecialWhileLoopMarker,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.Text.Range)">
<summary>
 Build a &apos;while&apos; loop expression
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkMemberLambdas(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.Val},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.Val},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Val}},FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType)">
<summary>
 Build a lambda expression that corresponds to the implementation of a member
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkMultiLambdas(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Val}},FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType)">
<summary>
 Build an iterated generic (type abstraction + tupled+curried) lambda expression
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkMultiLambdasCore(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Val}},FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType)">
<summary>
 Build an iterated (tupled+curried) lambda expression
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkLambdas(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Val},FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType)">
<summary>
 Build an iterated (curried) lambda expression
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkTypeChoose(FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},FSharp.Compiler.TypedTree.Expr)">
<summary>
 Build an type-chose expression, indicating that a local free choice of a type variable
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkObjExpr(FSharp.Compiler.TypedTree.TType,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.Val},FSharp.Compiler.TypedTree.Expr,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.ObjExprMethod},Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Compiler.TypedTree.TType,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.ObjExprMethod}}},FSharp.Compiler.Text.Range)">
<summary>
 Build an object expression
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkTypeLambda(FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType)">
<summary>
 Build a generic lambda expression (type abstraction)
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkLambda(FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.Val,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType)">
<summary>
 Build a lambda expression taking a single value
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.rebuildLambda(FSharp.Compiler.Text.Range,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.Val},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.Val},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Val},FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType)">
<summary>
 Rebuild a lambda during an expression tree traversal
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkMultiLambda(FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Val},FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType)">
<summary>
 Build a lambda expression taking multiple values
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkCompGenLocalAndInvisibleBind(FSharp.Compiler.TcGlobals.TcGlobals,System.String,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Make a new mutable compiler-generated local value, &apos;let&apos; bind it to an expression
 &apos;invisibly&apos; (no sequence point etc.), and build an expression to reference it
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkMutableCompGenLocal(FSharp.Compiler.Text.Range,System.String,FSharp.Compiler.TypedTree.TType)">
<summary>
 Make a new mutable compiler-generated local value and build an expression to reference it
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkCompGenLocal(FSharp.Compiler.Text.Range,System.String,FSharp.Compiler.TypedTree.TType)">
<summary>
 Make a new compiler-generated local value and build an expression to reference it
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkLocal(FSharp.Compiler.Text.Range,System.String,FSharp.Compiler.TypedTree.TType)">
<summary>
 Make a new local value and build an expression to reference it
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.exprForValRef(FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.ValRef)">
<summary>
 Build an expression corresponding to the use of a reference to a value
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.exprForVal(FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.Val)">
<summary>
 Build an expression corresponding to the use of a value
 Note: try to use exprForValRef or the expression returned from mkLocal instead of this.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkIfThen(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Build an if-then statement
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkNonNullCond(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Build a conditional expression that checks for non-nullness
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkCond(FSharp.Compiler.Syntax.DebugPointAtBinding,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Build a conditional expression
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.primMkCond(FSharp.Compiler.Syntax.DebugPointAtBinding,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Build a conditional expression
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkBoolSwitch(FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.DecisionTree,FSharp.Compiler.TypedTree.DecisionTree)">
<summary>
 Add an if-then-else boolean conditional node into a decision tree
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|ExprValWithPossibleTypeInst|_|(FSharp.Compiler.TypedTree.Expr)">
<summary>
 Look for a use of an F# value, possibly including application of a generic thing to a set of type arguments
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.valsOfBinds(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Binding})">
<summary>
 Get the values for a set of bindings
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.|DebugPoints|(FSharp.Compiler.TypedTree.Expr)">
<summary>
 Match any &apos;Expr.Link&apos; and &apos;Expr.DebugPoint&apos; in an expression, providing the inner expression and a function to rebuild debug points
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.stripDebugPoints(FSharp.Compiler.TypedTree.Expr)">
<summary>
 Ignore &apos;Expr.Link&apos; and &apos;Expr.DebugPoint&apos; in an expression
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.stripExpr(FSharp.Compiler.TypedTree.Expr)">
<summary>
 Ignore &apos;Expr.Link&apos; in an expression
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.ensureCcuHasModuleOrNamespaceAtPath(FSharp.Compiler.TypedTree.CcuThunk,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.Ident},FSharp.Compiler.TypedTree.CompilationPath,FSharp.Compiler.Xml.XmlDoc)">
<summary>
 Module publication, used while compiling fslib.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkMultiLambdaTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Val},FSharp.Compiler.TypedTree.TType)">
<summary>
 Get the curried type corresponding to a lambda
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkLambdaTy(FSharp.Compiler.TcGlobals.TcGlobals,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.TypedTree.TType)">
<summary>
 Get the type corresponding to a lambda
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.typeOfLambdaArg(FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Val})">
<summary>
 Get the natural type of a single argument amongst a set of curried arguments
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkIteratedFunTy(FSharp.Compiler.TcGlobals.TcGlobals,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.TypedTree.TType)">
<summary>
 Build a curried function type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkForallTyIfNeeded(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},FSharp.Compiler.TypedTree.TType)">
<summary>
 Build a type-forall anonymous generic type if necessary
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.mkFunTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.TType)">
<summary>
 Build a function type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.stripTyEqnsWrtErasure(FSharp.Compiler.TypedTreeOps.Erasure,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Reduce a type to its more canonical form subject to an erasure flag, inference equations and abbreviations
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.getMeasureOfType(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Get the unit of measure for an annotated type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.measureEquiv(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Measure,FSharp.Compiler.TypedTree.Measure)">
<summary>
 Check the equivalence of two units-of-measure
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.typeEquiv(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.TType)">
<summary>
 Check the equivalence of two types
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.typeEquivAux(FSharp.Compiler.TypedTreeOps.Erasure,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.TType)">
<summary>
 Check the equivalence of two types up to an erasure flag
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.DefensiveCopyWarning">
<summary>
 An exception representing a warning for a defensive copy of an immutable struct
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.IntegralConst.|Zero|_|(FSharp.Compiler.TypedTree.Const)">
<summary>
 Constant 0.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.DebugPrint.recdFieldRefL(FSharp.Compiler.TypedTree.RecdFieldRef)">
<summary>
 Debug layout for class and record fields
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.DebugPrint.implFilesL(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.CheckedImplFile})">
<summary>
 Debug layout for a list of implementation files
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.DebugPrint.implFileL(FSharp.Compiler.TypedTree.CheckedImplFile)">
<summary>
 Debug layout for an implementation file
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.DebugPrint.decisionTreeL(FSharp.Compiler.TypedTree.DecisionTree)">
<summary>
 Debug layout for a decision tree
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.DebugPrint.tyconL(FSharp.Compiler.TypedTree.Entity)">
<summary>
 Debug layout for a type definition
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.DebugPrint.exprL(FSharp.Compiler.TypedTree.Expr)">
<summary>
 Debug layout for an expression
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.DebugPrint.bindingL(FSharp.Compiler.TypedTree.Binding)">
<summary>
 Debug layout for a binding of an expression to a value
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.DebugPrint.entityL(FSharp.Compiler.TypedTree.Entity)">
<summary>
 Debug layout for a module or namespace definition
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.DebugPrint.slotSigL(FSharp.Compiler.TypedTree.SlotSig)">
<summary>
 Debug layout for a method slot signature
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.DebugPrint.typeL(FSharp.Compiler.TypedTree.TType)">
<summary>
 Debug layout for a type
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.DebugPrint.typarsL(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar})">
<summary>
 Debug layout for a set of type parameters
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.DebugPrint.typarL(FSharp.Compiler.TypedTree.Typar)">
<summary>
 Debug layout for a type parameter
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.DebugPrint.traitL(FSharp.Compiler.TypedTree.TraitConstraintInfo)">
<summary>
 Debug layout for a trait constraint
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.DebugPrint.typarDeclL(FSharp.Compiler.TypedTree.Typar)">
<summary>
 Debug layout for a type parameter definition
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.DebugPrint.valL(FSharp.Compiler.TypedTree.Val)">
<summary>
 Debug layout for a value definition
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.DebugPrint.intL(System.Int32)">
<summary>
 Debug layout for an integer
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.DebugPrint.valAtBindL(FSharp.Compiler.TypedTree.Val)">
<summary>
 Debug layout for an value definition at its binding site
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.DebugPrint.unionCaseRefL(FSharp.Compiler.TypedTree.UnionCaseRef)">
<summary>
 Debug layout for a reference to a union case
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.DebugPrint.valRefL(FSharp.Compiler.TypedTree.ValRef)">
<summary>
 Debug layout for a reference to a value
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.DebugPrint.showExpr(FSharp.Compiler.TypedTree.Expr)">
<summary>
 Convert an expression to a string for debugging purposes
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.DebugPrint.showType(FSharp.Compiler.TypedTree.TType)">
<summary>
 Convert a type to a string for debugging purposes
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreeOps.DebugPrint.layoutTypes">
<summary>
 A global flag indicating whether debug output should include type information
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreeOps.DebugPrint.layoutRanges">
<summary>
 A global flag indicating whether debug output should include ranges
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreeOps.DebugPrint.layoutStamps">
<summary>
 A global flag indicating whether debug output should include stamps of Val and Entity
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreeOps.DebugPrint.layoutValReprInfo">
<summary>
 A global flag indicating whether debug output should include ValReprInfo
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.DebugPrint">
<summary>
 Layout for internal compiler debugging purposes
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps.SimplifyTypes">
<summary>
 Utilities used in simplifying types for visual presentation
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.PrettyTypes.PrettifyDiscriminantAndTypePairs``1(FSharp.Compiler.TcGlobals.TcGlobals,Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,FSharp.Compiler.TypedTree.TType}})">
<summary>
 same as PrettifyTypes, but allows passing the types along with a discriminant value
 useful to prettify many types that need to be sorted out after prettifying operation
 took place.
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreeOps.PrettyTypes.AssignPrettyTyparNames(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Assign previously generated pretty names to typars
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreeOps">
<summary>
 Defines derived expression manipulation and construction functions.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreePickle.unpickler`1">
<summary>
 A function to read a value from a given state
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreePickle.ReaderState">
<summary>
 The type of state unpicklers read from
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreePickle.pickler`1">
<summary>
 A function to pickle a value into a given stateful writer
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreePickle.WriterState">
<summary>
 The type of state written to by picklers
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreePickle.PickledDataWithReferences`1.FixupThunks">
<summary>
 The assumptions that need to be fixed up
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreePickle.PickledDataWithReferences`1.RawData">
<summary>
 The data that uses a collection of CcuThunks internally
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreePickle.PickledDataWithReferences`1.OptionalFixup(Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.CcuThunk}})">
<summary>
 Like Fixup but loader may return None, in which case there is no fixup.
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreePickle.PickledDataWithReferences`1">
<summary>
 Represents deserialized data with a dangling set of CCU fixup thunks indexed by name
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreePickle.unpickleObjWithDanglingCcus``1(System.String,FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILModuleDef},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTreePickle.ReaderState,``0},FSharp.Compiler.IO.ReadOnlyByteMemory,FSharp.Compiler.IO.ReadOnlyByteMemory)">
<summary>
 Deserialize an arbitrary object which may have holes referring to other compilation units
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreePickle.unpickleCcuInfo(FSharp.Compiler.TypedTreePickle.ReaderState)">
<summary>
 Deserialize a TAST description of a compilation unit
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreePickle.u_ty">
<summary>
 Deserialize a TAST type
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreePickle.u_expr">
<summary>
 Deserialize a TAST expression
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreePickle.u_ucref">
<summary>
 Deserialize a TAST union case reference
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreePickle.u_tcref">
<summary>
 Deserialize a TAST type reference
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreePickle.u_vref">
<summary>
 Deserialize a TAST value reference
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreePickle.u_const">
<summary>
 Deserialize a TAST constant
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreePickle.u_namemap``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTreePickle.ReaderState,``0})">
<summary>
 Deserialize a namemap
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreePickle.u_array``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTreePickle.ReaderState,``0})">
<summary>
 Deserialize an array of values
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreePickle.u_tup4``4(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTreePickle.ReaderState,``0},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTreePickle.ReaderState,``1},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTreePickle.ReaderState,``2},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTreePickle.ReaderState,``3})">
<summary>
 Deserialize a tuple
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreePickle.u_tup3``3(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTreePickle.ReaderState,``0},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTreePickle.ReaderState,``1},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTreePickle.ReaderState,``2})">
<summary>
 Deserialize a tuple
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreePickle.u_tup2``2(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTreePickle.ReaderState,``0},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTreePickle.ReaderState,``1})">
<summary>
 Deserialize a tuple
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreePickle.u_lazy``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTreePickle.ReaderState,``0})">
<summary>
 Deserialize a lazy value (eagerly)
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreePickle.u_string(FSharp.Compiler.TypedTreePickle.ReaderState)">
<summary>
 Deserialize a string
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreePickle.u_int(FSharp.Compiler.TypedTreePickle.ReaderState)">
<summary>
 Deserialize an integer
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreePickle.u_bool(FSharp.Compiler.TypedTreePickle.ReaderState)">
<summary>
 Deserialize a bool
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreePickle.u_byte(FSharp.Compiler.TypedTreePickle.ReaderState)">
<summary>
 Deserialize a byte
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreePickle.pickleObjWithDanglingCcus``1(System.Boolean,System.String,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.CcuThunk,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTreePickle.WriterState,Microsoft.FSharp.Core.Unit}},``0)">
<summary>
 Serialize an arbitrary object using the given pickler
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreePickle.pickleCcuInfo">
<summary>
 Serialize a TAST description of a compilation unit
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreePickle.p_ty">
<summary>
 Serialize a TAST type
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreePickle.p_expr">
<summary>
 Serialize a TAST expression
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreePickle.p_ucref">
<summary>
 Serialize a TAST union case reference
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreePickle.p_tcref(System.String)">
<summary>
 Serialize a TAST type or entity reference
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreePickle.p_vref(System.String)">
<summary>
 Serialize a TAST value reference
</summary>
</member>
<member name="P:FSharp.Compiler.TypedTreePickle.p_const">
<summary>
 Serialize a TAST constant
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreePickle.p_namemap``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTreePickle.WriterState,Microsoft.FSharp.Core.Unit}})">
<summary>
 Serialize a namemap of data
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreePickle.p_array``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTreePickle.WriterState,Microsoft.FSharp.Core.Unit}})">
<summary>
 Serialize an array of data
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreePickle.p_tup4``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTreePickle.WriterState,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTreePickle.WriterState,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTreePickle.WriterState,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTreePickle.WriterState,Microsoft.FSharp.Core.Unit}})">
<summary>
 Serialize a tuple of data
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreePickle.p_tup3``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTreePickle.WriterState,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTreePickle.WriterState,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTreePickle.WriterState,Microsoft.FSharp.Core.Unit}})">
<summary>
 Serialize a tuple of data
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreePickle.p_tup2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTreePickle.WriterState,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTreePickle.WriterState,Microsoft.FSharp.Core.Unit}})">
<summary>
 Serialize a tuple of data
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreePickle.p_lazy``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTreePickle.WriterState,Microsoft.FSharp.Core.Unit}})">
<summary>
 Serialize a lazy value (eagerly)
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreePickle.p_string(System.String,FSharp.Compiler.TypedTreePickle.WriterState)">
<summary>
 Serialize a string
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreePickle.p_int(System.Int32,FSharp.Compiler.TypedTreePickle.WriterState)">
<summary>
 Serialize an integer
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreePickle.p_bool(System.Boolean,FSharp.Compiler.TypedTreePickle.WriterState)">
<summary>
 Serialize a boolean value
</summary>
</member>
<member name="M:FSharp.Compiler.TypedTreePickle.p_byte(System.Int32,FSharp.Compiler.TypedTreePickle.WriterState)">
<summary>
 Serialize a byte
</summary>
</member>
<member name="T:FSharp.Compiler.TypedTreePickle">
<summary>
 Defines the framework for serializing and de-serializing TAST data structures as binary blobs for the F# metadata format.
</summary>
</member>
<member name="T:FSharp.Compiler.UpdatePrettyTyparNames">
<summary>
 The Typars of a Val in the signature data should also be pretty named.
 This will happen for the implementation file contents, but not for the signature data.
 In this module some helpers will traverse the ModuleOrNamespaceType and update all the typars of each found Val.
</summary>
</member>
<member name="P:FSharp.Compiler.Import.ImportMap.g">
<summary>
 The TcGlobals for the import context
</summary>
</member>
<member name="P:FSharp.Compiler.Import.ImportMap.assemblyLoader">
<summary>
 The AssemblyLoader for the import context
</summary>
</member>
<member name="P:FSharp.Compiler.Import.ImportMap.TypeSubsumptionCache">
<summary>
 Type subsumption cache
</summary>
</member>
<member name="T:FSharp.Compiler.Import.ImportMap">
<summary>
 Represents a context used for converting AbstractIL .NET and provided types to F# internal compiler data structures.
 Also cache the conversion of AbstractIL ILTypeRef nodes, based on hashes of these.

 There is normally only one ImportMap for any assembly compilation, though additional instances can be created
 using tcImports.GetImportMap() if needed, and it is not harmful if multiple instances are used. The object
 serves as an interface through to the tables stored in the primary TcImports structures defined in CompileOps.fs.
</summary>
</member>
<member name="M:FSharp.Compiler.Import.AssemblyLoader.RecordGeneratedTypeRoot(FSharp.Compiler.TypeProviders.ProviderGeneratedType)">
<summary>
 Record a root for a [&lt;Generate&gt;] type to help guide static linking &amp; type relocation
</summary>
</member>
<member name="M:FSharp.Compiler.Import.AssemblyLoader.GetProvidedAssemblyInfo(Internal.Utilities.Library.CompilationThreadToken,FSharp.Compiler.Text.Range,FSharp.Compiler.Tainted{FSharp.Compiler.TypeProviders.ProvidedAssembly})">
<summary>
 Get a flag indicating if an assembly is a provided assembly, plus the
 table of information recording remappings from type names in the provided assembly to type
 names in the statically linked, embedded assembly.
</summary>
</member>
<member name="M:FSharp.Compiler.Import.AssemblyLoader.FindCcuFromAssemblyRef(Internal.Utilities.Library.CompilationThreadToken,FSharp.Compiler.Text.Range,FSharp.Compiler.AbstractIL.IL.ILAssemblyRef)">
<summary>
 Resolve an Abstract IL assembly reference to a Ccu
</summary>
</member>
<member name="T:FSharp.Compiler.Import.AssemblyLoader">
<summary>
 Represents an interface to some of the functionality of TcImports, for loading assemblies
 and accessing information about generated provided assemblies.
</summary>
</member>
<member name="M:FSharp.Compiler.Import.RescopeAndImportILType(FSharp.Compiler.AbstractIL.IL.ILScopeRef,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.Import.Nullness.NullableAttributesSource,FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Import an IL type as an F# type, first rescoping to view the metadata from the current assembly
 being compiled. importInst gives the context for interpreting type variables.
</summary>
</member>
<member name="M:FSharp.Compiler.Import.RescopeAndImportILTypeSkipNullness(FSharp.Compiler.AbstractIL.IL.ILScopeRef,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Import an IL type as an F# type, first rescoping to view the metadata from the current assembly
 being compiled. importInst gives the context for interpreting type variables.
 This function fully skips the &apos;nullness checking&apos; metadata flags.
</summary>
</member>
<member name="M:FSharp.Compiler.Import.ImportILAssemblyTypeForwarders(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,FSharp.Compiler.Import.ImportMap},FSharp.Compiler.Text.Range,FSharp.Compiler.AbstractIL.IL.ILExportedTypesAndForwarders)">
<summary>
 Import the type forwarder table for an IL assembly
</summary>
</member>
<member name="M:FSharp.Compiler.Import.ImportILAssembly(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,FSharp.Compiler.Import.ImportMap},FSharp.Compiler.Text.Range,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.AbstractIL.IL.ILScopeRef,FSharp.Compiler.AbstractIL.IL.ILModuleDef},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.Xml.IXmlDocumentationInfoLoader},FSharp.Compiler.AbstractIL.IL.ILScopeRef,System.String,Microsoft.FSharp.Core.FSharpOption{System.String},FSharp.Compiler.AbstractIL.IL.ILModuleDef,Microsoft.FSharp.Control.IEvent{Microsoft.FSharp.Control.FSharpHandler{System.String},System.String})">
<summary>
 Import an IL assembly as a new TAST CCU
</summary>
</member>
<member name="M:FSharp.Compiler.Import.ImportILGenericParameters(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,FSharp.Compiler.Import.ImportMap},FSharp.Compiler.Text.Range,FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.Import.Nullness.NullableContextSource,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILGenericParameterDef})">
<summary>
 Import a set of Abstract IL generic parameter specifications as a list of new F# generic parameters.
</summary>
</member>
<member name="M:FSharp.Compiler.Import.ImportProvidedMethodBaseAsILMethodRef(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.Tainted{FSharp.Compiler.TypeProviders.ProvidedMethodBase})">
<summary>
 Import a provided method reference as an Abstract IL method reference
</summary>
</member>
<member name="M:FSharp.Compiler.Import.ImportProvidedTypeAsILType(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.Tainted{FSharp.Compiler.TypeProviders.ProvidedType})">
<summary>
 Import a provided type as an AbstractIL type
</summary>
</member>
<member name="M:FSharp.Compiler.Import.ImportProvidedNamedType(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.Tainted{FSharp.Compiler.TypeProviders.ProvidedType})">
<summary>
 Import a provided type reference as an F# type TyconRef
</summary>
</member>
<member name="M:FSharp.Compiler.Import.ImportProvidedType(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.Tainted{FSharp.Compiler.TypeProviders.ProvidedType})">
<summary>
 Import a provided type as an F# type.
</summary>
</member>
<member name="M:FSharp.Compiler.Import.CanImportILType(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Pre-check for ability to import an IL type as an F# type.
</summary>
</member>
<member name="M:FSharp.Compiler.Import.ImportILType(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Import an IL type as an F# type.
</summary>
</member>
<member name="M:FSharp.Compiler.Import.CanImportILTypeRef(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.AbstractIL.IL.ILTypeRef)">
<summary>
 Pre-check for ability to import a reference to a type definition, given an AbstractIL ILTypeRef, with caching
</summary>
</member>
<member name="M:FSharp.Compiler.Import.ImportILTypeRef(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.AbstractIL.IL.ILTypeRef)">
<summary>
 Import a reference to a type definition, given an AbstractIL ILTypeRef, with caching
</summary>
</member>
<member name="T:FSharp.Compiler.Import">
<summary>
 Functions to import .NET binary metadata as TAST objects
</summary>
</member>
<member name="T:FSharp.Compiler.TypeHierarchy.AllowMultiIntfInstantiations">
<summary>
 Indicates whether we should visit multiple instantiations of the same generic interface or not
</summary>
</member>
<member name="T:FSharp.Compiler.TypeHierarchy.SkipUnrefInterfaces">
<summary>
 Indicates whether we can skip interface types that lie outside the reference set
</summary>
</member>
<member name="M:FSharp.Compiler.TypeHierarchy.FixupNewTypars(FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar})">
<summary>
 The constraints for each typar copied from another typar can only be fixed up once
 we have generated all the new constraints, e.g. f&lt;A :&gt; List&lt;B&gt;, B :&gt; List&lt;A&gt;&gt; ...
</summary>
</member>
<member name="M:FSharp.Compiler.TypeHierarchy.CopyTyparConstraints(FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Compiler.TypedTree.Typar,FSharp.Compiler.TypedTree.TType}},FSharp.Compiler.TypedTree.Typar)">
<summary>
 Copy constraints.  If the constraint comes from a type parameter associated
 with a type constructor then we are simply renaming type variables.  If it comes
 from a generic method in a generic class (e.g. ty.M&lt;_&gt;) then we may be both substituting the
 instantiation associated with &apos;ty&apos; as well as copying the type parameters associated with
 M and instantiating their constraints

 Note: this now looks identical to constraint instantiation.
</summary>
</member>
<member name="M:FSharp.Compiler.TypeHierarchy.ImportReturnTypeFromMetadata(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.Import.Nullness.NullableAttributesSource,FSharp.Compiler.AbstractIL.IL.ILType,FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType})">
<summary>
 Get the return type of an IL method, taking into account instantiations for type, return attributes and method generic parameters, and
 translating &apos;void&apos; to &apos;None&apos;.
</summary>
</member>
<member name="M:FSharp.Compiler.TypeHierarchy.ImportParameterTypeFromMetadata(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.Import.Nullness.NullableAttributesSource,FSharp.Compiler.AbstractIL.IL.ILType,FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType})">
<summary>
 Get the parameter type of an IL method.
</summary>
</member>
<member name="M:FSharp.Compiler.TypeHierarchy.ImportILTypeFromMetadataWithAttributes(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.Import.Nullness.NullableAttributesSource,FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Read an Abstract IL type from metadata, including any attributes that may affect the type itself, and convert to an F# type.
</summary>
</member>
<member name="M:FSharp.Compiler.TypeHierarchy.ImportILTypeFromMetadataSkipNullness(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Read an Abstract IL type from metadata and convert to an F# type, ignoring nullness checking.
</summary>
</member>
<member name="M:FSharp.Compiler.TypeHierarchy.ImportILTypeFromMetadata(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.Import.Nullness.NullableAttributesSource,FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Read an Abstract IL type from metadata and convert to an F# type.
</summary>
</member>
<member name="M:FSharp.Compiler.TypeHierarchy.ExistsHeadTypeInEntireHierarchy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Check if a type exists somewhere in the hierarchy which has the given head type.
</summary>
</member>
<member name="M:FSharp.Compiler.TypeHierarchy.ExistsSameHeadTypeInHierarchy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.TType)">
<summary>
 Check if a type exists somewhere in the hierarchy which has the same head type as the given type (note, the given type need not have a head type at all)
</summary>
</member>
<member name="M:FSharp.Compiler.TypeHierarchy.HasHeadType(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.EntityRef,FSharp.Compiler.TypedTree.TType)">
<summary>
 Check if a type has a particular head type
</summary>
</member>
<member name="M:FSharp.Compiler.TypeHierarchy.HaveSameHeadType(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.TType)">
<summary>
 Check if two types have the same nominal head type
</summary>
</member>
<member name="M:FSharp.Compiler.TypeHierarchy.AllInterfacesOfType(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.TypeHierarchy.AllowMultiIntfInstantiations,FSharp.Compiler.TypedTree.TType)">
<summary>
 Get all interfaces of a type, including the type itself if it is an interface
</summary>
</member>
<member name="M:FSharp.Compiler.TypeHierarchy.AllSuperTypesOfType(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.TypeHierarchy.AllowMultiIntfInstantiations,FSharp.Compiler.TypedTree.TType)">
<summary>
 Get all super types of the type, including the type itself
</summary>
</member>
<member name="M:FSharp.Compiler.TypeHierarchy.SearchEntireHierarchyOfType(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.TType,System.Boolean},FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Search for one element where a function returns a &apos;Some&apos; result, following interfaces
</summary>
</member>
<member name="M:FSharp.Compiler.TypeHierarchy.ExistsInEntireHierarchyOfType(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.TType,System.Boolean},FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.TypeHierarchy.AllowMultiIntfInstantiations,FSharp.Compiler.TypedTree.TType)">
<summary>
 Search for one element satisfying a predicate, following interfaces
</summary>
</member>
<member name="M:FSharp.Compiler.TypeHierarchy.IterateEntireHierarchyOfType(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.TType,Microsoft.FSharp.Core.Unit},FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.TypeHierarchy.AllowMultiIntfInstantiations,FSharp.Compiler.TypedTree.TType)">
<summary>
 Iterate, following interfaces. Skipping interfaces that lie outside the referenced assembly set is allowed.
</summary>
</member>
<member name="M:FSharp.Compiler.TypeHierarchy.FoldEntireHierarchyOfType``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.TType,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.TypeHierarchy.AllowMultiIntfInstantiations,FSharp.Compiler.TypedTree.TType,``0)">
<summary>
 Fold, following interfaces. Skipping interfaces that lie outside the referenced assembly set is allowed.
</summary>
</member>
<member name="M:FSharp.Compiler.TypeHierarchy.FoldPrimaryHierarchyOfType``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.TType,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.TypeHierarchy.AllowMultiIntfInstantiations,FSharp.Compiler.TypedTree.TType,``0)">
<summary>
 Fold, do not follow interfaces (unless the type is itself an interface)
</summary>
</member>
<member name="M:FSharp.Compiler.TypeHierarchy.GetImmediateInterfacesOfType(FSharp.Compiler.TypeHierarchy.SkipUnrefInterfaces,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Collect the set of immediate declared interface types for an F# type, but do not
 traverse the type hierarchy to collect further interfaces.
</summary>
</member>
<member name="M:FSharp.Compiler.TypeHierarchy.GetSuperTypeOfType(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Get the base type of a type, taking into account type instantiations. Return None if the
 type has no base type.
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.CompiledSig">
<summary>
 Represents the information about the compiled form of a method signature. Used when analyzing implementation
 relations between members and abstract slots.
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.EventInfo.ProvidedEvent">
<summary>
 An F# use of an event backed by provided metadata
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.EventInfo.ILEvent">
<summary>
 An F# use of an event backed by .NET metadata
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.EventInfo.FSEvent">
<summary>
 An F# use of an event backed by F#-declared metadata
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.EventInfo.XmlDoc">
<summary>
 Get the intra-assembly XML documentation for the property.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.EventInfo.TcGlobals">
<summary>
 Get the TcGlobals associated with the object
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.EventInfo.RemoveMethod">
<summary>
 Get the &apos;remove&apos; method associated with an event
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.EventInfo.IsValueType">
<summary>
 Indicates if the enclosing type for the event is a value type.

 For an extension event, this indicates if the event extends a struct type.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.EventInfo.IsStatic">
<summary>
 Indicates if this property is static.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.EventInfo.IsExtensionMember">
<summary>
 Indicates if this is an extension member
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.EventInfo.HasDirectXmlComment">
<summary>
 Indicates if this event has an associated XML comment authored in this assembly.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.EventInfo.EventName">
<summary>
 Get the logical name of the event.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.EventInfo.DisplayNameCore">
<summary>
 Get the event name in core DisplayName form (no backticks or parens added)
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.EventInfo.DisplayName">
<summary>
 Get the display name of the event.

 Backticks and parens are added implicitly for non-identifiers.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.EventInfo.DeclaringTyconRef">
<summary>
 Get the declaring type or module holding the method.
 Note that C#-style extension properties don&apos;t exist in the C# design as yet.
 If this is an F#-style extension method it is the logical module
 holding the value for the extension method.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.EventInfo.ArbitraryValRef">
<summary>
 Try to get an arbitrary F# ValRef associated with the member. This is to determine if the member is virtual, amongst other things.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.EventInfo.ApparentEnclosingType">
<summary>
 Get the enclosing type of the event.

 If this is an extension member, then this is the apparent parent, i.e. the type the event appears to extend.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.EventInfo.ApparentEnclosingAppType">
<summary>
 Get the enclosing type of the method info, using a nominal type for tuple types
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.EventInfo.AddMethod">
<summary>
 Get the &apos;add&apos; method associated with an event
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.EventInfo.GetDelegateType(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range)">
<summary>
 Get the delegate type associated with the event.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.EventInfo.GetCustomAttrs">
<summary>
 Get custom attributes for events (only applicable for IL events)
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.EventInfo.EventInfosUseIdenticalDefinitions(FSharp.Compiler.Infos.EventInfo,FSharp.Compiler.Infos.EventInfo)">
<summary>
 Test whether two event infos have the same underlying definition.
 Compatible with ItemsAreEffectivelyEqual relation.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.EventInfo.ComputeHashCode">
<summary>
 Calculates a hash code of event info (similar as previous)
 Compatible with ItemsAreEffectivelyEqual relation.
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.EventInfo">
<summary>
 Describes an F# use of an event
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILEventInfo.TypeRef">
<summary>
 Get the declaring type of the event as an ILTypeRef
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILEventInfo.RemoveMethod">
<summary>
 Get the ILMethInfo describing the &apos;remove&apos; method associated with the event
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILEventInfo.RawMetadata">
<summary>
 Get the raw Abstract IL metadata for the event
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILEventInfo.IsStatic">
<summary>
 Indicates if the property is static
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILEventInfo.ILTypeInfo">
<summary>
 Get the declaring IL type of the event as an ILTypeInfo
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILEventInfo.EventName">
<summary>
 Get the name of the event
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILEventInfo.ApparentEnclosingType">
<summary>
 Get the enclosing (&quot;parent&quot;/&quot;declaring&quot;) type of the field.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILEventInfo.AddMethod">
<summary>
 Get the ILMethInfo describing the &apos;add&apos; method associated with the event
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.ILEventInfo">
<summary>
 Describes an F# use of an event backed by Abstract IL metadata
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.PropInfo.ProvidedProp">
<summary>
 An F# use of a property backed by provided metadata
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.PropInfo.ILProp">
<summary>
 An F# use of a property backed by Abstract IL metadata
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.PropInfo.FSProp">
<summary>
 An F# use of a property backed by F#-declared metadata
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.PropInfo.XmlDoc">
<summary>
 Get the intra-assembly XML documentation for the property.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.PropInfo.TcGlobals">
<summary>
 Get the TcGlobals associated with the object
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.PropInfo.SetterMethod">
<summary>
 Get a MethInfo for the &apos;setter&apos; method associated with the property
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.PropInfo.PropertyName">
<summary>
 Get the logical name of the property.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.PropInfo.IsVirtualProperty">
<summary>
 True if the getter (or, if absent, the setter) is a virtual method
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.PropInfo.IsValueType">
<summary>
 Indicates if the enclosing type for the property is a value type.

 For an extension property, this indicates if the property extends a struct type.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.PropInfo.IsUnionCaseTester">
<summary>
 Indicates if the property is a IsABC union case tester implied by a union case definition
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.PropInfo.IsStatic">
<summary>
 Indicates if this property is static.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.PropInfo.IsSetterInitOnly">
<summary>
 Indicates whether IL property has an init-only setter (i.e. has the `System.Runtime.CompilerServices.IsExternalInit` modifier)
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.PropInfo.IsRequired">
<summary>
 Is the property required (has the RequiredMemberAttribute).
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.PropInfo.IsNewSlot">
<summary>
 Indicates if the property is logically a &apos;newslot&apos;, i.e. hides any previous slots of the same name.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.PropInfo.IsIndexer">
<summary>
 Indicates if this property is an indexer property, i.e. a property with arguments.
 &lt;code lang=&quot;fsharp&quot;&gt;
 member x.Prop with
     get (indexPiece1:int,indexPiece2: string) = ...
     and set (indexPiece1:int,indexPiece2: string) value = ...
 &lt;/code&gt;
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.PropInfo.IsFSharpEventProperty">
<summary>
 Indicates if this is an F# property compiled as a CLI event, e.g. a [&lt;CLIEvent&gt;] property.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.PropInfo.IsExtensionMember">
<summary>
 Indicates if this is an extension member
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.PropInfo.IsDispatchSlot">
<summary>
 Indicates if the getter (or, if absent, the setter) for the property is a dispatch slot.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.PropInfo.IsDefiniteFSharpOverride">
<summary>
 Indicates if this property is marked &apos;override&apos; and thus definitely overrides another property.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.PropInfo.HasSetter">
<summary>
 Indicates if this property has an associated setter method.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.PropInfo.HasGetter">
<summary>
 Indicates if this property has an associated getter method.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.PropInfo.HasDirectXmlComment">
<summary>
 Indicates if this property has an associated XML comment authored in this assembly.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.PropInfo.DisplayNameCore">
<summary>
 Get the property name in core DisplayName form (no backticks or parens added)
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.PropInfo.DisplayName">
<summary>
 Get the display name of the property.

 Backticks and parens are added implicitly for non-identifiers.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.PropInfo.DeclaringTyconRef">
<summary>
 Get the declaring type or module holding the method.
 Note that C#-style extension properties don&apos;t exist in the C# design as yet.
 If this is an F#-style extension method it is the logical module
 holding the value for the extension method.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.PropInfo.ArbitraryValRef">
<summary>
 Try to get an arbitrary F# ValRef associated with the member. This is to determine if the member is virtual, amongst other things.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.PropInfo.ApparentEnclosingType">
<summary>
 Get the enclosing type of the property.

 If this is an extension member, then this is the apparent parent, i.e. the type the property appears to extend.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.PropInfo.ApparentEnclosingAppType">
<summary>
 Get the enclosing type of the method info, using a nominal type for tuple types
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.PropInfo.PropInfosUseIdenticalDefinitions(FSharp.Compiler.Infos.PropInfo,FSharp.Compiler.Infos.PropInfo)">
<summary>
 Test whether two property infos have the same underlying definition.
 Uses the same techniques as &apos;MethInfosUseIdenticalDefinitions&apos;.
 Compatible with ItemsAreEffectivelyEqual relation.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.PropInfo.GetPropertyType(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range)">
<summary>
 Get the result type of the property
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.PropInfo.GetParamTypes(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range)">
<summary>
 Get the types of the indexer parameters associated with the property
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.PropInfo.GetParamNamesAndTypes(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range)">
<summary>
 Get the names and types of the indexer parameters associated with the property

 If the property is in a generic type, then the type parameters are instantiated in the types returned.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.PropInfo.GetParamDatas(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range)">
<summary>
 Get the details of the indexer parameters associated with the property
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.PropInfo.DropSetter">
<summary>
 Return a new property info where there is no associated setter, only an associated getter.

 Property infos can combine getters and setters, assuming they are consistent w.r.t. &apos;virtual&apos;, indexer argument types etc.
 When checking consistency we split these apart
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.PropInfo.DropGetter">
<summary>
 Return a new property info where there is no associated getter, only an associated setter.

 Property infos can combine getters and setters, assuming they are consistent w.r.t. &apos;virtual&apos;, indexer argument types etc.
 When checking consistency we split these apart
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.PropInfo.ComputeHashCode">
<summary>
 Calculates a hash code of property info. Must be compatible with ItemsAreEffectivelyEqual relation.
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.PropInfo">
<summary>
 Describes an F# use of a property
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILPropInfo.TcGlobals">
<summary>
 Get the TcGlobals governing this value
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILPropInfo.SetterMethod">
<summary>
 Gets the ILMethInfo of the &apos;set&apos; method for the IL property
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILPropInfo.RawMetadata">
<summary>
 Get the raw Abstract IL metadata for the IL property
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILPropInfo.PropertyName">
<summary>
 Get the name of the IL property
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILPropInfo.IsVirtual">
<summary>
 Indicates if the IL property is virtual
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILPropInfo.IsStatic">
<summary>
 Indicates if the IL property is static
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILPropInfo.IsRequired">
<summary>
 Is the property required (has the RequiredMemberAttribute).
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILPropInfo.IsNewSlot">
<summary>
 Indicates if the IL property is logically a &apos;newslot&apos;, i.e. hides any previous slots of the same name.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILPropInfo.ILTypeInfo">
<summary>
 Get the declaring IL type of the IL property, including any generic instantiation
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILPropInfo.HasSetter">
<summary>
 Indicates if the IL property has a &apos;set&apos; method
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILPropInfo.HasGetter">
<summary>
 Indicates if the IL property has a &apos;get&apos; method
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILPropInfo.GetterMethod">
<summary>
 Gets the ILMethInfo of the &apos;get&apos; method for the IL property
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILPropInfo.ApparentEnclosingType">
<summary>
 Get the apparent declaring type of the method as an F# type.
 If this is a C#-style extension method then this is the type which the method
 appears to extend. This may be a variable type.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILPropInfo.ApparentEnclosingAppType">
<summary>
 Like ApparentEnclosingType but use the compiled nominal type if this is a method on a tuple type
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.ILPropInfo.GetPropertyType(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range)">
<summary>
 Get the return type of the IL property.

 Any type parameters of the enclosing type are instantiated in the type returned.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.ILPropInfo.GetParamTypes(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range)">
<summary>
 Get the types of the indexer arguments associated with the IL property.

 Any type parameters of the enclosing type are instantiated in the type returned.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.ILPropInfo.GetParamNamesAndTypes(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range)">
<summary>
 Get the names and types of the indexer arguments associated with the IL property.

 Any type parameters of the enclosing type are instantiated in the type returned.
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.ILPropInfo">
<summary>
 Describes an F# use of a property backed by Abstract IL metadata
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.UnionCaseInfo.UnionCaseRef">
<summary>
 Get a reference to the F# metadata for the uninstantiated union case
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.UnionCaseInfo.UnionCase">
<summary>
 Get the F# metadata for the uninstantiated union case
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.UnionCaseInfo.TypeInst">
<summary>
 Get the list of types for the instantiation of the type parameters of the declaring type of the union case
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.UnionCaseInfo.TyconRef">
<summary>
 Get a reference to the F# metadata for the declaring union type
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.UnionCaseInfo.Tycon">
<summary>
 Get the F# metadata for the declaring union type
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.UnionCaseInfo.LogicalName">
<summary>
 Get the logical name of the union case.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.UnionCaseInfo.DisplayNameCore">
<summary>
 Get the core of the display name of the union case

 Backticks and parens are not added for non-identifiers.

 Note logical names op_Nil and op_ColonColon become [] and :: respectively.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.UnionCaseInfo.DisplayName">
<summary>
 Get the display name of the union case

 Backticks and parens are added implicitly for non-identifiers.

 Note logical names op_Nil and op_ColonColon become ([]) and (::) respectively.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.UnionCaseInfo.GetTyparInst(FSharp.Compiler.Text.Range)">
<summary>
 Get the instantiation of the type parameters of the declaring type of the union case
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.UnionCaseInfo">
<summary>
 Describes an F# use of a union case
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.RecdFieldInfo.TypeInst">
<summary>
 Get the generic instantiation of the declaring type of the field
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.RecdFieldInfo.TyconRef">
<summary>
 Get a reference to the F# metadata for the F#-declared record, class or struct type
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.RecdFieldInfo.Tycon">
<summary>
 Get the F# metadata for the F#-declared record, class or struct type
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.RecdFieldInfo.RecdFieldRef">
<summary>
 Get a reference to the F# metadata for the uninstantiated field
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.RecdFieldInfo.RecdField">
<summary>
 Get the F# metadata for the uninstantiated field
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.RecdFieldInfo.LogicalName">
<summary>
 Get the logical name of the field in an F#-declared record, class or struct type
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.RecdFieldInfo.LiteralValue">
<summary>
 Indicate if the field is a literal field in an F#-declared record, class or struct type
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.RecdFieldInfo.IsStatic">
<summary>
 Indicate if the field is a static field in an F#-declared record, class or struct type
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.RecdFieldInfo.FieldType">
<summary>
 Get the (instantiated) type of the field in an F#-declared record, class or struct type
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.RecdFieldInfo.DisplayNameCore">
<summary>
 Get the name of the field, same as LogicalName
 Note: no double-backticks added for non-identifiers
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.RecdFieldInfo.DisplayName">
<summary>
 Get the name of the field, with double-backticks added if necessary
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.RecdFieldInfo.DeclaringType">
<summary>
 Get the enclosing (declaring) type of the field in an F#-declared record, class or struct type
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.RecdFieldInfo">
<summary>
 Describes an F# use of a field in an F#-declared record, class or struct type
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.ILFieldInfo.ProvidedField">
<summary>
 Represents a single use of a field backed by provided metadata
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.ILFieldInfo.ILFieldInfo">
<summary>
 Represents a single use of a field backed by Abstract IL metadata
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILFieldInfo.TypeInst">
<summary>
 Get the type instantiation of the declaring type of the field
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILFieldInfo.ScopeRef">
<summary>
 Get the scope used to interpret IL metadata
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILFieldInfo.LiteralValue">
<summary>
 Indicates if the field is a literal field with an associated literal value
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILFieldInfo.IsValueType">
<summary>
 Indicates if the field is a member of a struct or enum type
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILFieldInfo.IsStatic">
<summary>
 Indicates if the field is static
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILFieldInfo.IsSpecialName">
<summary>
 Indicates if the field has the &apos;specialname&apos; property in the .NET IL
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILFieldInfo.IsInitOnly">
<summary>
 Indicates if the field is readonly (in the .NET/C# sense of readonly)
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILFieldInfo.ILTypeRef">
<summary>
 Get a reference to the declaring type of the field as an ILTypeRef
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILFieldInfo.ILFieldType">
<summary>
 Get the type of the field as an IL type
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILFieldInfo.ILFieldRef">
<summary>
 Get an (uninstantiated) reference to the field as an Abstract IL ILFieldRef
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILFieldInfo.FieldName">
<summary>
 Get the name of the field
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILFieldInfo.DisplayNameCore">
<summary>
 Get the core of the display name for the field. This is the same as the logical name.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILFieldInfo.ApparentEnclosingType">
<summary>
 Get the enclosing (&quot;parent&quot;/&quot;declaring&quot;) type of the field.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILFieldInfo.ApparentEnclosingAppType">
<summary>
 Like ApparentEnclosingType but use the compiled nominal type if this is a method on a tuple type
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.ILFieldInfo.ILFieldInfosUseIdenticalDefinitions(FSharp.Compiler.Infos.ILFieldInfo,FSharp.Compiler.Infos.ILFieldInfo)">
<summary>
 Tests whether two infos have the same underlying definition.
 Compatible with ItemsAreEffectivelyEqual relation.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.ILFieldInfo.FieldType(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range)">
<summary>
 Get the type of the field as an F# type
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.ILFieldInfo.ComputeHashCode">
<summary>
 Calculates a hash code of field info. Must be compatible with ItemsAreEffectivelyEqual relation.
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.ILFieldInfo">
<summary>
 Represents a single use of a IL or provided field from one point in an F# program
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.MethInfo.ProvidedMeth">
<summary>
 Describes a use of a method backed by provided metadata
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.MethInfo.DefaultStructCtor">
<summary>
 Describes a use of a pseudo-method corresponding to the default constructor for a .NET struct type
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.MethInfo.MethInfoWithModifiedReturnType">
<summary>
 A pseudo-method used by F# typechecker to treat Object.ToString() of known types as returning regular string, not `string?` as in the BCL
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.MethInfo.ILMeth">
<summary>
 Describes a use of a method backed by Abstract IL # metadata
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.MethInfo.FSMeth">
<summary>
 Describes a use of a method declared in F# code and backed by F# metadata.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.XmlDoc">
<summary>
 Get the XML documentation associated with the method
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.TcGlobals">
<summary>
 Get the TcGlobals value that governs the method declaration
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.ProvidedStaticParameterInfo">
<summary>
 Get the information about provided static parameters, if any
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.NumArgs">
<summary>
 Get a list of argument-number counts, one count for each set of curried arguments.

 For an extension member, drop the &apos;this&apos; argument.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.LogicalName">
<summary>
 Get the method name in LogicalName form, i.e. the name as it would be stored in .NET metadata
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.IsUnionCaseTester">
<summary>
 Indicates if the method is a get_IsABC union case tester implied by a union case definition
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.IsStruct">
<summary>
 Indicates if the enclosing type for the method is a value type.

 For an extension method, this indicates if the method extends a struct type.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.IsReadOnly">
<summary>
 Indicates if this method is read-only; usually by the [&lt;IsReadOnly&gt;] attribute.
 Must be an instance method.
 Receiver must be a struct type.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.IsNullary">
<summary>
 Indicates if this method takes no arguments
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.IsInstance">
<summary>
 Does the method appear to the user as an instance method?
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.IsILMethod">
<summary>
 Indicates if this is an IL method.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.IsFSharpStyleExtensionMember">
<summary>
 Indicates if this is an F#-style extension member.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.IsFSharpExplicitInterfaceImplementation">
<summary>
 Check if this method is an explicit implementation of an interface member
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.IsFSharpEventPropertyMethod">
<summary>
 Indicates if this method is a generated method associated with an F# CLIEvent property compiled as a .NET event
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.IsExtensionMember">
<summary>
 Indicates if this is an extension member.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.IsDefiniteFSharpOverride">
<summary>
 Check if this method is marked &apos;override&apos; and thus definitely overrides another method.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.IsCSharpStyleExtensionMember">
<summary>
 Indicates if this is an C#-style extension member.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.HasExternalInit">
<summary>
 Indicates, whether this method has `IsExternalInit` modreq.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.HasDirectXmlComment">
<summary>
 Indicates if this is a method defined in this assembly with an internal XML comment
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.GenericArity">
<summary>
 Get the number of generic method parameters for a method.
 For an extension method this includes all type parameters, even if it is extending a generic type.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.FormalMethodTypars">
<summary>
 Get the formal generic method parameters for the method as a list of type variables.

 For an extension method this includes all type parameters, even if it is extending a generic type.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.FormalMethodInst">
<summary>
 Get the formal generic method parameters for the method as a list of variable types.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.ExtensionMemberPriorityOption">
<summary>
 Get the extension method priority of the method, if it has one.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.ExtensionMemberPriority">
<summary>
 Get the extension method priority of the method. If it is not an extension method
 then use the highest possible value since non-extension methods always take priority
 over extension members.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.DisplayNameCore">
<summary>
 Get the method name in core DisplayName form (no backticks or parens added)
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.DisplayName">
<summary>
 Get the method name in DisplayName form
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.DeclaringTypeInst">
<summary>
 Get the actual type instantiation of the declaring type associated with this use of the method.

 For extension members this is empty (the instantiation of the declaring type).
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.DeclaringTyconRef">
<summary>
 Get the declaring type or module holding the method. If this is an C#-style extension method then this is the type
 holding the static member that is the extension method. If this is an F#-style extension method it is the logical module
 holding the value for the extension method.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.DebuggerDisplayName">
<summary>
 Get the method name in DebuggerDisplayForm
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.ArbitraryValRef">
<summary>
 Try to get an arbitrary F# ValRef associated with the member. This is to determine if the member is virtual, amongst other things.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.ApparentEnclosingType">
<summary>
 Get the enclosing type of the method info.

 If this is an extension member, then this is the apparent parent, i.e. the type the method appears to extend.
 This may be a variable type.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.MethInfo.ApparentEnclosingAppType">
<summary>
 Get the enclosing type of the method info, using a nominal type for tuple types
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.MethInfo.TryObjArgByrefType(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType})">
<summary>
 Tries to get the object arg type if it&apos;s a byref type.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.MethInfo.ObjArgNeedsAddress(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range)">
<summary>
 Indicates if this is an extension member (e.g. on a struct) that takes a byref arg
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.MethInfo.MethInfosUseIdenticalDefinitions(FSharp.Compiler.Infos.MethInfo,FSharp.Compiler.Infos.MethInfo)">
<summary>
 Tests whether two method infos have the same underlying definition.
 Used to merge operator overloads collected from left and right of an operator constraint.

 Compatible with ItemsAreEffectivelyEqual relation.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.MethInfo.IsReadOnlyExtensionMember(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range)">
<summary>
 Indicates if this method is an extension member that is read-only.
 An extension member is considered read-only if the first argument is a read-only byref (inref) type.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.MethInfo.Instantiate(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Compiler.TypedTree.Typar,FSharp.Compiler.TypedTree.TType}})">
<summary>
 Apply a type instantiation to a method info, i.e. apply the instantiation to the enclosing type.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.MethInfo.HasParamArrayArg(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType})">
<summary>
 Get the ParamData objects for the parameters of a MethInfo
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.MethInfo.GetSlotSig(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range)">
<summary>
 Get the signature of an abstract method slot.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.MethInfo.GetParamTypes(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType})">
<summary>
 Get the parameter types of a method info
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.MethInfo.GetParamNames">
<summary>
 Get the parameter names of a MethInfo
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.MethInfo.GetParamDatas(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType})">
<summary>
 Get the ParamData objects for the parameters of a MethInfo
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.MethInfo.GetParamAttribs(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range)">
<summary>
 Get the parameter attributes of a method info, which get combined with the parameter names and types
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.MethInfo.GetObjArgTypes(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType})">
<summary>
 Get the (zero or one) &apos;self&apos;/&apos;this&apos;/&apos;object&apos; arguments associated with a method.
 An instance method returns one object argument.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.MethInfo.GetFormalTyparsOfDeclaringType(FSharp.Compiler.Text.Range)">
<summary>
 Select all the type parameters of the declaring type of a method.

 For extension methods, no type parameters are returned, because all the
 type parameters are part of the apparent type, rather the
 declaring type, even for extension methods extending generic types.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.MethInfo.GetFSharpReturnType(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType})">
<summary>
 Get the return type of a method info, where &apos;void&apos; is returned as &apos;unit&apos;
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.MethInfo.GetCustomAttrs">
<summary>
 Get custom attributes for method (only applicable for IL methods)
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.MethInfo.GetCompiledReturnType(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType})">
<summary>
 Get the return type of a method info, where &apos;void&apos; is returned as &apos;None&apos;
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.MethInfo.CreateILMeth(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.AbstractIL.IL.ILMethodDef)">
<summary>
 Build IL method infos.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.MethInfo.CreateILExtensionMeth(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.EntityRef,Microsoft.FSharp.Core.FSharpOption{System.UInt64},FSharp.Compiler.AbstractIL.IL.ILMethodDef)">
<summary>
 Build IL method infos for a C#-style extension method
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.MethInfo.ComputeHashCode">
<summary>
 Calculates a hash code of method info. Compatible with ItemsAreEffectivelyEqual relation.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.MethInfo.AdjustUserTypeInstForFSharpStyleIndexedExtensionMembers(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType})">
<summary>
 Add the actual type instantiation of the apparent type of an F# extension method.
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.MethInfo">
<summary>
 Describes an F# use of a method
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILMethInfo.RawMetadata">
<summary>
 Get the Abstract IL metadata associated with the method.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILMethInfo.ParamMetadata">
<summary>
 Get the Abstract IL metadata corresponding to the parameters of the method.
 If this is an C#-style extension method then drop the object argument.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILMethInfo.NumParams">
<summary>
 Get the number of parameters of the method
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILMethInfo.MetadataScope">
<summary>
 Get the Abstract IL scope information associated with interpreting the Abstract IL metadata that backs this method.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILMethInfo.IsVirtual">
<summary>
 Indicates if the IL method is marked virtual.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILMethInfo.IsStatic">
<summary>
 Does it appear to the user as a static method?
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILMethInfo.IsProtectedAccessibility">
<summary>
 Indicates if the method has protected accessibility,
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILMethInfo.IsNewSlot">
<summary>
 Does it have the .NET IL &apos;newslot&apos; flag set, and is also a virtual?
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILMethInfo.IsInstance">
<summary>
 Does it appear to the user as an instance method?
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILMethInfo.IsILExtensionMethod">
<summary>
 Indicates if the method is an extension method
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILMethInfo.IsFinal">
<summary>
 Indicates if the IL method is marked final.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILMethInfo.IsConstructor">
<summary>
 Indicates if the method is a constructor
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILMethInfo.IsClassConstructor">
<summary>
 Indicates if the method is a class initializer.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILMethInfo.IsAbstract">
<summary>
 Indicates if the IL method is marked abstract.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILMethInfo.ILName">
<summary>
 Get the IL name of the method
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILMethInfo.ILMethodRef">
<summary>
 Get a reference to the method (dropping all generic instantiations), as an Abstract IL ILMethodRef.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILMethInfo.ILExtensionMethodDeclaringTyconRef">
<summary>
 Get the declaring type associated with an extension member, if any.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILMethInfo.FormalMethodTypars">
<summary>
 Get the formal method type parameters associated with a method.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILMethInfo.DeclaringTypeInst">
<summary>
 Get the instantiation of the declaring type of the method.
 If this is an C#-style extension method then this is empty because extension members
 are never in generic classes.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILMethInfo.DeclaringTyconRef">
<summary>
 Get the declaring type of the method. If this is an C#-style extension method then this is the IL type
 holding the static member that is the extension method.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILMethInfo.ApparentEnclosingType">
<summary>
 Get the apparent declaring type of the method as an F# type.
 If this is a C#-style extension method then this is the type which the method
 appears to extend. This may be a variable type.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILMethInfo.ApparentEnclosingAppType">
<summary>
 Like ApparentEnclosingType but use the compiled nominal type if this is a method on a tuple type
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.ILMethInfo.IsReadOnly(FSharp.Compiler.TcGlobals.TcGlobals)">
<summary>
 Indicates if the method is marked with the [&lt;IsReadOnly&gt;] attribute. This is done by looking at the IL custom attributes on
 the method.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.ILMethInfo.IsDllImport(FSharp.Compiler.TcGlobals.TcGlobals)">
<summary>
 Indicates if the method is marked as a DllImport (a PInvoke). This is done by looking at the IL custom attributes on
 the method.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.ILMethInfo.GetRawArgTypes(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType})">
<summary>
 Get all the argument types of the IL method. Include the object argument even if this is
 an C#-style extension method.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.ILMethInfo.GetParamTypes(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType})">
<summary>
 Get the argument types of the IL method. If this is an C#-style extension method
 then drop the object argument.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.ILMethInfo.GetParamNamesAndTypes(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType})">
<summary>
 Get info about the arguments of the IL method. If this is an C#-style extension method then
 drop the object argument.

 Any type parameters of the enclosing type are instantiated in the type returned.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.ILMethInfo.GetObjArgTypes(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType})">
<summary>
 Get the (zero or one) &apos;self&apos;/&apos;this&apos;/&apos;object&apos; arguments associated with an IL method.
 An instance extension method returns one object argument.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.ILMethInfo.GetFSharpReturnType(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType})">
<summary>
 Get the F# view of the return type of the method, where &apos;void&apos; is &apos;unit&apos;.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.ILMethInfo.GetCompiledReturnType(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType})">
<summary>
 Get the compiled return type of the method, where &apos;void&apos; is None.
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.ILMethInfo">
<summary>
 Describes an F# use of an IL method.
</summary>
</member>
<member name="P:FSharp.Compiler.Infos.ILTypeInfo.ToAppType">
<summary>
 Get the compiled nominal type. In the case of tuple types, this is a .NET tuple type
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.ILTypeInfo">
<summary>
 Describes an F# use of an IL type, including the type instantiation associated with the type at a particular usage point.
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.ParamData">
<summary>
 Full information about a parameter returned for use by the type checker and language service.
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.ParamNameAndType">
<summary>
 Partial information about a parameter returned for use by the Language Service
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.OptionalArgInfo.CallerSide">
<summary>
 The argument is optional, and is a caller-side .NET optional or default arg.
 Note this is correctly termed caller side, even though the default value is optically specified on the callee:
 in fact the default value is read from the metadata and passed explicitly to the callee on the caller side.
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.OptionalArgInfo.CalleeSide">
<summary>
 The argument is optional, and is an F# callee-side optional arg
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.OptionalArgInfo.NotOptional">
<summary>
 The argument is not optional
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.OptionalArgInfo.FromILParameter(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.AbstractIL.IL.ILParameter)">
<summary>
 Compute the OptionalArgInfo for an IL parameter

 This includes the Visual Basic rules for IDispatchConstant and IUnknownConstant and optional arguments.
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.OptionalArgInfo">
<summary>
 Represents information about a parameter indicating if it is optional.
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.OptionalArgCallerSideValue">
<summary>
 The caller-side value for the optional arg, if any
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.ExtensionMethodPriority">
<summary>
 Describes the sequence order of the introduction of an extension method. Extension methods that are introduced
 later through &apos;open&apos; get priority in overload resolution.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.PropInfosEquivByNameAndSig(FSharp.Compiler.TypedTreeOps.Erasure,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.Infos.PropInfo,FSharp.Compiler.Infos.PropInfo)">
<summary>
 Used to hide/filter members from super classes based on signature
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.MethInfosEquivByNameAndSig(FSharp.Compiler.TypedTreeOps.Erasure,System.Boolean,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.Infos.MethInfo,FSharp.Compiler.Infos.MethInfo)">
<summary>
 Used to hide/filter members from base classes based on signature
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.PropInfosEquivByNameAndPartialSig(FSharp.Compiler.TypedTreeOps.Erasure,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.Infos.PropInfo,FSharp.Compiler.Infos.PropInfo)">
<summary>
 Used to hide/filter members from super classes based on signature
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.MethInfosEquivByNameAndPartialSig(FSharp.Compiler.TypedTreeOps.Erasure,System.Boolean,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.Infos.MethInfo,FSharp.Compiler.Infos.MethInfo)">
<summary>
 Used to hide/filter members from super classes based on signature
 Inref and outref parameter types will be treated as a byref type for equivalency.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.MethInfosEquivByPartialSig(FSharp.Compiler.TypedTreeOps.Erasure,System.Boolean,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.Infos.MethInfo,FSharp.Compiler.Infos.MethInfo)">
<summary>
 Inref and outref parameter types will be treated as a byref type for equivalency.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.CompiledSigOfMeth(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.Infos.MethInfo)">
<summary>
 Get the information about the compiled form of a method signature. Used when analyzing implementation
 relations between members and abstract slots.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.stripByrefTy(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 Strips inref and outref to be a byref.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.FindDelegateTypeOfPropertyEvent(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,System.String,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Find the delegate type that an F# event property implements by looking through the type hierarchy of the type of the property
 for the first instantiation of IDelegateEvent.
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.nonStandardEventError(System.String,FSharp.Compiler.Text.Range)">
<summary>
 Create an error object to raise should an event not have the shape expected by the .NET idiom described further below
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.MakeSlotSig(System.String,FSharp.Compiler.TypedTree.TType,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.SlotParam}},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.TType})">
<summary>
 Construct the data representing the signature of an abstract method slot
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.MakeSlotParam(FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.ArgReprInfo)">
<summary>
 Construct the data representing a parameter in the signature of an abstract method slot
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.ReparentSlotSigToUseMethodTypars(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.ValRef,FSharp.Compiler.TypedTree.SlotSig)">
<summary>
 The slotsig returned by methInfo.GetSlotSig is in terms of the type parameters on the parent type of the overriding method.
 Reverse-map the slotsig so it is in terms of the type parameters for the overriding method
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.GetCompiledReturnTyOfProvidedMethodInfo(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.Tainted{FSharp.Compiler.TypeProviders.ProvidedMethodBase})">
<summary>
 Get the return type of a provided method, where &apos;void&apos; is returned as &apos;None&apos;
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.ValRef.IsFSharpExplicitInterfaceImplementation(FSharp.Compiler.TypedTree.ValRef,FSharp.Compiler.TcGlobals.TcGlobals)">
<summary>
 Check if an F#-declared member value is an  explicit interface member implementation
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.ValRef.get_IsDefiniteFSharpOverrideMember(FSharp.Compiler.TypedTree.ValRef)">
<summary>
 Check if an F#-declared member value is an &apos;override&apos; or explicit member implementation
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.ValRef.get_IsDispatchSlotMember(FSharp.Compiler.TypedTree.ValRef)">
<summary>
 Check if an F#-declared member value is a dispatch slot
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.ValRef.get_IsVirtualMember(FSharp.Compiler.TypedTree.ValRef)">
<summary>
 Check if an F#-declared member value is a virtual method
</summary>
</member>
<member name="M:FSharp.Compiler.Infos.ValRef.IsFSharpEventProperty(FSharp.Compiler.TypedTree.ValRef,FSharp.Compiler.TcGlobals.TcGlobals)">
<summary>
 Indicates if an F#-declared function or member value is a CLIEvent property compiled as a .NET event
</summary>
</member>
<member name="T:FSharp.Compiler.Infos.BadEventTransformation">
<summary>
 An exception type used to raise an error using the old error system.

 Error text: &quot;A definition to be compiled as a .NET event does not have the expected form. Only property members can be compiled as .NET events.&quot;
</summary>
</member>
<member name="T:FSharp.Compiler.AccessibilityLogic.AccessorDomain.AccessibleFromSomewhere">
<summary>
 An AccessorDomain which returns all items
</summary>
</member>
<member name="T:FSharp.Compiler.AccessibilityLogic.AccessorDomain.AccessibleFromSomeFSharpCode">
<summary>
 An AccessorDomain which returns everything but .NET private/internal items.
 This is used
    - when solving member trait constraints, which are solved independently of accessibility
    - for failure paths in error reporting, e.g. to produce an error that an F# item is not accessible
    - an adhoc use in service.fs to look up a delegate signature
</summary>
</member>
<member name="T:FSharp.Compiler.AccessibilityLogic.AccessorDomain.AccessibleFromEverywhere">
<summary>
 An AccessorDomain which returns public items
</summary>
</member>
<member name="T:FSharp.Compiler.AccessibilityLogic.AccessorDomain.AccessibleFrom">
<summary>
 cpaths: indicates we have the keys to access any members private to the given paths
 tyconRefOpt:  indicates we have the keys to access any protected members of the super types of &apos;TyconRef&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.AccessibilityLogic.AccessorDomain">
<summary>
 Represents the &apos;keys&apos; a particular piece of code can use to access other constructs?.
</summary>
</member>
<member name="M:FSharp.Compiler.AccessibilityLogic.ComputeILAccess(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
<summary>
 Compute the accessibility of a provided member
</summary>
</member>
<member name="M:FSharp.Compiler.AccessibilityLogic.IsProvidedMemberAccessible(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.AbstractIL.IL.ILMemberAccess)">
<summary>
 Indicate if a provided member is accessible
</summary>
</member>
<member name="M:FSharp.Compiler.AccessibilityLogic.IsTypeAccessible(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TypedTree.TType)">
<summary>
 Indicates if a type is accessible (both definition and instantiation)
</summary>
</member>
<member name="M:FSharp.Compiler.AccessibilityLogic.CheckTyconReprAccessible(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Check that a type definition and its representation contents are accessible
</summary>
</member>
<member name="M:FSharp.Compiler.AccessibilityLogic.IsTyconReprAccessible(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Indicates if a type definition and its representation contents are accessible
</summary>
</member>
<member name="M:FSharp.Compiler.AccessibilityLogic.CheckTyconAccessible(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Check that an entity is accessible
</summary>
</member>
<member name="M:FSharp.Compiler.AccessibilityLogic.IsEntityAccessible(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Indicates if an entity is accessible
</summary>
</member>
<member name="M:FSharp.Compiler.AccessibilityLogic.IsAccessible(FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TypedTree.Accessibility)">
<summary>
 Indicates if an F# item is accessible
</summary>
</member>
<member name="T:FSharp.Compiler.AccessibilityLogic">
<summary>
 The basic logic of private/internal/protected/InternalsVisibleTo/public accessibility
</summary>
</member>
<member name="T:FSharp.Compiler.AttributeChecking">
<summary>
 Logic associated with checking &quot;ObsoleteAttribute&quot; and other attributes
 on items from name resolution
</summary>
</member>
<member name="M:FSharp.Compiler.TypeRelations.FindUniqueFeasibleSupertype(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.TType)">
<summary>
 &quot;Single Feasible Type&quot; inference
 Look for the unique supertype of ty2 for which ty2 :&gt; ty1 might feasibly hold
</summary>
</member>
<member name="M:FSharp.Compiler.TypeRelations.IteratedAdjustLambdaToMatchValReprInfo(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.TypedTree.ValReprInfo,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Adjust a lambda expression to match the argument counts expected in the ValReprInfo
</summary>
</member>
<member name="M:FSharp.Compiler.TypeRelations.destLambdaWithValReprInfo(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.TypedTree.ValReprInfo,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType)">
<summary>
 Break apart lambdas according to a given expected ValReprInfo that the lambda implements.
</summary>
</member>
<member name="M:FSharp.Compiler.TypeRelations.tryDestLambdaWithValReprInfo(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.TypedTree.ValReprInfo,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType)">
<summary>
 Break apart lambdas according to a given expected ValReprInfo that the lambda implements.
</summary>
</member>
<member name="M:FSharp.Compiler.TypeRelations.ChooseTyparSolutionAndRange(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.TypedTree.Typar)">
<summary>
 Choose solutions for Expr.TyChoose type &quot;hidden&quot; variables introduced
 by letrec nodes. Also used by the pattern match compiler to choose type
 variables when compiling patterns at generalized bindings.
     e.g. let ([], x) = ([], [])
 Here x gets a generalized type &quot;list&lt;&apos;T&gt;&quot;.
</summary>
</member>
<member name="M:FSharp.Compiler.TypeRelations.TypeFeasiblySubsumesType(System.Int32,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.Import.CanCoerce,FSharp.Compiler.TypedTree.TType)">
<summary>
 The feasible coercion relation. Part of the language spec.
</summary>
</member>
<member name="M:FSharp.Compiler.TypeRelations.TypesFeasiblyEquivStripMeasures``1(FSharp.Compiler.TcGlobals.TcGlobals,``0,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.TType)">
<summary>
 The feasible equivalence relation after stripping Measures.
</summary>
</member>
<member name="M:FSharp.Compiler.TypeRelations.TypesFeasiblyEquiv``1(System.Int32,FSharp.Compiler.TcGlobals.TcGlobals,``0,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.TType)">
<summary>
 The feasible equivalence relation. Part of the language spec.
</summary>
</member>
<member name="M:FSharp.Compiler.TypeRelations.TypesFeasiblyEquivalent``1(System.Boolean,System.Int32,FSharp.Compiler.TcGlobals.TcGlobals,``0,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.TType)">
<summary>
 The feasible equivalence relation. Part of the language spec.
</summary>
</member>
<member name="M:FSharp.Compiler.TypeRelations.TypeDefinitelySubsumesTypeNoCoercion(System.Int32,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.TType)">
<summary>
 Implements a :&gt; b without coercion based on finalized (no type variable) types
</summary>
</member>
<member name="T:FSharp.Compiler.TypeRelations">
<summary>
 Primary relations on types and signatures, with the exception of
 constraint solving and method overload resolution.
</summary>
</member>
<member name="T:FSharp.Compiler.InfoReader.SigOfFunctionForDelegate">
<summary>
 Represents information about the delegate - the Invoke MethInfo, the delegate argument types, the delegate return type
 and the overall F# function type for the function type associated with a .NET delegate type
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.InfoReader.TryFindRecdOrClassFieldInfoOfType(System.String,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Try and find a record or class field for a type.
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.InfoReader.TryFindIntrinsicNamedItemOfType(System.String,FSharp.Compiler.AccessibilityLogic.AccessorDomain,System.Boolean,FSharp.Compiler.InfoReader.FindMemberFlag,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Perform type-directed name resolution of a particular named member in an F# type
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.InfoReader.IsLanguageFeatureRuntimeSupported(FSharp.Compiler.Features.LanguageFeature)">
<summary>
 Check if the given language feature is supported by the runtime.
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.InfoReader.IsInterfaceTypeWithMatchingStaticAbstractMember(FSharp.Compiler.Text.Range,System.String,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TypedTree.TType)">
<summary>
 Determine if a type has a static abstract method with the given name somewhere in its hierarchy
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.InfoReader.GetTraitInfosInType(Microsoft.FSharp.Core.FSharpOption{System.String},FSharp.Compiler.TypedTree.TType)">
<summary>
 Get the trait infos for a type variable (empty for everything else)
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.InfoReader.GetRecordOrClassFieldsOfType(Microsoft.FSharp.Core.FSharpOption{System.String},FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Read the record or class fields of a type, including inherited ones. Cache the result for monomorphic types.
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.InfoReader.GetRawIntrinsicMethodSetsOfType(Microsoft.FSharp.Core.FSharpOption{System.String},FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TypeHierarchy.AllowMultiIntfInstantiations,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Read the raw method sets of a type, including inherited ones. Cache the result for monomorphic types
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.InfoReader.GetPrimaryTypeHierarchy(FSharp.Compiler.TypeHierarchy.AllowMultiIntfInstantiations,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Get the super-types of a type, excluding interface types.
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.InfoReader.GetIntrinsicPropInfosOfType(Microsoft.FSharp.Core.FSharpOption{System.String},FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TypeHierarchy.AllowMultiIntfInstantiations,FSharp.Compiler.InfoReader.FindMemberFlag,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Get the flattened list of intrinsic properties in the hierarchy
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.InfoReader.GetIntrinsicPropInfoSetsOfType(Microsoft.FSharp.Core.FSharpOption{System.String},FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TypeHierarchy.AllowMultiIntfInstantiations,FSharp.Compiler.InfoReader.FindMemberFlag,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Get the sets of intrinsic properties in the hierarchy (not including extension properties)
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.InfoReader.GetIntrinsicMethInfosOfType(Microsoft.FSharp.Core.FSharpOption{System.String},FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TypeHierarchy.AllowMultiIntfInstantiations,FSharp.Compiler.InfoReader.FindMemberFlag,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Get the flattened list of intrinsic methods in the hierarchy
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.InfoReader.GetIntrinsicMethInfoSetsOfType(Microsoft.FSharp.Core.FSharpOption{System.String},FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TypeHierarchy.AllowMultiIntfInstantiations,FSharp.Compiler.InfoReader.FindMemberFlag,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Get the sets of intrinsic methods in the hierarchy (not including extension methods)
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.InfoReader.GetILFieldInfosOfType(Microsoft.FSharp.Core.FSharpOption{System.String},FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Read the IL fields of a type, including inherited ones. Cache the result for monomorphic types.
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.InfoReader.GetEventInfosOfType(Microsoft.FSharp.Core.FSharpOption{System.String},FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Read the events of a type, including inherited ones. Cache the result for monomorphic types.
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.InfoReader.GetEntireTypeHierarchy(FSharp.Compiler.TypeHierarchy.AllowMultiIntfInstantiations,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Get the super-types of a type, including interface types.
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.InfoReader.FindImplicitConversions(FSharp.Compiler.Text.Range,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TypedTree.TType)">
<summary>
 Find the op_Implicit for a type
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.InfoReader.ExcludeHiddenOfPropInfos(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Infos.PropInfo}})">
<summary>
 Exclude properties from super types which have the same name as a property in a more specific type.
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.InfoReader.ExcludeHiddenOfMethInfos(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Infos.MethInfo}})">
<summary>
 Exclude methods from super types which have the same signature as a method in a more specific type.
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.InfoReader.#ctor(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap)">
<summary>
 Get the declared IL fields of a type, not including inherited fields
</summary>
</member>
<member name="T:FSharp.Compiler.InfoReader.InfoReader">
<summary>
 An InfoReader is an object to help us read and cache infos.
 We create one of these for each file we typecheck.
</summary>
</member>
<member name="T:FSharp.Compiler.InfoReader.FindMemberFlag.DiscardOnFirstNonOverride">
<summary>
 Similar to &quot;IgnoreOverrides&quot;, but filters the items bottom-to-top,
 and discards all when finds first non-virtual member which hides one above it in hierarchy.
</summary>
</member>
<member name="T:FSharp.Compiler.InfoReader.FindMemberFlag.PreferOverrides">
<summary>
 Get overrides instead of abstract slots when measuring whether a class/interface implements all its required slots.
</summary>
</member>
<member name="T:FSharp.Compiler.InfoReader.FindMemberFlag.IgnoreOverrides">
<summary>
 Prefer items toward the top of the hierarchy, which we do if the items are virtual
 but not when resolving base calls.
</summary>
</member>
<member name="T:FSharp.Compiler.InfoReader.FindMemberFlag">
<summary>
 Indicates if we prefer overrides or abstract slots.
</summary>
</member>
<member name="T:FSharp.Compiler.InfoReader.HierarchyItem">
<summary>
 Sets of methods up the hierarchy, ignoring duplicates by name and sig.
 Used to collect sets of virtual methods, protected methods, protected
 properties etc.
</summary>
</member>
<member name="T:FSharp.Compiler.InfoReader.PropertyCollector">
<summary>
 A helper type to help collect properties.

 Join up getters and setters which are not associated in the F# data structure
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.TryFindXmlDocByAssemblyNameAndSig(FSharp.Compiler.InfoReader.InfoReader,System.String,System.String)">
<summary>
 Try to find the xml doc associated with the assembly name and metadata key
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.TryFindMetadataInfoOfExternalEntityRef(FSharp.Compiler.InfoReader.InfoReader,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Try to find the name of the metadata file for this external definition
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.IsStandardEventInfo(FSharp.Compiler.InfoReader.InfoReader,FSharp.Compiler.Text.Range,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.Infos.EventInfo)">
<summary>
 Indicates if an event info is associated with a delegate type that is a &quot;standard&quot; .NET delegate type
 with a sender parameter.
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.TryDestStandardDelegateType(FSharp.Compiler.InfoReader.InfoReader,FSharp.Compiler.Text.Range,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TypedTree.TType)">
<summary>
 Try and interpret a delegate type as a &quot;standard&quot; .NET delegate type associated with an event, with a &quot;sender&quot; parameter.
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.GetSigOfFunctionForDelegate(FSharp.Compiler.InfoReader.InfoReader,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.Text.Range,FSharp.Compiler.AccessibilityLogic.AccessorDomain)">
<summary>
 Given a delegate type work out the minfo, argument types, return type
 and F# function type by looking at the Invoke signature of the delegate.
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.GetIntrinsicMostSpecificOverrideMethInfoSetsOfType(FSharp.Compiler.InfoReader.InfoReader,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Get a set of most specific override methods.
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.TryFindIntrinsicPropInfo(FSharp.Compiler.InfoReader.InfoReader,FSharp.Compiler.Text.Range,FSharp.Compiler.AccessibilityLogic.AccessorDomain,System.String,FSharp.Compiler.TypedTree.TType)">
<summary>
 Try to find a particular named property on a type. Only used to ensure that local &apos;let&apos; definitions and property names
 are distinct, a somewhat adhoc check in tc.fs.
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.TryFindIntrinsicMethInfo(FSharp.Compiler.InfoReader.InfoReader,FSharp.Compiler.Text.Range,FSharp.Compiler.AccessibilityLogic.AccessorDomain,System.String,FSharp.Compiler.TypedTree.TType)">
<summary>
 Try to detect the existence of a method on a type.
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.TryFindIntrinsicNamedItemOfType(FSharp.Compiler.InfoReader.InfoReader,System.String,FSharp.Compiler.AccessibilityLogic.AccessorDomain,System.Boolean,FSharp.Compiler.InfoReader.FindMemberFlag,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Perform type-directed name resolution of a particular named member in an F# type
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.GetIntrinsicPropInfoWithOverriddenPropOfType(FSharp.Compiler.InfoReader.InfoReader,Microsoft.FSharp.Core.FSharpOption{System.String},FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TypeHierarchy.AllowMultiIntfInstantiations,FSharp.Compiler.InfoReader.FindMemberFlag,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Get the flattened list of intrinsic properties in the hierarchy. If the PropInfo is get-only or set-only, try to find its setter or getter from the hierarchy.
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.GetIntrinsicPropInfosOfType(FSharp.Compiler.InfoReader.InfoReader,Microsoft.FSharp.Core.FSharpOption{System.String},FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TypeHierarchy.AllowMultiIntfInstantiations,FSharp.Compiler.InfoReader.FindMemberFlag,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Get the flattened list of intrinsic properties in the hierarchy
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.GetIntrinsicMethInfosOfType(FSharp.Compiler.InfoReader.InfoReader,Microsoft.FSharp.Core.FSharpOption{System.String},FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TypeHierarchy.AllowMultiIntfInstantiations,FSharp.Compiler.InfoReader.FindMemberFlag,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Get the flattened list of intrinsic methods in the hierarchy
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.GetIntrinsicPropInfoSetsOfType(FSharp.Compiler.InfoReader.InfoReader,Microsoft.FSharp.Core.FSharpOption{System.String},FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TypeHierarchy.AllowMultiIntfInstantiations,FSharp.Compiler.InfoReader.FindMemberFlag,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Get the sets intrinsic properties in the hierarchy (not including extension properties)
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.GetIntrinsicMethInfoSetsOfType(FSharp.Compiler.InfoReader.InfoReader,Microsoft.FSharp.Core.FSharpOption{System.String},FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TypeHierarchy.AllowMultiIntfInstantiations,FSharp.Compiler.InfoReader.FindMemberFlag,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Get the sets of intrinsic methods in the hierarchy (not including extension methods)
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.ExcludeHiddenOfPropInfos(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Infos.PropInfo}})">
<summary>
 Exclude properties from super types which have the same name as a property in a more specific type.
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.ExcludeHiddenOfMethInfos(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Infos.MethInfo}})">
<summary>
 Exclude methods from super types which have the same signature as a method in a more specific type.
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.GetIntrinsicConstructorInfosOfType(FSharp.Compiler.InfoReader.InfoReader,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Get the declared constructors of any F# type
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.FilterMostSpecificMethInfoSets(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpMap{System.String,Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Compiler.TypedTree.TType,FSharp.Compiler.Infos.MethInfo}}})">
<summary>
 From the given method sets, filter each set down to the most specific ones.
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.GetMostSpecificItemsByType``1(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.Tuple{FSharp.Compiler.TypedTree.TType,FSharp.Compiler.Text.Range}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Get the items that are considered the most specific in the hierarchy out of the given items by type.
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.IsIndexerType(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.TypedTree.TType)">
<summary>
 Checks whether the given type has an indexer property.
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.GetImmediateIntrinsicPropInfosWithExplicitImplOfType(Microsoft.FSharp.Core.FSharpOption{System.String},FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Query the immediate properties of an F# type, not taking into account inherited properties. The optFilter
 parameter is an optional name to restrict the set of properties returned.
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.GetImmediateIntrinsicPropInfosOfType(Microsoft.FSharp.Core.FSharpOption{System.String},FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Query the immediate properties of an F# type, not taking into account inherited properties. The optFilter
 parameter is an optional name to restrict the set of properties returned.
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.GetImmediateIntrinsicMethInfosWithExplicitImplOfType(Microsoft.FSharp.Core.FSharpOption{System.String},FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Query the immediate methods of an F# type, not taking into account inherited methods. The optFilter
 parameter is an optional name to restrict the set of properties returned.
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.GetImmediateIntrinsicMethInfosOfType(Microsoft.FSharp.Core.FSharpOption{System.String},FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Query the immediate methods of an F# type, not taking into account inherited methods. The optFilter
 parameter is an optional name to restrict the set of properties returned.
</summary>
</member>
<member name="M:FSharp.Compiler.InfoReader.TrySelectMemberVal``1(FSharp.Compiler.TcGlobals.TcGlobals,Microsoft.FSharp.Core.FSharpOption{System.String},FSharp.Compiler.TypedTree.TType,Microsoft.FSharp.Core.FSharpOption{System.UInt64},``0,FSharp.Compiler.TypedTree.ValRef)">
<summary>
 Try to select an F# value when querying members, and if so return a MethInfo that wraps the F# value.
</summary>
</member>
<member name="T:FSharp.Compiler.InfoReader">
<summary>
 Select members from a type by name, searching the type hierarchy if needed
</summary>
</member>
<member name="M:FSharp.Compiler.NicePrint.stringOfMethInfoFSharpStyle(FSharp.Compiler.InfoReader.InfoReader,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTreeOps.DisplayEnv,FSharp.Compiler.Infos.MethInfo)">
<summary>
 Convert a MethInfo to a F# signature
</summary>
</member>
<member name="T:FSharp.Compiler.NicePrint">
<summary>
 Print Signatures/Types, for signatures, intellisense, quick info, FSI responses
</summary>
</member>
<member name="M:FSharp.Compiler.AugmentTypeDefinitions.TypeDefinitelyHasEquality(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType)">
<summary>
 This predicate can be used once type inference is complete, before then it is an approximation
 that doesn&apos;t assert any new constraints
</summary>
</member>
<member name="T:FSharp.Compiler.AugmentTypeDefinitions">
<summary>
 Generate the hash/compare functions we add to user-defined types by default.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.ShouldNotifySink">
<summary>
 Indicates whether we want to report found items to the name resolution sink
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.AfterResolution.RecordResolution">
<summary>
 Notify the sink of the information needed to complete recording a use of a symbol
 for the purposes of the language service.  One of the callbacks should be called by
 the checker.

 The first callback represents a case where we have learned the type
 instantiation of a generic method or value.

 The second represents the case where we have resolved overloading and/or
 a specific override. The &apos;Item option&apos; contains the candidate overrides.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.AfterResolution.DoNothing">
<summary>
 Notification is not needed
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.AfterResolution">
<summary>
 Specifies extra work to do after overload resolution
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.PermitDirectReferenceToGeneratedType">
<summary>
 Indicates whether we permit a direct reference to a type generator. Only set when resolving the
 right-hand-side of a [&lt;Generate&gt;] declaration.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.WarnOnUpperFlag">
<summary>
 Indicates if a warning should be given for the use of upper-case identifiers in patterns
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.LookupKind.Expr">
<summary>
 Indicates resolution within an expression, either A.B.C (static) or expr.A.B.C (instance) and
 whether we should filter content according to instance/static characteristic.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.LookupKind">
<summary>
 Indicates the kind of lookup being performed. Note, this type should be made private to nameres.fs.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.LookupIsInstance">
<summary>
 Indicates if a lookup requires a match on the instance/static characteristic.

 This is not supplied at all lookup sites - in theory it could be, but currently diagnostics on many paths
 rely on returning all the content and then filtering it later for instance/static characteristic.

 When applied, this also currently doesn&apos;t filter all content - it is currently only applied to filter out extension methods
 that have a static/instance mismatch.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.ResultCollectionSettings">
<summary>
 Indicates if we only need one result or all possible results from a resolution.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.TcResultsSink">
<summary>
 An abstract type for reporting the results of name resolution and type checking, and which allows
 temporary suspension and/or redirection of reporting.
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.TcResultsSinkImpl.GetSymbolUses">
<summary>
 Get all the uses of all symbols reported to the sink
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.TcResultsSinkImpl.GetResolutions">
<summary>
 Get all the resolutions reported to the sink
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.TcResultsSinkImpl.GetOpenDeclarations">
<summary>
 Get all open declarations reported to the sink
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.TcResultsSinkImpl.GetFormatSpecifierLocations">
<summary>
 Get the format specifier locations
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.TcResultsSinkImpl.#ctor(FSharp.Compiler.TcGlobals.TcGlobals,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.Text.ISourceText})">
<summary>
 Create a TcResultsSinkImpl
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.TcResultsSinkImpl">
<summary>
 An implementation of ITypecheckResultsSink to collect information during type checking
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.ITypecheckResultsSink.FormatStringCheckContext">
<summary>
 Cached line-end normalized source text and an array of line end positions, used for format string parsing
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.ITypecheckResultsSink.CurrentSourceText">
<summary>
 Get the current source
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.ITypecheckResultsSink.NotifyOpenDeclaration(FSharp.Compiler.TypedTree.OpenDeclaration)">
<summary>
 Record that an open declaration occurred in a given scope range
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.ITypecheckResultsSink.NotifyNameResolution(FSharp.Compiler.Text.Position,FSharp.Compiler.NameResolution.Item,Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Compiler.TypedTree.Typar,FSharp.Compiler.TypedTree.TType}},FSharp.Compiler.NameResolution.ItemOccurrence,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.Text.Range,System.Boolean)">
<summary>
 Record that a name resolution occurred at a specific location in the source
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.ITypecheckResultsSink.NotifyMethodGroupNameResolution(FSharp.Compiler.Text.Position,FSharp.Compiler.NameResolution.Item,FSharp.Compiler.NameResolution.Item,Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Compiler.TypedTree.Typar,FSharp.Compiler.TypedTree.TType}},FSharp.Compiler.NameResolution.ItemOccurrence,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.Text.Range,System.Boolean)">
<summary>
 Record that a method group name resolution occurred at a specific location in the source
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.ITypecheckResultsSink.NotifyFormatSpecifierLocation(FSharp.Compiler.Text.Range,System.Int32)">
<summary>
 Record that a printf format specifier occurred at a specific location in the source
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.ITypecheckResultsSink.NotifyExprHasType(FSharp.Compiler.TypedTree.TType,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.Text.Range)">
<summary>
 Record that an expression has a specific type at the given range.
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.ITypecheckResultsSink.NotifyEnvWithScope(FSharp.Compiler.Text.Range,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.AccessibilityLogic.AccessorDomain)">
<summary>
 Record that an environment is active over the given scope range
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.ITypecheckResultsSink">
<summary>
 An abstract type for reporting the results of name resolution and type checking
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.FormatStringCheckContext.LineStartPositions">
<summary>
 Array of line start positions
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.FormatStringCheckContext.SourceText">
<summary>
 Source text
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.FormatStringCheckContext">
<summary>
 Source text and an array of line end positions, used for format string parsing
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.TcSymbolUses.Empty">
<summary>
 Empty collection of symbol uses
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.TcSymbolUses.AllUsesOfSymbols">
<summary>
 All the uses of all items within the file
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.TcSymbolUses.GetUsesOfSymbol(FSharp.Compiler.NameResolution.Item)">
<summary>
 Get all the uses of a particular item within the file
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.TcSymbolUses.GetFormatSpecifierLocationsAndArity">
<summary>
 Get the locations of all the printf format specifiers in the file
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.TcSymbolUses">
<summary>
 Represents container for all name resolutions that were met so far when typechecking some particular file
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.TcResolutions.Empty">
<summary>
 Represents the empty set of resolutions
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.TcResolutions.CapturedNameResolutions">
<summary>
 Exact name resolutions
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.TcResolutions.CapturedMethodGroupResolutions">
<summary>
 Represents additional resolutions of names to groups of methods.
 CapturedNameResolutions should be checked when no captured method group is found.
 See TypeCheckInfo.GetCapturedNameResolutions for example.
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.TcResolutions.CapturedExpressionTypings">
<summary>
 Information of exact types found for expressions, that can be to the left of a dot.
 typ - the inferred type for an expression
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.TcResolutions.CapturedEnvs">
<summary>
 Name resolution environments for every interesting region in the file. These regions may
 overlap, in which case the smallest region applicable should be used.
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.CapturedNameResolution.Range">
<summary>
 The starting and ending position
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.CapturedNameResolution.Pos">
<summary>
 line and column
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.CapturedNameResolution.NameResolutionEnv">
<summary>
 Naming environment--for example, currently open namespaces.
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.CapturedNameResolution.ItemWithInst">
<summary>
 The active instantiation for any generic type parameters
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.CapturedNameResolution.ItemOccurrence">
<summary>
 Information about the occurrence of the symbol
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.CapturedNameResolution.Item">
<summary>
 Named item
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.CapturedNameResolution.DisplayEnv">
<summary>
 Information about printing. For example, should redundant keywords be hidden?
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.CapturedNameResolution.AccessorDomain">
<summary>
 The access rights of code at the location
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.ItemOccurrence">
<summary>
 Represents the kind of the occurrence when reporting a name in name resolution
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.TypeNameResolutionInfo">
<summary>
 Represents information which guides name resolution of types.
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.TypeNameResolutionStaticArgsInfo.DefiniteEmpty">
<summary>
 Indicates definite knowledge of empty type arguments, i.e. the logical equivalent of name&lt; &gt;
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.TypeNameResolutionStaticArgsInfo.FromTyArgs(System.Int32)">
<summary>
 Deduce definite knowledge of type arguments
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.TypeNameResolutionStaticArgsInfo">
<summary>
 Represents information about the generic argument count of a type name when resolving it.

 In some situations we resolve &quot;List&quot; to any type definition with that name regardless of the number
 of generic arguments. In others, we know precisely how many generic arguments are needed.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.TypeNameResolutionFlag.ResolveTypeNamesToTypeRefs">
<summary>
 Indicates we are resolving type names to type definitions
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.TypeNameResolutionFlag.ResolveTypeNamesToCtors">
<summary>
 Indicates we are resolving type names to constructor methods.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.TypeNameResolutionFlag">
<summary>
 Indicates whether we are resolving type names to type definitions or to constructor methods.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.CheckForDuplicateTyparFlag">
<summary>
 A flag which indicates if it is an error to have two declared type parameters with identical names
 in the name resolution environment.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.ExtraDotAfterIdentifier">
<summary>
 Indicates whether an identifier (single or long) is followed by an extra dot. Typically used
 to provide better tooling and error reporting.
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.NameResolutionEnv.eTypars">
<summary>
 Typars (always available by unqualified names). Further typars can be
 in the tpenv, a structure folded through each top-level definition.
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.NameResolutionEnv.eUnindexedExtensionMembers">
<summary>
 Other extension members unindexed by type
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.NameResolutionEnv.eIndexedExtensionMembers">
<summary>
 Extension members by type and name
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.NameResolutionEnv.eFullyQualifiedTyconsByDemangledNameAndArity">
<summary>
 Tycons available by unqualified, demangled names (i.e. (List,1) --&gt; TyconRef)
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.NameResolutionEnv.eTyconsByDemangledNameAndArity">
<summary>
 Tycons available by unqualified, demangled names (i.e. (List,1) --&gt; TyconRef)
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.NameResolutionEnv.eTyconsByAccessNames">
<summary>
 Tycons indexed by the various names that may be used to access them, e.g.
     &quot;List&quot; --&gt; multiple TyconRef&apos;s for the various tycons accessible by this name.
     &quot;List`1&quot; --&gt; TyconRef
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.NameResolutionEnv.eUnqualifiedRecordOrUnionTypeInsts">
<summary>
 Record or unions that may have type instantiations associated with them
 when record labels or union cases are used in an unqualified context.
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.NameResolutionEnv.eFieldLabels">
<summary>
 RecdField labels in scope.  RecdField labels are those where type are inferred
 by label rather than by known type annotation.
 Bools indicate if from a record, where no warning is given on indeterminate lookup
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.NameResolutionEnv.eFullyQualifiedModulesAndNamespaces">
<summary>
 Fully qualified modules and namespaces. &apos;open&apos; does not change this.
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.NameResolutionEnv.eModulesAndNamespaces">
<summary>
 Modules accessible via &quot;.&quot; notation. Note this is a multi-map.
 Adding a module abbreviation adds it a local entry to this List.map.
 Likewise adding a ccu or opening a path adds entries to this List.map.
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.NameResolutionEnv.ePatItems">
<summary>
 Data Tags and Active Pattern Tags available by unqualified name
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.NameResolutionEnv.eUnqualifiedEnclosingTypeInsts">
<summary>
 Enclosing type instantiations that are associated with an unqualified type item
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.NameResolutionEnv.eUnqualifiedItems">
<summary>
 Values and Data Tags available by unqualified name
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.NameResolutionEnv.eDisplayEnv">
<summary>
 Display environment information for output
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.NameResolutionEnv">
<summary>
 The environment of information used to resolve names
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.ExtensionMember.ILExtMem">
<summary>
 ILExtMem(declaringTyconRef, ilMetadata, pri)

 IL-style extension member, backed by some kind of method with an [&lt;Extension&gt;] attribute
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.ExtensionMember.FSExtMem">
<summary>
 F#-style Extrinsic extension member, defined in F# code
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.ExtensionMember.Priority">
<summary>
 Describes the sequence order of the introduction of an extension method. Extension methods that are introduced
 later through &apos;open&apos; get priority in overload resolution.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.ExtensionMember">
<summary>
 Information about an extension member held in the name resolution environment
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.FieldResolution">
<summary>
 Represents a record field resolution and the information if the usage is deprecated.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.ItemWithInst">
<summary>
 Pairs an Item with a TyparInstantiation showing how generic type variables of the item are instantiated at
 a particular usage point.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.Item.UnqualifiedType">
<summary>
 Represents the potential resolution of an unqualified name to a type.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.Item.SetterArg">
<summary>
 Represents the resolution of a name to a named property setter
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.Item.OtherName">
<summary>
 Represents the resolution of a name to a named argument
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.Item.ImplicitOp">
<summary>
 Represents the resolution of a name to an operator
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.Item.ModuleOrNamespaces">
<summary>
 Represents the resolution of a name to a module or namespace
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.Item.TypeVar">
<summary>
 Represents the resolution of a name to a type variable
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.Item.CustomBuilder">
<summary>
 Represents the resolution of a name to a custom builder in the F# computation expression syntax
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.Item.CustomOperation">
<summary>
 CustomOperation(nm, helpText, methInfo)

 Used to indicate the availability or resolution of a custom query operation such as &apos;sortBy&apos; or &apos;where&apos; in computation expression syntax
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.Item.Types">
<summary>
 Represents the resolution of a name to a group of types
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.Item.DelegateCtor">
<summary>
 Represents the resolution of a name to a delegate
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.Item.CtorGroup">
<summary>
 Represents the resolution of a name to a constructor
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.Item.MethodGroup">
<summary>
 Represents the resolution of a name to a group of methods.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.Item.Property">
<summary>
 Represents the resolution of a name to a property
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.Item.Event">
<summary>
 Represents the resolution of a name to an event
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.Item.ILField">
<summary>
 Represents the resolution of a name to a .NET field
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.Item.NewDef">
<summary>
 Represents the resolution of a name at the point of its own definition.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.Item.AnonRecdField">
<summary>
 Represents the resolution of a name to a field of an anonymous record type.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.Item.UnionCaseField">
<summary>
 Represents the resolution of a name to a union case field.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.Item.Trait">
<summary>
 Represents the resolution of a name to an F# trait
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.Item.RecdField">
<summary>
 Represents the resolution of a name to an F# record or exception field.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.Item.ExnCase">
<summary>
 Represents the resolution of a name to an F# exception definition.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.Item.ActivePatternCase">
<summary>
 Represents the resolution of a name to an F# active pattern case within the body of an active pattern.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.Item.ActivePatternResult">
<summary>
 Represents the resolution of a name to an F# active pattern result.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.Item.UnionCase">
<summary>
 Represents the resolution of a name to an F# union case.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.Item.Value">
<summary>
 Represents the resolution of a name to an F# value or function.
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.Item.DisplayNameCore">
<summary>
 The text for the item to use in the declaration list.
 This does not include backticks, parens etc.

 Note: here &quot;Core&quot; means &quot;without added backticks or parens&quot;
</summary>
</member>
<member name="P:FSharp.Compiler.NameResolution.Item.DisplayName">
<summary>
 The full text for the item to show in error messages and to use in code.
 This includes backticks, parens etc.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.Item">
<summary>
 Represents an item that results from name resolution
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.ArgumentContainer.Type">
<summary>
 The named argument is a static parameter to a provided type.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.ArgumentContainer.Method">
<summary>
 The named argument is an argument of a method
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.ArgumentContainer">
<summary>
 Represents the item with which a named argument is associated.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.NameResolver">
<summary>
 A NameResolver is a context for name resolution. It primarily holds an InfoReader.
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.ResolveCompletionsInType(FSharp.Compiler.NameResolution.NameResolver,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.NameResolution.ResolveCompletionTargets,FSharp.Compiler.Text.Range,FSharp.Compiler.AccessibilityLogic.AccessorDomain,System.Boolean,FSharp.Compiler.TypedTree.TType)">
<summary>
 Resolve a (possibly incomplete) long identifier to a set of possible resolutions, qualified by type.
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.ResolvePartialLongIdent(FSharp.Compiler.NameResolution.NameResolver,FSharp.Compiler.NameResolution.NameResolutionEnv,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Infos.MethInfo,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.TType,System.Boolean}},FSharp.Compiler.Text.Range,FSharp.Compiler.AccessibilityLogic.AccessorDomain,Microsoft.FSharp.Collections.FSharpList{System.String},System.Boolean)">
<summary>
 Resolve a (possibly incomplete) long identifier to a set of possible resolutions.
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.TryToResolveLongIdentAsType(FSharp.Compiler.NameResolution.NameResolver,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Try to resolve a long identifier as type.
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.FakeInstantiationGenerator(FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar})">
<summary>
 A generator of type instantiations used when no more specific type instantiation is known.
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.ResolveExprDotLongIdentAndComputeRange(FSharp.Compiler.NameResolution.TcResultsSink,FSharp.Compiler.NameResolution.NameResolver,FSharp.Compiler.Text.Range,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.TypedTree.TType,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.Ident},FSharp.Compiler.NameResolution.TypeNameResolutionInfo,FSharp.Compiler.InfoReader.FindMemberFlag,System.Boolean,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.Syntax.SynExpr})">
<summary>
 Resolve a long identifier occurring in an expression position, qualified by a type.
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.ResolveLongIdentAsExprAndComputeRange(FSharp.Compiler.NameResolution.TcResultsSink,FSharp.Compiler.NameResolution.NameResolver,FSharp.Compiler.Text.Range,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.NameResolution.TypeNameResolutionInfo,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.Ident},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.Syntax.SynExpr})">
<summary>
 Resolve a long identifier occurring in an expression position.
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.ResolveRecordOrClassFieldsOfType(FSharp.Compiler.NameResolution.NameResolver,FSharp.Compiler.Text.Range,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TypedTree.TType,System.Boolean)">
<summary>
 Return the fields for the given class or record
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.ResolvePartialLongIdentToClassOrRecdFields(FSharp.Compiler.NameResolution.NameResolver,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.Text.Range,FSharp.Compiler.AccessibilityLogic.AccessorDomain,Microsoft.FSharp.Collections.FSharpList{System.String},System.Boolean,System.Boolean)">
<summary>
 Resolve a (possibly incomplete) long identifier to a list of possible class or record fields
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.ResolveExprLongIdent(FSharp.Compiler.NameResolution.TcResultsSink,FSharp.Compiler.NameResolution.NameResolver,FSharp.Compiler.Text.Range,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.NameResolution.TypeNameResolutionInfo,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.Ident},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.Syntax.SynExpr})">
<summary>
 Resolve a long identifier occurring in an expression position
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.ResolveNestedField(FSharp.Compiler.NameResolution.TcResultsSink,FSharp.Compiler.NameResolution.NameResolver,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TypedTree.TType,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.Ident})">
<summary>
 Resolve a long identifier to a nested field
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.ResolveField(FSharp.Compiler.NameResolution.TcResultsSink,FSharp.Compiler.NameResolution.NameResolver,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TypedTree.TType,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.Ident},FSharp.Compiler.Syntax.Ident,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.Ident})">
<summary>
 Resolve a long identifier to a field
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.ResolveTypeLongIdent(FSharp.Compiler.NameResolution.TcResultsSink,FSharp.Compiler.NameResolution.NameResolver,FSharp.Compiler.NameResolution.ItemOccurrence,FSharp.Compiler.NameResolution.FullyQualifiedFlag,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.AccessibilityLogic.AccessorDomain,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.Ident},FSharp.Compiler.NameResolution.TypeNameResolutionStaticArgsInfo,FSharp.Compiler.NameResolution.PermitDirectReferenceToGeneratedType)">
<summary>
 Resolve a long identifier to a type definition
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.ResolveTypeLongIdentInTyconRef(FSharp.Compiler.NameResolution.TcResultsSink,FSharp.Compiler.NameResolution.NameResolver,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.NameResolution.TypeNameResolutionInfo,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.EntityRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.Ident})">
<summary>
 Resolve a long identifier representing a type name
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.ResolvePatternLongIdent(FSharp.Compiler.NameResolution.TcResultsSink,FSharp.Compiler.NameResolution.NameResolver,FSharp.Compiler.NameResolution.WarnOnUpperFlag,System.Boolean,FSharp.Compiler.Text.Range,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.NameResolution.TypeNameResolutionInfo,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.Ident},FSharp.Compiler.NameResolution.ExtraDotAfterIdentifier)">
<summary>
 Resolve a long identifier when used in a pattern.
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.ResolveLongIdentInType(FSharp.Compiler.NameResolution.TcResultsSink,FSharp.Compiler.NameResolution.NameResolver,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.NameResolution.LookupKind,FSharp.Compiler.Text.Range,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.Syntax.Ident,FSharp.Compiler.InfoReader.FindMemberFlag,FSharp.Compiler.NameResolution.TypeNameResolutionInfo,FSharp.Compiler.TypedTree.TType)">
<summary>
 Resolve a long identifier using type-qualified name resolution.
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.ResolveObjectConstructor(FSharp.Compiler.NameResolution.NameResolver,FSharp.Compiler.TypedTreeOps.DisplayEnv,FSharp.Compiler.Text.Range,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.TypedTree.TType)">
<summary>
 Resolve a long identifier to an object constructor.
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.ResolveLongIdentAsModuleOrNamespace(FSharp.Compiler.NameResolution.TcResultsSink,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,System.Boolean,FSharp.Compiler.NameResolution.FullyQualifiedFlag,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.Syntax.Ident,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.Ident},System.Boolean,FSharp.Compiler.NameResolution.ShouldNotifySink)">
<summary>
 Resolve a long identifier to a namespace, module.
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.FreshenTypeInst(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar})">
<summary>
 Given a set of type parameters, make new inference type variables for
 each and ensure that the constraints on the new type variables are adjusted.

 Returns
   1. the new type parameters
   2. the instantiation mapping old type parameters to inference variables
   3. the inference type variables as a list of types.
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.FreshenAndFixupTypars(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TyparRigidity,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar})">
<summary>
 Given a set of formal type parameters and their constraints, make new inference type variables for
 each and ensure that the constraints on the new type variables are adjusted to refer to these.

 Returns
   1. the new type parameters
   2. the instantiation mapping old type parameters to inference variables
   3. the inference type variables as a list of types.
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.FreshenMethInfo(FSharp.Compiler.Text.Range,FSharp.Compiler.Infos.MethInfo)">
<summary>
 Given a method, which may be generic, make new inference type variables for
 its generic parameters, and ensure that the constraints the new type variables are adjusted.

 Returns the inference type variables as a list of types.
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.FreshenTypars(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar})">
<summary>
 Given a set of type parameters, make new inference type variables for
 each and ensure that the constraints on the new type variables are adjusted.

 Returns the inference type variables as a list of types.
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.NewInferenceTypes``1(FSharp.Compiler.TcGlobals.TcGlobals,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Create a list of inference type variables, one for each element in the input list
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.NewErrorMeasure">
<summary>
 Create an inference type variable representing an error condition when checking a measure
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.NewErrorType">
<summary>
 Create an inference type variable representing an error condition when checking an expression
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.NewByRefKindInferenceType(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range)">
<summary>
 Create an inference type variable for the kind of a byref pointer
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.NewInferenceType(FSharp.Compiler.TcGlobals.TcGlobals)">
<summary>
 Create an inference type variable
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.NewAnonTypar(FSharp.Compiler.TypedTree.TyparKind,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TyparRigidity,FSharp.Compiler.Syntax.TyparStaticReq,FSharp.Compiler.TypedTree.TyparDynamicReq)">
<summary>
 Create a type variable representing the use of a &quot;_&quot; in F# code
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.FreshenRecdFieldRef(FSharp.Compiler.NameResolution.NameResolver,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.RecdFieldRef)">
<summary>
 Generate a new reference to a record field with a fresh type instantiation
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.AllMethInfosOfTypeInScope(FSharp.Compiler.NameResolution.ResultCollectionSettings,FSharp.Compiler.InfoReader.InfoReader,FSharp.Compiler.NameResolution.NameResolutionEnv,Microsoft.FSharp.Core.FSharpOption{System.String},FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.InfoReader.FindMemberFlag,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Get the available methods of a type (both declared and inherited)
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.ExtensionPropInfosOfTypeInScope(FSharp.Compiler.NameResolution.ResultCollectionSettings,FSharp.Compiler.InfoReader.InfoReader,FSharp.Compiler.NameResolution.NameResolutionEnv,Microsoft.FSharp.Core.FSharpOption{System.String},FSharp.Compiler.NameResolution.LookupIsInstance,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Get all the available properties of a type (only extension)
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.AllPropInfosOfTypeInScope(FSharp.Compiler.NameResolution.ResultCollectionSettings,FSharp.Compiler.InfoReader.InfoReader,FSharp.Compiler.NameResolution.NameResolutionEnv,Microsoft.FSharp.Core.FSharpOption{System.String},FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.InfoReader.FindMemberFlag,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Get all the available properties of a type (both intrinsic and extension)
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.CallOpenDeclarationSink(FSharp.Compiler.NameResolution.TcResultsSink,FSharp.Compiler.TypedTree.OpenDeclaration)">
<summary>
 Report an open declaration
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.CallExprHasTypeSink(FSharp.Compiler.NameResolution.TcResultsSink,FSharp.Compiler.Text.Range,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.AccessibilityLogic.AccessorDomain)">
<summary>
 Report a specific name resolution at a source range
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.CallNameResolutionSinkReplacing(FSharp.Compiler.NameResolution.TcResultsSink,FSharp.Compiler.Text.Range,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.NameResolution.Item,Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Compiler.TypedTree.Typar,FSharp.Compiler.TypedTree.TType}},FSharp.Compiler.NameResolution.ItemOccurrence,FSharp.Compiler.AccessibilityLogic.AccessorDomain)">
<summary>
 Report a specific name resolution at a source range, replacing any previous resolutions
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.CallMethodGroupNameResolutionSink(FSharp.Compiler.NameResolution.TcResultsSink,FSharp.Compiler.Text.Range,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.NameResolution.Item,FSharp.Compiler.NameResolution.Item,Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Compiler.TypedTree.Typar,FSharp.Compiler.TypedTree.TType}},FSharp.Compiler.NameResolution.ItemOccurrence,FSharp.Compiler.AccessibilityLogic.AccessorDomain)">
<summary>
 Report a specific method group name resolution at a source range
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.CallNameResolutionSink(FSharp.Compiler.NameResolution.TcResultsSink,FSharp.Compiler.Text.Range,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.NameResolution.Item,Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Compiler.TypedTree.Typar,FSharp.Compiler.TypedTree.TType}},FSharp.Compiler.NameResolution.ItemOccurrence,FSharp.Compiler.AccessibilityLogic.AccessorDomain)">
<summary>
 Report a specific name resolution at a source range
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.CallEnvSink(FSharp.Compiler.NameResolution.TcResultsSink,FSharp.Compiler.Text.Range,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.AccessibilityLogic.AccessorDomain)">
<summary>
 Report the active name resolution environment for a source range
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.TemporarilySuspendReportingTypecheckResultsToSink(FSharp.Compiler.NameResolution.TcResultsSink)">
<summary>
 Temporarily suspend reporting of name resolution and type checking results
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.WithNewTypecheckResultsSink(FSharp.Compiler.NameResolution.ITypecheckResultsSink,FSharp.Compiler.NameResolution.TcResultsSink)">
<summary>
 Temporarily redirect reporting of name resolution and type checking results
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.ItemsAreEffectivelyEqualHash(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.NameResolution.Item)">
<summary>
 Hash compatible with ItemsAreEffectivelyEqual
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.ItemsAreEffectivelyEqual(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.NameResolution.Item,FSharp.Compiler.NameResolution.Item)">
<summary>
 Check for equality, up to signature matching
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.LookupTypeNameInEnvNoArity(FSharp.Compiler.NameResolution.FullyQualifiedFlag,System.String,FSharp.Compiler.NameResolution.NameResolutionEnv)">
<summary>
 Qualified lookup of type names in the environment
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.AddDeclaredTyparsToNameEnv(FSharp.Compiler.NameResolution.CheckForDuplicateTyparFlag,FSharp.Compiler.NameResolution.NameResolutionEnv,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar})">
<summary>
 Add some declared type parameters to the name resolution environment
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.AddTypeContentsToNameEnv(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.Text.Range,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.TypedTree.TType)">
<summary>
 Add the content of a type to the name resolution environment
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.AddModuleOrNamespaceRefsContentsToNameEnv(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.Text.Range,System.Boolean,FSharp.Compiler.NameResolution.NameResolutionEnv,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.EntityRef})">
<summary>
 Add a list of modules or namespaces to the name resolution environment
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.AddModuleOrNamespaceRefToNameEnv(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,System.Boolean,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Add a single modules or namespace to the name resolution environment
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.AddModuleOrNamespaceRefsToNameEnv(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,System.Boolean,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.NameResolution.NameResolutionEnv,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.EntityRef})">
<summary>
 Add a list of module or namespace to the name resolution environment, including any sub-modules marked &apos;AutoOpen&apos;
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.AddModuleAbbrevToNameEnv(FSharp.Compiler.Syntax.Ident,FSharp.Compiler.NameResolution.NameResolutionEnv,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.EntityRef})">
<summary>
 Add a module abbreviation to the name resolution environment
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.AddExceptionDeclsToNameEnv(FSharp.Compiler.NameResolution.BulkAdd,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Add an F# exception definition to the name resolution environment
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.AddTyconRefsToNameEnv(FSharp.Compiler.NameResolution.BulkAdd,System.Boolean,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.Text.Range,System.Boolean,FSharp.Compiler.NameResolution.NameResolutionEnv,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.EntityRef})">
<summary>
 Add a list of type definitions to the name resolution environment
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.AddActivePatternResultTagsToNameEnv(FSharp.Compiler.Syntax.PrettyNaming.ActivePatternInfo,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.Text.Range)">
<summary>
 Add active pattern result tags to the environment.
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.AddValRefToNameEnv(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.TypedTree.ValRef)">
<summary>
 Add a single F# value to the environment.
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.AddFakeNameToNameEnv(System.String,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.NameResolution.Item)">
<summary>
 Add some extra items to the environment for Visual Studio, e.g. record members
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.AddFakeNamedValRefToNameEnv(System.String,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.TypedTree.ValRef)">
<summary>
 Add extra items to the environment for Visual Studio, e.g. static members
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.TryFindAnonRecdFieldOfType(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.TType,System.String)">
<summary>
 Find a field in anonymous record type
</summary>
</member>
<member name="M:FSharp.Compiler.NameResolution.ActivePatternElemsOfModuleOrNamespace(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.EntityRef)">
<summary>
 Get the active pattern elements defined in a module, if any. Cache in the slot in the module type.
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.UpperCaseIdentifierInPattern">
<summary>
 Used to report a warning condition for the use of upper-case identifiers in patterns
</summary>
</member>
<member name="T:FSharp.Compiler.NameResolution.IndeterminateType">
<summary>
 Used to report an error condition where name resolution failed due to an indeterminate type
</summary>
</member>
<member name="M:FSharp.Compiler.SignatureConformance.CheckNamesOfModuleOrNamespace(FSharp.Compiler.TypedTreeOps.DisplayEnv,FSharp.Compiler.InfoReader.InfoReader,FSharp.Compiler.TypedTree.EntityRef,FSharp.Compiler.TypedTree.ModuleOrNamespaceType)">
<summary>
 Check the names add up between a signature and its implementation. We check this first.
</summary>
</member>
<member name="T:FSharp.Compiler.SignatureConformance">
<summary>
 Primary relations on types and signatures, with the exception of
 constraint solving and method overload resolution.
</summary>
</member>
<member name="P:FSharp.Compiler.MethodOverrides.RequiredSlot.PossiblyNoMostSpecificImplementation">
<summary>
 A slot that *might* have ambiguity due to multiple inheritance; happens with default interface implementations.
</summary>
</member>
<member name="P:FSharp.Compiler.MethodOverrides.RequiredSlot.MethodInfo">
<summary>
 Gets the method info.
</summary>
</member>
<member name="P:FSharp.Compiler.MethodOverrides.RequiredSlot.IsOptional">
<summary>
 Indicates a slot which does not have to be implemented, because an inherited implementation is available.
</summary>
</member>
<member name="P:FSharp.Compiler.MethodOverrides.RequiredSlot.HasDefaultInterfaceImplementation">
<summary>
 Indicates a slot which has a default interface implementation.
 A combination of this flag and the lack of IsOptional means the slot may have been reabstracted.
</summary>
</member>
<member name="T:FSharp.Compiler.MethodOverrides.OverrideInfo">
<summary>
 The overall information about a method implementation in a class or object expression
</summary>
</member>
<member name="M:FSharp.Compiler.MethodOverrides.GetAbstractPropInfosForSynPropertyDecl(FSharp.Compiler.InfoReader.InfoReader,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.Syntax.Ident,FSharp.Compiler.Text.Range,System.Tuple{FSharp.Compiler.TypedTree.TType,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.MethodOverrides.SlotImplSet}},FSharp.Compiler.Syntax.SynMemberFlags)">
<summary>
 Get the properties relevant to determining if a uniquely-identified-override exists based on the syntactic information
 at the member signature prior to type inference. This is used to pre-assign type information if it does
</summary>
</member>
<member name="M:FSharp.Compiler.MethodOverrides.GetAbstractMethInfosForSynMethodDecl(FSharp.Compiler.InfoReader.InfoReader,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.Syntax.Ident,FSharp.Compiler.Text.Range,System.Tuple{FSharp.Compiler.TypedTree.TType,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.MethodOverrides.SlotImplSet}},FSharp.Compiler.Syntax.SynValInfo,FSharp.Compiler.Syntax.SynMemberFlags,FSharp.Compiler.InfoReader.FindMemberFlag)">
<summary>
 Get the methods relevant to determining if a uniquely-identified-override exists based on the syntactic information
 at the member signature prior to type inference. This is used to pre-assign type information if it does
</summary>
</member>
<member name="M:FSharp.Compiler.MethodOverrides.FinalTypeDefinitionChecksAtEndOfInferenceScope(FSharp.Compiler.InfoReader.InfoReader,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.NameResolution.TcResultsSink,System.Boolean,FSharp.Compiler.TypedTreeOps.DisplayEnv,FSharp.Compiler.TypedTree.Entity)">
<summary>
 &quot;Type Completion&quot; inference and a few other checks at the end of the inference scope
</summary>
</member>
<member name="M:FSharp.Compiler.MethodOverrides.DispatchSlotChecking.GetSlotImplSets(FSharp.Compiler.InfoReader.InfoReader,FSharp.Compiler.TypedTreeOps.DisplayEnv,FSharp.Compiler.AccessibilityLogic.AccessorDomain,System.Boolean,Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Compiler.TypedTree.TType,FSharp.Compiler.Text.Range}})">
<summary>
 Get the slots of a type that can or must be implemented.
</summary>
</member>
<member name="M:FSharp.Compiler.MethodOverrides.DispatchSlotChecking.CheckOverridesAreAllUsedOnce(FSharp.Compiler.TypedTreeOps.DisplayEnv,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.InfoReader.InfoReader,System.Boolean,FSharp.Compiler.TypedTree.TType,Microsoft.FSharp.Collections.FSharpMap{System.String,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.MethodOverrides.RequiredSlot}},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.MethodOverrides.OverrideInfo},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.MethodOverrides.OverrideInfo})">
<summary>
 Check all implementations implement some dispatch slot.
</summary>
</member>
<member name="M:FSharp.Compiler.MethodOverrides.DispatchSlotChecking.CheckDispatchSlotsAreImplemented(FSharp.Compiler.TypedTreeOps.DisplayEnv,FSharp.Compiler.InfoReader.InfoReader,FSharp.Compiler.Text.Range,FSharp.Compiler.NameResolution.NameResolutionEnv,FSharp.Compiler.NameResolution.TcResultsSink,System.Boolean,System.Boolean,FSharp.Compiler.TypedTree.TType,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.MethodOverrides.RequiredSlot},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.MethodOverrides.OverrideInfo},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.MethodOverrides.OverrideInfo})">
<summary>
 Check all dispatch slots are implemented by some override.
</summary>
</member>
<member name="M:FSharp.Compiler.MethodOverrides.DispatchSlotChecking.IsExactMatch(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.Infos.MethInfo,FSharp.Compiler.MethodOverrides.OverrideInfo)">
<summary>
 Check if an override exactly matches the requirements for a dispatch slot.
</summary>
</member>
<member name="M:FSharp.Compiler.MethodOverrides.DispatchSlotChecking.GetObjectExprOverrideInfo(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.Syntax.Ident,FSharp.Compiler.Syntax.SynMemberFlags,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.ValReprInfo,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Attrib},FSharp.Compiler.TypedTree.Expr)">
<summary>
 Get the override information for an object expression method being used to implement dispatch slots
</summary>
</member>
<member name="M:FSharp.Compiler.MethodOverrides.DispatchSlotChecking.FormatMethInfoSig(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTreeOps.DisplayEnv,FSharp.Compiler.Infos.MethInfo)">
<summary>
 Format the signature of a MethInfo as a string as part of an error message
</summary>
</member>
<member name="M:FSharp.Compiler.MethodOverrides.DispatchSlotChecking.FormatOverride(FSharp.Compiler.TypedTreeOps.DisplayEnv,FSharp.Compiler.MethodOverrides.OverrideInfo)">
<summary>
 Format the signature of an override as a string as part of an error message
</summary>
</member>
<member name="T:FSharp.Compiler.MethodOverrides">
<summary>
 Primary logic related to method overrides.
</summary>
</member>
<member name="P:FSharp.Compiler.MethodCalls.CalledMeth`1.UnnamedCalledOutArgs">
<summary>
 Unnamed called out args: return these as part of the return tuple
</summary>
</member>
<member name="P:FSharp.Compiler.MethodCalls.CalledMeth`1.UnnamedCalledOptArgs">
<summary>
 Unnamed called optional args: pass defaults for these
</summary>
</member>
<member name="P:FSharp.Compiler.MethodCalls.CalledMeth`1.UnassignedNamedArgs">
<summary>
 Unassigned args
</summary>
</member>
<member name="P:FSharp.Compiler.MethodCalls.CalledMeth`1.Method">
<summary>
 The method we&apos;re attempting to call
</summary>
</member>
<member name="P:FSharp.Compiler.MethodCalls.CalledMeth`1.CallerTyArgs">
<summary>
 The formal instantiation of the method we&apos;re attempting to call
</summary>
</member>
<member name="P:FSharp.Compiler.MethodCalls.CalledMeth`1.CallerObjArgTys">
<summary>
 The types of the actual object arguments, if any
</summary>
</member>
<member name="P:FSharp.Compiler.MethodCalls.CalledMeth`1.CalledTyparInst">
<summary>
 The instantiation of the method we&apos;re attempting to call
</summary>
</member>
<member name="P:FSharp.Compiler.MethodCalls.CalledMeth`1.CalledTyArgs">
<summary>
 The generic instantiation of the method we&apos;re attempting to call
</summary>
</member>
<member name="P:FSharp.Compiler.MethodCalls.CalledMeth`1.CalledReturnTypeAfterOutArgTupling">
<summary>
 Return type after tupling of out args is taken into account
</summary>
</member>
<member name="P:FSharp.Compiler.MethodCalls.CalledMeth`1.CalledReturnTypeAfterByrefDeref">
<summary>
 The return type after implicit deference of byref returns is taken into account
</summary>
</member>
<member name="P:FSharp.Compiler.MethodCalls.CalledMeth`1.AttributeAssignedNamedArgs">
<summary>
 Args assigned to specify values for attribute fields and properties (these are not necessarily &quot;property sets&quot;)
</summary>
</member>
<member name="P:FSharp.Compiler.MethodCalls.CalledMeth`1.AssociatedPropertyInfo">
<summary>
 The property related to the method we&apos;re attempting to call, if any
</summary>
</member>
<member name="P:FSharp.Compiler.MethodCalls.CalledMeth`1.AssignedItemSetters">
<summary>
 Named setters
</summary>
</member>
<member name="P:FSharp.Compiler.MethodCalls.CalledMeth`1.ArgSets">
<summary>
 The argument analysis for each set of curried arguments
</summary>
</member>
<member name="T:FSharp.Compiler.MethodCalls.CalledMeth`1">
<summary>
 Represents the syntactic matching between a caller of a method and the called method.

 The constructor takes all the information about the caller and called side of a method, match up named arguments, property setters etc.,
 and returns a CalledMeth object for further analysis.
</summary>
</member>
<member name="P:FSharp.Compiler.MethodCalls.CalledMethArgSet`1.AssignedNamedArgs">
<summary>
 Named args
</summary>
</member>
<member name="P:FSharp.Compiler.MethodCalls.CalledMethArgSet`1.ParamArrayCallerArgs">
<summary>
 Any unnamed caller arguments assigned to a &quot;param array&quot; argument
</summary>
</member>
<member name="P:FSharp.Compiler.MethodCalls.CalledMethArgSet`1.ParamArrayCalledArgOpt">
<summary>
 The called &quot;ParamArray&quot; argument, if any
</summary>
</member>
<member name="P:FSharp.Compiler.MethodCalls.CalledMethArgSet`1.UnnamedCallerArgs">
<summary>
 Any unnamed caller arguments not otherwise assigned
</summary>
</member>
<member name="P:FSharp.Compiler.MethodCalls.CalledMethArgSet`1.UnnamedCalledArgs">
<summary>
 The called arguments corresponding to &quot;unnamed&quot; arguments
</summary>
</member>
<member name="T:FSharp.Compiler.MethodCalls.TypeDirectedConversionUsed">
<summary>
 Indicates whether a type directed conversion (e.g. int32 to int64, or op_Implicit)
 has been used in F# code
</summary>
</member>
<member name="T:FSharp.Compiler.MethodCalls.CallerArgs`1">
<summary>
 Represents the list of unnamed / named arguments at method call site
 remark: The usage of list list is due to tupling and currying of arguments,
 stemming from SynValInfo in the AST.
</summary>
</member>
<member name="T:FSharp.Compiler.MethodCalls.AssignedItemSetter`1">
<summary>
 Represents the resolution of a caller argument as a named-setter argument
</summary>
</member>
<member name="T:FSharp.Compiler.MethodCalls.AssignedItemSetterTarget">
<summary>
 Represents the possibilities for a named-setter argument (a property, field, or a record field setter)
</summary>
</member>
<member name="P:FSharp.Compiler.MethodCalls.AssignedCalledArg`1.CallerArg">
<summary>
 The argument on the caller side
</summary>
</member>
<member name="P:FSharp.Compiler.MethodCalls.AssignedCalledArg`1.CalledArg">
<summary>
 The called argument in the method
</summary>
</member>
<member name="P:FSharp.Compiler.MethodCalls.AssignedCalledArg`1.NamedArgIdOpt">
<summary>
 The identifier for a named argument, if any
</summary>
</member>
<member name="T:FSharp.Compiler.MethodCalls.AssignedCalledArg`1">
<summary>
 Represents a match between a caller argument and a called argument, arising from either
 a named argument or an unnamed argument.
</summary>
</member>
<member name="T:FSharp.Compiler.MethodCalls.CallerArg`1">
<summary>
 In the following, &apos;T gets instantiated to:
   1. the expression being supplied for an argument
   2. &quot;unit&quot;, when simply checking for the existence of an overload that satisfies
      a signature, or when finding the corresponding witness.
 Note the parametricity helps ensure that overload resolution doesn&apos;t depend on the
 expression on the callside (though it is in some circumstances allowed
 to depend on some type information inferred syntactically from that
 expression, e.g. a lambda expression may be converted to a delegate as
 an adhoc conversion.

 The bool indicates if named using a &apos;?&apos;, making the caller argument explicit-optional
</summary>
</member>
<member name="M:FSharp.Compiler.MethodCalls.GenWitnessArgs(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TraitConstraintInfo})">
<summary>
 Generate the arguments passed for a set of (solved) traits in non-generic code
</summary>
</member>
<member name="M:FSharp.Compiler.MethodCalls.GenWitnessExprLambda(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TraitConstraintInfo)">
<summary>
 Generate a lambda expression for the given solved trait.
</summary>
</member>
<member name="M:FSharp.Compiler.MethodCalls.GenWitnessExpr(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TraitConstraintInfo,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Expr})">
<summary>
 Generate a witness for the given (solved) constraint.  Five possibilities are taken
 into account.
   1. The constraint is solved by a .NET-declared method or an F#-declared method
   2. The constraint is solved by an F# record field
   3. The constraint is solved by an F# anonymous record field
   4. The constraint is considered solved by a &quot;built in&quot; solution
   5. The constraint is solved by a closed expression given by a provided method from a type provider

 In each case an expression is returned where the method is applied to the given arguments, or the
 field is dereferenced.

 None is returned in the cases where the trait has not been solved (e.g. is part of generic code)
 or there is an unexpected mismatch of some kind.
</summary>
</member>
<member name="M:FSharp.Compiler.MethodCalls.AdjustCallerArgs``3(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.ValRef,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.ValUseFlag,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Text.Range,System.Tuple{FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType}}}}},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Text.Range,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.AbstractIL.IL.ILFieldInit,FSharp.Compiler.TypedTree.Const}},Microsoft.FSharp.Core.FSharpOption{System.String},FSharp.Compiler.InfoReader.InfoReader,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.MethodCalls.CalledMeth{FSharp.Compiler.TypedTree.Expr},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Expr},Microsoft.FSharp.Core.FSharpOption{``0},FSharp.Compiler.Text.Range,FSharp.Compiler.Text.Range)">
<summary>
 Build the argument list for a method call. Adjust for param array, optional arguments, byref arguments and coercions.
 For example, if you pass an F# reference cell to a byref then we must get the address of the
 contents of the ref. Likewise lots of adjustments are made for optional arguments etc.
</summary>
</member>
<member name="M:FSharp.Compiler.MethodCalls.BuildNewDelegateExpr(Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.Infos.EventInfo},FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.Infos.MethInfo,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.Text.Range)">
<summary>
 Implements the elaborated form of adhoc conversions from functions to delegates at member callsites
</summary>
</member>
<member name="M:FSharp.Compiler.MethodCalls.BuildObjCtorCall(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Text.Range)">
<summary>
 Build a call to the System.Object constructor taking no arguments,
</summary>
</member>
<member name="M:FSharp.Compiler.MethodCalls.BuildMethodCall(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.ValRef,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.ValUseFlag,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Text.Range,System.Tuple{FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType}}}}},FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.TypedTreeOps.Mutates,FSharp.Compiler.Text.Range,System.Boolean,FSharp.Compiler.Infos.MethInfo,FSharp.Compiler.TypedTree.ValUseFlag,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Expr},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Expr},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.TType})">
<summary>
 Build an expression that calls a given method info.
 This is called after overload resolution, and also to call other
 methods such as &apos;setters&apos; for properties.
</summary>
</member>
<member name="M:FSharp.Compiler.MethodCalls.MakeMethInfoCall(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.Infos.MethInfo,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Expr},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.TType})">
<summary>
 Make a call to a method info. Used by the optimizer and code generator to build
 calls to the type-directed solutions to member constraints.
</summary>
</member>
<member name="M:FSharp.Compiler.MethodCalls.IsBaseCall(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Expr})">
<summary>
 Is this a &apos;base&apos; call
</summary>
</member>
<member name="M:FSharp.Compiler.MethodCalls.AdjustCalledArgType``1(FSharp.Compiler.InfoReader.InfoReader,FSharp.Compiler.AccessibilityLogic.AccessorDomain,System.Boolean,System.Boolean,FSharp.Compiler.MethodCalls.CalledArg,FSharp.Compiler.MethodCalls.CallerArg{``0})">
<summary>
 F# supports some adhoc conversions to make expression fit known overall type
</summary>
</member>
<member name="M:FSharp.Compiler.MethodCalls.AdjustRequiredTypeForTypeDirectedConversions(FSharp.Compiler.InfoReader.InfoReader,FSharp.Compiler.AccessibilityLogic.AccessorDomain,System.Boolean,System.Boolean,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.Text.Range)">
<summary>
 F# supports some adhoc conversions to make expression fit known overall type
</summary>
</member>
<member name="M:FSharp.Compiler.MethodCalls.MapCombineTDC2D``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,FSharp.Compiler.DiagnosticsLogger.OperationResult{FSharp.Compiler.MethodCalls.TypeDirectedConversionUsed}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Performs a set of constraint solver operations returning TypeDirectedConversionUsed and
 combines their results.
</summary>
</member>
<member name="M:FSharp.Compiler.MethodCalls.MapCombineTDCD``1(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Compiler.DiagnosticsLogger.OperationResult{FSharp.Compiler.MethodCalls.TypeDirectedConversionUsed}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Performs a set of constraint solver operations returning TypeDirectedConversionUsed and
 combines their results.
</summary>
</member>
<member name="T:FSharp.Compiler.MethodCalls">
<summary>
 Logic associated with resolving method calls.
</summary>
</member>
<member name="T:FSharp.Compiler.PatternMatchCompilation.Pattern">
<summary>
 Represents the typechecked, elaborated form of a pattern, prior to pattern-match compilation.
</summary>
</member>
<member name="T:FSharp.Compiler.PatternMatchCompilation.ActionOnFailure">
<summary>
 What should the decision tree contain for any incomplete match?
</summary>
</member>
<member name="M:FSharp.Compiler.PatternMatchCompilation.CompilePattern(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTreeOps.DisplayEnv,FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.ValRef,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.ValUseFlag,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Text.Range,System.Tuple{FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType}}}}},FSharp.Compiler.InfoReader.InfoReader,FSharp.Compiler.Text.Range,FSharp.Compiler.Text.Range,System.Boolean,FSharp.Compiler.PatternMatchCompilation.ActionOnFailure,FSharp.Compiler.TypedTree.Val,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.Expr},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.PatternMatchCompilation.MatchClause},FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.TType)">
<summary>
 Compile a pattern into a decision tree and a set of targets.
</summary>
</member>
<member name="P:FSharp.Compiler.ConstraintSolver.ConstraintSolverState.PostInferenceChecksFinal">
<summary>
 Checks to run after all inference is complete.
</summary>
</member>
<member name="P:FSharp.Compiler.ConstraintSolver.ConstraintSolverState.PostInferenceChecksPreDefaults">
<summary>
 Checks to run after all inference is complete, but before defaults are applied and internal unknowns solved
</summary>
</member>
<member name="P:FSharp.Compiler.ConstraintSolver.ConstraintSolverState.ExtraCxs">
<summary>
 This table stores all unsolved, ungeneralized trait constraints, indexed by free type variable.
 That is, there will be one entry in this table for each free type variable in
 each outstanding, unsolved, ungeneralized trait constraint. Constraints are removed from the table and resolved
 each time a solution to an index variable is found.
</summary>
</member>
<member name="P:FSharp.Compiler.ConstraintSolver.ConstraintSolverState.TcVal">
<summary>
 The function used to freshen values we encounter during trait constraint solving
</summary>
</member>
<member name="M:FSharp.Compiler.ConstraintSolver.ConstraintSolverState.PushPostInferenceCheck(System.Boolean,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Add a post-inference check to run at the end of inference
</summary>
</member>
<member name="M:FSharp.Compiler.ConstraintSolver.ConstraintSolverState.GetPostInferenceChecksPreDefaults">
<summary>
 Get the post-inference checks to run near the end of inference, but before defaults are applied
</summary>
</member>
<member name="M:FSharp.Compiler.ConstraintSolver.ConstraintSolverState.GetPostInferenceChecksFinal">
<summary>
 Get the post-inference checks to run at the end of inference
</summary>
</member>
<member name="T:FSharp.Compiler.ConstraintSolver.TcValF">
<summary>
 A function that denotes captured tcVal, Used in constraint solver and elsewhere to get appropriate expressions for a ValRef.
</summary>
</member>
<member name="T:FSharp.Compiler.ConstraintSolver.OverallTy.MustConvertTo">
<summary>
 Each branch of the expression must convert to the type indicated
</summary>
</member>
<member name="T:FSharp.Compiler.ConstraintSolver.OverallTy.MustEqual">
<summary>
 Each branch of the expression must have the type indicated
</summary>
</member>
<member name="P:FSharp.Compiler.ConstraintSolver.OverallTy.Commit">
<summary>
 Represents a point where no subsumption/widening is possible
</summary>
</member>
<member name="T:FSharp.Compiler.ConstraintSolver.OverallTy">
<summary>
 Represents known information prior to checking an expression or pattern, e.g. it&apos;s expected type
</summary>
</member>
<member name="T:FSharp.Compiler.ConstraintSolver.OverloadResolutionFailure">
<summary>
 Cases for overload resolution failure that exists in the implementation of the compiler.
</summary>
</member>
<member name="T:FSharp.Compiler.ConstraintSolver.OverloadInformation">
<summary>
 Captures relevant information for a particular failed overload resolution.
</summary>
</member>
<member name="T:FSharp.Compiler.ConstraintSolver.ContextInfo.SequenceExpression">
<summary>
 The type equation comes from a sequence expression.
</summary>
</member>
<member name="T:FSharp.Compiler.ConstraintSolver.ContextInfo.PatternMatchGuard">
<summary>
 The type equation comes from a pattern match guard.
</summary>
</member>
<member name="T:FSharp.Compiler.ConstraintSolver.ContextInfo.FollowingPatternMatchClause">
<summary>
 The type equation comes from a return type of a pattern match clause (not the first clause).
</summary>
</member>
<member name="T:FSharp.Compiler.ConstraintSolver.ContextInfo.DowncastUsedInsteadOfUpcast">
<summary>
 The type equation comes from an downcast where a upcast could be used.
</summary>
</member>
<member name="T:FSharp.Compiler.ConstraintSolver.ContextInfo.RuntimeTypeTest">
<summary>
 The type equation comes from a runtime type test.
</summary>
</member>
<member name="T:FSharp.Compiler.ConstraintSolver.ContextInfo.YieldInComputationExpression">
<summary>
 The type equation comes from a yield in a computation expression.
</summary>
</member>
<member name="T:FSharp.Compiler.ConstraintSolver.ContextInfo.ReturnInComputationExpression">
<summary>
 The type equation comes from a return in a computation expression.
</summary>
</member>
<member name="T:FSharp.Compiler.ConstraintSolver.ContextInfo.CollectionElement">
<summary>
 The type equation comes from a list or array constructor
</summary>
</member>
<member name="T:FSharp.Compiler.ConstraintSolver.ContextInfo.TupleInRecordFields">
<summary>
 The type equation comes from the verification of a tuple in record fields.
</summary>
</member>
<member name="T:FSharp.Compiler.ConstraintSolver.ContextInfo.RecordFields">
<summary>
 The type equation comes from the verification of record fields.
</summary>
</member>
<member name="T:FSharp.Compiler.ConstraintSolver.ContextInfo.ElseBranchResult">
<summary>
 The type equation comes from a type check of the result of an else branch.
</summary>
</member>
<member name="T:FSharp.Compiler.ConstraintSolver.ContextInfo.OmittedElseBranch">
<summary>
 The type equation comes from an omitted else branch.
</summary>
</member>
<member name="T:FSharp.Compiler.ConstraintSolver.ContextInfo.IfExpression">
<summary>
 The type equation comes from an IF expression.
</summary>
</member>
<member name="T:FSharp.Compiler.ConstraintSolver.ContextInfo.NoContext">
<summary>
 No context was given.
</summary>
</member>
<member name="T:FSharp.Compiler.ConstraintSolver.ContextInfo">
<summary>
 Information about the context of a type equation.
</summary>
</member>
<member name="M:FSharp.Compiler.ConstraintSolver.ChooseTyparSolutionAndSolve(FSharp.Compiler.ConstraintSolver.ConstraintSolverState,FSharp.Compiler.TypedTreeOps.DisplayEnv,FSharp.Compiler.TypedTree.Typar)">
<summary>
 For some code like &quot;let f() = ([] = [])&quot;, a free choice is made for a type parameter
 for an interior type variable.  This chooses a solution for a type parameter subject
 to its constraints and applies that solution by using a constraint.
</summary>
</member>
<member name="M:FSharp.Compiler.ConstraintSolver.CodegenWitnessArgForTraitConstraint(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.ValRef,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.ValUseFlag,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Text.Range,System.Tuple{FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType}}}}},FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TraitConstraintInfo)">
<summary>
 Generate the lambda argument passed for a use of a generic construct that accepts trait witnesses
</summary>
</member>
<member name="M:FSharp.Compiler.ConstraintSolver.CodegenWitnessesForTyparInst(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.ValRef,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.ValUseFlag,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Text.Range,System.Tuple{FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType}}}}},FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType})">
<summary>
 Generate the arguments passed when using a generic construct that accepts traits witnesses
</summary>
</member>
<member name="M:FSharp.Compiler.ConstraintSolver.CodegenWitnessExprForTraitConstraintWillRequireWitnessArgs(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.ValRef,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.ValUseFlag,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Text.Range,System.Tuple{FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType}}}}},FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TraitConstraintInfo)">
<summary>
 Determine if a codegen witness for a trait will require witness args to be available, e.g. in generic code
</summary>
</member>
<member name="M:FSharp.Compiler.ConstraintSolver.CodegenWitnessExprForTraitConstraint(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.ValRef,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.ValUseFlag,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Text.Range,System.Tuple{FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType}}}}},FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TraitConstraintInfo,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Expr})">
<summary>
 Generate a witness expression if none is otherwise available, e.g. in legacy non-witness-passing code
</summary>
</member>
<member name="M:FSharp.Compiler.ConstraintSolver.EliminateConstraintsForGeneralizedTypars(FSharp.Compiler.TypedTreeOps.DisplayEnv,FSharp.Compiler.ConstraintSolver.ConstraintSolverState,FSharp.Compiler.Text.Range,FSharp.Compiler.ConstraintSolver.OptionalTrace,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar})">
<summary>
 Remove the global constraints related to generalized type variables
</summary>
</member>
<member name="M:FSharp.Compiler.ConstraintSolver.UpdateStaticReqOfTypar(FSharp.Compiler.TypedTreeOps.DisplayEnv,FSharp.Compiler.ConstraintSolver.ConstraintSolverState,FSharp.Compiler.Text.Range,FSharp.Compiler.ConstraintSolver.OptionalTrace,FSharp.Compiler.TypedTree.Typar)">
<summary>
 Re-assess the staticness of the type parameters
</summary>
</member>
<member name="M:FSharp.Compiler.ConstraintSolver.ResolveOverloadingForCall(FSharp.Compiler.TypedTreeOps.DisplayEnv,FSharp.Compiler.ConstraintSolver.ConstraintSolverState,FSharp.Compiler.Text.Range,System.String,FSharp.Compiler.MethodCalls.CallerArgs{FSharp.Compiler.TypedTree.Expr},FSharp.Compiler.AccessibilityLogic.AccessorDomain,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.MethodCalls.CalledMeth{FSharp.Compiler.TypedTree.Expr}},System.Boolean,FSharp.Compiler.ConstraintSolver.OverallTy)">
<summary>
 The entry point to resolve the overloading for an entire call
</summary>
</member>
<member name="T:FSharp.Compiler.ConstraintSolver">
<summary>
 Solves constraints using a mutable constraint-solver state
</summary>
</member>
<member name="T:FSharp.Compiler.CheckFormatStrings">
<summary>
 Parse &quot;printf-style&quot; format specifiers at compile time, producing
 a list of items that specify the types of the things that follow.

 Must be updated if the Printf runtime component is updated.
</summary>
</member>
<member name="M:FSharp.Compiler.FindUnsolved.UnsolvedTyparsOfModuleDef(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.TypedTreeOps.DisplayEnv,FSharp.Compiler.TypedTree.ModuleOrNamespaceContents,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Attrib})">
<summary>
 Find all unsolved inference variables after type inference for an entire file
</summary>
</member>
<member name="P:FSharp.Compiler.QuotationTranslator.QuotationSerializationFormat.SupportsDeserializeEx">
<summary>
 Indicates that type references are emitted as integer indexes into a supplied table
</summary>
</member>
<member name="P:FSharp.Compiler.QuotationTranslator.QuotationSerializationFormat.SupportsWitnesses">
<summary>
 Indicates that witness parameters are recorded
</summary>
</member>
<member name="T:FSharp.Compiler.QuotationTranslator">
<summary>
 Convert quoted TAST data structures to structures ready for pickling
</summary>
</member>
<member name="M:FSharp.Compiler.PostTypeCheckSemanticChecks.CheckImplFile(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,System.Boolean,FSharp.Compiler.InfoReader.InfoReader,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.CompilationPath},FSharp.Compiler.TypedTree.CcuThunk,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.ValRef,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.ValUseFlag,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Text.Range,System.Tuple{FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType}}}}},FSharp.Compiler.TypedTreeOps.DisplayEnv,FSharp.Compiler.TypedTree.ModuleOrNamespaceType,FSharp.Compiler.TypedTree.ModuleOrNamespaceContents,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Attrib},System.Tuple{System.Boolean,System.Boolean},System.Boolean)">
<summary>
 Perform the checks on the TAST for a file after type inference is complete.
</summary>
</member>
<member name="P:FSharp.Compiler.PostTypeCheckSemanticChecks.Limit.Limit.flags">
<summary>
 The combinations of limits which apply.
</summary>
</member>
<member name="P:FSharp.Compiler.PostTypeCheckSemanticChecks.Limit.Limit.scope">
<summary>
 The scope of this Limit, i.e. &quot;to which scope can a Val safely escape?&quot;.
 Some values are not allowed to escape their scope.
 For example, a top-level function is allowed to return a byref type, but inner functions are not.
 This `scope` field is the information that lets us track that.
 (Recall that in general scopes are counted starting from 0 indicating the top-level scope, and
 increasing by 1 essentially for every nested `let`-binding, method, or module.)

 Some specific values which are often used:
 * the value 0 is used in NoLimit and other situations which don&apos;t limit where the Val can escape;
 * the value 1 is a &quot;top-level local scope&quot;, allowing us to express the restriction &quot;this cannot appear
   at the top level&quot; (for example, `let x = &amp;y` cannot appear at the top level).
</summary>
</member>
<member name="T:FSharp.Compiler.PostTypeCheckSemanticChecks.Limit.Limit">
<summary>
 A &quot;limit&quot; here is some combination of restrictions on a Val.
</summary>
</member>
<member name="M:FSharp.Compiler.PostTypeCheckSemanticChecks.Limit.CombineTwoLimits(FSharp.Compiler.PostTypeCheckSemanticChecks.Limit.Limit,FSharp.Compiler.PostTypeCheckSemanticChecks.Limit.Limit)">
<summary>
 Construct a Limit which expresses &quot;this Val must obey the first Limit and the second Limit simultaneously&quot;.
</summary>
</member>
<member name="P:FSharp.Compiler.PostTypeCheckSemanticChecks.Limit.NoLimit">
<summary>
 Indicates that no limit applies to some Val. It can appear at the top level or within a `let`-binding,
 and the Val does not have any byref- or span-related restrictions.
</summary>
</member>
<member name="T:FSharp.Compiler.PostTypeCheckSemanticChecks.Limit">
<summary>
 It&apos;s unlikely you want to use this module except within
 PostInferenceChecks. It&apos;s exposed to allow testing.
</summary>
</member>
<member name="T:FSharp.Compiler.PostTypeCheckSemanticChecks">
<summary>
 Implements a set of checks on the TAST for a file that can only be performed after type inference
 is complete.
</summary>
</member>
<member name="M:FSharp.Compiler.TailCallChecks.CheckImplFile(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,System.Boolean,FSharp.Compiler.TypedTree.ModuleOrNamespaceContents)">
<summary>
 Perform the TailCall analysis on the optimized TAST for a file.
 The TAST is traversed analogously to the PostInferenceChecks phase.
 For functions that are annotated with the [&lt;TailCall&gt;] attribute, a warning is emitted if they are called in a
 non-tailrecursive manner in the recursive scope of the function.
 The ModuleOrNamespaceContents aren&apos;t mutated in any way by performing this check.
</summary>
</member>
<member name="P:FSharp.Compiler.CheckBasics.TcFileState.argInfoCache">
<summary>
 A cache for ArgReprInfos which get created multiple times for the same values
 Since they need to be later mutated with updates from signature files this should make sure
 we&apos;re always dealing with the same instance and the updates don&apos;t get lost
</summary>
</member>
<member name="P:FSharp.Compiler.CheckBasics.TcFileState.conditionalDefines">
<summary>
 The set of active conditional defines. The value is None when conditional erasure is disabled in tooling.
</summary>
</member>
<member name="P:FSharp.Compiler.CheckBasics.TcFileState.nameResolver">
<summary>
 Used to resolve names
</summary>
</member>
<member name="P:FSharp.Compiler.CheckBasics.TcFileState.infoReader">
<summary>
 Used to read and cache information about types and members
</summary>
</member>
<member name="P:FSharp.Compiler.CheckBasics.TcFileState.niceNameGen">
<summary>
 Used to generate names
</summary>
</member>
<member name="P:FSharp.Compiler.CheckBasics.TcFileState.haveSig">
<summary>
 Does this .fs file have a .fsi file?
</summary>
</member>
<member name="P:FSharp.Compiler.CheckBasics.TcFileState.isSig">
<summary>
 Is this a .fsi file?
</summary>
</member>
<member name="P:FSharp.Compiler.CheckBasics.TcFileState.compilingCanonicalFslibModuleType">
<summary>
 Are we compiling the signature of a module from fslib?
</summary>
</member>
<member name="P:FSharp.Compiler.CheckBasics.TcFileState.css">
<summary>
 Holds the current inference constraints
</summary>
</member>
<member name="P:FSharp.Compiler.CheckBasics.TcFileState.thisCcu">
<summary>
 Holds a reference to the component being compiled.
 This field is very rarely used (mainly when fixing up forward references to fslib.
</summary>
</member>
<member name="P:FSharp.Compiler.CheckBasics.TcFileState.synArgNameGenerator">
<summary>
 Used to generate new syntactic argument names in post-parse syntactic processing
</summary>
</member>
<member name="P:FSharp.Compiler.CheckBasics.TcFileState.amap">
<summary>
 Environment needed to convert IL types to F# types in the importer.
</summary>
</member>
<member name="P:FSharp.Compiler.CheckBasics.TcFileState.isScript">
<summary>
 Are we in a script? if so relax the reporting of discarded-expression warnings at the top level
</summary>
</member>
<member name="P:FSharp.Compiler.CheckBasics.TcFileState.createsGeneratedProvidedTypes">
<summary>
 Set to true if this file causes the creation of generated provided types.
</summary>
</member>
<member name="P:FSharp.Compiler.CheckBasics.TcFileState.stackGuard">
<summary>
 Guard against depth of expression nesting, by moving to new stack when a maximum depth is reached
</summary>
</member>
<member name="P:FSharp.Compiler.CheckBasics.TcFileState.recUses">
<summary>
 Push an entry every time a recursive value binding is used,
 in order to be able to fix up recursive type applications as
 we infer type parameters
</summary>
</member>
<member name="T:FSharp.Compiler.CheckBasics.TcFileState">
<summary>
 Represents the compilation environment for typechecking a single file in an assembly.
</summary>
</member>
<member name="T:FSharp.Compiler.CheckBasics.TcPatValFlags">
<summary>
 Represents the flags passed to TcPat regarding the binding location
</summary>
</member>
<member name="T:FSharp.Compiler.CheckBasics.TcPatLinearEnv">
<summary>
 Represents the context flowed left-to-right through pattern checking
</summary>
</member>
<member name="T:FSharp.Compiler.CheckBasics.TcPatPhase2Input">
<summary>
 Translation of patterns is split into three phases. The first collects names.
 The second is run after val_specs have been created for those names and inference
 has been resolved. The second phase is run by applying a function returned by the
 first phase. The input to the second phase is a List.map that gives the Val and type scheme
 for each value bound by the pattern.
</summary>
</member>
<member name="T:FSharp.Compiler.CheckBasics.PrelimVal1">
<summary>
 Represents the results of the first phase of preparing simple values from a pattern
</summary>
</member>
<member name="T:FSharp.Compiler.CheckBasics.PrelimMemberInfo">
<summary>
 Holds the initial ValMemberInfo and other information before it is fully completed
</summary>
</member>
<member name="T:FSharp.Compiler.CheckBasics.PrelimValReprInfo">
<summary>
 Represents the ValReprInfo for a value, before the typars are fully inferred
</summary>
</member>
<member name="T:FSharp.Compiler.CheckBasics.CheckConstraints">
<summary>
 Indicates whether constraints should be checked when checking syntactic types
</summary>
</member>
<member name="T:FSharp.Compiler.CheckBasics.ExplicitTyparInfo">
<summary>
 A type to represent information associated with values to indicate what explicit (declared) type parameters
 are given and what additional type parameters can be inferred, if any.

 The declared type parameters, e.g. let f&lt;&apos;a&gt; (x:&apos;a) = x, plus an indication
 of whether additional polymorphism may be inferred, e.g. let f&lt;&apos;a, ..&gt; (x:&apos;a) y = x
</summary>
</member>
<member name="T:FSharp.Compiler.CheckBasics.UnscopedTyparEnv">
<summary>
 Represents the current environment of type variables that have implicit scope
 (i.e. are without explicit declaration).
</summary>
</member>
<member name="P:FSharp.Compiler.CheckBasics.TcEnv.eFamilyType">
<summary>
 Here Some tcref indicates we can access protected members in all super types
</summary>
</member>
<member name="P:FSharp.Compiler.CheckBasics.TcEnv.eContextInfo">
<summary>
 Context information for type checker
</summary>
</member>
<member name="P:FSharp.Compiler.CheckBasics.TcEnv.eModuleOrNamespaceTypeAccumulator">
<summary>
 Mutable accumulator for the current module type
</summary>
</member>
<member name="P:FSharp.Compiler.CheckBasics.TcEnv.eInternalsVisibleCompPaths">
<summary>
 Internals under these should be accessible
</summary>
</member>
<member name="P:FSharp.Compiler.CheckBasics.TcEnv.eAccessRights">
<summary>
 This field is computed from other fields, but we amortize the cost of computing it.
</summary>
</member>
<member name="P:FSharp.Compiler.CheckBasics.TcEnv.eUngeneralizableItems">
<summary>
 The list of items in the environment that may contain free inference
 variables (which may not be generalized). The relevant types may
 change as a result of inference equations being asserted, hence may need to
 be recomputed.
</summary>
</member>
<member name="P:FSharp.Compiler.CheckBasics.TcEnv.eNameResEnv">
<summary>
 Name resolution information
</summary>
</member>
<member name="T:FSharp.Compiler.CheckBasics.TcEnv">
<summary>
 Represents the type environment at a particular scope. Includes the name
 resolution environment, the ungeneralizable items from earlier in the scope
 and other information about the scope.
</summary>
</member>
<member name="T:FSharp.Compiler.CheckBasics.UngeneralizableItem">
<summary>
 Represents an item in the environment that may restrict the automatic generalization of later
 declarations because it refers to type inference variables. As type inference progresses
 these type inference variables may get solved.
</summary>
</member>
<member name="P:FSharp.Compiler.CheckBasics.CtorInfo.ctorIsImplicit">
<summary>
 Is there an implicit constructor or an explicit one?
</summary>
</member>
<member name="P:FSharp.Compiler.CheckBasics.CtorInfo.safeInitInfo">
<summary>
 A handle to the boolean ref cell to hold success of initialized &apos;this&apos; for &apos;type X() as x = ...&apos; constructs
</summary>
</member>
<member name="P:FSharp.Compiler.CheckBasics.CtorInfo.safeThisValOpt">
<summary>
 A handle to the ref cell to hold results of &apos;this&apos; for &apos;type X() as x = ...&apos; and &apos;new() as x = ...&apos; constructs
 in case &apos;x&apos; is used in the arguments to the &apos;inherits&apos; call.
</summary>
</member>
<member name="P:FSharp.Compiler.CheckBasics.CtorInfo.ctorShapeCounter">
<summary>
 Object model constructors have a very specific form to satisfy .NET limitations.
 For &quot;new = \arg. { new C with ... }&quot;
     ctor = 3 indicates about to type check &quot;\arg. (body)&quot;,
     ctor = 2 indicates about to type check &quot;body&quot;
     ctor = 1 indicates actually type checking the body expression
 0 indicates everywhere else, including auxiliary expressions such expr1 in &quot;let x = expr1 in { new ... }&quot;
 REVIEW: clean up this rather odd approach ...
</summary>
</member>
<member name="T:FSharp.Compiler.CheckBasics.CtorInfo">
<summary>
 Represents information about object constructors
</summary>
</member>
<member name="T:FSharp.Compiler.CheckBasics.SafeInitData">
<summary>
 Represents information about the initialization field used to check that object constructors
 have completed before fields are accessed.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressionsOps.|SimpleSemicolonSequence|_|(FSharp.Compiler.CheckBasics.TcFileState,System.Boolean,FSharp.Compiler.Syntax.SynExpr)">
<summary>
 Determine if a syntactic expression inside &apos;seq { ... }&apos; or &apos;[...]&apos; counts as a &quot;simple sequence
 of semicolon separated values&quot;. For example [1;2;3].
 &apos;acceptDeprecated&apos; is true for the &apos;[ ... ]&apos; case, where we allow the syntax &apos;[ if g then t else e ]&apos; but ask it to be parenthesized
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressionsOps.YieldFree(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.Syntax.SynExpr)">
<summary>
 Check if a computation or sequence expression is syntactically free of &apos;yield&apos; (though not yield!)
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressionsOps.UnifyTypes(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.TType)">
<summary>
 Constrain two types to be equal within this type checking context
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressionsOps.CompilePatternForMatchClauses(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.Text.Range,FSharp.Compiler.Text.Range,System.Boolean,FSharp.Compiler.PatternMatchCompilation.ActionOnFailure,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.Expr},FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.TType,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.PatternMatchCompilation.MatchClause})">
<summary>
 Invoke pattern match compilation
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressionsOps.LightweightTcValForUsingInBuildMethodCall(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.ValRef,FSharp.Compiler.TypedTree.ValUseFlag,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.Text.Range)">
<summary>
 simplified version of TcVal used in calls to BuildMethodCall (typrelns.fs)
 this function is used on typechecking step for making calls to provided methods and on optimization step (for the same purpose).
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.PreInitializationGraphEliminationBinding">
<summary>
 Represents a recursive binding after it has been both checked and generalized, but
 before initialization recursion has been rewritten
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.TcTrueMatchClause">
<summary>
 Represents a pattern  that is used in a true match clause e.g. | pat -&gt; expr
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.PostSpecialValsRecursiveBinding">
<summary>
 Represents a recursive binding after it has been both checked and generalized and after
 the special adjustments for &apos;as this&apos; class initialization checks have been inserted into members.
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.PostGeneralizationRecursiveBinding">
<summary>
 Represents a recursive binding after it has been both checked and generalized
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.RecursiveUseFixupPoints">
<summary>
 Represents the usage points of a recursive binding that need later adjustment once the
 type of the member of value is fully inferred.
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.PreGeneralizationRecursiveBinding">
<summary>
 Represents a recursive binding after it has been checked but prior to generalization
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.PreCheckingRecursiveBinding">
<summary>
 Represents a recursive binding after it has been normalized but before it has been checked
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.NormalizedRecBindingDefn">
<summary>
 Represents a recursive binding after it has been normalized but before it&apos;s info has been put together
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.ValScheme">
<summary>
 Represents the results of the second phase of checking simple values
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.CheckedBindingInfo">
<summary>
 Represents the results of the first phase of preparing bindings
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.RecursiveBindingInfo">
<summary>
 RecursiveBindingInfo - flows through initial steps of TcLetrec
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.NormalizedBinding">
<summary>
 Represents a syntactic, unchecked binding after the resolution of the name resolution status of pattern
 constructors and after &quot;pushing&quot; all complex patterns to the right hand side.
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.NormalizedBindingRhs">
<summary>
 NormalizedBindingRhs records the r.h.s. of a binding after some munging just before type checking.
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.ValSpecResult">
<summary>
 The result of checking a value or member signature
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.RecDefnBindingInfo">
<summary>
 Represents the initial information about a recursive binding
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.IsObjExprBinding">
<summary>
 Indicates if a member binding is an object expression binding
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.WarnOnIWSAM">
<summary>
 Indicates whether the position being checked is precisely the r.h.s. of a &quot;&apos;T :&gt; ***&quot; constraint or a similar
 places where IWSAM types do not generate a warning
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.DeclKind.ExpressionBinding">
<summary>
 A binding in an expression
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.DeclKind.ObjectExpressionOverrideBinding">
<summary>
 A binding in an object expression
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.DeclKind.ClassLetBinding">
<summary>
 A binding in a class
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.DeclKind.ExtrinsicExtensionBinding">
<summary>
 Extensions to a type in a different assembly
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.DeclKind.IntrinsicExtensionBinding">
<summary>
 Extensions to a type within the same assembly
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.DeclKind.ModuleOrMemberBinding">
<summary>
 A binding in a module, or a member
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.DeclKind">
<summary>
 A flag to represent the sort of bindings are we processing.
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.OverridesOK">
<summary>
 Indicates if member declarations are allowed to be override members.
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.NewSlotsOK">
<summary>
 Indicates if member declarations are allowed to be abstract members.
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.ContainerInfo">
<summary>
 Provides information about the context for a value or member definition.
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.MemberOrValContainerInfo">
<summary>
 Represents information about the module or type in which a member or value is declared.
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.PrelimVal2">
<summary>
 The results of applying let-style generalization after type checking.
</summary>
</member>
<member name="T:FSharp.Compiler.CheckExpressions.ImplicitlyBoundTyparsAllowed">
<summary>
 Indicates whether a syntactic type is allowed to include new type variables
 not declared anywhere, e.g. `let f (x: &apos;T option) = x.Value`
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.ConvSynPatToSynExpr(FSharp.Compiler.Syntax.SynPat)">
<summary>
 The pattern syntax can also represent active pattern arguments. This routine
 converts from the pattern syntax to the expression syntax.

 Note we parse arguments to parameterized pattern labels as patterns, not expressions.
 This means the range of syntactic expression forms that can be used here is limited.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcPatLongIdentActivePatternCase(FSharp.Compiler.NameResolution.WarnOnUpperFlag,FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.CheckBasics.TcPatValFlags,FSharp.Compiler.CheckBasics.TcPatLinearEnv,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.Text.Range,FSharp.Compiler.NameResolution.Item,FSharp.Compiler.TypedTree.ActivePatternElemRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SynPat},FSharp.Compiler.Text.Range)">
<summary>
 Check a long identifier &apos;Case&apos; or &apos;Case argsR&apos; that has been resolved to an active pattern case
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.BuildFieldMap``1(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,System.Boolean,FSharp.Compiler.TypedTree.TType,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Tuple{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.Ident},FSharp.Compiler.Syntax.Ident},``0}},FSharp.Compiler.Text.Range)">
<summary>
 Helper used to check both record expressions and record patterns
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.UnifyTupleTypeAndInferCharacteristics``1(FSharp.Compiler.ConstraintSolver.ContextInfo,FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.TypedTreeOps.DisplayEnv,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType,System.Boolean,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Allow the inference of structness from the known type, e.g.
    let (x: struct (int * int)) = (3,4)
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TranslatePartialValReprInfo(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},FSharp.Compiler.CheckBasics.PrelimValReprInfo)">
<summary>
 Given the declaration of a function or member, complete the processing of its ValReprInfo
 once type parameters have been fully inferred via generalization.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TranslateSynValInfo(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.Text.Range,Microsoft.FSharp.Core.FSharpFunc{System.AttributeTargets,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SynAttribute},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Attrib}}},FSharp.Compiler.Syntax.SynValInfo)">
<summary>
 Given the declaration of a function or member, process it to produce the ValReprInfo
 giving the names and attributes relevant to arguments and return, but before type
 parameters have been fully inferred via generalization.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcValSpec(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.CheckExpressions.DeclKind,FSharp.Compiler.CheckExpressions.ImplicitlyBoundTyparsAllowed,FSharp.Compiler.CheckExpressions.ContainerInfo,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.Syntax.SynMemberFlags},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.CheckBasics.UnscopedTyparEnv,FSharp.Compiler.Syntax.SynValSig,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Attrib})">
<summary>
 Check a specification of a value or member in a signature or an abstract member
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcTypeAndRecover(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckExpressions.ImplicitlyBoundTyparsAllowed,FSharp.Compiler.CheckBasics.CheckConstraints,FSharp.Compiler.NameResolution.ItemOccurrence,FSharp.Compiler.CheckExpressions.WarnOnIWSAM,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.CheckBasics.UnscopedTyparEnv,FSharp.Compiler.Syntax.SynType)">
<summary>
 Check a syntactic type (with error recovery)
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcTypeOrMeasureAndRecover(Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.TyparKind},FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckExpressions.ImplicitlyBoundTyparsAllowed,FSharp.Compiler.CheckBasics.CheckConstraints,FSharp.Compiler.NameResolution.ItemOccurrence,FSharp.Compiler.CheckExpressions.WarnOnIWSAM,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.CheckBasics.UnscopedTyparEnv,FSharp.Compiler.Syntax.SynType)">
<summary>
 Check a syntactic type or unit of measure
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcType(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckExpressions.ImplicitlyBoundTyparsAllowed,FSharp.Compiler.CheckBasics.CheckConstraints,FSharp.Compiler.NameResolution.ItemOccurrence,FSharp.Compiler.CheckExpressions.WarnOnIWSAM,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.CheckBasics.UnscopedTyparEnv,FSharp.Compiler.Syntax.SynType)">
<summary>
 Check a syntactic type
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcTyparDecls(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SynTyparDecl})">
<summary>
 Check a collection of type parameters declarations
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcTyparConstraints(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckExpressions.ImplicitlyBoundTyparsAllowed,FSharp.Compiler.CheckBasics.CheckConstraints,FSharp.Compiler.NameResolution.ItemOccurrence,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.CheckBasics.UnscopedTyparEnv,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SynTypeConstraint})">
<summary>
 Check a set of explicitly declared constraints on type parameters
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcProvidedTypeAppToStaticConstantArgs(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.String}},FSharp.Compiler.CheckBasics.UnscopedTyparEnv,FSharp.Compiler.TypedTree.EntityRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SynType},FSharp.Compiler.Text.Range)">
<summary>
 Check the application of a provided type to static args
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcNameOfExpr(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.CheckBasics.UnscopedTyparEnv,FSharp.Compiler.Syntax.SynExpr)">
<summary>
 Check a &apos;nameof&apos; expression
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcNewExpr(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.CheckBasics.UnscopedTyparEnv,FSharp.Compiler.TypedTree.TType,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.Text.Range},System.Boolean,FSharp.Compiler.Syntax.SynExpr,FSharp.Compiler.Text.Range)">
<summary>
 Check an inheritance expression or other &apos;new XYZ()&apos; expression
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcLetrecAdjustMemberForSpecialVals(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckExpressions.PostGeneralizationRecursiveBinding)">
<summary>
 Part of check a collection of recursive bindings that might include members
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcLetrecBindings(FSharp.Compiler.CheckExpressions.OverridesOK,FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.CheckBasics.UnscopedTyparEnv,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.CheckExpressions.RecDefnBindingInfo},FSharp.Compiler.Text.Range,FSharp.Compiler.Text.Range)">
<summary>
 Check a collection of `let rec` bindings
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcLetrecComputeCtorSafeThisValBind(FSharp.Compiler.CheckBasics.TcFileState,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.Val})">
<summary>
 Get the binding for the implicit safe initialization check value if it is being used
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcLetrecBinding(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.CheckBasics.TcEnv,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.CheckExpressions.PostGeneralizationRecursiveBinding},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.CheckExpressions.PreGeneralizationRecursiveBinding},FSharp.Compiler.CheckBasics.UnscopedTyparEnv,Microsoft.FSharp.Collections.FSharpMap{System.Int64,FSharp.Compiler.CheckExpressions.PreCheckingRecursiveBinding},FSharp.Compiler.CheckExpressions.PreCheckingRecursiveBinding)">
<summary>
 Check an individual `let rec` binding
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcLetBindings(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.CheckExpressions.ContainerInfo,FSharp.Compiler.CheckExpressions.DeclKind,FSharp.Compiler.CheckBasics.UnscopedTyparEnv,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SynBinding},FSharp.Compiler.Text.Range,FSharp.Compiler.Text.Range)">
<summary>
 Check a set of let bindings in a class or module
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcMatchPattern(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.CheckBasics.UnscopedTyparEnv,FSharp.Compiler.Syntax.SynPat,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.Syntax.SynExpr},FSharp.Compiler.CheckExpressions.TcTrueMatchClause)">
<summary>
 Check a pattern being used as a pattern match
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TryTcStmt(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.CheckBasics.UnscopedTyparEnv,FSharp.Compiler.Syntax.SynExpr)">
<summary>
 Try to check a syntactic statement and indicate if it&apos;s type is not unit without emitting a warning
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcLinearExprs(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.ConstraintSolver.OverallTy,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.CheckBasics.TcEnv,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.CheckBasics.UnscopedTyparEnv,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Syntax.SynExpr,System.Tuple{FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.CheckBasics.UnscopedTyparEnv}}}}},FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.ConstraintSolver.OverallTy,FSharp.Compiler.CheckBasics.UnscopedTyparEnv,System.Boolean,FSharp.Compiler.Syntax.SynExpr,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.CheckBasics.UnscopedTyparEnv},System.Tuple{FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.CheckBasics.UnscopedTyparEnv}})">
<summary>
 Check a linear expression (e.g. a sequence of &apos;let&apos;) in a tail-recursive way
 and convert it to a typed tree expression, using the bodyChecker to check the parts
 that are not linear.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcExprUndelayed(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.ConstraintSolver.OverallTy,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.CheckBasics.UnscopedTyparEnv,FSharp.Compiler.Syntax.SynExpr)">
<summary>
 Check a syntactic expression and convert it to a typed tree expression
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcStmtThatCantBeCtorBody(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.CheckBasics.UnscopedTyparEnv,FSharp.Compiler.Syntax.SynExpr)">
<summary>
 Check a syntactic statement and convert it to a typed tree expression.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcPropagatingExprLeafThenConvert(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.ConstraintSolver.OverallTy,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.Text.Range,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.CheckBasics.UnscopedTyparEnv}})">
<summary>
 Process a leaf construct where the actual type of that construct is already pre-known,
 and the overall type can be eagerly propagated into the actual type, including pre-calculating
 any type-directed conversion.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcExprFlex(FSharp.Compiler.CheckBasics.TcFileState,System.Boolean,System.Boolean,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.CheckBasics.UnscopedTyparEnv,FSharp.Compiler.Syntax.SynExpr)">
<summary>
 Check a syntactic expression and convert it to a typed tree expression. Possibly allow for subsumption flexibility
 and insert a coercion if necessary.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcExprOfUnknownType(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.CheckBasics.UnscopedTyparEnv,FSharp.Compiler.Syntax.SynExpr)">
<summary>
 Check a syntactic expression and convert it to a typed tree expression
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.RecordNameAndTypeResolutions(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.CheckBasics.UnscopedTyparEnv,FSharp.Compiler.Syntax.SynExpr)">
<summary>
 Check record names and types for cases like cases like `query { for ... join(for x in f(). }`
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.CheckTupleIsCorrectLength``1(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType,Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},Microsoft.FSharp.Core.Unit})">
<summary>
 Check that &apos;args&apos; have the correct number of elements for a tuple expression.
 If not, use &apos;tcArgs&apos; to type check the given elements to show
 their correct types (if known) in the error message and raise the error
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcExpr(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.ConstraintSolver.OverallTy,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.CheckBasics.UnscopedTyparEnv,FSharp.Compiler.Syntax.SynExpr)">
<summary>
 Check a syntactic expression and convert it to a typed tree expression
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcConst(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.Text.Range,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.Syntax.SynConst)">
<summary>
 Check a constant value, e.g. a literal
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcAttributesWithPossibleTargets(FSharp.Compiler.CheckExpressions.TcCanFail,FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,System.AttributeTargets,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SynAttribute})">
<summary>
 Check a set of attributes which can only target specific elements
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcAttributesCanFail(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,System.AttributeTargets,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SynAttribute})">
<summary>
 Check a set of attributes and allow failure because a later phase of type realization
 may successfully check the attributes (if the attribute type or its arguments is in the
 same recursive group)
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcAttributes(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,System.AttributeTargets,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SynAttribute})">
<summary>
 Check a set of attributes
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.TcAndPublishValSpec(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.CheckExpressions.ContainerInfo,FSharp.Compiler.CheckExpressions.DeclKind,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.Syntax.SynMemberFlags},FSharp.Compiler.CheckBasics.UnscopedTyparEnv,FSharp.Compiler.Syntax.SynValSig)">
<summary>
 Check and publish a value specification (in a signature or &apos;abstract&apos; member) to the
 module/namespace type accumulator and return the resulting Val(s).  Normally only one
 &apos;Val&apos; results but CLI events may produce both and add_Event and _remove_Event Val.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.SetTyparRigid(FSharp.Compiler.TypedTreeOps.DisplayEnv,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.Typar)">
<summary>
 Mark a typar as no longer being an inference type variable
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.PublishValueDefnMaybeInclCompilerGenerated(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,System.Boolean,FSharp.Compiler.CheckExpressions.DeclKind,FSharp.Compiler.TypedTree.Val)">
<summary>
 Publish a value definition to the module/namespace type accumulator.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.PublishValueDefn(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.CheckExpressions.DeclKind,FSharp.Compiler.TypedTree.Val)">
<summary>
 Publish a value definition to the module/namespace type accumulator.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.PublishTypeDefn(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.TypedTree.Entity)">
<summary>
 Publish a type definition to the module/namespace type accumulator.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.PublishModuleDefn(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.TypedTree.Entity)">
<summary>
 Publish a module definition to the module/namespace type accumulator.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.NonGenericTypeScheme(FSharp.Compiler.TypedTree.TType)">
<summary>
 Produce a post-generalization type scheme for a simple type where no type inference generalization
 is applied.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.MakeInnerEnvWithAcc(System.Boolean,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.Syntax.Ident,Microsoft.FSharp.Core.FSharpRef{FSharp.Compiler.TypedTree.ModuleOrNamespaceType},FSharp.Compiler.TypedTree.ModuleOrNamespaceKind)">
<summary>
 Return a new environment suitable for processing declarations in the interior of a module definition
 given that the accumulator for the module type already exists.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.MakeInnerEnv(System.Boolean,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.Syntax.Ident,FSharp.Compiler.TypedTree.ModuleOrNamespaceKind)">
<summary>
 Return a new environment suitable for processing declarations in the interior of a module definition
 including creating an accumulator for the module type.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.MakeInnerEnvForTyconRef(FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.TypedTree.EntityRef,System.Boolean)">
<summary>
 Return a new environment suitable for processing declarations in the interior of a type definition
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.MakeMemberDataAndMangledNameForMemberVal(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.EntityRef,System.Boolean,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Attrib},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.Syntax.SynMemberFlags,FSharp.Compiler.Syntax.SynValInfo,FSharp.Compiler.Syntax.Ident,System.Boolean)">
<summary>
 Make initial information for a member value
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.MakeAndPublishSafeThisVal(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.Syntax.Ident},FSharp.Compiler.TypedTree.TType)">
<summary>
 Make an initial implicit safe initialization value
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.MakeAndPublishSimpleVals(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,Microsoft.FSharp.Collections.FSharpMap{System.String,FSharp.Compiler.CheckBasics.PrelimVal1})">
<summary>
 Make simple values (which are not recursive nor members)
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.MakeAndPublishBaseVal(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.Syntax.Ident},FSharp.Compiler.TypedTree.TType)">
<summary>
 Make an initial &apos;base&apos; value
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.MakeAndPublishVal(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.TypedTree.ParentRef,System.Boolean,FSharp.Compiler.CheckExpressions.DeclKind,FSharp.Compiler.TypedTree.ValRecursiveScopeInfo,FSharp.Compiler.CheckExpressions.ValScheme,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Attrib},FSharp.Compiler.Xml.XmlDoc,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.Const},System.Boolean)">
<summary>
 Make an initial &apos;Val&apos; and publish it to the environment and mutable module type accumulator.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.MakeCheckSafeInit(FSharp.Compiler.TcGlobals.TcGlobals,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.CheckBasics.SafeInitData,FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Make the check for safe initialization of a member
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.LocateEnv(System.Boolean,FSharp.Compiler.TypedTree.CcuThunk,FSharp.Compiler.CheckBasics.TcEnv,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.Ident})">
<summary>
 Locate the environment within a particular namespace path, used to process a
 &apos;namespace&apos; declaration.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.InferGenericArityFromTyScheme(FSharp.Compiler.TypedTreeOps.GeneralizedType,FSharp.Compiler.CheckBasics.PrelimValReprInfo)">
<summary>
 Build the full ValReprInfo one type inference is complete.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.GetInstanceMemberThisVariable(FSharp.Compiler.TypedTree.Val,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Get the &quot;this&quot; variable from the lambda for an instance member binding
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.GetCurrAccumulatedModuleOrNamespaceType(FSharp.Compiler.CheckBasics.TcEnv)">
<summary>
 Get the accumulated module/namespace type for the current module/namespace being processed.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.FreshenObjectArgType(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TyparRigidity,FSharp.Compiler.TypedTree.EntityRef,System.Boolean,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar})">
<summary>
 Produce a fresh view of an object type, e.g. &apos;List&lt;T&gt;&apos; becomes &apos;List&lt;?&gt;&apos; for new
 inference variables with the given rigidity.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.FixupLetrecBind(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.TypedTreeOps.DisplayEnv,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},FSharp.Compiler.CheckExpressions.PostSpecialValsRecursiveBinding)">
<summary>
 Adjust a recursive binding after generalization
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.EliminateInitializationGraphs``2(FSharp.Compiler.TcGlobals.TcGlobals,System.Boolean,FSharp.Compiler.TypedTreeOps.DisplayEnv,Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.CheckExpressions.PreInitializationGraphEliminationBinding},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Binding},``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.CheckExpressions.PreInitializationGraphEliminationBinding},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Binding}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1}}},FSharp.Compiler.Text.Range)">
<summary>
 Process recursive bindings so that initialization is through laziness and is checked.
 The bindings may be either plain &apos;let rec&apos; bindings or mutually recursive nestings of modules and types.
 The functions must iterate the actual bindings and process them to the overall result.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.ConvertArbitraryExprToEnumerable(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Get the expression resulting from turning an expression into an enumerable value, e.g. at &apos;for&apos; loops
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.ComputeAccessAndCompPath(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.CheckBasics.TcEnv,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.CheckExpressions.DeclKind},FSharp.Compiler.Text.Range,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.Syntax.SynAccess},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.Accessibility},FSharp.Compiler.TypedTree.ParentRef)">
<summary>
 Compute the available access rights and module/entity compilation path for a particular location in code
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.ComputeAccessRights(FSharp.Compiler.TypedTree.CompilationPath,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.CompilationPath},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.EntityRef})">
<summary>
 Compute the available access rights from a particular location in code
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.ComputeIsComplete(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},FSharp.Compiler.TypedTree.TType)">
<summary>
 Check if the type annotations and inferred type information in a value give a
 full and complete generic type for a value. If so, enable generic recursion.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.ChooseCanonicalValSchemeAfterInference(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTreeOps.DisplayEnv,FSharp.Compiler.CheckExpressions.ValScheme,FSharp.Compiler.Text.Range)">
<summary>
 After inference, view a ValScheme in a canonical way.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.ChooseCanonicalDeclaredTyparsAfterInference(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTreeOps.DisplayEnv,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},FSharp.Compiler.Text.Range)">
<summary>
 After inference, view a set of declared type parameters in a canonical way.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.CheckSuperType(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.Text.Range)">
<summary>
 Check a super type is valid
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.CheckMemberFlags``1(Microsoft.FSharp.Core.FSharpOption{``0},FSharp.Compiler.CheckExpressions.NewSlotsOK,FSharp.Compiler.CheckExpressions.OverridesOK,FSharp.Compiler.Syntax.SynMemberFlags,FSharp.Compiler.Text.Range)">
<summary>
 Check the flags on a member definition for consistency
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.CheckForNonAbstractInterface(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.CheckExpressions.DeclKind,FSharp.Compiler.TypedTree.EntityRef,FSharp.Compiler.Syntax.SynMemberFlags,System.Boolean,FSharp.Compiler.Text.Range)">
<summary>
 Check that a member can be included in an interface
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.AnalyzeAndMakeAndPublishRecursiveValue(FSharp.Compiler.CheckExpressions.OverridesOK,System.Boolean,FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.CheckBasics.UnscopedTyparEnv,System.Int32,FSharp.Compiler.CheckExpressions.NormalizedRecBindingDefn)">
<summary>
 Process a normalized recursive binding and prepare for progressive generalization
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.AdjustRecType(FSharp.Compiler.TypedTree.Val,FSharp.Compiler.CheckExpressions.ValScheme)">
<summary>
 Set the type of a &apos;Val&apos; after it has been fully inferred.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.AddLocalVals(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.NameResolution.TcResultsSink,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Val},FSharp.Compiler.CheckBasics.TcEnv)">
<summary>
 Add a list of values to the environment, producing a new environment. Report to the sink.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.AddLocalValPrimitive(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Val,FSharp.Compiler.CheckBasics.TcEnv)">
<summary>
 Add a value to the environment, producing a new environment
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.AddLocalVal(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.NameResolution.TcResultsSink,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.Val,FSharp.Compiler.CheckBasics.TcEnv)">
<summary>
 Add a value to the environment, producing a new environment. Report to the sink.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.AddDeclaredTypars(FSharp.Compiler.NameResolution.CheckForDuplicateTyparFlag,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},FSharp.Compiler.CheckBasics.TcEnv)">
<summary>
 Add a list of explicitly declared type variables to the environment, producing a new environment
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.unionGeneralizedTypars(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar}})">
<summary>
 Merge together lists of type variables to generalize, keeping canonical order
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.addFreeItemOfModuleTy(FSharp.Compiler.TypedTree.ModuleOrNamespaceType,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.CheckBasics.UngeneralizableItem})">
<summary>
 Record the entire contents of a module or namespace type as not-generalizable, that is
 if any type variables occur free in the module or namespace type (because type inference
 is not yet complete), then they can&apos;t be generalized.
</summary>
</member>
<member name="P:FSharp.Compiler.CheckExpressions.emptyUnscopedTyparEnv">
<summary>
 An empty environment of type variables with implicit scope
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.BindingNormalization.NormalizeBinding(FSharp.Compiler.CheckExpressions.IsObjExprBinding,FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.Syntax.SynBinding)">
<summary>
 Take a syntactic binding and do the very first processing step to normalize it.
</summary>
</member>
<member name="P:FSharp.Compiler.CheckExpressions.AttributeTargets.Top">
<summary>
 The allowed attribute targets for an F# top level &apos;do&apos; expression
</summary>
</member>
<member name="P:FSharp.Compiler.CheckExpressions.AttributeTargets.ModuleDecl">
<summary>
 The allowed attribute targets for an F# module declaration
</summary>
</member>
<member name="P:FSharp.Compiler.CheckExpressions.AttributeTargets.ExnDecl">
<summary>
 The allowed attribute targets for an F# exception declaration
</summary>
</member>
<member name="P:FSharp.Compiler.CheckExpressions.AttributeTargets.TyconDecl">
<summary>
 The allowed attribute targets for an F# type declaration
</summary>
</member>
<member name="P:FSharp.Compiler.CheckExpressions.AttributeTargets.UnionCaseDecl">
<summary>
 The allowed attribute targets for an F# union case declaration
</summary>
</member>
<member name="P:FSharp.Compiler.CheckExpressions.AttributeTargets.FieldDeclRestricted">
<summary>
 The allowed attribute targets for an F# field declaration once it&apos;s known to be targeting
 a field not a property (see useGenuineField)
</summary>
</member>
<member name="P:FSharp.Compiler.CheckExpressions.AttributeTargets.FieldDecl">
<summary>
 The allowed attribute targets for an F# field declaration
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.GeneralizationHelpers.ComputeUnabstractableTycons(FSharp.Compiler.CheckBasics.TcEnv)">
<summary>
 Given an environment, compute the set of type definitions which must appear before
 the current location, not after (to prevent use-before-definition of type definitions
 via type inference).
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.GeneralizationHelpers.ComputeUnabstractableTraitSolutions(FSharp.Compiler.CheckBasics.TcEnv)">
<summary>
 Given an environment, compute the set of trait solutions which must appear before
 the current location, not after (to prevent use-before definitions and
 forward calls via type inference filling in trait solutions).
</summary>
</member>
<member name="M:FSharp.Compiler.CheckExpressions.GeneralizationHelpers.ComputeUngeneralizableTypars(FSharp.Compiler.CheckBasics.TcEnv)">
<summary>
 Given an environment, compute the set of inference type variables which may not be
 generalised, because they appear somewhere in the types of the constructs available
 in the environment.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckPatterns.TcSimplePatsOfUnknownType(FSharp.Compiler.CheckBasics.TcFileState,System.Boolean,FSharp.Compiler.CheckBasics.CheckConstraints,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.CheckBasics.UnscopedTyparEnv,FSharp.Compiler.Syntax.SynPat)">
<summary>
 Check a set of simple patterns, e.g. the declarations of parameters for an implicit constructor.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckSequenceExpressions.TcSequenceExpression(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.CheckBasics.UnscopedTyparEnv,FSharp.Compiler.Syntax.SynExpr,FSharp.Compiler.ConstraintSolver.OverallTy,FSharp.Compiler.Text.Range)">
<summary>
 This case is used for computation expressions which are sequence expressions. Technically the code path is different because it
 typechecks rather than doing a shallow syntactic translation, and generates calls into the Seq.* library
 and helpers rather than to the builder methods (there is actually no builder for &apos;seq&apos; in the library).
 These are later detected by state machine compilation.

 Also &quot;ienumerable extraction&quot; is performed on arguments to &quot;for&quot;.
</summary>
</member>
<member name="T:FSharp.Compiler.CheckSequenceExpressions">
<summary>
 Sequence expressions checking
</summary>
</member>
<member name="T:FSharp.Compiler.CheckArrayOrListComputedExpressions">
<summary>
 Sequence expressions checking
</summary>
</member>
<member name="T:FSharp.Compiler.CheckIncrementalClasses.IncrClassBindingGroup">
<summary>
 Represents a single group of bindings in a class with an implicit constructor
</summary>
</member>
<member name="P:FSharp.Compiler.CheckIncrementalClasses.IncrClassReprInfo.ValsWithRepresentation">
<summary>
 vals represented as fields or members from this point on
</summary>
</member>
<member name="P:FSharp.Compiler.CheckIncrementalClasses.IncrClassReprInfo.ValReprs">
<summary>
 vals mapped to representations
</summary>
</member>
<member name="P:FSharp.Compiler.CheckIncrementalClasses.IncrClassReprInfo.TakenFieldNames">
<summary>
 Indicates the set of field names taken within one incremental class
</summary>
</member>
<member name="M:FSharp.Compiler.CheckIncrementalClasses.IncrClassReprInfo.FixupIncrClassExprPhase2C(FSharp.Compiler.CheckBasics.TcFileState,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.Val},FSharp.Compiler.CheckBasics.SafeInitData,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},FSharp.Compiler.TypedTree.Expr)">
<summary>
 Given localRep saying how locals have been represented, e.g. as fields.
 Given an expr under a given thisVal context.
</summary>
</member>
<member name="T:FSharp.Compiler.CheckIncrementalClasses.IncrClassReprInfo">
<summary>
 IncrClassReprInfo represents the decisions we make about the representation of &apos;let&apos; and &apos;do&apos; bindings in a
 type defined with implicit class construction.
</summary>
</member>
<member name="T:FSharp.Compiler.CheckIncrementalClasses.IncrClassValRepr">
<summary>
 Indicates how is a &apos;let&apos; bound value in a class with implicit construction is represented in
 the TAST ultimately produced by type checking.
</summary>
</member>
<member name="P:FSharp.Compiler.CheckIncrementalClasses.IncrClassCtorInfo.InstanceCtorThisVal">
<summary>
 The value representing the &apos;this&apos; variable within the implicit instance constructor.
</summary>
</member>
<member name="P:FSharp.Compiler.CheckIncrementalClasses.IncrClassCtorInfo.InstanceCtorBaseValOpt">
<summary>
 The value representing the &apos;base&apos; variable within the implicit instance constructor.
</summary>
</member>
<member name="P:FSharp.Compiler.CheckIncrementalClasses.IncrClassCtorInfo.InstanceCtorSafeInitInfo">
<summary>
 Data indicating if safe-initialization checks need to be inserted for this type.
</summary>
</member>
<member name="P:FSharp.Compiler.CheckIncrementalClasses.IncrClassCtorInfo.InstanceCtorSafeThisValOpt">
<summary>
 The reference cell holding the &apos;this&apos; parameter within the implicit constructor so it can be referenced in the
 arguments passed to the base constructor
</summary>
</member>
<member name="P:FSharp.Compiler.CheckIncrementalClasses.IncrClassCtorInfo.InstanceCtorArgs">
<summary>
 The values representing the arguments to the implicit constructor.
</summary>
</member>
<member name="P:FSharp.Compiler.CheckIncrementalClasses.IncrClassCtorInfo.InstanceCtorValScheme">
<summary>
 The type of the implicit constructor, representing as a ValScheme.
</summary>
</member>
<member name="P:FSharp.Compiler.CheckIncrementalClasses.IncrClassCtorInfo.InstanceCtorVal">
<summary>
 The value representing the implicit constructor.
</summary>
</member>
<member name="T:FSharp.Compiler.CheckIncrementalClasses.IncrClassCtorInfo">
<summary>
 Typechecked info for implicit instance constructor and it&apos;s arguments
</summary>
</member>
<member name="P:FSharp.Compiler.CheckIncrementalClasses.StaticCtorInfo.NameGenerator">
<summary>
 The name generator used to generate the names of fields etc. within the type.
</summary>
</member>
<member name="P:FSharp.Compiler.CheckIncrementalClasses.StaticCtorInfo.StaticCtorValInfo">
<summary>
 The value representing the static implicit constructor.
 Lazy to ensure the static ctor value is only published if needed.
</summary>
</member>
<member name="P:FSharp.Compiler.CheckIncrementalClasses.StaticCtorInfo.IncrCtorDeclaredTypars">
<summary>
 The copy of the type parameters allocated for implicit construction
</summary>
</member>
<member name="P:FSharp.Compiler.CheckIncrementalClasses.StaticCtorInfo.TyconRef">
<summary>
 The TyconRef for the type being defined
</summary>
</member>
<member name="T:FSharp.Compiler.CheckIncrementalClasses.StaticCtorInfo">
<summary>
 Typechecked info for implicit static constructor
</summary>
</member>
<member name="M:FSharp.Compiler.CheckIncrementalClasses.MakeCtorForIncrClassConstructionPhase2C(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.CheckIncrementalClasses.StaticCtorInfo,Microsoft.FSharp.Core.FSharpOption{System.Tuple{FSharp.Compiler.CheckIncrementalClasses.IncrClassCtorInfo,FSharp.Compiler.TypedTree.Expr,System.Boolean}},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.CheckIncrementalClasses.IncrClassConstructionBindingsPhase2C},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Binding},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},FSharp.Compiler.CheckBasics.SafeInitData)">
 <summary>
 Given a set of 'let' bindings (static or not, recursive or not) that make up a class,
 generate their initialization expression(s).
 </summary>
 <param name='cenv'></param>
 <param name='env'></param>
 <param name='staticCtorInfo'>The information about the static implicit constructor</param>
 <param name='instanceInfo'>The lhs information about the implicit constructor, the call to the super class constructor and whether we should we place a sequence point at the 'inheritedTys call?</param>
 <param name='decs'>The declarations</param>
 <param name='memberBinds'></param>
 <param name='generalizedTyparsForRecursiveBlock'>Record any unconstrained type parameters generalized for the outer members as "free choices" in the let bindings</param>
 <param name='safeStaticInitInfo'></param>
</member>
<member name="M:FSharp.Compiler.CheckIncrementalClasses.TcImplicitCtorInfo_Phase2A(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.CheckBasics.UnscopedTyparEnv,FSharp.Compiler.TypedTree.EntityRef,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.Syntax.SynAccess},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SynAttribute},FSharp.Compiler.Syntax.SynPat,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.Syntax.Ident},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.Val},FSharp.Compiler.CheckBasics.SafeInitData,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar},FSharp.Compiler.TypedTree.TType,FSharp.Compiler.TypedTree.TType,FSharp.Compiler.Xml.PreXmlDoc)">
<summary>
 Check and elaborate the &quot;left hand side&quot; of the implicit class construction
 syntax.
</summary>
</member>
<member name="M:FSharp.Compiler.CheckIncrementalClasses.TcStaticImplicitCtorInfo_Phase2A(FSharp.Compiler.CheckBasics.TcFileState,FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.TypedTree.EntityRef,FSharp.Compiler.Text.Range,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Typar})">
<summary>
 Check and elaborate the &quot;left hand side&quot; of the implicit class construction
 syntax.
</summary>
</member>
<member name="T:FSharp.Compiler.Optimizer.ModuleInfo">
<summary>
 Optimization information
</summary>
</member>
<member name="P:FSharp.Compiler.Optimizer.OptimizationSettings.reportingPhase">
<summary>
 For unit testing
</summary>
</member>
<member name="P:FSharp.Compiler.Optimizer.OptimizationSettings.lambdaInlineThreshold">
<summary>
 The size after which we don&apos;t inline
</summary>
</member>
<member name="P:FSharp.Compiler.Optimizer.OptimizationSettings.veryBigExprSize">
<summary>
 size after which we start enforcing splitting sub-expressions to new methods, to avoid hitting .NET IL limitations
</summary>
</member>
<member name="P:FSharp.Compiler.Optimizer.OptimizationSettings.bigTargetSize">
<summary>
 size after which we start chopping methods in two, though only at match targets
</summary>
</member>
<member name="T:FSharp.Compiler.Optimizer.OptimizationProcessingMode.Parallel">
<summary>
 Use multiple threads.
 As soon as a given phase for a file has finished, start processing the next phase of the current file and the same phase of the next file.
</summary>
</member>
<member name="T:FSharp.Compiler.Optimizer.OptimizationProcessingMode.Sequential">
<summary>
 Process files sequentially, on a single thread, doing all optimization phases for each file next to each other.
</summary>
</member>
<member name="M:FSharp.Compiler.Optimizer.IsKnownOnlyMutableBeforeUse(FSharp.Compiler.TypedTree.ValRef)">
<summary>
 Indicates the value is only mutable during its initialization and before any access or capture
</summary>
</member>
<member name="M:FSharp.Compiler.Optimizer.ExprHasEffect(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Check if an expression has an effect
</summary>
</member>
<member name="M:FSharp.Compiler.Optimizer.UnionOptimizationInfos(System.Collections.Generic.IEnumerable{Internal.Utilities.Library.InterruptibleLazy{FSharp.Compiler.Optimizer.ModuleInfo}})">
<summary>
 Combine optimization infos
</summary>
</member>
<member name="P:FSharp.Compiler.Optimizer.AbstractOptimizationInfoToEssentials">
<summary>
 Ensure that &apos;internal&apos; items are not exported in the optimization info
</summary>
</member>
<member name="M:FSharp.Compiler.Optimizer.RemapOptimizationInfo(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTreeOps.Remap)">
<summary>
 Rewrite the module info using the export remapping
</summary>
</member>
<member name="M:FSharp.Compiler.Optimizer.p_CcuOptimizationInfo(Internal.Utilities.Library.InterruptibleLazy{FSharp.Compiler.Optimizer.ModuleInfo},FSharp.Compiler.TypedTreePickle.WriterState)">
<summary>
 Saving and re-reading optimization information
</summary>
</member>
<member name="M:FSharp.Compiler.Optimizer.OptimizeImplFile(FSharp.Compiler.Optimizer.OptimizationSettings,FSharp.Compiler.TypedTree.CcuThunk,FSharp.Compiler.TcGlobals.TcGlobals,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.ValRef,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.ValUseFlag,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Text.Range,System.Tuple{FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType}}}}},FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Optimizer.IncrementalOptimizationEnv,System.Boolean,System.Boolean,FSharp.Compiler.TypedTreeOps.SignatureHidingInfo,FSharp.Compiler.TypedTree.CheckedImplFile)">
<summary>
 Optimize one implementation file in the given environment
</summary>
</member>
<member name="M:FSharp.Compiler.Optimizer.BindCcu(FSharp.Compiler.TypedTree.CcuThunk,Internal.Utilities.Library.InterruptibleLazy{FSharp.Compiler.Optimizer.ModuleInfo},FSharp.Compiler.Optimizer.IncrementalOptimizationEnv,FSharp.Compiler.TcGlobals.TcGlobals)">
<summary>
 For building optimization environments incrementally
</summary>
</member>
<member name="P:FSharp.Compiler.Detuple.GlobalUsageAnalysis.Results.IterationIsAtTopLevel">
<summary>
 top of expr toplevel? (true)
</summary>
</member>
<member name="P:FSharp.Compiler.Detuple.GlobalUsageAnalysis.Results.TopLevelBindings">
<summary>
 val not defined under lambdas
</summary>
</member>
<member name="P:FSharp.Compiler.Detuple.GlobalUsageAnalysis.Results.RecursiveBindings">
<summary>
 v -&gt; recursive? * v list   -- the others in the mutual binding
</summary>
</member>
<member name="P:FSharp.Compiler.Detuple.GlobalUsageAnalysis.Results.DecisionTreeBindings">
<summary>
 bound in a decision tree?
</summary>
</member>
<member name="P:FSharp.Compiler.Detuple.GlobalUsageAnalysis.Results.Defns">
<summary>
 v -&gt; binding repr
</summary>
</member>
<member name="P:FSharp.Compiler.Detuple.GlobalUsageAnalysis.Results.Uses">
<summary>
 v -&gt; context / APP inst args
</summary>
</member>
<member name="M:FSharp.Compiler.LowerCalls.LowerImplFile(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.CheckedImplFile)">
<summary>
 Expands under-applied values of known arity to lambda expressions, and then reduce to bind
 any known arguments. The results are later optimized by Optimizer.fs
</summary>
</member>
<member name="M:FSharp.Compiler.LowerSequenceExpressions.ConvertSequenceExprToObject(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Analyze a TAST expression to detect the elaborated form of a sequence expression.
 Then compile it to a state machine represented as a TAST containing goto, return and label nodes.
 The returned state machine will also contain references to state variables (from internal &apos;let&apos; bindings),
 a program counter (pc) that records the current state, and a current generated value (current).
 All these variables are then represented as fields in a hosting closure object along with any additional
 free variables of the sequence expression.
</summary>
</member>
<member name="M:FSharp.Compiler.LowerSequenceExpressions.|SeqElemTy|_|(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.Text.Range,FSharp.Compiler.TypedTree.TType)">
<summary>
 Detect a &apos;seq&lt;int&gt;&apos; type
</summary>
</member>
<member name="T:FSharp.Compiler.LowerStateMachines.LoweredStateMachineResult.NotAStateMachine">
<summary>
 The construct was not a state machine
</summary>
</member>
<member name="T:FSharp.Compiler.LowerStateMachines.LoweredStateMachineResult.NoAlternative">
<summary>
 A state machine was recognised and was not compilable and no alternative is available
</summary>
</member>
<member name="T:FSharp.Compiler.LowerStateMachines.LoweredStateMachineResult.UseAlternative">
<summary>
 A state machine was recognised and was not compilable and an alternative is available
</summary>
</member>
<member name="T:FSharp.Compiler.LowerStateMachines.LoweredStateMachineResult.Lowered">
<summary>
 A state machine was recognised and was compilable
</summary>
</member>
<member name="M:FSharp.Compiler.LowerStateMachines.LowerStateMachineExpr(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Expr)">
<summary>
 Analyze a TAST expression to detect the elaborated form of a state machine expression, a special kind
 of object expression that uses special code generation constructs.
</summary>
</member>
<member name="M:FSharp.Compiler.LowerLocalMutables.TransformImplFile(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.Import.ImportMap,FSharp.Compiler.TypedTree.CheckedImplFile)">
<summary>
 Rewrite mutable locals to reference cells across an entire implementation file
</summary>
</member>
<member name="T:FSharp.Compiler.IlxGenSupport">
<summary>
 The ILX generator.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.Diagnostics">
<summary>
 Diagnostics from the AbsIL toolkit. You can reset the diagnostics
 stream to point elsewhere, or turn it
 off altogether by setting it to &apos;None&apos;.  The logging channel initially
 points to stderr.  All functions call flush() automatically.

 REVIEW: review if we should just switch to System.Diagnostics
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILPropertyRef">
<summary>
 A utility type provided for completeness
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILEventRef">
<summary>
 A utility type provided for completeness
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILEnumInfo">
<summary>
 Decompose a type definition according to its kind.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILLocalsAllocator">
<summary>
 Helpers for codegen: scopes for allocating new temporary variables.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.ILGlobals.IsPossiblePrimaryAssemblyRef(FSharp.Compiler.AbstractIL.IL.ILAssemblyRef)">
<summary>
 Is the given assembly possibly a primary assembly?
 In practice, a primary assembly is an assembly that contains the System.Object type definition
 and has no referenced assemblies.
 However, we must consider assemblies that forward the System.Object type definition
 to be possible primary assemblies.
 Therefore, this will return true if the given assembly is the real primary assembly or an assembly that forwards
 the System.Object type definition.
 Assembly equivalency ignores the version here.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILGlobals">
<summary>
 A table of common references to items in primary assembly (System.Runtime or mscorlib).
 If a particular version of System.Runtime.dll has been loaded then you should
 reference items from it via an ILGlobals for that specific version built using mkILGlobals.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILModuleDef.NativeResources">
<summary>
 e.g. win86 resources, as the exact contents of a .res or .obj file. Must be unlinked manually.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILModuleDef">
<summary>
 One module in the &quot;current&quot; assembly, either a main-module or
 an auxiliary module.  The main module will have a manifest.

 An assembly is built by joining together a &quot;main&quot; module plus
 several auxiliary modules.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILNativeResource.Out">
<summary>
 Represents a native resource to be written in an output file
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILNativeResource.In">
<summary>
 Represents a native resource to be read from the PE file
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILAssemblyManifest.EntrypointElsewhere">
<summary>
 Records whether the entrypoint resides in another module.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILAssemblyManifest.ExportedTypes">
<summary>
 Records the types implemented by this assembly in auxiliary
 modules.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILAssemblyManifest.PublicKey">
<summary>
 This is the public key used to sign this
 assembly (the signature itself is stored elsewhere: see the
 binary format, and may not have been written if delay signing
 is used).  (member Name, member PublicKey) forms the full
 public name of the assembly.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILAssemblyManifest.AuxModuleHashAlgorithm">
<summary>
 This is the ID of the algorithm used for the hashes of auxiliary
 files in the assembly.   These hashes are stored in the
 &lt;c&gt;ILModuleRef.Hash&lt;/c&gt; fields of this assembly. These are not
 cryptographic hashes: they are simple file hashes. The algorithm
 is normally &lt;c&gt;0x00008004&lt;/c&gt; indicating the SHA1 hash algorithm.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILAssemblyManifest">
<summary>
 The main module of an assembly is a module plus some manifest information.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILResources">
<summary>
 Table of resources in a module.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.ILResource.GetBytes">
<summary>
 Read the bytes from a resource local to an assembly. Will fail for non-local resources.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILResource">
<summary>
 &quot;Manifest ILResources&quot; are chunks of resource data, being one of:
   - the data section of the current module (byte[] of resource given directly).
   - in an external file in this assembly (offset given in the ILResourceLocation field).
   - as a resources in another assembly of the same name.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILResourceLocation.Assembly">
<summary>
 Represents a manifest resource in a different assembly
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILResourceLocation.File">
<summary>
 Represents a manifest resource in an associated file
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILResourceLocation.Local">
<summary>
 Represents a manifest resource that can be read or written to a PE file
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILExportedTypeOrForwarder.Name">
<summary>
 [Namespace.]Name
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILExportedTypeOrForwarder">
<summary>
 these are only found in the ILExportedTypesAndForwarders table in the manifest
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILNestedExportedType">
<summary>
 &quot;Classes Elsewhere&quot; - classes in auxiliary modules.

 Manifests include declarations for all the classes in an
 assembly, regardless of which module they are in.

 The &quot;.class extern&quot; construct describes so-called exported types --
 these are public classes defined in the auxiliary modules of this assembly,
 i.e. modules other than the manifest-carrying module.

 For example, if you have a two-module
 assembly (A.DLL and B.DLL), and the manifest resides in the A.DLL,
 then in the manifest all the public classes declared in B.DLL should
 be defined as exported types, i.e., as &quot;.class extern&quot;. The public classes
 defined in A.DLL should not be defined as &quot;.class extern&quot; -- they are
 already available in the manifest-carrying module. The union of all
 public classes defined in the manifest-carrying module and all
 exported types defined there is the set of all classes exposed by
 this assembly. Thus, by analysing the metadata of the manifest-carrying
 module of an assembly, you can identify all the classes exposed by
 this assembly, and where to find them.

 Nested classes found in external modules should also be located in
 this table, suitably nested inside another &quot;ILExportedTypeOrForwarder&quot;
 definition.
 these are only found in the &quot;Nested&quot; field of ILExportedTypeOrForwarder objects
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.ILPreTypeDef.GetTypeDef">
<summary>
 Realise the actual full typedef
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILPreTypeDef">
<summary>
 Represents a prefix of information for ILTypeDef.

 The information is enough to perform name resolution for the F# compiler, probe attributes
 for ExtensionAttribute  etc.  This is key to the on-demand exploration of .NET metadata.
 This information has to be &quot;Goldilocks&quot; - not too much, not too little, just right.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILTypeDef.IsComInterop">
<summary>
 Class or interface generated for COM interop.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILTypeDef.HasSecurity">
<summary>
 Some classes are marked &quot;HasSecurity&quot; even if there are no permissions attached,
 e.g. if they use SuppressUnmanagedCodeSecurityAttribute
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.ILTypeDef.With(Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Reflection.TypeAttributes},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILTypeDefLayout},Microsoft.FSharp.Core.FSharpOption{Internal.Utilities.Library.InterruptibleLazy{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.InterfaceImpl}}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILGenericParameterDef}},Microsoft.FSharp.Core.FSharpOption{Internal.Utilities.Library.InterruptibleLazy{Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILType}}},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILMethodDefs},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILTypeDefs},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILFieldDefs},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILMethodImplDefs},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILEventDefs},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILPropertyDefs},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILTypeDefAdditionalFlags},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILAttributesStored},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILSecurityDecls})">
<summary>
 Functional update
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.ILTypeDef.#ctor(System.String,System.Reflection.TypeAttributes,FSharp.Compiler.AbstractIL.IL.ILTypeDefLayout,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.InterfaceImpl},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILGenericParameterDef},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILType},FSharp.Compiler.AbstractIL.IL.ILMethodDefs,FSharp.Compiler.AbstractIL.IL.ILTypeDefs,FSharp.Compiler.AbstractIL.IL.ILFieldDefs,FSharp.Compiler.AbstractIL.IL.ILMethodImplDefs,FSharp.Compiler.AbstractIL.IL.ILEventDefs,FSharp.Compiler.AbstractIL.IL.ILPropertyDefs,FSharp.Compiler.AbstractIL.IL.ILSecurityDecls,FSharp.Compiler.AbstractIL.IL.ILAttributesStored)">
<summary>
 Functional creation of a value, immediate
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.ILTypeDef.#ctor(System.String,System.Reflection.TypeAttributes,FSharp.Compiler.AbstractIL.IL.ILTypeDefLayout,Internal.Utilities.Library.InterruptibleLazy{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.InterfaceImpl}},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILGenericParameterDef},Internal.Utilities.Library.InterruptibleLazy{Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILType}},FSharp.Compiler.AbstractIL.IL.ILMethodDefs,FSharp.Compiler.AbstractIL.IL.ILTypeDefs,FSharp.Compiler.AbstractIL.IL.ILFieldDefs,FSharp.Compiler.AbstractIL.IL.ILMethodImplDefs,FSharp.Compiler.AbstractIL.IL.ILEventDefs,FSharp.Compiler.AbstractIL.IL.ILPropertyDefs,FSharp.Compiler.AbstractIL.IL.ILTypeDefAdditionalFlags,FSharp.Compiler.AbstractIL.IL.ILSecurityDecls,FSharp.Compiler.AbstractIL.IL.ILAttributesStored)">
<summary>
 Functional creation of a value with lazy calculated data
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.ILTypeDef.#ctor(System.String,System.Reflection.TypeAttributes,FSharp.Compiler.AbstractIL.IL.ILTypeDefLayout,Internal.Utilities.Library.InterruptibleLazy{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.InterfaceImpl}},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILGenericParameterDef},Internal.Utilities.Library.InterruptibleLazy{Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILType}},FSharp.Compiler.AbstractIL.IL.ILMethodDefs,FSharp.Compiler.AbstractIL.IL.ILTypeDefs,FSharp.Compiler.AbstractIL.IL.ILFieldDefs,FSharp.Compiler.AbstractIL.IL.ILMethodImplDefs,FSharp.Compiler.AbstractIL.IL.ILEventDefs,FSharp.Compiler.AbstractIL.IL.ILPropertyDefs,FSharp.Compiler.AbstractIL.IL.ILTypeDefAdditionalFlags,FSharp.Compiler.AbstractIL.IL.ILSecurityDeclsStored,FSharp.Compiler.AbstractIL.IL.ILAttributesStored,System.Int32)">
<summary>
 Functional creation of a value, using delayed reading via a metadata index, for ilread.fs
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILTypeDef">
<summary>
 Represents IL Type Definitions.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.ILTypeDefs.FindByName(System.String)">
<summary>
 Calls to &lt;c&gt;FindByName&lt;/c&gt; will result in all the ILPreTypeDefs being read.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.ILTypeDefs.ExistsByName(System.String)">
<summary>
 Calls to &lt;c&gt;ExistsByName&lt;/c&gt; will result in all the ILPreTypeDefs being read.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.ILTypeDefs.AsArrayOfPreTypeDefs">
<summary>
 Get some information about the type defs, but do not force the read of the type defs themselves.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILTypeDefs">
<summary>
 Tables of named type definitions.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILTypeDefAccess">
<summary>
 Type Access.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILDefaultPInvokeEncoding">
<summary>
 Default Unicode encoding for P/Invoke  within a type.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILTypeInit">
<summary>
 Indicate the initialization semantics of a type.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILTypeDefLayout">
<summary>
 Type Layout information.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILMethodImplDef">
<summary>
 Method Impls
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILPropertyDefs">
<summary>
 Table of properties in an IL type definition.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.ILPropertyDef.With(Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Reflection.PropertyAttributes},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILMethodRef}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILMethodRef}},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILThisConvention},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILType},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILFieldInit}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILType}},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILAttributes})">
<summary>
 Functional update of the value
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.ILPropertyDef.#ctor(System.String,System.Reflection.PropertyAttributes,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILMethodRef},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILMethodRef},FSharp.Compiler.AbstractIL.IL.ILThisConvention,FSharp.Compiler.AbstractIL.IL.ILType,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILFieldInit},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILType},FSharp.Compiler.AbstractIL.IL.ILAttributes)">
<summary>
 Functional creation of a value, immediate
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.ILPropertyDef.#ctor(System.String,System.Reflection.PropertyAttributes,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILMethodRef},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILMethodRef},FSharp.Compiler.AbstractIL.IL.ILThisConvention,FSharp.Compiler.AbstractIL.IL.ILType,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILFieldInit},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILType},FSharp.Compiler.AbstractIL.IL.ILAttributesStored,System.Int32)">
<summary>
 Functional creation of a value, using delayed reading via a metadata index, for ilread.fs
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILPropertyDef">
<summary>
 Property definitions
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILEventDefs">
<summary>
 Table of those events in a type definition.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.ILEventDef.With(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILType}},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Reflection.EventAttributes},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILMethodRef},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILMethodRef},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILMethodRef}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILMethodRef}},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILAttributes})">
<summary>
 Functional update of the value
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.ILEventDef.#ctor(Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILType},System.String,System.Reflection.EventAttributes,FSharp.Compiler.AbstractIL.IL.ILMethodRef,FSharp.Compiler.AbstractIL.IL.ILMethodRef,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILMethodRef},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILMethodRef},FSharp.Compiler.AbstractIL.IL.ILAttributes)">
<summary>
 Functional creation of a value, immediate
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.ILEventDef.#ctor(Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILType},System.String,System.Reflection.EventAttributes,FSharp.Compiler.AbstractIL.IL.ILMethodRef,FSharp.Compiler.AbstractIL.IL.ILMethodRef,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILMethodRef},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILMethodRef},FSharp.Compiler.AbstractIL.IL.ILAttributesStored,System.Int32)">
<summary>
 Functional creation of a value, using delayed reading via a metadata index, for ilread.fs
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILEventDef">
<summary>
 Event definitions.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILFieldDefs">
<summary>
 Tables of fields.  Logically equivalent to a list of fields but the table is kept in
 a form to allow efficient looking up fields by name.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILFieldDef.Offset">
<summary>
 The explicit offset in bytes when explicit layout is used.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.ILFieldDef.With(Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILType},Microsoft.FSharp.Core.FSharpOption{System.Reflection.FieldAttributes},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{System.Byte[]}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILFieldInit}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{System.Int32}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILNativeType}},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILAttributes})">
<summary>
 Functional update of the value
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.ILFieldDef.#ctor(System.String,FSharp.Compiler.AbstractIL.IL.ILType,System.Reflection.FieldAttributes,Microsoft.FSharp.Core.FSharpOption{System.Byte[]},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILFieldInit},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILNativeType},FSharp.Compiler.AbstractIL.IL.ILAttributes)">
<summary>
 Functional creation of a value, immediate
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.ILFieldDef.#ctor(System.String,FSharp.Compiler.AbstractIL.IL.ILType,System.Reflection.FieldAttributes,Microsoft.FSharp.Core.FSharpOption{System.Byte[]},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILFieldInit},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILNativeType},FSharp.Compiler.AbstractIL.IL.ILAttributesStored,System.Int32)">
<summary>
 Functional creation of a value using delayed reading via a metadata index
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILFieldDef">
<summary>
 Field definitions.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILMethodDefs">
<summary>
 Tables of methods.  Logically equivalent to a list of methods but
 the table is kept in a form optimized for looking up methods by
 name and arity.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILMethodDef.IsVirtual">
<summary>
 Indicates an instance methods that is virtual or abstract or implements an interface slot.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILMethodDef.IsUnmanagedExport">
<summary>
 The method is exported to unmanaged code using COM interop.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILMethodDef.IsStatic">
<summary>
 Indicates a static method.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILMethodDef.IsNonVirtualInstance">
<summary>
 Indicates this is an instance methods that is not virtual.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILMethodDef.IsMustRun">
<summary>
 SafeHandle finalizer must be run.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILMethodDef.IsConstructor">
<summary>
 Indicates a .ctor method.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILMethodDef.IsClassInitializer">
<summary>
 Indicates a .cctor method.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILMethodDef.HasSecurity">
<summary>
 Some methods are marked &quot;HasSecurity&quot; even if there are no permissions attached, e.g. if they use SuppressUnmanagedCodeSecurityAttribute
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.ILMethodDef.With(Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Reflection.MethodAttributes},Microsoft.FSharp.Core.FSharpOption{System.Reflection.MethodImplAttributes},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILCallingConv},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILParameter}},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILReturn},Microsoft.FSharp.Core.FSharpOption{Internal.Utilities.Library.InterruptibleLazy{FSharp.Compiler.AbstractIL.IL.MethodBody}},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILSecurityDecls},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILGenericParameterDef}},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILAttributes})">
<summary>
 Functional update of the value
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.ILMethodDef.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.MethodImplAttributes,FSharp.Compiler.AbstractIL.IL.ILCallingConv,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILParameter},FSharp.Compiler.AbstractIL.IL.ILReturn,Internal.Utilities.Library.InterruptibleLazy{FSharp.Compiler.AbstractIL.IL.MethodBody},System.Boolean,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILGenericParameterDef},FSharp.Compiler.AbstractIL.IL.ILSecurityDecls,FSharp.Compiler.AbstractIL.IL.ILAttributes)">
<summary>
 Functional creation of a value, immediate
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.ILMethodDef.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.MethodImplAttributes,FSharp.Compiler.AbstractIL.IL.ILCallingConv,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILParameter},FSharp.Compiler.AbstractIL.IL.ILReturn,Internal.Utilities.Library.InterruptibleLazy{FSharp.Compiler.AbstractIL.IL.MethodBody},System.Boolean,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILGenericParameterDef},FSharp.Compiler.AbstractIL.IL.ILSecurityDeclsStored,FSharp.Compiler.AbstractIL.IL.ILAttributesStored,System.Int32)">
<summary>
 Functional creation of a value, with delayed reading of some elements via a metadata index
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILMethodDef">
<summary>
 IL Method definitions.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILGenericParameterDef.MetadataIndex">
<summary>
 Do not use this
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILGenericParameterDef.CustomAttrsStored">
<summary>
 Do not use this
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILGenericParameterDef.HasAllowsRefStruct">
<summary>
 Indicates the type parameter allows ref struct, i.e. an anti constraint.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILGenericParameterDef.HasDefaultConstructorConstraint">
<summary>
 Indicates the type argument must have a public nullary constructor.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILGenericParameterDef.HasNotNullableValueTypeConstraint">
<summary>
 Indicates the type argument must be a value type, but not Nullable.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILGenericParameterDef.HasReferenceTypeConstraint">
<summary>
 Indicates the type argument must be a reference type.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILGenericParameterDef.Variance">
<summary>
 Variance of type parameters, only applicable to generic parameters for generic interfaces and delegates.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILGenericParameterDef.Constraints">
<summary>
 At most one is the parent type, the others are interface types.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILGenericParameterDef">
<summary>
 Generic parameters.  Formal generic parameter declarations may include the bounds, if any, on the generic parameter.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILOverridesSpec">
<summary>
 Represents a reference to a method declaration in a superclass or interface.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.PInvokeCallingConvention">
<summary>
 PInvoke attributes.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILSecurityDeclsStored">
<summary>
 Represents the efficiency-oriented storage of ILSecurityDecls in another item.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILSecurityDecls">
<summary>
 Abstract type equivalent to ILSecurityDecl list - use helpers
 below to construct/destruct these.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILReturn">
<summary>
 Method return values.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILParameter.Marshal">
<summary>
 Marshalling map for parameters. COM Interop only.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILParameter">
<summary>
 Method parameters and return values.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILAttributesStored.Given">
<summary>
 Already computed
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILAttributesStored.Reader">
<summary>
 Computed by ilread.fs based on metadata index
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILAttributesStored">
<summary>
 Represents the efficiency-oriented storage of ILAttributes in another item.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILAttribute.Decoded">
<summary>
 Attribute with args in decoded form.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILAttribute.Encoded">
<summary>
 Attribute with args encoded to a binary blob according to ECMA-335 II.21 and II.23.3.
 &apos;decodeILAttribData&apos; is used to parse the byte[] blob to ILAttribElem&apos;s as best as possible.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILAttribute.Method">
<summary>
 Attribute instance constructor.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILAttribute.Elements">
<summary>
 Decoded arguments. May be empty in encoded attribute form.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILAttribute">
<summary>
 Custom attribute.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILAttributeNamedArg">
<summary>
 Named args: values and flags indicating if they are fields or properties.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILAttribElem.String">
<summary>
 Represents a custom attribute parameter of type &apos;string&apos;. These may be null, in which case they are encoded in a special
 way as indicated by Ecma-335 Partition II.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILMemberAccess.Family">
<summary>
 Family - Indicates that the method is accessible only to members of this class and its derived classes. (protected)
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILMemberAccess.FamilyOrAssembly">
<summary>
 FamilyOrAssembly - Indicates that the method is accessible to derived classes anywhere, as well as to any class _in the assembly_. (protected internal)
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILMemberAccess.FamilyAndAssembly">
<summary>
 FamilyAndAssembly - Indicates that the method is accessible to members of this type and its derived types that are in _this assembly only_. (private protected)
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILMemberAccess.Assembly">
<summary>
 Assembly - Indicates that the method is accessible to any class of this assembly. (internal)
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILMemberAccess">
<summary>
 Member Access
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILMethodBody">
<summary>
 IL method bodies
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILDebugImports">
<summary>
 Defines a set of opened namespace, type relevant to a code location.

 Emitted to the PortablePDB format.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILDebugImport.ImportNamespace">
<summary>
 Represents an &apos;open XYZ&apos; opening a namespace
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILDebugImport.ImportType">
<summary>
 Represents an &apos;open type XYZ&apos; opening a type
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILDebugImport">
<summary>
 Defines an opened namespace, type relevant to a code location.

 Emitted to the PortablePDB format. Note the format supports additional variations on
 imported things that are not yet emitted in F#.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILLocal">
<summary>
 Local variables
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILNativeType.Array">
<summary>
  optional idx of parameter giving size plus optional additive i.e. num elems
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILNativeType">
<summary>
 Native Types, for marshalling to the native C interface.
 These are taken directly from the ILASM syntax.
 Most of these are listed in the CLI ECMA-335 Spec (Partition II, 7.4).
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILFieldInit">
<summary>
 Field Init
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILLocalDebugMapping">
<summary>
 Indicates that a particular local variable has a particular source
 language name within a given set of ranges. This does not effect local
 variable numbering, which is global over the whole method.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILInstr">
<summary>
 The instruction set.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILCodeLabel">
<summary>
 ILCode labels.  In structured code each code label refers to a basic block somewhere in the code of the method.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILFieldSpec">
<summary>
 Field specs.  The data given for a ldfld, stfld etc. instruction.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.ILMethodSpec.Create(FSharp.Compiler.AbstractIL.IL.ILType,FSharp.Compiler.AbstractIL.IL.ILMethodRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILType})">
<summary>
 Functional creation
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILMethodSpec">
<summary>
 The information at the callsite of a method
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILFieldRef">
<summary>
 Formal identities of fields.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.ILMethodRef.Create(FSharp.Compiler.AbstractIL.IL.ILTypeRef,FSharp.Compiler.AbstractIL.IL.ILCallingConv,System.String,System.Int32,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILType},FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Functional creation
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILMethodRef">
<summary>
 Formal identities of methods.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILGenericArgs">
<summary>
 Actual generic parameters are  always types.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILType.Modified.Item3">
<summary>
 The type being modified.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILType.Modified.Item2">
<summary>
 The class of the custom modifier.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILType.Modified.Item1">
<summary>
 True if modifier is &quot;required&quot;.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILType.Modified">
<summary>
 Custom modifiers.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILType.TypeVar">
<summary>
 Reference a generic arg.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILType.FunctionPointer">
<summary>
 ILCode pointers.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILType.Byref">
<summary>
 Managed pointers.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILType.Ptr">
<summary>
 Unmanaged pointers.  Nb. the type is used by tools and for binding only, not by the verifier.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILType.Boxed">
<summary>
 Reference types.  Also may be used for parents of members even if for members in value types.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILType.Value">
<summary>
 Unboxed types, including builtin types.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILType.Array">
<summary>
 Array types
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILType.Void">
<summary>
 Used only in return and pointer types.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILTypeSpec.TypeRef">
<summary>
 Which type is being referred to?
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILTypeSpec.Scope">
<summary>
 Where is the type, i.e. is it in this module, in another module in this assembly or in another assembly?
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILTypeSpec.Name">
<summary>
 The name of the type. This also contains the namespace if Enclosing is empty.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILTypeSpec.GenericArgs">
<summary>
 The type instantiation if the type is generic, otherwise empty
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILTypeSpec.FullName">
<summary>
 The name of the type in the assembly using the &apos;.&apos; notation for nested types.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILTypeSpec.Enclosing">
<summary>
 The list of enclosing type names for a nested type. If non-nil then the first of these also contains the namespace.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.ILTypeSpec.Create(FSharp.Compiler.AbstractIL.IL.ILTypeRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILType})">
<summary>
 Create an ILTypeSpec.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILTypeSpec">
<summary>
 Type specs and types.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILTypeRef.Scope">
<summary>
 Where is the type, i.e. is it in this module, in another module in this assembly or in another assembly?
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILTypeRef.Name">
<summary>
 The name of the type. This also contains the namespace if Enclosing is empty.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILTypeRef.FullName">
<summary>
 The name of the type in the assembly using the &apos;.&apos; notation for nested types.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILTypeRef.Enclosing">
<summary>
 The list of enclosing type names for a nested type. If non-nil then the first of these also contains the namespace.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILTypeRef.BasicQualifiedName">
<summary>
 The name of the type in the assembly using the &apos;+&apos; notation for nested types.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.ILTypeRef.Create(FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList{System.String},System.String)">
<summary>
 Create a ILTypeRef.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILTypeRef">
<summary>
 Type refs, i.e. references to types in some .NET assembly
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILArrayShape.SingleDimensional">
<summary>
 Bounds for a single dimensional, zero based array
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILArrayBounds">
<summary>
 Lower-bound/size pairs
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILArrayBound">
<summary>
 Array shapes. For most purposes the rank is the only thing that matters.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILThisConvention.Static">
<summary>
 no &apos;this&apos; pointer is passed
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILThisConvention.InstanceExplicit">
<summary>
 accepts an explicit &apos;this&apos; pointer
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILThisConvention.Instance">
<summary>
 accepts an implicit &apos;this&apos; pointer
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILScopeRef.PrimaryAssembly">
<summary>
 A reference to a type in the primary assembly
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILScopeRef.Assembly">
<summary>
 A reference to a type in another assembly
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILScopeRef.Module">
<summary>
 A reference to a type in a module in the same assembly
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILScopeRef.Local">
<summary>
 A reference to the type in the current module
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILAssemblyRef.Retargetable">
<summary>
 CLI says this indicates if the assembly can be retargeted (at runtime) to be from a different publisher.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ILAssemblyRef.QualifiedName">
<summary>
 The fully qualified name of the assembly reference, e.g. mscorlib, Version=1.0.3705 etc.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILSourceDocument">
<summary>
 Debug info.  Values of type &quot;source&quot; can be attached at sequence
 points and some other locations.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.ILGuid">
<summary>
 Represents guids
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.PrimaryAssembly.IsPossiblePrimaryAssembly(System.String)">
<summary>
 Checks if an assembly resolution may represent a primary assembly that actually contains the
 definition of System.Object.  Note that the chosen target primary assembly may not actually be the one
 that contains the definition of System.Object - it is just the one we are choosing to emit for.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL.PrimaryAssembly">
<summary>
 Represents the target primary assembly
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.computeILRefs(FSharp.Compiler.AbstractIL.IL.ILGlobals,FSharp.Compiler.AbstractIL.IL.ILModuleDef)">
<summary>
 Find the full set of assemblies referenced by a module.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.parseILVersion(System.String)">
<summary>
 Get a version number from a CLR version string, e.g. 1.0.3705.0
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.sha1HashBytes(System.Byte[])">
<summary>
 Get a public key token from a public key.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.isILObjectTy(FSharp.Compiler.AbstractIL.IL.ILGlobals,FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Discriminating different important built-in types.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.stripILModifiedFromTy(FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Strips ILType.Modified from the ILType.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.ecmaPublicKey">
<summary>
 This is a &apos;vendor neutral&apos; way of referencing mscorlib.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.instILType(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILType},FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Instantiate type variables that occur within types and other items.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.instILTypeAux(System.Int32,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILType},FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Instantiate type variables that occur within types and other items.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.unscopeILType(FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Unscoping. Clears every scope information, use for looking up IL method references only.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.rescopeILFieldRef(FSharp.Compiler.AbstractIL.IL.ILScopeRef,FSharp.Compiler.AbstractIL.IL.ILFieldRef)">
<summary>
 Rescoping. The first argument indicates how to reference the original scope from
 the new scope.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.rescopeILMethodRef(FSharp.Compiler.AbstractIL.IL.ILScopeRef,FSharp.Compiler.AbstractIL.IL.ILMethodRef)">
<summary>
 Rescoping. The first argument indicates how to reference the original scope from
 the new scope.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.rescopeILType(FSharp.Compiler.AbstractIL.IL.ILScopeRef,FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Rescoping. The first argument indicates how to reference the original scope from
 the new scope.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.rescopeILTypeSpec(FSharp.Compiler.AbstractIL.IL.ILScopeRef,FSharp.Compiler.AbstractIL.IL.ILTypeSpec)">
<summary>
 Rescoping. The first argument indicates how to reference the original scope from
 the new scope.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.rescopeILTypeRef(FSharp.Compiler.AbstractIL.IL.ILScopeRef,FSharp.Compiler.AbstractIL.IL.ILTypeRef)">
<summary>
 Rescoping. The first argument indicates how to reference the original scope from
 the new scope.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.rescopeILScopeRef(FSharp.Compiler.AbstractIL.IL.ILScopeRef,FSharp.Compiler.AbstractIL.IL.ILScopeRef)">
<summary>
 Rescoping. The first argument indicates how to reference the original scope from
 the new scope.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkRefForNestedILTypeDef(FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILTypeDef},FSharp.Compiler.AbstractIL.IL.ILTypeDef)">
<summary>
 Generate references to existing type definitions, method definitions
 etc.  Useful for generating references, e.g. to a  class we&apos;re processing
 Also used to reference type definitions that we&apos;ve generated.  [ILScopeRef]
 is normally ILScopeRef.Local, unless we&apos;ve generated the ILTypeDef in
 an auxiliary module or are generating multiple assemblies at
 once.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkILSimpleModule(System.String,System.String,System.Boolean,System.Tuple{System.Int32,System.Int32},System.Boolean,FSharp.Compiler.AbstractIL.IL.ILTypeDefs,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},System.Int32,FSharp.Compiler.AbstractIL.IL.ILExportedTypesAndForwarders,System.String)">
<summary>
 Making modules.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkILTypeDefsComputed(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,FSharp.Compiler.AbstractIL.IL.ILPreTypeDef[]})">
<summary>
 Create table of types which is loaded/computed on-demand, and whose individual
 elements are also loaded/computed on-demand. Any call to tdefs.AsList will
 result in the laziness being forced.  Operations can examine the
 custom attributes and name of each type in order to decide whether
 to proceed with examining the other details of the type.

 Note that individual type definitions may contain further delays
 in their method, field and other tables.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkILCustomAttrs(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILAttribute})">
<summary>
 Making tables of custom attributes, etc.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkILTypeForGlobalFunctions(FSharp.Compiler.AbstractIL.IL.ILScopeRef)">
<summary>
 The toplevel &quot;class&quot; for a module or assembly.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkCtorMethSpecForDelegate(FSharp.Compiler.AbstractIL.IL.ILGlobals,FSharp.Compiler.AbstractIL.IL.ILType,System.Boolean)">
<summary>
 Given a delegate type definition which lies in a particular scope,
 make a reference to its constructor.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkILStorageCtor(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILInstr},FSharp.Compiler.AbstractIL.IL.ILType,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,FSharp.Compiler.AbstractIL.IL.ILType,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILAttribute}}},FSharp.Compiler.AbstractIL.IL.ILMemberAccess,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILDebugPoint},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILDebugImports})">
<summary>
 Derived functions for making some simple constructors
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.prependInstrsToClassCtor(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILInstr},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILDebugPoint},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILDebugImports},FSharp.Compiler.AbstractIL.IL.ILTypeDef)">
<summary>
 Injecting initialization code into a class.
 Add some code to the end of the .cctor for a type.  Create a .cctor
 if one doesn&apos;t exist already.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.appendInstrsToCode(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILInstr},FSharp.Compiler.AbstractIL.IL.ILCode)">
<summary>
 Injecting code into existing code blocks.  A branch will
 be added from the given instructions to the (unique) entry of
 the code, and the first instruction will be the new entry
 of the method.  The instructions should be non-branching.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkRawDataValueTypeDef(FSharp.Compiler.AbstractIL.IL.ILType,System.String,System.Int32,System.UInt16)">
<summary>
 Make a type definition for a value type used to point to raw data.
 These are useful when generating array initialization code
 according to the
   ldtoken    field valuetype &apos;&lt;PrivateImplementationDetails&gt;&apos;/&apos;$$struct0x6000127-1&apos; &apos;&lt;PrivateImplementationDetails&gt;&apos;::&apos;$$method0x6000127-1&apos;
   call       void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(class System.Array,valuetype System.RuntimeFieldHandle)
 idiom.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkILGenericClass(System.String,FSharp.Compiler.AbstractIL.IL.ILTypeDefAccess,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILGenericParameterDef},FSharp.Compiler.AbstractIL.IL.ILType,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.InterfaceImpl},FSharp.Compiler.AbstractIL.IL.ILMethodDefs,FSharp.Compiler.AbstractIL.IL.ILFieldDefs,FSharp.Compiler.AbstractIL.IL.ILTypeDefs,FSharp.Compiler.AbstractIL.IL.ILPropertyDefs,FSharp.Compiler.AbstractIL.IL.ILEventDefs,FSharp.Compiler.AbstractIL.IL.ILAttributes,FSharp.Compiler.AbstractIL.IL.ILTypeInit)">
<summary>
 Make a type definition.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkILInstanceField(System.String,FSharp.Compiler.AbstractIL.IL.ILType,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILFieldInit},FSharp.Compiler.AbstractIL.IL.ILMemberAccess)">
<summary>
 Make field definitions.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkILMethodBody(System.Boolean,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILLocal},System.Int32,FSharp.Compiler.AbstractIL.IL.ILCode,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILDebugPoint},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILDebugImports})">
<summary>
 Make method definitions.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.IL.mkILEmptyGenericParams">
<summary>
 Make a formal generic parameters.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkILParam(Microsoft.FSharp.Core.FSharpOption{System.String},FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Derived functions for making return, parameter and local variable
 objects for use in method definitions.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkNormalCall(FSharp.Compiler.AbstractIL.IL.ILMethodSpec)">
<summary>
 Derived functions for making some common patterns of instructions.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.nonBranchingInstrsToCode(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILInstr})">
<summary>
 Make some code that is a straight line sequence of instructions.
 The function will add a &quot;return&quot; if the last instruction is not an exiting instruction.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.generateCodeLabel">
<summary>
 Making code.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkILCustomAttribMethRef(FSharp.Compiler.AbstractIL.IL.ILMethodSpec,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILAttribElem},Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,FSharp.Compiler.AbstractIL.IL.ILType,System.Boolean,FSharp.Compiler.AbstractIL.IL.ILAttribElem}})">
<summary>
 Make custom attributes.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkILFormalBoxedTy(FSharp.Compiler.AbstractIL.IL.ILTypeRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILGenericParameterDef})">
<summary>
 Make generalized versions of possibly-generic types, e.g. Given the ILTypeDef for List, return the type &quot;List&lt;T&gt;&quot;.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkILFieldRef(FSharp.Compiler.AbstractIL.IL.ILTypeRef,System.String,FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Construct references to fields.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkILCtorMethSpecForTy(FSharp.Compiler.AbstractIL.IL.ILType,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILType})">
<summary>
 Construct references to constructors.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkILNonGenericStaticMethSpecInTy(FSharp.Compiler.AbstractIL.IL.ILType,System.String,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILType},FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Construct references to static, non-generic methods.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkILStaticMethSpecInTy(FSharp.Compiler.AbstractIL.IL.ILType,System.String,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILType},FSharp.Compiler.AbstractIL.IL.ILType,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILType})">
<summary>
 Construct references to static methods.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkILNonGenericInstanceMethSpecInTy(FSharp.Compiler.AbstractIL.IL.ILType,System.String,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILType},FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Construct references to instance methods.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkILInstanceMethSpecInTy(FSharp.Compiler.AbstractIL.IL.ILType,System.String,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILType},FSharp.Compiler.AbstractIL.IL.ILType,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILType})">
<summary>
 Construct references to instance methods.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkILNonGenericMethSpecInTy(FSharp.Compiler.AbstractIL.IL.ILType,FSharp.Compiler.AbstractIL.IL.ILCallingConv,System.String,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILType},FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Construct references to methods on a given type .
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkILMethRef(FSharp.Compiler.AbstractIL.IL.ILTypeRef,FSharp.Compiler.AbstractIL.IL.ILCallingConv,System.String,System.Int32,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILType},FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Make method references and specs.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkILTy(FSharp.Compiler.AbstractIL.IL.ILBoxity,FSharp.Compiler.AbstractIL.IL.ILTypeSpec)">
<summary>
 Make types.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkILNonGenericTySpec(FSharp.Compiler.AbstractIL.IL.ILTypeRef)">
<summary>
 Make type specs.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkILNestedTyRef(FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList{System.String},System.String)">
<summary>
 Make type refs.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkSimpleAssemblyRef(System.String)">
<summary>
 Generate simple references to assemblies and modules.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.decodeILAttribData(FSharp.Compiler.AbstractIL.IL.ILAttribute)">
<summary>
 Not all custom attribute data can be decoded without binding types.  In particular
 enums must be bound in order to discover the size of the underlying integer.
 The following assumes enums have size int32.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.destTypeDefsWithGlobalFunctionsFirst(FSharp.Compiler.AbstractIL.IL.ILGlobals,FSharp.Compiler.AbstractIL.IL.ILTypeDefs)">
<summary>
 When writing a binary the fake &quot;toplevel&quot; type definition (called &lt;Module&gt;)
 must come first. This function puts it first, and creates it in the returned
 list as an empty typedef if it doesn&apos;t already exist.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.mkILGlobals(FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILAssemblyRef},FSharp.Compiler.AbstractIL.IL.ILScopeRef)">
<summary>
 Build the table of commonly used references given functions to find types in system assemblies

   primaryScopeRef is the primary assembly we are emitting
   equivPrimaryAssemblyRefs are ones regarded as equivalent
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.splitTypeNameRight(System.String)">
 <c>splitTypeNameRight</c> is like <c>splitILTypeName</c> except the
 namespace is kept as a whole string, rather than split at dots.
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.splitILTypeName(System.String)">
<summary>
 The &lt;c&gt;splitILTypeName&lt;/c&gt; utility helps you split a string representing
 a type name into the leading namespace elements (if any), the
 names of any nested types and the type name itself.  This function
 memoizes and interns the splitting of the namespace portion of
 the type name.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.IL.resolveILMethodRef(FSharp.Compiler.AbstractIL.IL.ILTypeDef,FSharp.Compiler.AbstractIL.IL.ILMethodRef)">
<summary>
 Find the method definition corresponding to the given property or
 event operation. These are always in the same class as the property
 or event. This is useful especially if your code is not using the Ilbind
 API to bind references.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.IL">
<summary>
 The &quot;unlinked&quot; view of .NET metadata and code.  Central to the Abstract IL library
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.AsciiConstants">
<summary>
 Various constants and utilities used when parsing the ILASM format for IL
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.AsciiParser.token_to_string(FSharp.Compiler.AbstractIL.AsciiParser.token)">
<summary>
 This function gets the name of a token as a string
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.AsciiParser.prodIdxToNonTerminal(System.Int32)">
<summary>
 This function maps production indexes returned in syntax errors to strings representing the non terminal that would be produced by that production
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.AsciiParser.tokenTagToTokenId(System.Int32)">
<summary>
 This function maps integer indexes to symbolic token ids
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.AsciiParser.tagOfToken(FSharp.Compiler.AbstractIL.AsciiParser.token)">
<summary>
 This function maps tokens to integer indexes
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.AsciiLexer.token(Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Rule token
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.ILAsciiWriter">
<summary>
 Printer for the abstract syntax.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.Morphs.morphILTypeRefsInILModuleMemoized(Microsoft.FSharp.Core.FSharpFunc{System.String,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.AbstractIL.IL.ILTypeRef,FSharp.Compiler.AbstractIL.IL.ILTypeRef},FSharp.Compiler.AbstractIL.IL.ILModuleDef)">
<summary>
 Morph all type references throughout an entire module.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.Morphs.morphILTypeRefsInILType(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.AbstractIL.IL.ILTypeRef,FSharp.Compiler.AbstractIL.IL.ILTypeRef},FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Morph each ILTypeRef inside an ILType
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.Morphs.morphILScopeRefsInILTypeRef(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.AbstractIL.IL.ILScopeRef,FSharp.Compiler.AbstractIL.IL.ILScopeRef},FSharp.Compiler.AbstractIL.IL.ILTypeRef)">
<summary>
 Morph each scope reference inside a type signature.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.Morphs">
<summary>
 A set of &quot;IL rewrites&quot; (&quot;morphs&quot;).  These map each sub-construct
 of particular ILTypeDefs.  The morphing functions are passed
 some details about the context in which the item being
 morphed occurs, e.g. the module being morphed itself, the
 ILTypeDef (possibly nested) where the item occurs,
 the ILMethodDef (if any) where the item occurs. etc.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.StrongNameSign">
<summary>
 Functions associated with signing il assemblies which
 vary between supported implementations of the CLI Common Language
 Runtime, e.g. between the SSCLI, Mono and the Microsoft CLR.

</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.Support.linkNativeResources(Microsoft.FSharp.Collections.FSharpList{System.Byte[]},System.Int32)">
<summary>
 Unmanaged resource file linker - for native resources (not managed ones).
 The function may be called twice, once with a zero-RVA and
 arbitrary buffer, and once with the real buffer.  The size of the
 required buffer is returned.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.Support">
<summary>
 Functions associated with writing binaries which
 vary between supported implementations of the CLI Common Language
 Runtime, e.g. between the SSCLI, Mono and the Microsoft CLR.

 The implementation of the functions can be found in ilsupp-*.fs
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.BinaryConstants">
<summary>
 Compiler use only.  Code and constants shared between binary reader/writer.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.ILBinaryReader.ILModuleReader">
<summary>
 Represents a reader of the metadata of a .NET binary.  May also give some values (e.g. IL code) from the PE file
 if it was provided.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.ILBinaryReader.ILReaderOptions.tryGetMetadataSnapshot">
<summary>
 A function to call to try to get an object that acts as a snapshot of the metadata section of a .NET binary,
 and from which we can read the metadata. Only used when metadataOnly=true.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.ILBinaryReader.ILReaderOptions.metadataOnly">
<summary>
 Only open a metadata reader for the metadata portion of the .NET binary without keeping alive any data associated with the PE reader
 - IL code will not be available (mdBody in ILMethodDef will return NotAvailable)
 - Managed resources will be reported back as ILResourceLocation.LocalIn (as always)
 - Native resources will not be available (none will be returned)
 - Static data associated with fields will not be available
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.ILBinaryReader.ILReaderMetadataSnapshot">
<summary>
 Used to implement a Binary file over native memory, used by Roslyn integration
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.ILBinaryReader.OpenILModuleReaderFromStream(System.String,System.IO.Stream,FSharp.Compiler.AbstractIL.ILBinaryReader.ILReaderOptions)">
<summary>
 Open a binary reader based on the given stream. 
 This binary reader is not internally cached.
 The binary reader will own the given stream and the stream will be disposed when there are no references to the binary reader.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.ILBinaryReader.OpenILModuleReaderFromBytes(System.String,System.Byte[],FSharp.Compiler.AbstractIL.ILBinaryReader.ILReaderOptions)">
<summary>
 Open a binary reader based on the given bytes. 
 This binary reader is not internally cached.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.ILBinaryReader.OpenILModuleReader(System.String,FSharp.Compiler.AbstractIL.ILBinaryReader.ILReaderOptions)">
<summary>
 Open a binary reader, except first copy the entire contents of the binary into 
 memory, close the file and ensure any subsequent reads happen from the in-memory store. 
 PDB files may not be read with this option. 
 Binary reader is internally cached.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.ILBinaryReader.Shim">
<summary>
 The public API hook for changing the IL assembly reader, used by Resharper
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.ILBinaryReader">
<summary>
 Binary reader.  Read a .NET binary and concert it to Abstract IL data
 structures.
 
 NOTE:
   - The metadata in the loaded modules will be relative to 
     those modules, e.g. ILScopeRef.Local will mean &quot;local to 
     that module&quot;.  You must use [rescopeILType] etc. if you want to include 
     (i.e. copy) the metadata into your own module. 

   - PDB (debug info) reading/folding:
     The PDB reader is invoked if you give a PDB path 
     This indicates if you want to search for PDB files and have the 
     reader fold them in.  You cannot currently name the pdb file 
     directly - you can only name the path.  Giving &quot;None&quot; says 
     &quot;do not read the PDB file even if one exists&quot;. 
 
     The debug info appears primarily as I_seqpoint annotations in 
     the instruction streams.  Unfortunately the PDB information does
     not, for example, tell you how to map back from a class definition
     to a source code line number - you will need to explicitly search
     for a sequence point in the code for one of the methods of the 
     class.  That is not particularly satisfactory, and it may be
     a good idea to build a small library which extracts the information
     you need.  
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.ILPdbWriter.PdbData.ModuleID">
<summary>
 MVID of the generated .NET module (used by MDB files to identify debug info)
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.ILPdbWriter.PdbImport.ImportNamespace">
<summary>
 Represents an &apos;open XYZ&apos; opening a namespace
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.ILPdbWriter.PdbImport.ImportType">
<summary>
 Represents an &apos;open type XYZ&apos; opening a type
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.ILPdbWriter.PdbImport">
<summary>
 Defines the set of &apos;imports&apos; - that is, opened namespaces, types etc. - at each code location

 Note the C# debug evaluation engine used for F# will give C# semantics to these.  That in general
 is very close to F# semantics, except for things like union type.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.ILPdbWriter.PdbLocalVar.Index">
<summary>
 the local index the name corresponds to
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.ILPdbWriter.unshadowScopes(FSharp.Compiler.AbstractIL.ILPdbWriter.PdbMethodScope)">
<summary>
 Check to see if a scope has a local with the same name as any of its children

 If so, do not emit &apos;scope&apos; itself. Instead,
  1. Emit a copy of &apos;scope&apos; in each true gap, with all locals
  2. Adjust each child scope to also contain the locals from &apos;scope&apos;,
     adding the text &quot; (shadowed)&quot; to the names of those with name conflicts.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.ILPdbWriter.sizeof_IMAGE_DEBUG_DIRECTORY">
<summary>
 28 is the size of the IMAGE_DEBUG_DIRECTORY in ntimage.h
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.ILPdbWriter.getDebugFileName(System.String)">
<summary>
 Takes the output file name and returns debug file name.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.ILPdbWriter">
<summary>
 The ILPdbWriter
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.ILBinaryWriter.WriteILBinaryInMemory(FSharp.Compiler.AbstractIL.ILBinaryWriter.options,FSharp.Compiler.AbstractIL.IL.ILModuleDef,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.AbstractIL.IL.ILAssemblyRef,FSharp.Compiler.AbstractIL.IL.ILAssemblyRef})">
<summary>
 Write a binary to an array of bytes suitable for dynamic loading.
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.ILBinaryWriter.WriteILBinaryFile(FSharp.Compiler.AbstractIL.ILBinaryWriter.options,FSharp.Compiler.AbstractIL.IL.ILModuleDef,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.AbstractIL.IL.ILAssemblyRef,FSharp.Compiler.AbstractIL.IL.ILAssemblyRef})">
<summary>
 Write a binary to the file system.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.ILBinaryWriter">
<summary>
 The IL Binary writer.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.ILDynamicAssemblyWriter">
<summary>
 Write Abstract IL structures at runtime using Reflection.Emit
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.ILX.Types.IlxUnionInfo.DebugImports">
<summary>
 Debug info for generated code for classunions
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.ILX.Types.IlxUnionInfo.DebugPoint">
<summary>
 Debug info for generated code for classunions.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.ILX.Types.IlxUnionInfo.HasHelpers">
<summary>
 Generate the helpers?
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.ILX.Types.IlxUnionInfo.HelpersAccessibility">
<summary>
 Are the representation helpers public?
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.ILX.Types.IlxUnionInfo.UnionCasesAccessibility">
<summary>
 Is the representation public?
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.ILX.Types.IlxUnionInfo">
<summary>
 Represents a discriminated union type prior to erasure
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.ILX.Types.IlxClosureInfo">
<summary>
 Represents a closure prior to erasure
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.ILX.Types.IlxClosureApps">
<summary>
 IlxClosureApps - i.e. types being applied at a callsite.
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.ILX.Types.IlxClosureSpec.UseStaticField">
<summary>
 Indicates if a static field being used to store an instance of this closure (because it has no free variables)
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.ILX.Types.IlxClosureSpec.Constructor">
<summary>
 Get the constructor for the closure
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.ILX.Types.IlxClosureSpec.GetStaticFieldSpec">
<summary>
 Get the static field used to store an instance of this closure, if useStaticField is true
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.ILX.Types.IlxClosureSpec">
<summary>
 Represents a usage of a closure
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.ILX.Types.IlxUnionRef">
<summary>
 Union references
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.ILX.Types.IlxUnionCase">
<summary>
 Union alternative
</summary>
</member>
<member name="P:FSharp.Compiler.AbstractIL.ILX.Types.IlxUnionCaseField.LowerName">
<summary>
 The name used for the field in parameter or IL field position.
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.ILX.Types.IlxUnionCaseField">
<summary>
 Union case field
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.ILX.Types">
<summary>
 ILX extensions to Abstract IL types and instructions F#
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.ILX.EraseClosures">
<summary>
 Compiler use only.  Erase closures
</summary>
</member>
<member name="T:FSharp.Compiler.AbstractIL.ILX.EraseUnions.ICodeGen`1">
<summary>
 Used to emit instructions (an interface to the IlxGen.fs code generator)
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.ILX.EraseUnions.emitDataSwitch``1(FSharp.Compiler.AbstractIL.IL.ILGlobals,FSharp.Compiler.AbstractIL.ILX.EraseUnions.ICodeGen{``0},System.Boolean,FSharp.Compiler.AbstractIL.ILX.Types.IlxUnionSpec,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Int32}})">
<summary>
 Emit the instruction sequence for a &quot;switchdata&quot; operation
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.ILX.EraseUnions.emitLdDataTag``1(FSharp.Compiler.AbstractIL.IL.ILGlobals,FSharp.Compiler.AbstractIL.ILX.EraseUnions.ICodeGen{``0},System.Boolean,FSharp.Compiler.AbstractIL.ILX.Types.IlxUnionSpec)">
<summary>
 Emit the instruction sequence for a &quot;lddatatag&quot; operation
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.ILX.EraseUnions.emitCastData``1(FSharp.Compiler.AbstractIL.IL.ILGlobals,FSharp.Compiler.AbstractIL.ILX.EraseUnions.ICodeGen{``0},System.Boolean,System.Boolean,FSharp.Compiler.AbstractIL.ILX.Types.IlxUnionSpec,System.Int32)">
<summary>
 Emit the instruction sequence for a &quot;castdata&quot; operation
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.ILX.EraseUnions.GetILTypeForAlternative(FSharp.Compiler.AbstractIL.ILX.Types.IlxUnionSpec,System.Int32)">
<summary>
 Make the IL type for a union type alternative
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.ILX.EraseUnions.mkClassUnionDef(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.AbstractIL.IL.ILMethodDef,FSharp.Compiler.AbstractIL.IL.ILMethodDef},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.AbstractIL.IL.ILPropertyDef,FSharp.Compiler.AbstractIL.IL.ILPropertyDef},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.AbstractIL.IL.ILPropertyDef,FSharp.Compiler.AbstractIL.IL.ILPropertyDef},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.AbstractIL.IL.ILFieldDef,FSharp.Compiler.AbstractIL.IL.ILFieldDef},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.AbstractIL.IL.ILFieldDef,FSharp.Compiler.AbstractIL.IL.ILFieldDef},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.AbstractIL.IL.ILType,FSharp.Compiler.AbstractIL.IL.ILAttribute},FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.AbstractIL.IL.ILTypeRef,FSharp.Compiler.AbstractIL.IL.ILTypeDef,FSharp.Compiler.AbstractIL.ILX.Types.IlxUnionInfo)">
<summary>
 Make the type definition for a union type
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.ILX.EraseUnions.mkBrIsData(FSharp.Compiler.AbstractIL.IL.ILGlobals,System.Boolean,System.Boolean,FSharp.Compiler.AbstractIL.ILX.Types.IlxUnionSpec,System.Int32,System.Int32)">
<summary>
 Make the instruction sequence for a &quot;brisnotdata&quot; operation
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.ILX.EraseUnions.mkStData(FSharp.Compiler.AbstractIL.ILX.Types.IlxUnionSpec,System.Int32,System.Int32)">
<summary>
 Make the instruction for a &quot;stdata&quot; operation
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.ILX.EraseUnions.mkLdDataAddr(System.Boolean,FSharp.Compiler.AbstractIL.ILX.Types.IlxUnionSpec,System.Int32,System.Int32)">
<summary>
 Make the instruction for a &quot;lddataa&quot; operation
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.ILX.EraseUnions.mkLdData(System.Boolean,FSharp.Compiler.AbstractIL.ILX.Types.IlxUnionSpec,System.Int32,System.Int32)">
<summary>
 Make the instruction for a &quot;lddata&quot; operation
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.ILX.EraseUnions.mkIsData(FSharp.Compiler.AbstractIL.IL.ILGlobals,System.Boolean,FSharp.Compiler.AbstractIL.ILX.Types.IlxUnionSpec,System.Int32)">
<summary>
 Make the instruction sequence for a &quot;isdata&quot; operation
</summary>
</member>
<member name="M:FSharp.Compiler.AbstractIL.ILX.EraseUnions.mkNewData(FSharp.Compiler.AbstractIL.IL.ILGlobals,FSharp.Compiler.AbstractIL.ILX.Types.IlxUnionSpec,System.Int32)">
<summary>
 Make the instruction sequence for a &quot;newdata&quot; operation
</summary>
</member>
<member name="M:FSharp.Compiler.IlxGen.IlxAssemblyGenerator.LookupGeneratedValue(FSharp.Compiler.IlxGen.ExecutionContext,FSharp.Compiler.TypedTree.Val)">
<summary>
 Invert the compilation of the given value and return its current dynamic value and its compiled System.Type
</summary>
</member>
<member name="M:FSharp.Compiler.IlxGen.IlxAssemblyGenerator.GenerateCode(FSharp.Compiler.IlxGen.IlxGenOptions,FSharp.Compiler.TypedTree.CheckedAssemblyAfterOptimization,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Attrib},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.Attrib})">
<summary>
 Generate ILX code for an assembly fragment
</summary>
</member>
<member name="M:FSharp.Compiler.IlxGen.IlxAssemblyGenerator.ForceSetGeneratedValue(FSharp.Compiler.IlxGen.ExecutionContext,FSharp.Compiler.TypedTree.Val,System.Object)">
<summary>
 Invert the compilation of the given value and set the storage of the value, even if it is immutable
</summary>
</member>
<member name="M:FSharp.Compiler.IlxGen.IlxAssemblyGenerator.ClearGeneratedValue(FSharp.Compiler.IlxGen.ExecutionContext,FSharp.Compiler.TypedTree.Val)">
<summary>
 Invert the compilation of the given value and clear the storage of the value
</summary>
</member>
<member name="M:FSharp.Compiler.IlxGen.IlxAssemblyGenerator.AddIncrementalLocalAssemblyFragment(System.Boolean,System.String,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.CheckedImplFile})">
<summary>
 Register a fragment of the current assembly with the ILX code generator. If &apos;isIncrementalFragment&apos; is true then the input
 is assumed to be a fragment &apos;typed&apos; into FSI.EXE, otherwise the input is assumed to be the result of a &apos;#load&apos;
</summary>
</member>
<member name="M:FSharp.Compiler.IlxGen.IlxAssemblyGenerator.AddExternalCcus(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.CcuThunk})">
<summary>
 Register a set of referenced assemblies with the ILX code generator
</summary>
</member>
<member name="M:FSharp.Compiler.IlxGen.IlxAssemblyGenerator.#ctor(FSharp.Compiler.Import.ImportMap,FSharp.Compiler.TcGlobals.TcGlobals,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.ValRef,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.TypedTree.ValUseFlag,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.TType},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Text.Range,System.Tuple{FSharp.Compiler.TypedTree.Expr,FSharp.Compiler.TypedTree.TType}}}}},FSharp.Compiler.TypedTree.CcuThunk)">
<summary>
 Create an incremental ILX code generator for a single assembly
</summary>
</member>
<member name="T:FSharp.Compiler.IlxGen.IlxAssemblyGenerator">
<summary>
 An incremental ILX code generator for a single assembly
</summary>
</member>
<member name="T:FSharp.Compiler.IlxGen.ExecutionContext">
<summary>
 Used to support the compilation-inversion operations &quot;ClearGeneratedValue&quot; and &quot;LookupGeneratedValue&quot;
</summary>
</member>
<member name="P:FSharp.Compiler.IlxGen.IlxGenResults.quotationResourceInfo">
<summary>
 The generated IL/ILX resources associated with F# quotations
</summary>
</member>
<member name="P:FSharp.Compiler.IlxGen.IlxGenResults.permissionSets">
<summary>
 The security attributes to attach to the assembly
</summary>
</member>
<member name="P:FSharp.Compiler.IlxGen.IlxGenResults.topAssemblyAttrs">
<summary>
 The attributes for the assembly in F# form
</summary>
</member>
<member name="P:FSharp.Compiler.IlxGen.IlxGenResults.ilNetModuleAttrs">
<summary>
 The generated IL/ILX .NET module attributes
</summary>
</member>
<member name="P:FSharp.Compiler.IlxGen.IlxGenResults.ilAssemAttrs">
<summary>
 The generated IL/ILX assembly attributes
</summary>
</member>
<member name="P:FSharp.Compiler.IlxGen.IlxGenResults.ilTypeDefs">
<summary>
 The generated IL/ILX type definitions
</summary>
</member>
<member name="T:FSharp.Compiler.IlxGen.IlxGenResults">
<summary>
 The results of the ILX compilation of one fragment of an assembly
</summary>
</member>
<member name="P:FSharp.Compiler.IlxGen.IlxGenOptions.parallelIlxGenEnabled">
<summary>
 When set to true, the IlxGen will delay generation of method bodies and generate them later in parallel (parallelized across files)
</summary>
</member>
<member name="P:FSharp.Compiler.IlxGen.IlxGenOptions.alwaysCallVirt">
<summary>
 Indicates that, whenever possible, use callvirt instead of call
</summary>
</member>
<member name="P:FSharp.Compiler.IlxGen.IlxGenOptions.useReflectionFreeCodeGen">
<summary>
 Suppress ToString emit
</summary>
</member>
<member name="P:FSharp.Compiler.IlxGen.IlxGenOptions.isInteractiveItExpr">
<summary>
 Indicates the code generated is an interactive &apos;it&apos; expression. We generate a setter to allow clearing of the underlying
 storage, even though &apos;it&apos; is not logically mutable
</summary>
</member>
<member name="P:FSharp.Compiler.IlxGen.IlxGenOptions.isInteractive">
<summary>
 Indicates the code is being generated in FSI.EXE and is executed immediately after code generation
 This includes all interactively compiled code, including #load, definitions, and expressions
</summary>
</member>
<member name="P:FSharp.Compiler.IlxGen.IlxGenOptions.fsiMultiAssemblyEmit">
<summary>
 Is --multiemit enabled?
</summary>
</member>
<member name="P:FSharp.Compiler.IlxGen.IlxGenOptions.ilxBackend">
<summary>
 Indicates which backend we are generating code for
</summary>
</member>
<member name="P:FSharp.Compiler.IlxGen.IlxGenOptions.testFlagEmitFeeFeeAs100001">
<summary>
 A flag to help test emit of debug information
</summary>
</member>
<member name="P:FSharp.Compiler.IlxGen.IlxGenOptions.generateDebugSymbols">
<summary>
 Indicates if we are generating debug symbols or not
</summary>
</member>
<member name="P:FSharp.Compiler.IlxGen.IlxGenOptions.localOptimizationsEnabled">
<summary>
 Indicates if local optimizations are active
</summary>
</member>
<member name="P:FSharp.Compiler.IlxGen.IlxGenOptions.mainMethodInfo">
<summary>
 If this is set, then the last module becomes the &quot;main&quot; module
</summary>
</member>
<member name="P:FSharp.Compiler.IlxGen.IlxGenOptions.emitConstantArraysUsingStaticDataBlobs">
<summary>
 Indicates if static array data should be emitted using static blobs
</summary>
</member>
<member name="P:FSharp.Compiler.IlxGen.IlxGenOptions.workAroundReflectionEmitBugs">
<summary>
 Indicates if we should workaround old reflection emit bugs
</summary>
</member>
<member name="P:FSharp.Compiler.IlxGen.IlxGenOptions.generateFilterBlocks">
<summary>
 Indicates if we are generating filter blocks
</summary>
</member>
<member name="T:FSharp.Compiler.IlxGen.IlxGenBackend">
<summary>
 Indicates how the generated IL code is ultimately emitted
</summary>
</member>
<member name="M:FSharp.Compiler.IlxGen.IsFSharpValCompiledAsMethod(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.Val)">
<summary>
 Determine if an F#-declared value, method or function is compiled as a method.
</summary>
</member>
<member name="M:FSharp.Compiler.DependencyManager.AssemblyResolveHandler.#ctor(Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.DependencyManager.AssemblyResolutionProbe})">
<summary>
 Construct a new DependencyProvider
</summary>
</member>
<member name="M:FSharp.Compiler.DependencyManager.AssemblyResolveHandler.#ctor(FSharp.Compiler.DependencyManager.AssemblyResolutionProbe)">
<summary>
 Construct a new DependencyProvider
</summary>
</member>
<member name="T:FSharp.Compiler.DependencyManager.AssemblyResolveHandler">
<summary>
 Handle Assembly resolution
</summary>
</member>
<member name="T:FSharp.Compiler.DependencyManager.AssemblyResolutionProbe">
<summary>
 Signature for ResolutionProbe callback
 host implements this, it&apos;s job is to return a list of assembly paths to probe.
</summary>
</member>
<member name="M:FSharp.Compiler.DependencyManager.NativeDllResolveHandler.#ctor(Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.DependencyManager.NativeResolutionProbe})">
<summary>
 Construct a new NativeDllResolveHandler
</summary>
</member>
<member name="M:FSharp.Compiler.DependencyManager.NativeDllResolveHandler.#ctor(FSharp.Compiler.DependencyManager.NativeResolutionProbe)">
<summary>
 Construct a new NativeDllResolveHandler
</summary>
</member>
<member name="T:FSharp.Compiler.DependencyManager.NativeResolutionProbe">
<summary>
 Signature for Native library resolution probe callback
 host implements this, it&apos;s job is to return a list of package roots to probe.
</summary>
</member>
<member name="M:FSharp.Compiler.DependencyManager.DependencyProvider.TryFindDependencyManagerInPath(System.Collections.Generic.IEnumerable{System.String},System.String,FSharp.Compiler.DependencyManager.ResolvingErrorReport,System.String)">
<summary>
 TryFindDependencyManagerInPath - given a #r &quot;key:sometext&quot; go and find a DependencyManager that satisfies the key
</summary>
</member>
<member name="M:FSharp.Compiler.DependencyManager.DependencyProvider.TryFindDependencyManagerByKey(System.Collections.Generic.IEnumerable{System.String},System.String,FSharp.Compiler.DependencyManager.ResolvingErrorReport,System.String)">
<summary>
 Fetch a dependencymanager that supports a specific key
</summary>
</member>
<member name="M:FSharp.Compiler.DependencyManager.DependencyProvider.Resolve(FSharp.Compiler.DependencyManager.IDependencyManagerProvider,System.String,System.Collections.Generic.IEnumerable{System.Tuple{System.String,System.String}},FSharp.Compiler.DependencyManager.ResolvingErrorReport,System.String,System.String,System.String,System.String,System.String,System.Int32)">
<summary>
 Resolve reference for a list of package manager lines
</summary>
</member>
<member name="M:FSharp.Compiler.DependencyManager.DependencyProvider.GetRegisteredDependencyManagerHelpText(System.Collections.Generic.IEnumerable{System.String},System.String,FSharp.Compiler.DependencyManager.ResolvingErrorReport)">
<summary>
 Returns a formatted help messages for registered dependencymanagers for the host to present
</summary>
</member>
<member name="M:FSharp.Compiler.DependencyManager.DependencyProvider.CreatePackageManagerUnknownError(System.Collections.Generic.IEnumerable{System.String},System.String,System.String,FSharp.Compiler.DependencyManager.ResolvingErrorReport)">
<summary>
 Returns a formatted error message for the host to present
</summary>
</member>
<member name="M:FSharp.Compiler.DependencyManager.DependencyProvider.ClearResultsCache(System.Collections.Generic.IEnumerable{System.String},System.String,FSharp.Compiler.DependencyManager.ResolvingErrorReport)">
<summary>
 Clear the DependencyManager results caches
</summary>
</member>
<member name="M:FSharp.Compiler.DependencyManager.DependencyProvider.#ctor(FSharp.Compiler.DependencyManager.AssemblyResolutionProbe,FSharp.Compiler.DependencyManager.NativeResolutionProbe,System.Boolean)">
<summary>
 Construct a new DependencyProvider with managed and native resolution and specify caching
</summary>
</member>
<member name="M:FSharp.Compiler.DependencyManager.DependencyProvider.#ctor(FSharp.Compiler.DependencyManager.AssemblyResolutionProbe,FSharp.Compiler.DependencyManager.NativeResolutionProbe)">
<summary>
 Construct a new DependencyProvider with managed and native resolution
</summary>
</member>
<member name="M:FSharp.Compiler.DependencyManager.DependencyProvider.#ctor(FSharp.Compiler.DependencyManager.NativeResolutionProbe,System.Boolean)">
<summary>
 Construct a new DependencyProvider with only native resolution and specify caching
</summary>
</member>
<member name="M:FSharp.Compiler.DependencyManager.DependencyProvider.#ctor(FSharp.Compiler.DependencyManager.NativeResolutionProbe)">
<summary>
 Construct a new DependencyProvider with only native resolution
</summary>
</member>
<member name="M:FSharp.Compiler.DependencyManager.DependencyProvider.#ctor">
<summary>
 Construct a new DependencyProvider with no dynamic load handlers (only for compilation/analysis)
</summary>
</member>
<member name="T:FSharp.Compiler.DependencyManager.DependencyProvider">
<summary>
 Provides DependencyManagement functions.

 The class incrementally collects IDependencyManagerProvider, indexed by key, and
 queries them.  These are found and instantiated with respect to the compilerTools and outputDir
 provided each time the TryFindDependencyManagerByKey and TryFindDependencyManagerInPath are
 executed, which are assumed to be invariant over the lifetime of the DependencyProvider.
</summary>
</member>
<member name="T:FSharp.Compiler.DependencyManager.ErrorReportType">
<summary>
 Todo describe this API
</summary>
</member>
<member name="P:FSharp.Compiler.DependencyManager.IDependencyManagerProvider.Name">
<summary>
 Name of the dependency manager
</summary>
</member>
<member name="P:FSharp.Compiler.DependencyManager.IDependencyManagerProvider.Key">
<summary>
 Key that identifies the types of dependencies that this DependencyManager operates on
 E.g
     nuget: indicates that this DM is for nuget packages
     paket: indicates that this DM is for paket scripts, which manage nuget packages, github source dependencies etc ...
</summary>
</member>
<member name="P:FSharp.Compiler.DependencyManager.IDependencyManagerProvider.HelpMessages">
<summary>
 The help messages for this dependency manager instance
</summary>
</member>
<member name="M:FSharp.Compiler.DependencyManager.IDependencyManagerProvider.ResolveDependencies(System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.Tuple{System.String,System.String}},System.String,System.String,System.Int32)">
<summary>
 Resolve the dependencies, for the given set of arguments, go find the .dll references, scripts and additional include values.
</summary>
</member>
<member name="M:FSharp.Compiler.DependencyManager.IDependencyManagerProvider.ClearResultsCache">
<summary>
 Clear the results cache
</summary>
</member>
<member name="T:FSharp.Compiler.DependencyManager.IDependencyManagerProvider">
<summary>
 Wraps access to a DependencyManager implementation
</summary>
</member>
<member name="P:FSharp.Compiler.DependencyManager.IResolveDependenciesResult.Success">
<summary>
 Succeeded?
</summary>
</member>
<member name="P:FSharp.Compiler.DependencyManager.IResolveDependenciesResult.StdOut">
<summary>
 The resolution output log
</summary>
</member>
<member name="P:FSharp.Compiler.DependencyManager.IResolveDependenciesResult.StdError">
<summary>
 The resolution error log (process stderr)
</summary>
</member>
<member name="P:FSharp.Compiler.DependencyManager.IResolveDependenciesResult.SourceFiles">
<summary>
 The source code file paths
</summary>
</member>
<member name="P:FSharp.Compiler.DependencyManager.IResolveDependenciesResult.Roots">
<summary>
 The roots to package directories
     This points to the root of each located package.
     The layout of the package manager will be package manager specific.
     however, the dependency manager dll understands the nuget package layout
     and so if the package contains folders similar to the nuget layout then
     the dependency manager will be able to probe and resolve any native dependencies
     required by the nuget package.

 This path is also equivalent to
     #I @&quot;c:\somepath\to\packages\1.1.1\ResolvedPackage&quot;
</summary>
</member>
<member name="P:FSharp.Compiler.DependencyManager.IResolveDependenciesResult.Resolutions">
<summary>
 The resolution paths - the full paths to selected resolved dll&apos;s.
 In scripts this is equivalent to #r @&quot;c:\somepath\to\packages\ResolvedPackage\1.1.1\lib\netstandard2.0\ResolvedAssembly.dll&quot;
</summary>
</member>
<member name="T:FSharp.Compiler.DependencyManager.IResolveDependenciesResult">
<summary>
 The results of ResolveDependencies
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerConfig.TcConfigProvider.Constant(FSharp.Compiler.CompilerConfig.TcConfig)">
<summary>
 Get a TcConfigProvider which will return only the exact TcConfig.
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerConfig.TcConfigProvider.BasedOnMutableBuilder(FSharp.Compiler.CompilerConfig.TcConfigBuilder)">
<summary>
 Get a TcConfigProvider which will continue to respect changes in the underlying
 TcConfigBuilder rather than delivering snapshots.
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerConfig.TcConfigProvider">
<summary>
 Represents a computation to return a TcConfig. Normally this is just a constant immutable TcConfig,
 but for F# Interactive it may be based on an underlying mutable TcConfigBuilder.
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.TcConfig.noConditionalErasure">
<summary>
 Prevent erasure of conditional attributes and methods so tooling is able analyse them.
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.TcConfig.isInteractive">
<summary>
 If true, indicates all type checking and code generation is in the context of fsi.exe
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.TcConfig.internalTestSpanStackReferring">
<summary>
 if true - &apos;let mutable x = Span.Empty&apos;, the value &apos;x&apos; is a stack referring span. Used for internal testing purposes only until we get true stack spans.
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.TcConfig.indentationAwareSyntax">
<summary>
 Set if the user has explicitly turned indentation-aware syntax on/off
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.TcConfig.fsiMultiAssemblyEmit">
<summary>
 Indicates if F# Interactive is using single-assembly emit via Reflection.Emit, where internals are available.
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.TcConfig.assumeDotNetFramework">
<summary>
 Check if the primary assembly is mscorlib
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.TcConfig.applyLineDirectives">
<summary>
 Take &apos;#line&apos; into account? Defaults to true
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.TcConfig.GenerateSignatureData">
<summary>
 Indicates if the compilation will result in F# signature data resource in the generated binary
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.TcConfig.GenerateOptimizationData">
<summary>
 Indicates if the compilation will result in an F# optimization data resource in the generated binary
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerConfig.TcConfig.ResolveSourceFile(FSharp.Compiler.Text.Range,System.String,System.String)">
<summary>
 File system query based on TcConfig settings
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerConfig.TcConfig.MakePathAbsolute(System.String)">
<summary>
 File system query based on TcConfig settings
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerConfig.TcConfig.GetAvailableLoadedSources">
<summary>
 Get the loaded sources that exist and issue a warning for the ones that don&apos;t
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerConfig.TcConfig.CloneToBuilder">
<summary>
 Allow forking and subsequent modification of the TcConfig via a new TcConfigBuilder
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerConfig.TcConfig">
<summary>
 Immutable TcConfig, modifications are made via a TcConfigBuilder
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.TcConfigBuilder.applyLineDirectives">
<summary>
 Take &apos;#line&apos; into account? Defaults to true
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.TcConfigBuilder.noConditionalErasure">
<summary>
 Prevent erasure of conditional attributes and methods so tooling is able analyse them.
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.TcConfigBuilder.internalTestSpanStackReferring">
<summary>
 if true - &apos;let mutable x = Span.Empty&apos;, the value &apos;x&apos; is a stack referring span. Used for internal testing purposes only until we get true stack spans.
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.TcConfigBuilder.tryGetMetadataSnapshot">
<summary>
 A function to call to try to get an object that acts as a snapshot of the metadata section of a .NET binary,
 and from which we can read the metadata. Only used when metadataOnly=true.
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.TcConfigBuilder.isInteractive">
<summary>
 If true, indicates all type checking and code generation is in the context of fsi.exe
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.TcConfigBuilder.loadedSources">
<summary>
 Sources added into the build with #load
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.TcConfigBuilder.indentationAwareSyntax">
<summary>
 Set if the user has explicitly turned indentation-aware syntax on/off
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.TypeCheckingConfig.DumpGraph">
<summary>
 When using TypeCheckingMode.Graph, this flag determines whether the
 resolved file graph should be serialised as a Mermaid diagram into a file next to the output dll.
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerConfig.TypeCheckingConfig">
<summary>
 Some of the information dedicated to type-checking.
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerConfig.TypeCheckingMode.Graph">
<summary>
 Parallel type-checking that uses automated file-to-file dependency detection to construct a file graph processed in parallel.
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerConfig.TypeCheckingMode.Sequential">
<summary>
 Default mode where all source files are processed sequentially in compilation order.
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerConfig.TypeCheckingMode">
<summary>
 Determines the algorithm used for type-checking.
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerConfig.MetadataAssemblyGeneration.ReferenceOnly">
<summary>
 Includes F# signature and optimization metadata as resources in the emitting assembly.
 Only emits the assembly as a reference assembly.
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerConfig.MetadataAssemblyGeneration.ReferenceOut">
<summary>
 Includes F# signature and optimization metadata as resources in the emitting assembly.
 Implementation assembly will still be emitted normally, but will emit the reference assembly with the specified output path.
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerConfig.VersionFlag">
<summary>
 Represents the file or string used for the --version flag
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.IProjectReference.FileName">
<summary>
 The name of the assembly file generated by the project
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerConfig.IProjectReference.TryGetLogicalTimeStamp(FSharp.Compiler.CompilerConfig.TimeStampCache)">
<summary>
 Get the logical timestamp that would be the timestamp of the assembly file generated by the project.

 For project references this is maximum of the timestamps of all dependent files.
 The project is not actually built, nor are any assemblies read, but the timestamps for each dependent file
 are read via the FileSystem.  If the files don&apos;t exist, then a default timestamp is used.

 The operation returns None only if it is not possible to create an IncrementalBuilder for the project at all, e.g. if there
 are fatal errors in the options for the project.
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerConfig.IProjectReference.EvaluateRawContents">
<summary>
 Evaluate raw contents of the assembly file generated by the project.
 &apos;None&apos; may be returned if an in-memory view of the contents is, for some reason,
 not available.  In this case the on-disk view of the contents will be preferred.
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.IRawFSharpAssemblyData.ShortAssemblyName">
<summary>
 Get the short name for this assembly
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.IRawFSharpAssemblyData.ILScopeRef">
<summary>
 Get the identity of the assembly
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.IRawFSharpAssemblyData.ILAssemblyRefs">
<summary>
 Get the identities of the assemblies referenced by this assembly
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.IRawFSharpAssemblyData.HasMatchingFSharpSignatureDataAttribute">
<summary>
 Indicates if the assembly has an F# signature data attribute suitable for use with this version of F# tooling
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.IRawFSharpAssemblyData.HasAnyFSharpSignatureDataAttribute">
<summary>
 Indicates if the assembly has any F# signature data attribute
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerConfig.IRawFSharpAssemblyData.TryGetILModuleDef">
<summary>
 The raw IL module definition in the assembly, if any. This is not present for cross-project references
 in the language service
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerConfig.IRawFSharpAssemblyData.GetRawTypeForwarders">
<summary>
 Get the table of type forwarders in the assembly
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerConfig.IRawFSharpAssemblyData.GetRawFSharpSignatureData(FSharp.Compiler.Text.Range,System.String,System.String)">
<summary>
 Get the raw F# signature data in the assembly, if any
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerConfig.IRawFSharpAssemblyData.GetRawFSharpOptimizationData(FSharp.Compiler.Text.Range,System.String,System.String)">
<summary>
 Get the raw F# optimization data in the assembly, if any
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerConfig.IRawFSharpAssemblyData.GetInternalsVisibleToAttributes">
<summary>
 The raw list InternalsVisibleToAttribute attributes in the assembly
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerConfig.IRawFSharpAssemblyData.GetAutoOpenAttributes">
<summary>
 The raw list AutoOpenAttribute attributes in the assembly
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerConfig.IRawFSharpAssemblyData">
<summary>
 Represents a reference to an F# assembly. May be backed by a real assembly on disk (read by Abstract IL), or a cross-project
 reference in FSharp.Compiler.Service.
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.FSharpExperimentalFeaturesEnabledAutomatically">
<summary>
 Indicates whether experimental features should be enabled automatically
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.FSharpIndentationAwareSyntaxFileSuffixes">
<summary>
 File suffixes where #light is the default
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.FSharpScriptFileSuffixes">
<summary>
 Script file suffixes
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.FSharpImplFileSuffixes">
<summary>
 Implementation file suffixes
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerConfig.FSharpSigFileSuffixes">
<summary>
 Signature file suffixes
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerConfig.GetFSharpCoreLibraryName">
<summary>
 Get the name used for FSharp.Core
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerConfig">
<summary>
 The configuration of the compiler (TcConfig and TcConfigBuilder)
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerImports.TcImports.TryResolveAssemblyReference(Internal.Utilities.Library.CompilationThreadToken,FSharp.Compiler.CompilerConfig.AssemblyReference,FSharp.Compiler.CompilerImports.ResolveAssemblyReferenceMode)">
<summary>
 Try to resolve a referenced assembly based on TcConfig settings.
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerImports.TcImports.TryFindProviderGeneratedAssemblyByName(Internal.Utilities.Library.CompilationThreadToken,System.String)">
<summary>
 Try to find a provider-generated assembly
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerImports.TcImports.TryFindExistingFullyQualifiedPathBySimpleAssemblyName(System.String)">
<summary>
 Try to find the given assembly reference by simple name.  Used in magic assembly resolution.  Effectively does implicit
 unification of assemblies by simple assembly name.
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerImports.TcImports.TryFindExistingFullyQualifiedPathByExactAssemblyRef(FSharp.Compiler.AbstractIL.IL.ILAssemblyRef)">
<summary>
 Try to find the given assembly reference.
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerImports.TcImports.ResolveAssemblyReference(Internal.Utilities.Library.CompilationThreadToken,FSharp.Compiler.CompilerConfig.AssemblyReference,FSharp.Compiler.CompilerImports.ResolveAssemblyReferenceMode)">
<summary>
 Resolve a referenced assembly and report an error if the resolution fails.
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerImports.TcImports.ReportUnresolvedAssemblyReferences(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.CompilerConfig.UnresolvedAssemblyReference})">
<summary>
 Report unresolved references that also weren&apos;t consumed by any type providers.
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerImports.TcImports.GetCcusExcludingBase">
<summary>
 This excludes any framework imports (which may be shared between multiple builds)
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerImports.TcImports">
<summary>
 Represents a table of imported assemblies with their resolutions.
 Is a disposable object, but it is recommended not to explicitly call Dispose unless you absolutely know nothing will be using its contents after the disposal.
 Otherwise, simply allow the GC to collect this and it will properly call Dispose from the finalizer.
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerImports.TcAssemblyResolutions">
<summary>
 Tables of assembly resolutions
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerImports.ImportedAssembly">
<summary>
 Represents a resolved imported assembly
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerImports.ImportedBinary">
<summary>
 Represents a resolved imported binary
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerImports.AssemblyResolution.ilAssemblyRef">
<summary>
 Lazily populated ilAssemblyRef for this reference.
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerImports.AssemblyResolution.sysdir">
<summary>
 Whether or not this is an installed system assembly (for example, System.dll)
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerImports.AssemblyResolution.prepareToolTip">
<summary>
 Create the tooltip text for the assembly reference
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerImports.AssemblyResolution.resolvedPath">
<summary>
 Path to the resolvedFile
</summary>
</member>
<member name="P:FSharp.Compiler.CompilerImports.AssemblyResolution.originalReference">
<summary>
 The original reference to the assembly.
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerImports.RequireReferences(Internal.Utilities.Library.CompilationThreadToken,FSharp.Compiler.CompilerImports.TcImports,FSharp.Compiler.CheckBasics.TcEnv,System.String,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.CompilerImports.AssemblyResolution})">
<summary>
 Process a group of #r in F# Interactive.
 Adds the reference to the tcImports and add the ccu to the type checking environment.
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerImports.EncodeSignatureData(FSharp.Compiler.CompilerConfig.TcConfig,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTreeOps.Remap,FSharp.Compiler.TypedTree.CcuThunk,System.String,System.Boolean)">
<summary>
 Encode the F# interface data into a set of IL attributes and resources
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerImports.IsReflectedDefinitionsResource(FSharp.Compiler.AbstractIL.IL.ILResource)">
<summary>
 Determine if an IL resource attached to an F# assembly is an F# quotation data resource for reflected definitions
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerImports.IsOptimizationDataResourceB(FSharp.Compiler.AbstractIL.IL.ILResource)">
<summary>
 Determine if an IL resource attached to an F# assembly is an F# optimization data resource (data stream B)
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerImports.IsOptimizationDataResource(FSharp.Compiler.AbstractIL.IL.ILResource)">
<summary>
 Determine if an IL resource attached to an F# assembly is an F# optimization data resource
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerImports.IsSignatureDataResourceB(FSharp.Compiler.AbstractIL.IL.ILResource)">
<summary>
 Determine if an IL resource attached to an F# assembly is an F# signature data resource (data stream B)
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerImports.IsSignatureDataResource(FSharp.Compiler.AbstractIL.IL.ILResource)">
<summary>
 Determine if an IL resource attached to an F# assembly is an F# signature data resource
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerImports.MSBuildReferenceResolutionError">
<summary>
 This exception is an old-style way of reporting a diagnostic
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerImports.MSBuildReferenceResolutionWarning">
<summary>
 This exception is an old-style way of reporting a diagnostic
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerImports.AssemblyNotResolved">
<summary>
 This exception is an old-style way of reporting a diagnostic
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerImports">
<summary>
 Contains logic to coordinate assembly resolution and manage the TcImports table of referenced
 assemblies.
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerDiagnostics.FormattedDiagnostic">
<summary>
 Used internally and in LegacyHostedCompilerForTesting
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerDiagnostics.FormattedDiagnosticDetailedInfo">
<summary>
 Used internally and in LegacyHostedCompilerForTesting
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerDiagnostics.FormattedDiagnosticCanonicalInformation">
<summary>
 Used internally and in LegacyHostedCompilerForTesting
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerDiagnostics.FormattedDiagnosticLocation">
<summary>
 Used internally and in LegacyHostedCompilerForTesting
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerDiagnostics.CollectFormattedDiagnostics(FSharp.Compiler.CompilerConfig.TcConfig,FSharp.Compiler.Diagnostics.FSharpDiagnosticSeverity,FSharp.Compiler.DiagnosticsLogger.PhasedDiagnostic,System.Boolean)">
<summary>
 Used internally and in LegacyHostedCompilerForTesting
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerDiagnostics.SanitizeFileName(System.String,System.String)">
<summary>
 Remove &apos;implicitIncludeDir&apos; from a file name before output
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerDiagnostics.GetDiagnosticsLoggerFilteringByScopedPragmas(System.Boolean,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.ScopedPragma},FSharp.Compiler.Diagnostics.FSharpDiagnosticOptions,FSharp.Compiler.DiagnosticsLogger.DiagnosticsLogger)">
<summary>
 Get a diagnostics logger that filters the reporting of warnings based on scoped pragma information
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerDiagnostics.PhasedDiagnostic.WriteWithContext(FSharp.Compiler.DiagnosticsLogger.PhasedDiagnostic,System.IO.TextWriter,System.String,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.String}},FSharp.Compiler.CompilerConfig.TcConfig,FSharp.Compiler.Diagnostics.FSharpDiagnosticSeverity)">
<summary>
 Write extra context information for a diagnostic
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerDiagnostics.PhasedDiagnostic.Output(FSharp.Compiler.DiagnosticsLogger.PhasedDiagnostic,System.Text.StringBuilder,FSharp.Compiler.CompilerConfig.TcConfig,FSharp.Compiler.Diagnostics.FSharpDiagnosticSeverity)">
<summary>
 Output all of a diagnostic to a buffer, including range
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerDiagnostics.PhasedDiagnostic.AdjustSeverity(FSharp.Compiler.DiagnosticsLogger.PhasedDiagnostic,FSharp.Compiler.Diagnostics.FSharpDiagnosticOptions,FSharp.Compiler.Diagnostics.FSharpDiagnosticSeverity)">
<summary>
 Compute new severity according to the various diagnostics options
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerDiagnostics.PhasedDiagnostic.FormatCore(FSharp.Compiler.DiagnosticsLogger.PhasedDiagnostic,System.Boolean,System.Boolean)">
<summary>
 Format the core of the diagnostic as a string. Doesn&apos;t include the range information.
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerDiagnostics.PhasedDiagnostic.EagerlyFormatCore(FSharp.Compiler.DiagnosticsLogger.PhasedDiagnostic,System.Boolean)">
<summary>
 Eagerly format a PhasedDiagnostic return as a new PhasedDiagnostic requiring no formatting of types.
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerDiagnostics.PhasedDiagnostic.get_Number(FSharp.Compiler.DiagnosticsLogger.PhasedDiagnostic)">
<summary>
 Get the number associated with a diagnostic
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerDiagnostics.PhasedDiagnostic.get_Range(FSharp.Compiler.DiagnosticsLogger.PhasedDiagnostic)">
<summary>
 Get the location associated with a diagnostic
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerDiagnostics.InternalCommandLineOption">
<summary>
 This exception is an old-style way of reporting a diagnostic
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerDiagnostics.DeprecatedCommandLineOptionNoDescription">
<summary>
 This exception is an old-style way of reporting a diagnostic
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerDiagnostics.DeprecatedCommandLineOptionSuggestAlternative">
<summary>
 This exception is an old-style way of reporting a diagnostic
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerDiagnostics.DeprecatedCommandLineOptionForHtmlDoc">
<summary>
 This exception is an old-style way of reporting a diagnostic
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerDiagnostics.DeprecatedCommandLineOptionFull">
<summary>
 This exception is an old-style way of reporting a diagnostic
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerDiagnostics.HashDirectiveNotAllowedInNonScript">
<summary>
 This exception is an old-style way of reporting a diagnostic
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerDiagnostics.HashLoadedScriptConsideredSource">
<summary>
 This exception is an old-style way of reporting a diagnostic
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerDiagnostics.HashLoadedSourceHasIssues">
<summary>
 This exception is an old-style way of reporting a diagnostic
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerDiagnostics.HashReferenceNotAllowedInNonScript">
<summary>
 This exception is an old-style way of reporting a diagnostic
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerDiagnostics.HashIncludeNotAllowedInNonScript">
<summary>
 This exception is an old-style way of reporting a diagnostic
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerDiagnostics">
<summary>
 Contains logic to prepare, post-process, filter and emit compiler diagnostics
</summary>
</member>
<member name="T:FSharp.Compiler.GraphChecking.Finisher`3">
<summary>
 Callback that returns a previously calculated &apos;Result and updates &apos;State accordingly.
</summary>
</member>
<member name="T:FSharp.Compiler.GraphChecking.FilePairMap">
<summary>
 Helper class for mapping signature files to implementation files and vice versa.
</summary>
</member>
<member name="T:FSharp.Compiler.GraphChecking.QueryTrie">
<summary>
 A function for querying a Trie (the Trie is defined within the function&apos;s context)
</summary>
</member>
<member name="T:FSharp.Compiler.GraphChecking.QueryTrieNodeResult.NodeExposesData">
<summary>
 A node was found with one or more files that contain relevant definitions required for type-checking.
</summary>
</member>
<member name="T:FSharp.Compiler.GraphChecking.QueryTrieNodeResult.NodeDoesNotExposeData">
 <summary>A node was found but no file exposes data for the LongIdentifier in question.</summary>
 <example>
 This could happen if there is a single file with a top-level module `module A.B`,
 and we search for `A`.
 Although the `A` path exists in the Trie, it does not contain any relevant definitions (beyond itself).
 </example>
</member>
<member name="T:FSharp.Compiler.GraphChecking.QueryTrieNodeResult.NodeDoesNotExist">
<summary>
 No node was found for the path in the trie.
</summary>
</member>
<member name="T:FSharp.Compiler.GraphChecking.QueryTrieNodeResult">
<summary>
 Result of querying a Trie Node.
</summary>
</member>
<member name="T:FSharp.Compiler.GraphChecking.FileContent">
<summary>
 File identifiers and its content extract for dependency resolution
</summary>
</member>
<member name="T:FSharp.Compiler.GraphChecking.FileContentEntry.ModuleName">
<summary>
 A single identifier that could be the name of a module.
 Example use-case: `let x = nameof Foo` where `Foo` is a module.
</summary>
</member>
<member name="T:FSharp.Compiler.GraphChecking.FileContentEntry.NestedModule">
<summary>
 Being explicit about nested modules allows for easier reasoning what namespaces (paths) are open.
 For example we can limit the scope of an `OpenStatement` to symbols defined inside the nested module.
</summary>
</member>
<member name="T:FSharp.Compiler.GraphChecking.FileContentEntry.PrefixedIdentifier">
<summary>
 Any identifier that has more than one piece (LongIdent or SynLongIdent) in it.
 The last part of the identifier should not be included.
</summary>
</member>
<member name="T:FSharp.Compiler.GraphChecking.FileContentEntry.OpenStatement">
<summary>
 The `open X.Y.Z` syntax.
</summary>
</member>
<member name="T:FSharp.Compiler.GraphChecking.FileContentEntry.TopLevelNamespace">
<summary>
 Any toplevel namespace a file might have.
 In case a file has `module X.Y.Z`, then `X.Y` is considered to be the toplevel namespace
</summary>
</member>
<member name="T:FSharp.Compiler.GraphChecking.FileContentEntry">
<summary>
 A significant construct found in the syntax tree of a file.
 This construct needs to be processed in order to deduce potential links to other files in the project.
</summary>
</member>
<member name="P:FSharp.Compiler.GraphChecking.TrieNode.Children">
<summary>
 Child nodes
</summary>
</member>
<member name="P:FSharp.Compiler.GraphChecking.TrieNode.Current">
<summary>
 Information about this node.
</summary>
</member>
<member name="P:FSharp.Compiler.GraphChecking.TrieNode.Files">
<summary>
 Zero or more files that define the LongIdentifier represented by this node.
</summary>
</member>
<member name="T:FSharp.Compiler.GraphChecking.TrieNode">
<summary>
 A node in the Trie structure.
</summary>
</member>
<member name="P:FSharp.Compiler.GraphChecking.TrieNodeInfo.Namespace.filesDefiningNamespaceWithoutTypes">
<summary>
 Files that use this namespace but don&apos;t contain any types.
</summary>
</member>
<member name="P:FSharp.Compiler.GraphChecking.TrieNodeInfo.Namespace.filesThatExposeTypes">
<summary>
 Files that expose types that are part of this namespace.
</summary>
</member>
<member name="T:FSharp.Compiler.GraphChecking.TrieNodeInfo">
<summary>
 There is a subtle difference between a module and namespace.
 A namespace does not necessarily expose a set of dependent files.
 Only when the namespace exposes types that could later be inferred.
 Children of a namespace don&apos;t automatically depend on each other for that reason
</summary>
</member>
<member name="T:FSharp.Compiler.GraphChecking.FileInProject">
<summary>
 Combines the file name, index and parsed syntax tree of a file in a project.
</summary>
</member>
<member name="T:FSharp.Compiler.GraphChecking.LongIdentifier">
<summary>
 Represents one or more identifiers in the syntax tree.
 For example, `[ &quot;X&quot;; &quot;Y&quot;; &quot;Z&quot; ]` in `open X.Y.Z`
</summary>
</member>
<member name="T:FSharp.Compiler.GraphChecking.Identifier">
<summary>
 Represents the string value of a single identifier in the syntax tree.
 For example, `&quot;Hello&quot;` in `module Hello`.
</summary>
</member>
<member name="T:FSharp.Compiler.GraphChecking.FileName">
<summary>
 File name captured by ParsedInput.FileName.
</summary>
</member>
<member name="T:FSharp.Compiler.GraphChecking.FileIndex">
<summary>
 The index of a file inside a project.
</summary>
</member>
<member name="T:FSharp.Compiler.GraphChecking.Graph`1">
<summary>
 A Directed Acyclic Graph (DAG) of arbitrary nodes.
</summary>
</member>
<member name="M:FSharp.Compiler.GraphChecking.Graph.writeMermaidToFile(System.String,System.Collections.Generic.IReadOnlyDictionary{System.Tuple{System.Int32,System.String},System.Tuple{System.Int32,System.String}[]})">
<summary>
 Create a simple Mermaid graph and save it under the path specified.
</summary>
</member>
<member name="M:FSharp.Compiler.GraphChecking.Graph.serialiseToMermaid(System.Collections.Generic.IReadOnlyDictionary{System.Tuple{System.Int32,System.String},System.Tuple{System.Int32,System.String}[]})">
<summary>
 Create a simple Mermaid graph
</summary>
</member>
<member name="M:FSharp.Compiler.GraphChecking.Graph.print``1(System.Collections.Generic.IReadOnlyDictionary{``0,``0[]})">
<summary>
 Print the contents of the graph to the standard output.
</summary>
</member>
<member name="M:FSharp.Compiler.GraphChecking.Graph.reverse``1(System.Collections.Generic.IReadOnlyDictionary{``0,``0[]})">
<summary>
 Create a reverse of the graph.
</summary>
</member>
<member name="M:FSharp.Compiler.GraphChecking.Graph.subGraphFor``1(``0,System.Collections.Generic.IReadOnlyDictionary{``0,``0[]})">
<summary>
 Get a sub-graph of the graph containing only the nodes reachable from the given node.
</summary>
</member>
<member name="M:FSharp.Compiler.GraphChecking.Graph.transitive``1(System.Collections.Generic.IReadOnlyDictionary{``0,``0[]})">
<summary>
 Create a transitive closure of the graph in O(n^2) time (but parallelize it).
 The resulting graph contains edge A -&gt; C iff the input graph contains a (directed) non-zero length path from A to C.
</summary>
</member>
<member name="M:FSharp.Compiler.GraphChecking.Graph.nodes``1(System.Collections.Generic.IReadOnlyDictionary{``0,``0[]})">
<summary>
 Get all nodes of the graph.
</summary>
</member>
<member name="M:FSharp.Compiler.GraphChecking.Graph.make``1(System.Collections.Generic.IEnumerable{System.Tuple{``0,``0[]}})">
<summary>
 Build the graph.
</summary>
</member>
<member name="T:FSharp.Compiler.GraphChecking.Graph">
<summary>
 Functions for operating on the Graph type.
</summary>
</member>
<member name="M:FSharp.Compiler.GraphChecking.TrieMapping.mkTrie(FSharp.Compiler.GraphChecking.FileInProject[])">
<summary>
 Process all the files (in parallel) in a project to construct a Root TrieNode.
 When the project has signature files, the implementation counterparts will not be processed.
</summary>
</member>
<member name="M:FSharp.Compiler.GraphChecking.FileContentMapping.mkFileContent(FSharp.Compiler.GraphChecking.FileInProject)">
<summary>
 Extract the FileContentEntries from the ParsedInput of a file.
</summary>
</member>
<member name="M:FSharp.Compiler.GraphChecking.DependencyResolution.mkGraph(FSharp.Compiler.GraphChecking.FilePairMap,FSharp.Compiler.GraphChecking.FileInProject[])">
 <summary>
 Construct an approximate* dependency graph for files within a project, based on their ASTs.
 </summary>
 <param name="filePairs">Maps the index of a signature file with the index of its implementation counterpart and vice versa.</param>
 <param name="files">The files inside a project.</param>
 <returns>A tuple consisting of a dictionary of FileIndex (alias for int) and a Trie</returns>
 <remarks>
 <para>
 *The constructed graph is a supergraph of the "necessary" file dependency graph,
 ie. if file A is necessary to type-check file B, the resulting graph will contain edge B -> A.
 The opposite is not true, ie. if file A is not necessary to type-check file B, the resulting graph *might* contain edge B -> A.
 This is because the graph resolution algorithm has limited capability as it is based on ASTs alone.
 </para>
 <para>
 The file order is used by the resolution algorithm to remove edges not allowed by the language.
 Ie. if file B precedes file A, the resulting graph will not contain edge B -> A.
 Hence this function cannot, as it stands, be used to help create a "reasonable" file ordering for an unordered set of files.
 </para>
 </remarks>
</member>
<member name="M:FSharp.Compiler.GraphChecking.DependencyResolution.processOpenPath(FSharp.Compiler.GraphChecking.TrieNode,Microsoft.FSharp.Collections.FSharpList{System.String},FSharp.Compiler.GraphChecking.FileContentQueryState)">
 <summary>Process an open path (found in the ParsedInput) with a given FileContentQueryState.</summary>
 <remarks>This code is only used directly in unit tests.</remarks>
</member>
<member name="M:FSharp.Compiler.GraphChecking.DependencyResolution.queryTrie(FSharp.Compiler.GraphChecking.TrieNode,Microsoft.FSharp.Collections.FSharpList{System.String})">
 <summary>
 Query a TrieNode to find a certain path.
 </summary>
 <remarks>This code is only used directly in unit tests.</remarks>
</member>
<member name="T:FSharp.Compiler.GraphChecking.DependencyResolution">
<summary>
 Logic for constructing a file dependency graph for the purposes of parallel type-checking.
</summary>
</member>
<member name="T:FSharp.Compiler.GraphChecking.GraphProcessing.ProcessedNode`2">
<summary>
 An already processed node in the graph, with its result available
</summary>
</member>
<member name="T:FSharp.Compiler.GraphChecking.GraphProcessing.NodeInfo`1">
<summary>
 Information about the node in a graph, describing its relation with other nodes.
</summary>
</member>
<member name="M:FSharp.Compiler.GraphChecking.GraphProcessing.processGraph``2(System.Collections.Generic.IReadOnlyDictionary{``0,``0[]},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.Compiler.GraphChecking.GraphProcessing.ProcessedNode{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.GraphChecking.GraphProcessing.NodeInfo{``0},``1}},System.Threading.CancellationToken)">
 <summary>
 A generic method to generate results for a graph of work items in parallel.
 Processes leaves first, and after each node has been processed, schedules any now unblocked dependents.
 Returns a list of results, one per item.
 Uses the Thread Pool to schedule work.
 </summary>
 <param name="graph">Graph of work items</param>
 <param name="work">A function to generate results for a single item</param>
 <param name="parentCt">Cancellation token</param>
 <remarks>
 An alternative scheduling approach is to schedule N parallel tasks that process items from a BlockingCollection.
 My basic tests suggested it's faster, although confirming that would require more detailed testing.
 </remarks>
</member>
<member name="T:FSharp.Compiler.GraphChecking.GraphProcessing">
<summary>
 Parallel processing of graph of work items with dependencies
</summary>
</member>
<member name="P:FSharp.Compiler.ParseAndCheckInputs.TcState.TcEnvFromSignatures">
<summary>
 Get the typing environment implied by the set of signature files and/or inferred signatures of implementation files checked so far
</summary>
</member>
<member name="P:FSharp.Compiler.ParseAndCheckInputs.TcState.TcEnvFromImpls">
<summary>
 Get the typing environment implied by the set of implementation files checked so far
</summary>
</member>
<member name="P:FSharp.Compiler.ParseAndCheckInputs.TcState.CcuSig">
<summary>
 The inferred contents of the assembly, containing the signatures of all files.
</summary>
</member>
<member name="P:FSharp.Compiler.ParseAndCheckInputs.TcState.Ccu">
<summary>
 The CcuThunk for the current assembly being checked
</summary>
</member>
<member name="T:FSharp.Compiler.ParseAndCheckInputs.TcState">
<summary>
 Represents the incremental type checking state for a set of inputs
</summary>
</member>
<member name="T:FSharp.Compiler.ParseAndCheckInputs.ModuleNamesDict">
<summary>
 State used to de-deduplicate module names along a list of file names
</summary>
</member>
<member name="T:FSharp.Compiler.ParseAndCheckInputs.NodeToTypeCheck.ArtificialImplFile">
<summary>
 An artificial node that will add the earlier processed signature information to the TcEnvFromImpls.
 Dependents on this type of node will perceive that a file is known in both TcEnvFromSignatures and TcEnvFromImpls.
 Even though the actual implementation file was not type-checked.
</summary>
</member>
<member name="T:FSharp.Compiler.ParseAndCheckInputs.NodeToTypeCheck.PhysicalFile">
<summary>
 A real physical file in the current project.
 This can be either an implementation or a signature file.
</summary>
</member>
<member name="T:FSharp.Compiler.ParseAndCheckInputs.NodeToTypeCheck">
<summary>
 Auxiliary type for re-using signature information in TcEnvFromImpls.

 TcState has two typing environments: TcEnvFromSignatures &amp;&amp; TcEnvFromImpls
 When type checking a file, depending on the type (implementation or signature), it will use one of these typing environments (TcEnv).
 Checking a file will populate the respective TcEnv.

 When a file has a dependencies, the information of the signature file in case a pair (implementation file backed by a signature) will suffice to type-check that file.
 Example: if `B.fs` has a dependency on `A`, the information of `A.fsi` is enough for `B.fs` to type-check, on condition that information is available in the TcEnvFromImpls.
 We introduce a special ArtificialImplFile node in the graph to satisfy this. `B.fs -&gt; [ A.fsi ]` becomes `B.fs -&gt; [ ArtificialImplFile A ].
 The `ArtificialImplFile A` node will duplicate the signature information which A.fsi provided earlier.
 Processing a `ArtificialImplFile` node will add the information from the TcEnvFromSignatures to the TcEnvFromImpls.
 This means `A` will be known in both TcEnvs and therefor `B.fs` can be type-checked.
 By doing this, we can speed up the graph processing as type checking a signature file is less expensive than its implementation counterpart.

 When we need to actually type-check an implementation file backed by a signature, we cannot have the duplicate information of the signature file present in TcEnvFromImpls.
 Example `A.fs -&gt; [ A.fsi ]`. An implementation file always depends on its signature.
 Type-checking `A.fs` will add the actual information to TcEnvFromImpls and we do not depend on the `ArtificialImplFile A` for `A.fs`.

 In order to deal correctly with the `ArtificialImplFile` logic, we need to transform the resolved graph to contain the additional pair nodes.
 After we have type-checked the graph, we exclude the ArtificialImplFile nodes as they are not actual physical files in our project.
</summary>
</member>
<member name="M:FSharp.Compiler.ParseAndCheckInputs.CheckOneInputAndFinish(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Boolean},FSharp.Compiler.CompilerConfig.TcConfig,FSharp.Compiler.CompilerImports.TcImports,FSharp.Compiler.TcGlobals.TcGlobals,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.Ident}},FSharp.Compiler.NameResolution.TcResultsSink,FSharp.Compiler.ParseAndCheckInputs.TcState,FSharp.Compiler.Syntax.ParsedInput)">
<summary>
 Check a single input and finish the checking
</summary>
</member>
<member name="M:FSharp.Compiler.ParseAndCheckInputs.CheckClosedInputSet(Internal.Utilities.Library.CompilationThreadToken,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Boolean},FSharp.Compiler.CompilerConfig.TcConfig,FSharp.Compiler.CompilerImports.TcImports,FSharp.Compiler.TcGlobals.TcGlobals,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.Ident}},FSharp.Compiler.ParseAndCheckInputs.TcState,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.DiagnosticsLogger.PhasedDiagnostic,FSharp.Compiler.DiagnosticsLogger.PhasedDiagnostic},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.ParsedInput})">
<summary>
 Check a closed set of inputs
</summary>
</member>
<member name="M:FSharp.Compiler.ParseAndCheckInputs.CheckClosedInputSetFinish(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.CheckedImplFile},FSharp.Compiler.ParseAndCheckInputs.TcState)">
<summary>
 Finish the checking of a closed set of inputs
</summary>
</member>
<member name="M:FSharp.Compiler.ParseAndCheckInputs.CheckMultipleInputsFinish``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Compiler.CheckBasics.TcEnv,FSharp.Compiler.CheckDeclarations.TopAttribs,Microsoft.FSharp.Core.FSharpOption{``0},``1}},FSharp.Compiler.ParseAndCheckInputs.TcState)">
<summary>
 Finish the checking of multiple inputs
</summary>
</member>
<member name="M:FSharp.Compiler.ParseAndCheckInputs.CheckOneInput(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Boolean},FSharp.Compiler.CompilerConfig.TcConfig,FSharp.Compiler.CompilerImports.TcImports,FSharp.Compiler.TcGlobals.TcGlobals,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.Ident}},FSharp.Compiler.NameResolution.TcResultsSink,FSharp.Compiler.ParseAndCheckInputs.TcState,FSharp.Compiler.Syntax.ParsedInput)">
<summary>
 Check one input, returned as an Eventually computation
</summary>
</member>
<member name="M:FSharp.Compiler.ParseAndCheckInputs.SkippedImplFilePlaceholder(FSharp.Compiler.CompilerConfig.TcConfig,FSharp.Compiler.CompilerImports.TcImports,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.ParseAndCheckInputs.TcState,FSharp.Compiler.Syntax.ParsedInput)">
<summary>
 Returns partial type check result for skipped implementation files.
</summary>
</member>
<member name="M:FSharp.Compiler.ParseAndCheckInputs.GetInitialTcState(FSharp.Compiler.Text.Range,System.String,FSharp.Compiler.CompilerConfig.TcConfig,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.CompilerImports.TcImports,FSharp.Compiler.CheckBasics.TcEnv,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.TypedTree.OpenDeclaration})">
<summary>
 Get the initial type checking state for a set of inputs
</summary>
</member>
<member name="M:FSharp.Compiler.ParseAndCheckInputs.GetInitialTcEnv(System.String,FSharp.Compiler.Text.Range,FSharp.Compiler.CompilerConfig.TcConfig,FSharp.Compiler.CompilerImports.TcImports,FSharp.Compiler.TcGlobals.TcGlobals)">
<summary>
 Get the initial type checking environment including the loading of mscorlib/System.Core, FSharp.Core
 applying the InternalsVisibleTo in referenced assemblies and opening &apos;Checked&apos; if requested.
</summary>
</member>
<member name="M:FSharp.Compiler.ParseAndCheckInputs.ParseInputFiles(FSharp.Compiler.CompilerConfig.TcConfig,FSharp.Compiler.Lexhelp.LexResourceManager,Microsoft.FSharp.Collections.FSharpList{System.String},FSharp.Compiler.DiagnosticsLogger.DiagnosticsLogger,System.Boolean)">
<summary>
 Parse multiple input files from disk
</summary>
</member>
<member name="M:FSharp.Compiler.ParseAndCheckInputs.ParseOneInputFile(FSharp.Compiler.CompilerConfig.TcConfig,FSharp.Compiler.Lexhelp.LexResourceManager,System.String,System.Tuple{System.Boolean,System.Boolean},FSharp.Compiler.DiagnosticsLogger.DiagnosticsLogger,System.Boolean)">
<summary>
 Parse one input file
</summary>
</member>
<member name="M:FSharp.Compiler.ParseAndCheckInputs.ParseOneInputSourceText(FSharp.Compiler.CompilerConfig.TcConfig,FSharp.Compiler.Lexhelp.LexResourceManager,System.String,System.Tuple{System.Boolean,System.Boolean},FSharp.Compiler.DiagnosticsLogger.DiagnosticsLogger,FSharp.Compiler.Text.ISourceText)">
<summary>
 Parse one input source text
</summary>
</member>
<member name="M:FSharp.Compiler.ParseAndCheckInputs.ParseOneInputStream(FSharp.Compiler.CompilerConfig.TcConfig,FSharp.Compiler.Lexhelp.LexResourceManager,System.String,System.Tuple{System.Boolean,System.Boolean},FSharp.Compiler.DiagnosticsLogger.DiagnosticsLogger,System.Boolean,System.IO.Stream)">
<summary>
 Parse one input stream
</summary>
</member>
<member name="M:FSharp.Compiler.ParseAndCheckInputs.ApplyNoWarnsToTcConfig(FSharp.Compiler.CompilerConfig.TcConfig,FSharp.Compiler.Syntax.ParsedInput,System.String)">
<summary>
 Process the #nowarn in an input and integrate them into the TcConfig
</summary>
</member>
<member name="M:FSharp.Compiler.ParseAndCheckInputs.ApplyMetaCommandsFromInputToTcConfig(FSharp.Compiler.CompilerConfig.TcConfig,FSharp.Compiler.Syntax.ParsedInput,System.String,FSharp.Compiler.DependencyManager.DependencyProvider)">
<summary>
 Process all the #r, #I etc. in an input.  For non-scripts report warnings about ignored directives.
</summary>
</member>
<member name="M:FSharp.Compiler.ParseAndCheckInputs.ProcessMetaCommandsFromInput``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{FSharp.Compiler.Text.Range,System.String},``0}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{FSharp.Compiler.Text.Range,System.String,FSharp.Compiler.CompilerConfig.Directive},``0}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{FSharp.Compiler.Text.Range,System.String},Microsoft.FSharp.Core.Unit}},FSharp.Compiler.CompilerConfig.TcConfigBuilder,FSharp.Compiler.Syntax.ParsedInput,System.String,``0)">
<summary>
 A general routine to process hash directives
</summary>
</member>
<member name="M:FSharp.Compiler.ParseAndCheckInputs.ParseInput(Microsoft.FSharp.Core.FSharpFunc{Internal.Utilities.Text.Lexing.LexBuffer{System.Char},FSharp.Compiler.Parser.token},FSharp.Compiler.Diagnostics.FSharpDiagnosticOptions,FSharp.Compiler.DiagnosticsLogger.DiagnosticsLogger,Internal.Utilities.Text.Lexing.LexBuffer{System.Char},Microsoft.FSharp.Core.FSharpOption{System.String},System.String,System.Tuple{System.Boolean,System.Boolean},System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Parse a single input (A signature file or implementation file)
</summary>
</member>
<member name="M:FSharp.Compiler.ParseAndCheckInputs.DeduplicateParsedInputModuleName(Microsoft.FSharp.Collections.FSharpMap{System.String,Microsoft.FSharp.Collections.FSharpMap{System.String,FSharp.Compiler.Syntax.QualifiedNameOfFile}},FSharp.Compiler.Syntax.ParsedInput)">
<summary>
 Checks if a ParsedInput is using a module name that was already given and deduplicates the name if needed.
</summary>
</member>
<member name="T:FSharp.Compiler.ParseAndCheckInputs">
<summary>
 Contains logic to coordinate the parsing and checking of one or a group of files
</summary>
</member>
<member name="P:FSharp.Compiler.ScriptClosure.LoadClosure.LoadClosureRootFileDiagnostics">
<summary>
 Diagnostics seen while processing the compiler options implied root of closure
</summary>
</member>
<member name="P:FSharp.Compiler.ScriptClosure.LoadClosure.AllRootFileDiagnostics">
<summary>
 Diagnostics to show for root of closure (used by fsc.fs)
</summary>
</member>
<member name="P:FSharp.Compiler.ScriptClosure.LoadClosure.ResolutionDiagnostics">
<summary>
 Diagnostics seen while processing resolutions
</summary>
</member>
<member name="P:FSharp.Compiler.ScriptClosure.LoadClosure.NoWarns">
<summary>
 The #nowarns
</summary>
</member>
<member name="P:FSharp.Compiler.ScriptClosure.LoadClosure.OriginalLoadReferences">
<summary>
 The original #load references, including those that didn&apos;t resolve
</summary>
</member>
<member name="P:FSharp.Compiler.ScriptClosure.LoadClosure.Inputs">
<summary>
 The list of all sources in the closure with inputs when available, with associated parse errors and warnings
</summary>
</member>
<member name="P:FSharp.Compiler.ScriptClosure.LoadClosure.UnresolvedReferences">
<summary>
 The list of references that were not resolved during load closure.
</summary>
</member>
<member name="P:FSharp.Compiler.ScriptClosure.LoadClosure.SdkDirOverride">
<summary>
 Was the SDK directory override given?
</summary>
</member>
<member name="P:FSharp.Compiler.ScriptClosure.LoadClosure.UseDesktopFramework">
<summary>
 Whether we&apos;re decided to use .NET Framework analysis for this script
</summary>
</member>
<member name="P:FSharp.Compiler.ScriptClosure.LoadClosure.PackageReferences">
<summary>
 The resolved package references along with the ranges of the #r positions in each file.
</summary>
</member>
<member name="P:FSharp.Compiler.ScriptClosure.LoadClosure.References">
<summary>
 The resolved references along with the ranges of the #r positions in each file.
</summary>
</member>
<member name="P:FSharp.Compiler.ScriptClosure.LoadClosure.SourceFiles">
<summary>
 The source files along with the ranges of the #load positions in each file.
</summary>
</member>
<member name="M:FSharp.Compiler.ScriptClosure.LoadClosure.ComputeClosureOfScriptText(FSharp.Compiler.CodeAnalysis.LegacyReferenceResolver,System.String,System.String,FSharp.Compiler.Text.ISourceText,FSharp.Compiler.ScriptClosure.CodeContext,System.Boolean,System.Boolean,System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.String},FSharp.Compiler.Lexhelp.LexResourceManager,Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.CompilerConfig.TcConfigBuilder,Microsoft.FSharp.Core.Unit},System.Boolean,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.String,System.DateTime},Microsoft.FSharp.Core.FSharpOption{System.Tuple{System.Object,System.IntPtr,System.Int32}}},FSharp.Compiler.AbstractIL.ILBinaryReader.ReduceMemoryFlag,FSharp.Compiler.DependencyManager.DependencyProvider)">
<summary>
 Analyze a script text and find the closure of its references.
 Used from FCS, when editing a script file.
</summary>
</member>
<member name="M:FSharp.Compiler.ScriptClosure.LoadClosure.ComputeClosureOfScriptFiles(FSharp.Compiler.CompilerConfig.TcConfig,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,FSharp.Compiler.Text.Range}},FSharp.Compiler.ScriptClosure.CodeContext,FSharp.Compiler.Lexhelp.LexResourceManager,FSharp.Compiler.DependencyManager.DependencyProvider)">
<summary>
 Analyze a set of script files and find the closure of their references. The resulting references are then added to the given TcConfig.
 Used from fsi.fs and fsc.fs, for #load and command line.
</summary>
</member>
<member name="T:FSharp.Compiler.ScriptClosure">
<summary>
 Compute the load closure of a set of script files
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerOptions.OptionSpec">
<summary>
 The spec value describes the action of the argument,
 and whether it expects a following parameter.
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerOptions.ApplyCommandLineArgs(FSharp.Compiler.CompilerConfig.TcConfigBuilder,Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Apply args to TcConfigBuilder and return new list of source files
</summary>
</member>
<member name="M:FSharp.Compiler.CompilerOptions.ParseCompilerOptions(Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.CompilerOptions.CompilerOptionBlock},Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Parse and process a set of compiler options
</summary>
</member>
<member name="T:FSharp.Compiler.CompilerOptions">
<summary>
 Compiler Option Parser
</summary>
</member>
<member name="M:FSharp.Compiler.XmlDocFileWriter.XmlDocWriter.WriteXmlDocFile(FSharp.Compiler.TcGlobals.TcGlobals,System.String,FSharp.Compiler.TypedTree.CcuThunk,System.String)">
<summary>
 Writes the XmlDocSig property of each element (field, union case, etc)
 of the specified compilation unit to an XML document in a new text file.
</summary>
</member>
<member name="M:FSharp.Compiler.XmlDocFileWriter.XmlDocWriter.ComputeXmlDocSigs(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.CcuThunk)">
<summary>
 Writes the XML document signature to the XmlDocSig property of each
 element (field, union case, etc) of the specified compilation unit.
 The XmlDocSig is the unique identifier of this XmlDoc in the generated Xml documentation file.
 The full format is described at https://learn.microsoft.com/dotnet/csharp/language-reference/language-specification/documentation-comments#id-string-format
</summary>
</member>
<member name="T:FSharp.Compiler.StaticLinking">
<summary>
 Optional static linking of all DLLs that depend on the F# Library, plus other specified DLLs
</summary>
</member>
<member name="T:FSharp.Compiler.CreateILModule.StrongNameSigningInfo">
<summary>
 Represents the configuration settings used to perform strong-name signing
</summary>
</member>
<member name="M:FSharp.Compiler.CreateILModule.GetStrongNameSigner(FSharp.Compiler.CreateILModule.StrongNameSigningInfo)">
<summary>
 Get the object used to perform strong-name signing
</summary>
</member>
<member name="M:FSharp.Compiler.CreateILModule.ValidateKeySigningAttributes(FSharp.Compiler.CompilerConfig.TcConfig,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.CheckDeclarations.TopAttribs)">
<summary>
 Validate the attributes and configuration settings used to perform strong-name signing
</summary>
</member>
<member name="M:FSharp.Compiler.CreateILModule.GetStrongNameSigningInfo(System.Boolean,System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.Byte[]},Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Get the SigningInfo for specific values(delaysign, tcConfig.publicsign, signer, container)
</summary>
</member>
<member name="M:FSharp.Compiler.CreateILModule.MainModuleBuilder.ConvertProductVersionToILVersionInfo(System.String)">
<summary>
 For unit testing
</summary>
</member>
<member name="M:FSharp.Compiler.CreateILModule.MainModuleBuilder.ComputeProductVersion(Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{System.String}},FSharp.Compiler.AbstractIL.IL.ILVersionInfo)">
<summary>
 For unit testing
</summary>
</member>
<member name="M:FSharp.Compiler.CreateILModule.MainModuleBuilder.ComputeILFileVersion(Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{System.String}},FSharp.Compiler.AbstractIL.IL.ILVersionInfo)">
<summary>
 For unit testing
</summary>
</member>
<member name="M:FSharp.Compiler.CreateILModule.MainModuleBuilder.CreateMainModule``1(Internal.Utilities.Library.CompilationThreadToken,FSharp.Compiler.CompilerConfig.TcConfig,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.CompilerImports.TcImports,Microsoft.FSharp.Core.FSharpOption{``0},System.String,System.String,FSharp.Compiler.CheckDeclarations.TopAttribs,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILAttribute},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILResource},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.AbstractIL.IL.ILResource},FSharp.Compiler.IlxGen.IlxGenResults,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.AbstractIL.IL.ILVersionInfo},System.String,FSharp.Compiler.AbstractIL.IL.ILSecurityDecls)">
<summary>
 Put together all the pieces of information to create the overall IL ModuleDef for
 the generated assembly
</summary>
</member>
<member name="T:FSharp.Compiler.CreateILModule.AttributeHelpers">
<summary>
 Helpers for finding attributes
</summary>
</member>
<member name="M:FSharp.Compiler.Driver.DiagnosticsLoggerUpToMaxErrors.HandleTooManyErrors(System.String)">
<summary>
 Called when &apos;too many errors&apos; has occurred
</summary>
</member>
<member name="M:FSharp.Compiler.Driver.DiagnosticsLoggerUpToMaxErrors.HandleIssue(FSharp.Compiler.CompilerConfig.TcConfig,FSharp.Compiler.DiagnosticsLogger.PhasedDiagnostic,FSharp.Compiler.Diagnostics.FSharpDiagnosticSeverity)">
<summary>
 Called when a diagnostic occurs
</summary>
</member>
<member name="T:FSharp.Compiler.Driver.DiagnosticsLoggerUpToMaxErrors">
<summary>
 An diagnostic logger that reports errors up to some maximum, notifying the exiter when that maximum is reached

 Used only in LegacyHostedCompilerForTesting
</summary>
</member>
<member name="T:FSharp.Compiler.Driver.ConsoleLoggerProvider">
<summary>
 The default DiagnosticsLoggerProvider implementation, reporting messages to the Console up to the maxerrors maximum
</summary>
</member>
<member name="T:FSharp.Compiler.Driver.IDiagnosticsLoggerProvider">
<summary>
 DiagnosticLoggers can be sensitive to the TcConfig flags. During the checking
 of the flags themselves we have to create temporary loggers, until the full configuration is
 available.
</summary>
</member>
<member name="M:FSharp.Compiler.Driver.getParallelReferenceResolutionFromEnvironment">
<summary>
 Read the parallelReferenceResolution flag from environment variables
</summary>
</member>
<member name="M:FSharp.Compiler.Driver.CompileFromCommandLineArguments(Internal.Utilities.Library.CompilationThreadToken,System.String[],FSharp.Compiler.CodeAnalysis.LegacyReferenceResolver,System.Boolean,FSharp.Compiler.AbstractIL.ILBinaryReader.ReduceMemoryFlag,FSharp.Compiler.CompilerConfig.CopyFSharpCoreFlag,FSharp.Compiler.DiagnosticsLogger.Exiter,FSharp.Compiler.Driver.IDiagnosticsLoggerProvider,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.CompilerImports.TcImports,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Tuple{FSharp.Compiler.CompilerConfig.TcConfig,FSharp.Compiler.TcGlobals.TcGlobals,System.String,FSharp.Compiler.AbstractIL.IL.ILModuleDef},Microsoft.FSharp.Core.Unit}})">
<summary>
 The main (non-incremental) compilation entry point used by fsc.exe
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpXmlDoc.FromXmlFile">
<summary>
 Indicates that the XML for the documentation can be found in a .xml documentation file for the given DLL, using the given signature key
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpXmlDoc.FromXmlText">
<summary>
 The text for documentation for in-memory references.
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpXmlDoc.None">
<summary>
 No documentation is available
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpXmlDoc">
<summary>
 Describe a comment as either a block of text or a file+signature reference into an intellidoc file.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpOpenDeclaration.Types">
<summary>
 Types whose static members and nested types is opened with this declaration.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpOpenDeclaration.Target">
<summary>
 The syntactic target of the declaration
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpOpenDeclaration.Range">
<summary>
 Range of the open declaration.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpOpenDeclaration.Modules">
<summary>
 Modules or namespaces which is opened with this declaration.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpOpenDeclaration.LongId">
<summary>
 The syntactic target of the declaration
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpOpenDeclaration.IsOwnNamespace">
<summary>
 If it&apos;s `namespace Xxx.Yyy` declaration.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpOpenDeclaration.AppliedScope">
<summary>
 Scope in which open declaration is visible.
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpOpenDeclaration">
<summary>
 Represents open declaration in F# code.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAttribute.Range">
<summary>
 Get the range of the name of the attribute
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAttribute.NamedArguments">
<summary>
 The named arguments for the attribute
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAttribute.IsUnresolved">
<summary>
 Indicates if the attribute type is in an unresolved assembly
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAttribute.ConstructorArguments">
<summary>
 The arguments to the constructor for the attribute
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAttribute.AttributeType">
<summary>
 The type of the attribute
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpAttribute.IsAttribute``1">
<summary>
 Indicates if attribute matches the full name of the given type parameter
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpAttribute.Format(FSharp.Compiler.Symbols.FSharpDisplayContext)">
<summary>
 Format the attribute using the rules of the given display context
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpAttribute">
<summary>
 Represents a custom attribute attached to F# source code or a compiler .NET component
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpType.TypeDefinition">
<summary>
 Get the type definition for a type
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpType.IsUnresolved">
<summary>
 Indicates this is a named type in an unresolved assembly
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpType.IsTupleType">
<summary>
 Indicates if the type is a tuple type (reference or struct). The GenericArguments property returns the elements of the tuple type.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpType.IsStructTupleType">
<summary>
 Indicates if the type is a struct tuple type. The GenericArguments property returns the elements of the tuple type.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpType.IsNullAmbivalent">
<summary>
 Indicates this type is assumed to support the null value
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpType.IsMeasureType">
<summary>
 Indicates if the type is a measure type.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpType.IsGenericParameter">
<summary>
 Indicates if the type is a variable type, whether declared, generalized or an inference type parameter
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpType.IsFunctionType">
<summary>
 Indicates if the type is a function type. The GenericArguments property returns the domain and range of the function type.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpType.IsAnonRecordType">
<summary>
 Indicates if the type is an anonymous record type. The GenericArguments property returns the type instantiation of the anonymous record type
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpType.IsAbbreviation">
<summary>
 Indicates this is an abbreviation for another type
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpType.HasTypeDefinition">
<summary>
 Indicates if the type is constructed using a named entity, including array and byref types
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpType.HasNullAnnotation">
<summary>
 Indicates this type is known to have a null annotation
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpType.GenericParameter">
<summary>
 Get the generic parameter data for a generic parameter type
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpType.GenericArguments">
<summary>
 Get the generic arguments for a tuple type, a function type or a type constructed using a named entity
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpType.ErasedType">
<summary>
 Canonical form of the type with abbreviations, measures, and F# tuples and functions erased.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpType.BasicQualifiedName">
<summary>
 The fully qualified name of the type or module without strong assembly name.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpType.BaseType">
<summary>
 Get the base type, if any, taking into account the instantiation of this type
 if it is an instantiation of a generic type.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpType.AnonRecordTypeDetails">
<summary>
 Get the details of the anonymous record type.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpType.AllInterfaces">
<summary>
 Get all the interface implementations, by walking the type hierarchy, taking into account the instantiation of this type
 if it is an instantiation of a generic type.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpType.AbbreviatedType">
<summary>
 Get the type for which this is an abbreviation
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpType.StripAbbreviations">
<summary>
 Strip any outer abbreviations from the type
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpType.Prettify(System.Collections.Generic.IList{System.Collections.Generic.IList{FSharp.Compiler.Symbols.FSharpParameter}},FSharp.Compiler.Symbols.FSharpParameter)">
<summary>
 Adjust the types in a group of curried parameters and return type by removing any occurrences of type inference variables, replacing them
 systematically with lower-case type inference variables such as &lt;c&gt;&apos;a&lt;/c&gt;.
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpType.Prettify(System.Collections.Generic.IList{System.Collections.Generic.IList{FSharp.Compiler.Symbols.FSharpParameter}})">
<summary>
 Adjust the types in a group of curried parameters by removing any occurrences of type inference variables, replacing them
 systematically with lower-case type inference variables such as &lt;c&gt;&apos;a&lt;/c&gt;.
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpType.Prettify(System.Collections.Generic.IList{FSharp.Compiler.Symbols.FSharpParameter})">
<summary>
 Adjust the types in a group of parameters by removing any occurrences of type inference variables, replacing them
 systematically with lower-case type inference variables such as &lt;c&gt;&apos;a&lt;/c&gt;.
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpType.Prettify(FSharp.Compiler.Symbols.FSharpParameter)">
<summary>
 Adjust the type in a single parameter by removing any occurrences of type inference variables, replacing them
 systematically with lower-case type inference variables such as &lt;c&gt;&apos;a&lt;/c&gt;.
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpType.Prettify(System.Collections.Generic.IList{FSharp.Compiler.Symbols.FSharpType})">
<summary>
 Adjust a group of types by removing any occurrences of type inference variables, replacing them
 systematically with lower-case type inference variables such as &lt;c&gt;&apos;a&lt;/c&gt;.
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpType.Prettify(FSharp.Compiler.Symbols.FSharpType)">
<summary>
 Adjust the type by removing any occurrences of type inference variables, replacing them
 systematically with lower-case type inference variables such as &lt;c&gt;&apos;a&lt;/c&gt;.
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpType.Instantiate(Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Compiler.Symbols.FSharpGenericParameter,FSharp.Compiler.Symbols.FSharpType}})">
<summary>
 Instantiate generic type parameters in a type
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpType.FormatWithConstraints(FSharp.Compiler.Symbols.FSharpDisplayContext)">
<summary>
 Format the type using the rules of the given display context
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpType.FormatLayoutWithConstraints(FSharp.Compiler.Symbols.FSharpDisplayContext)">
<summary>
 Format the type - with constraints - using the rules of the given display context
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpType.FormatLayout(FSharp.Compiler.Symbols.FSharpDisplayContext)">
<summary>
 Format the type using the rules of the given display context
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpType.Format(FSharp.Compiler.Symbols.FSharpDisplayContext)">
<summary>
 Format the type using the rules of the given display context, skipping type constraints
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpType.#ctor(FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.TypedTree.CcuThunk,FSharp.Compiler.TypedTree.ModuleOrNamespaceType,FSharp.Compiler.CompilerImports.TcImports,FSharp.Compiler.TypedTree.TType)">
<summary>
 Internal use only. Create a ground type.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpActivePatternGroup.OverallType">
<summary>
 Get the type indicating signature of the active pattern
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpActivePatternGroup.Names">
<summary>
 The names of the active pattern cases
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpActivePatternGroup.Name">
<summary>
 The whole group name
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpActivePatternGroup.IsTotal">
<summary>
 Indicate this is a total active pattern
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpActivePatternGroup.DeclaringEntity">
<summary>
 Try to get the entity in which the active pattern is declared
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpActivePatternGroup">
<summary>
 Represents all cases within an active pattern
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpActivePatternCase.XmlDocSig">
<summary>
 XML documentation signature for the active pattern case, used for .xml file lookup for compiled code
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpActivePatternCase.XmlDoc">
<summary>
 Get the XML documentation for the entity
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpActivePatternCase.Name">
<summary>
 The name of the active pattern case
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpActivePatternCase.Index">
<summary>
 Index of the case in the pattern group
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpActivePatternCase.Group">
<summary>
 The group of active pattern cases this belongs to
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpActivePatternCase.DeclarationLocation">
<summary>
 The location of declaration of the active pattern case
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpActivePatternCase">
<summary>
 A subtype of FSharpSymbol that represents a single case within an active pattern
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpParameter.Type">
<summary>
 The declared or inferred type of the parameter
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpParameter.Name">
<summary>
 The optional name of the parameter
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpParameter.IsParamArrayArg">
<summary>
 Indicate this is a param array argument
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpParameter.IsOutArg">
<summary>
 Indicate this is an out argument
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpParameter.IsOptionalArg">
<summary>
 Indicate this is an optional argument
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpParameter.IsInArg">
<summary>
 Indicate this is an in argument
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpParameter.DeclarationLocation">
<summary>
 The declaration location of the parameter
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpParameter.Attributes">
<summary>
 The declared attributes of the parameter
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpParameter">
<summary>
 A subtype of FSharpSymbol that represents a parameter
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.XmlDocSig">
<summary>
 XML documentation signature for the value, used for .xml file lookup for compiled code
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.XmlDoc">
<summary>
 Get the XML documentation for the entity
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.SetterMethod">
<summary>
 Get an associated setter method of the property
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.LogicalName">
<summary>
 Get the logical name of the member
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.LiteralValue">
<summary>
 Indicates if this is a [&lt;Literal&gt;] value, and if so what value? (may be null)
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsValue">
<summary>
 Indicated if this is a value
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsValCompiledAsMethod">
<summary>
 Indicated if this is a value compiled to a method
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsUnresolved">
<summary>
 Indicates if the member, function or value is in an unresolved assembly
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsUnionCaseTester">
<summary>
 Indicates if the property or getter method is part of a IsABC union case tester implied by a union case definition
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsTypeFunction">
<summary>
 Indicates if this is an F# type function
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsReferencedValue">
<summary>
 Indicates if this is a value that has been referenced
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsRefCell">
<summary>
 Indicates if this is a ref cell
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsPropertySetterMethod">
<summary>
 Indicates if this is a setter method for a property, or a use of a property in setter mode
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsPropertyGetterMethod">
<summary>
 Indicates if this is a getter method for a property, or a use of a property in getter mode
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsProperty">
<summary>
 Indicates if this is a property member
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsOverrideOrExplicitInterfaceImplementation">
<summary>
 Indicates if this is an &apos;override&apos;, &apos;default&apos; or an explicit implementation of an interface member
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsMutable">
<summary>
 Indicates if this is a mutable value
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsModuleValueOrMember">
<summary>
 Indicates if this is a module or member value
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsMethod">
<summary>
 Indicates if this is a method member
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsMemberThisValue">
<summary>
 Indicates if this is the &quot;x&quot; in &quot;member x.M = ...&quot;
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsMember">
<summary>
 Indicates if this is a member, including extension members?
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsInstanceMemberInCompiledCode">
<summary>
 Indicates if this is an instance member in compiled code.

 Explanatory note: some members such as IsNone and IsSome on types with UseNullAsTrueValue appear
 as instance members in F# code but are compiled as static members.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsInstanceMember">
<summary>
 Indicates if this is an instance member, when seen from F#?
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsImplicitConstructor">
<summary>
 Indicates if this is an implicit constructor?
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsFunction">
<summary>
 Indicated if this is a function
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsExtensionMember">
<summary>
 Indicates if this is an extension member?
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsExplicitInterfaceImplementation">
<summary>
 Indicates if this is an explicit implementation of an interface member
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsEventRemoveMethod">
<summary>
 Indicates if this is a remove method for an event
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsEventAddMethod">
<summary>
 Indicates if this is an add method for an event
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsEvent">
<summary>
 Indicates if this is an event member
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsDispatchSlot">
<summary>
 Indicates if this is an abstract member?
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsConstructorThisValue">
<summary>
 Indicates if this is the &quot;x&quot; in &quot;type C() as x = ...&quot;
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsConstructor">
<summary>
 Indicates if this is a constructor.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsCompilerGenerated">
<summary>
 Indicates if this is a compiler generated value
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsBaseValue">
<summary>
 Indicates if this is &quot;base&quot; in &quot;base.M(...)&quot;
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.IsActivePattern">
<summary>
 Indicates if this value or member is an F# active pattern
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.InlineAnnotation">
<summary>
 Get a result indicating if this is a must-inline value
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.ImplementedAbstractSignatures">
<summary>
 Gets the list of the abstract slot signatures implemented by the member
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.HasSignatureFile">
<summary>
 Indicates if the value has a signature file counterpart
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.HasSetterMethod">
<summary>
 Indicates if this is a property and there exists an associated setter method
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.HasGetterMethod">
<summary>
 Indicates if this is a property and there exists an associated getter method
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.GetterMethod">
<summary>
 Get an associated getter method of the property
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.GenericParameters">
<summary>
 Get the typars of the member, function or value
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.FullTypeSafe">
<summary>
 Safe version of `FullType`.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.FullType">
<summary>
 Get the full type of the member, function or value when used as a first class value
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.EventRemoveMethod">
<summary>
 Get an associated remove method of an event
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.EventIsStandard">
<summary>
 Indicate if an event can be considered to be a property for the F# type system of type IEvent or IDelegateEvent.
 In this case ReturnParameter will have a type corresponding to the property type.  For
 non-standard events, ReturnParameter will have a type corresponding to the delegate type.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.EventForFSharpProperty">
<summary>
 Gets the event symbol implied by the use of a property,
 for the case where the property is actually an F#-declared CLIEvent.

 Uses of F#-declared events are considered to be properties as far as the language specification
 and this API are concerned.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.EventDelegateType">
<summary>
 Get an associated delegate type of an event
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.EventAddMethod">
<summary>
 Get an associated add method of an event
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.DisplayName">
<summary>
 Get the name as presented in F# error messages and documentation
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.DeclaringEntity">
<summary>
 Get the enclosing entity for the definition
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.DeclarationLocation">
<summary>
 Get the declaration location of the member, function or value
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.CurriedParameterGroups">
 <summary>List of list of parameters, where each nested item represents a defined parameter</summary>
 <remarks>
 Typically, there is only one nested list.
 However, code such as 'f (a, b) (c, d)' contains two groups, each with two parameters.
 In that example, there is a list made up of two lists, each with a parameter.
 </remarks>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.CompiledName">
<summary>
 Get the member name in compiled code
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.Attributes">
<summary>
 Custom attributes attached to the value. These contain references to other values (i.e. constructors in types). Mutable to fixup
 these value references after copying a collection of values.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.ApparentEnclosingEntity">
<summary>
 Get the logical enclosing entity, which for an extension member is type being extended
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.Accessibility">
<summary>
 Get the accessibility information for the member, function or value
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.TryGetFullDisplayName">
<summary>
 Full name with last part replaced with display name.
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.TryGetFullCompiledOperatorNameIdents">
<summary>
 Full operator compiled name.
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.GetWitnessPassingInfo">
<summary>
 Check if this method has an entrypoint that accepts witness arguments and if so return
 the name of that entrypoint and information about the additional witness arguments
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.GetValSignatureText(FSharp.Compiler.Symbols.FSharpDisplayContext,FSharp.Compiler.Text.Range)">
<summary>
 Get the signature text to include this Symbol into an existing signature file.
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.GetReturnTypeLayout(FSharp.Compiler.Symbols.FSharpDisplayContext)">
<summary>
 Format the type using the rules of the given display context
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.GetOverloads(System.Boolean)">
 <summary>Gets the overloads for the current method.</summary>

 <params>
   <param name="matchParameterNumber">Indicates whether to filter the overloads to match the number of parameters in the current symbol</param>
 </params>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue.FormatLayout(FSharp.Compiler.Symbols.FSharpDisplayContext)">
<summary>
 Format the type using the rules of the given display context
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue">
<summary>
 A subtype of F# symbol that represents an F# method, property, event, function or value, including extension members.
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpInlineAnnotation.AggressiveInline">
<summary>
 Indicates the value is aggressively inlined by the .NET runtime
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpInlineAnnotation.NeverInline">
<summary>
 Indicates the value is never inlined
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpInlineAnnotation.OptionalInline">
<summary>
 Indicates the value is optionally inlined
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpInlineAnnotation.AlwaysInline">
<summary>
 Indicates the value is always inlined in statically compiled code
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterConstraint.SimpleChoices">
<summary>
 Gets further information about a choice constraint
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterConstraint.MemberConstraintData">
<summary>
 Gets further information about a member constraint
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterConstraint.IsUnmanagedConstraint">
<summary>
 Indicates a constraint that a type is an unmanaged type
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterConstraint.IsSupportsNullConstraint">
<summary>
 Indicates a constraint that a type has a &apos;null&apos; value
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterConstraint.IsSimpleChoiceConstraint">
<summary>
 Indicates a constraint that is a type is a simple choice between one of the given ground types. Used by printf format strings.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterConstraint.IsRequiresDefaultConstructorConstraint">
<summary>
 Indicates a constraint that a type has a parameterless constructor
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterConstraint.IsReferenceTypeConstraint">
<summary>
 Indicates a constraint that a type is a reference type
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterConstraint.IsNotSupportsNullConstraint">
<summary>
 Indicates a constraint that a type doesn&apos;t support nullness
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterConstraint.IsNonNullableValueTypeConstraint">
<summary>
 Indicates a constraint that a type is a non-Nullable value type
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterConstraint.IsMemberConstraint">
<summary>
 Indicates a constraint that a type has a member with the given signature
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterConstraint.IsEqualityConstraint">
<summary>
 Indicates a constraint that a type supports F# generic equality
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterConstraint.IsEnumConstraint">
<summary>
 Indicates a constraint that a type is an enum with the given underlying
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterConstraint.IsDelegateConstraint">
<summary>
 Indicates a constraint that a type is a delegate from the given tuple of args to the given return type
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterConstraint.IsDefaultsToConstraint">
<summary>
 Indicates a default value for an inference type variable should it be neither generalized nor solved
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterConstraint.IsComparisonConstraint">
<summary>
 Indicates a constraint that a type supports F# generic comparison
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterConstraint.IsCoercesToConstraint">
<summary>
 Indicates a constraint that a type is a subtype of the given type
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterConstraint.IsAllowsRefStructConstraint">
<summary>
 An anti-constraint indicating that ref structs (e.g. Span&lt;&gt;) are allowed here
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterConstraint.EnumConstraintTarget">
<summary>
 Gets further information about an enumeration constraint
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterConstraint.DelegateConstraintData">
<summary>
 Gets further information about a delegate constraint
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterConstraint.DefaultsToConstraintData">
<summary>
 Gets further information about a defaults-to constraint
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterConstraint.CoercesToTarget">
<summary>
 Gets further information about a coerces-to constraint
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpGenericParameterConstraint">
<summary>
 Represents a constraint on a generic type parameter
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterDefaultsToConstraint.DefaultsToTarget">
<summary>
 Get the default type associated with the &apos;defaults to&apos; constraint
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterDefaultsToConstraint.DefaultsToPriority">
<summary>
 Get the priority off the &apos;defaults to&apos; constraint
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpGenericParameterDefaultsToConstraint">
<summary>
 Represents further information about a &apos;defaults to&apos; constraint on a generic type parameter
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterDelegateConstraint.DelegateTupledArgumentType">
<summary>
 Get the tupled argument type required by the constraint
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterDelegateConstraint.DelegateReturnType">
<summary>
 Get the return type required by the constraint
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpGenericParameterDelegateConstraint">
<summary>
 Represents further information about a delegate constraint on a generic type parameter
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterMemberConstraint.MemberSources">
<summary>
 Get the types that may be used to satisfy the constraint
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterMemberConstraint.MemberReturnType">
<summary>
 Get the return type of the method required by the constraint
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterMemberConstraint.MemberName">
<summary>
 Get the name of the method required by the constraint
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterMemberConstraint.MemberIsStatic">
<summary>
 Indicates if the method required by the constraint must be static
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameterMemberConstraint.MemberArgumentTypes">
<summary>
 Get the argument types of the method required by the constraint
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpGenericParameterMemberConstraint">
<summary>
 Represents further information about a member constraint on a generic type parameter
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpStaticParameter.Range">
<summary>
 Get the range of the construct
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpStaticParameter.Name">
<summary>
 Get the name of the static parameter
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpStaticParameter.Kind">
<summary>
 Get the kind of the static parameter
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpStaticParameter.IsOptional">
<summary>
 Indicates if the static parameter is optional
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpStaticParameter.DefaultValue">
<summary>
 Get the default value for the static parameter
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpStaticParameter.DeclarationLocation">
<summary>
 Get the declaration location of the static parameter
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpStaticParameter">
<summary>
 A subtype of FSharpSymbol that represents a static parameter to an F# type provider
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameter.XmlDoc">
<summary>
 Get the XML documentation for the entity
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameter.Name">
<summary>
 Get the name of the generic parameter
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameter.IsSolveAtCompileTime">
<summary>
 Indicates if this is a statically resolved type variable
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameter.IsMeasure">
<summary>
 Indicates if this is a measure variable
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameter.IsCompilerGenerated">
<summary>
 Indicates if this is a compiler generated type parameter
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameter.DeclarationLocation">
<summary>
 Get the range of the generic parameter
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameter.Constraints">
<summary>
 Get the declared or inferred constraints for the type parameter
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpGenericParameter.Attributes">
<summary>
 Get the declared attributes of the type parameter.
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpGenericParameter">
<summary>
 A subtype of FSharpSymbol that represents a generic parameter for an FSharpSymbol
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpAccessibilityRights">
<summary>
 Represents the rights of a compilation to access symbols
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpField.XmlDocSig">
<summary>
 Get the XML documentation signature for .xml file lookup for the field, used for .xml file lookup for compiled code
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpField.XmlDoc">
<summary>
 Get the XML documentation for the entity
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpField.PropertyAttributes">
<summary>
 Get the attributes attached to generated property
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpField.Name">
<summary>
 Get the name of the field
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpField.LiteralValue">
<summary>
 Get the default initialization info, for static literals
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpField.IsVolatile">
<summary>
 Indicates if the field is declared volatile
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpField.IsUnresolved">
<summary>
 Indicates if the record field is for a type in an unresolved assembly
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpField.IsUnionCaseField">
<summary>
 Indicates if the field is declared in a union case
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpField.IsStatic">
<summary>
 Indicates a static field
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpField.IsNameGenerated">
<summary>
 Indicates if the field name was generated by compiler (e.g. ItemN names in union cases and DataN in exceptions).
 This API returns true for source defined symbols only.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpField.IsMutable">
<summary>
 Indicates if the field is declared &apos;static&apos;
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpField.IsLiteral">
<summary>
 Indicates if the field has a literal value
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpField.IsDefaultValue">
<summary>
 Indicates if the field declared is declared &apos;DefaultValue&apos;
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpField.IsCompilerGenerated">
<summary>
 Indicates a compiler generated field, not visible to Intellisense or name resolution
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpField.IsAnonRecordField">
<summary>
 Is this a field from an anonymous record type?
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpField.FieldType">
<summary>
 Get the type of the field, w.r.t. the generic parameters of the enclosing type constructor
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpField.FieldAttributes">
<summary>
 Get the attributes attached to generated field
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpField.DeclaringUnionCase">
<summary>
 Returns the declaring union case symbol
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpField.DeclaringEntity">
<summary>
 Get the declaring entity of this field, if any. Fields from anonymous types do not have a declaring entity
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpField.DeclarationLocation">
<summary>
 Get the declaration location of the field
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpField.AnonRecordFieldDetails">
<summary>
 If the field is from an anonymous record type then get the details of the field including the index in the sorted array of fields
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpField.Accessibility">
<summary>
  Indicates if the declared visibility of the field, not taking signatures into account
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpField">
<summary>
 A subtype of FSharpSymbol that represents a record or union case field as seen by the F# language
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAnonRecordTypeDetails.SortedFieldNames">
<summary>
 The sorted labels of the anonymous type
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAnonRecordTypeDetails.EnclosingCompiledTypeNames">
<summary>
 Names of any enclosing types of the compiled form of the anonymous type (if the anonymous type was defined as a nested type)
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAnonRecordTypeDetails.CompiledName">
<summary>
 The name of the compiled form of the anonymous type
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAnonRecordTypeDetails.Assembly">
<summary>
 The assembly where the compiled form of the anonymous type is defined
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpAnonRecordTypeDetails">
<summary>
 A subtype of FSharpSymbol that represents a record or union case field as seen by the F# language
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpUnionCase.XmlDocSig">
<summary>
 Get the XML documentation signature for .xml file lookup for the union case, used for .xml file lookup for compiled code
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpUnionCase.XmlDoc">
<summary>
 Get the XML documentation for the entity
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpUnionCase.ReturnType">
<summary>
 Get the type constructed by the case. Normally exactly the type of the enclosing type, sometimes an abbreviation of it
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpUnionCase.Name">
<summary>
 Get the name of the union case
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpUnionCase.IsUnresolved">
<summary>
 Indicates if the union case is for a type in an unresolved assembly
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpUnionCase.HasFields">
<summary>
 Indicates if the union case has field definitions
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpUnionCase.Fields">
<summary>
 Get the data carried by the case.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpUnionCase.DeclaringEntity">
<summary>
 Get the declaring entity of the case
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpUnionCase.DeclarationLocation">
<summary>
 Get the range of the name of the case
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpUnionCase.CompiledName">
<summary>
 Get the name of the case in generated IL code
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpUnionCase.Attributes">
<summary>
 Get the attributes for the case, attached to the generated static method to make instances of the case
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpUnionCase.Accessibility">
<summary>
  Indicates if the declared visibility of the union constructor, not taking signatures into account
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpUnionCase">
<summary>
 A subtype of FSharpSymbol that represents a union case as seen by the F# language
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAbstractSignature.Name">
<summary>
 Get the name of the abstract slot
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAbstractSignature.MethodGenericParameters">
<summary>
 Get the generic arguments of the abstract slot
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAbstractSignature.DeclaringTypeGenericParameters">
<summary>
 Get the generic arguments of the type defining the abstract slot
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAbstractSignature.DeclaringType">
<summary>
 Get the declaring type of the abstract slot
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAbstractSignature.AbstractReturnType">
<summary>
 Get the return type of the abstract slot
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAbstractSignature.AbstractArguments">
<summary>
 Get the arguments of the abstract slot
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpAbstractSignature">
<summary>
 Represents the signature of an abstract slot of a class or interface
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAbstractParameter.Type">
<summary>
 The declared or inferred type of the parameter
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAbstractParameter.Name">
<summary>
 The optional name of the parameter
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAbstractParameter.IsOutArg">
<summary>
 Indicate this is an out argument
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAbstractParameter.IsOptionalArg">
<summary>
 Indicate this is an optional argument
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAbstractParameter.IsInArg">
<summary>
 Indicate this is an in argument
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAbstractParameter.Attributes">
<summary>
 The declared attributes of the parameter
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpAbstractParameter">
<summary>
 Represents a parameter in an abstract method of a class or interface
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpDelegateSignature.DelegateReturnType">
<summary>
 Get the return type of the delegate signature
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpDelegateSignature.DelegateArguments">
<summary>
 Get the argument types of the delegate signature
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpDelegateSignature">
<summary>
 Represents a delegate signature in an F# symbol
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.XmlDocSig">
<summary>
 Get the XML documentation signature for the entity, used for .xml file lookup for compiled code
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.XmlDoc">
<summary>
 Get the XML documentation for the entity
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.UsesPrefixDisplay">
<summary>
 Indicates if the type prefers the &quot;tycon&lt;a,b&gt;&quot; syntax for display etc.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.UnionCases">
<summary>
 Get the cases of a union type
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.TryFullName">
<summary>
 Get the full name of the type or module if it is available
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.StaticParameters">
<summary>
 Get the static parameters for a provided type
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.RepresentationAccessibility">
<summary>
 Get the declared accessibility of the representation, not taking signatures into account
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.QualifiedName">
<summary>
 Get the fully qualified name of the type or module
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.NestedEntities">
<summary>
 Get the modules and types defined in a module, or the nested types of a type
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.Namespace">
<summary>
 Get the namespace containing the type or module, if any. Use &apos;None&apos; for item not in a namespace.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.MembersFunctionsAndValues">
<summary>
 Get the properties, events and methods of a type definitions, or the functions and values of a module
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.LogicalName">
<summary>
 Get the name of the type or module, possibly with `n mangling
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.IsValueType">
<summary>
 Indicates if the entity is a struct or enum
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.IsUnresolved">
<summary>
 Indicates if the entity is in an unresolved assembly
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.IsStaticInstantiation">
<summary>
 Indicates if the entity is a &apos;fake&apos; symbol related to a static instantiation of a type provider
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.IsProvidedAndGenerated">
<summary>
 Indicates if the entity is a generated provided type
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.IsProvidedAndErased">
<summary>
 Indicates if the entity is an erased provided type
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.IsProvided">
<summary>
 Indicates if the entity is a provided type
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.IsOpaque">
<summary>
 Indicates if the entity is a type definition for a reference type where the implementation details are hidden by a signature
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.IsNamespace">
<summary>
 Indicates if the entity is a part of a namespace path
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.IsMeasure">
<summary>
 Indicates if the entity is a measure definition
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.IsInterface">
<summary>
 Indicates if the entity is an interface type definition
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.IsFSharpUnion">
<summary>
 Indicates if the entity is union type
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.IsFSharpRecord">
<summary>
 Indicates if the entity is record type
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.IsFSharpModule">
<summary>
 Indicates if the entity is an F# module definition
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.IsFSharpExceptionDeclaration">
<summary>
 Indicates an F# exception declaration
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.IsFSharpAbbreviation">
<summary>
 Indicates if the entity is a measure, type or exception abbreviation
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.IsFSharp">
<summary>
 Indicates if this is a reference to something in an F#-compiled assembly
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.IsEnum">
<summary>
 Indicates if the entity is an enum type definition
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.IsDelegate">
<summary>
 Indicates if the entity is a delegate type definition
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.IsClass">
<summary>
 Indicates if the entity is a class type definition
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.IsByRef">
<summary>
 Indicates if is the &apos;byref&lt;_&gt;&apos; type definition used for byref types in F#-compiled assemblies
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.IsAttributeType">
<summary>
 Check if the entity inherits from System.Attribute in its type hierarchy
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.IsArrayType">
<summary>
 Indicates if the entity is an array type
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.IsAbstractClass">
<summary>
 Indicates if the entity is an abstract class
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.HasFSharpModuleSuffix">
<summary>
 Indicates that a module is compiled to a class with the given mangled name. The mangling is reversed during lookup
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.HasAssemblyCodeRepresentation">
<summary>
 Indicates if the type is implemented through a mapping to IL assembly code. This is only
 true for types in FSharp.Core.dll
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.GenericParameters">
<summary>
 Get the generic parameters, possibly including unit-of-measure parameters
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.GenericArguments">
<summary>
 Get the generic parameters, possibly including unit-of-measure parameters
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.FullName">
<summary>
 Get the full name of the type or module
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.FSharpFields">
<summary>
 Get the fields of a record, class, struct or enum from the perspective of the F# language.
 This includes static fields, the &apos;val&apos; bindings in classes and structs, and the value definitions in enums.
 For classes, the list may include compiler generated fields implied by the use of primary constructors.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.FSharpDelegateSignature">
<summary>
 Indicates if the type is a delegate with the given Invoke signature
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.DisplayName">
<summary>
 Get the name of the type or module as displayed in F# code
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.DeclaringEntity">
<summary>
 Get the enclosing entity for the definition
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.DeclaredInterfaces">
<summary>
 Get the declared interface implementations
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.DeclarationLocation">
<summary>
 Get the declaration location for the type constructor
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.CompiledName">
<summary>
 Get the compiled name of the type or module, possibly with `n mangling. This is identical to LogicalName
 unless the CompiledName attribute is used.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.BasicQualifiedName">
<summary>
 The fully qualified name of the type or module without strong assembly name.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.BaseType">
<summary>
 Get the base type, if any
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.Attributes">
<summary>
 Get the declared attributes for the type
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.ArrayRank">
<summary>
 Get the rank of an array type
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.AllInterfaces">
<summary>
 Get all the interface implementations, by walking the type hierarchy
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.AllCompilationPaths">
<summary>
 Get all compilation paths, taking `Module` suffixes into account.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.ActivePatternCases">
<summary>
 Get all active pattern cases defined in all active patterns in the module.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.Accessibility">
<summary>
 Get the declared accessibility of the type
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.AccessPath">
<summary>
 Get the path used to address the entity (e.g. &quot;Namespace.Module1.NestedModule2&quot;). Gives
 &quot;global&quot; for items not in a namespace.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpEntity.AbbreviatedType">
<summary>
 Get the type abbreviated by an F# type abbreviation
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpEntity.TryGetMetadataText">
<summary>
 Get the source text of the entity&apos;s signature to be used as metadata.
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpEntity.TryGetMembersFunctionsAndValues">
<summary>
 Safe version of `GetMembersFunctionsAndValues`.
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpEntity.TryGetFullName">
<summary>
 Safe version of `FullName`.
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpEntity.TryGetFullDisplayName">
<summary>
 Safe version of `DisplayName`.
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpEntity.TryGetFullCompiledName">
<summary>
 Safe version of `CompiledName`.
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpEntity.GetPublicNestedEntities">
<summary>
 Public nested entities (methods, functions, values, nested modules).
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpEntity.AsType">
<summary>
 Instantiates FSharpType
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpEntity">
<summary>
 A subtype of FSharpSymbol that represents a type definition or module as seen by the F# language
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAssemblySignature.Entities">
<summary>
 The (non-nested) module and type definitions in this signature
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAssemblySignature.Attributes">
<summary>
 Get the declared attributes for the assembly.
 Only available when parsing an entire project.
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpAssemblySignature.TryGetEntities">
<summary>
 Safe version of `Entities`.
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpAssemblySignature.FindEntityByPath(Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Find entity using compiled names
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpAssemblySignature">
<summary>
 Represents an inferred signature of part of an assembly as seen by the F# language
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAssembly.SimpleName">
<summary>
 The simple name for the assembly
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAssembly.QualifiedName">
<summary>
 The qualified name of the assembly
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAssembly.IsProviderGenerated">
<summary>
 Indicates if the assembly was generated by a type provider and is due for static linking
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAssembly.FileName">
<summary>
 The file name for the assembly, if any
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAssembly.Contents">
<summary>
 The contents of the this assembly
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpAssembly">
<summary>
 Represents an assembly as seen by the F# language
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpSymbol.SignatureLocation">
<summary>
 Get the signature location for the symbol if it was declared in an implementation
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpSymbol.ImplementationLocation">
<summary>
 Get the implementation location for the symbol if it was declared in a signature that has an implementation
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpSymbol.FullName">
<summary>
 Get a textual representation of the full name of the symbol. The text returned for some symbols
 may not be a valid identifier path in F# code, but rather a human-readable representation of the symbol.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpSymbol.DisplayNameCore">
<summary>
 Gets the display name for the symbol where double backticks are not added for non-identifiers
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpSymbol.DisplayName">
<summary>
 Gets the display name for the symbol. Double backticks are added if the name is not a valid identifier.

 For FSharpParameter symbols without a name for the parameter, this returns &quot;````&quot;
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpSymbol.DeclarationLocation">
<summary>
 Get the declaration location for the symbol
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpSymbol.Attributes">
<summary>
 Get the attributes for the symbol, if any
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpSymbol.Assembly">
<summary>
 Get the assembly declaring this symbol
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpSymbol.Accessibility">
<summary>
 Get the declared accessibility of the symbol, if any
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpSymbol.TryGetAttribute``1">
<summary>
 Try to get an attribute matching the full name of the given type parameter
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpSymbol.IsEffectivelySameAs(FSharp.Compiler.Symbols.FSharpSymbol)">
<summary>
 Return true if two symbols are effectively the same when referred to in F# source code text.
 This sees through signatures (a symbol in a signature will be considered effectively the same as
 the matching symbol in an implementation).  In addition, other equivalences are applied
 when the same F# source text implies the same declaration name - for example, constructors
 are considered to be effectively the same symbol as the corresponding type definition.

 This is the relation used by GetUsesOfSymbol and GetUsesOfSymbolInFile.
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpSymbol.IsAccessible(FSharp.Compiler.Symbols.FSharpAccessibilityRights)">
<summary>
 Computes if the symbol is accessible for the given accessibility rights
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpSymbol.HasAttribute``1">
<summary>
 Indicates if this symbol has an attribute matching the full name of the given type parameter
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpSymbol.GetEffectivelySameAsHash">
<summary>
 A hash compatible with the IsEffectivelySameAs relation
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpSymbol">
<summary>
 Represents a symbol in checked F# source code or a compiled .NET component.

 The subtype of the symbol may reveal further information and can be one of FSharpEntity, FSharpUnionCase
 FSharpField, FSharpGenericParameter, FSharpStaticParameter, FSharpMemberOrFunctionOrValue, FSharpParameter,
 or FSharpActivePatternCase.
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpDisplayContext.WithSuffixGenericParameters">
<summary>
 Causes type signatures to be formatted with suffix-style generic parameters,
 for example `int list`
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpDisplayContext.WithPrefixGenericParameters">
<summary>
 Causes type signatures to be formatted with prefix-style generic parameters,
 for example `list&lt;int&gt;`.
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpDisplayContext">
<summary>
 Represents the information needed to format types and other information in a style
 suitable for use in F# source text at a particular source location.

 Acquired via GetDisplayEnvAtLocationAlternate and similar methods. May be passed
 to the Format method on FSharpType and other methods.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAccessibility.IsPublic">
<summary>
 Indicates the symbol has public accessibility.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAccessibility.IsProtected">
<summary>
 Indicates the symbol has protected accessibility.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAccessibility.IsPrivate">
<summary>
 Indicates the symbol has private accessibility.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAccessibility.IsInternal">
<summary>
 Indicates the symbol has internal accessibility.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAccessibility.Contents">
<summary>
 The underlying Accessibility
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpAccessibility">
<summary>
 Indicates the accessibility of a symbol, as seen by the F# language
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpObjectExprOverride.Signature">
<summary>
 The signature of the implemented abstract slot
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpObjectExprOverride.GenericParameters">
<summary>
 The generic parameters of the method
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpObjectExprOverride.CurriedParameterGroups">
<summary>
 The parameters of the method
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpObjectExprOverride.Body">
<summary>
 The expression that forms the body of the method
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpObjectExprOverride">
<summary>
 Represents a checked method in an object expression, as seen by the F# language.
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpExpr.Type">
<summary>
 The type of the expression
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpExpr.Range">
<summary>
 The range of the expression
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpExpr.ImmediateSubExpressions">
<summary>
 The immediate sub-expressions of the expression.
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpExpr">
<summary>
 Represents a checked and reduced expression, as seen by the F# language.  The active patterns
 in &apos;FSharp.Compiler.SourceCodeServices&apos; can be used to analyze information about the expression.

 Pattern matching is reduced to decision trees and conditional tests. Some other
 constructs may be represented in reduced form.
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpImplementationFileDeclaration.InitAction">
<summary>
 Represents the declaration of a static initialization action
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpImplementationFileDeclaration.MemberOrFunctionOrValue">
<summary>
 Represents the declaration of a member, function or value, including the parameters and body of the member
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpImplementationFileDeclaration.Entity">
<summary>
 Represents the declaration of a type
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpImplementationFileDeclaration">
<summary>
 Represents a declaration in an implementation file, as seen by the F# language
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpImplementationFileContents.QualifiedName">
<summary>
 The qualified name acts to fully-qualify module specifications and implementations
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpImplementationFileContents.IsScript">
<summary>
 Indicates if the implementation file is a script
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpImplementationFileContents.HasExplicitEntryPoint">
<summary>
 Indicates if the implementation file has an explicit entry point
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpImplementationFileContents.FileName">
<summary>
 Get the system path of the implementation file
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpImplementationFileContents.Declarations">
<summary>
 Get the declarations that make up this implementation file
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpImplementationFileContents">
<summary>
 Represents the definitional contents of a single file or fragment in an assembly, as seen by the F# language
</summary>
</member>
<member name="P:FSharp.Compiler.Symbols.FSharpAssemblyContents.ImplementationFiles">
<summary>
 The contents of the implementation files in the assembly
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpAssemblyContents">
<summary>
 Represents the definitional contents of an assembly, as seen by the F# language
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|WitnessArg|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Indicates a witness argument index from the witness arguments supplied to the enclosing method
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|TraitCall|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions for an unresolved call to a trait
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|ObjectExpr|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches object expressions, returning the base type, the base call, the overrides and the interface implementations
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|ILFieldSet|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which set a field in a .NET type
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|ILFieldGet|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which fetch a field from a .NET type
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|ILAsm|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which are IL assembly code
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|NewDelegate|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which create an instance of a delegate type
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|TryWith|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches try/with expressions
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|TryFinally|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches try/finally expressions
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|WhileLoop|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches while loops
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|FastIntegerForLoop|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches fast-integer loops (up or down)
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|DebugPoint|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches debug points at leaf expressions in control flow
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|Sequential|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches sequential expressions
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|AddressOf|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which take the address of a location
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|Const|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches constant expressions, including signed and unsigned integers, strings, characters, booleans, arrays
 of bytes and arrays of unit16.
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|DefaultValue|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches default-value expressions, including null expressions
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|ValueSet|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which set the contents of a mutable variable
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|AddressSet|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which set the contents of an address
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|TypeTest|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which test the runtime type of a value
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|NewArray|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches array expressions
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|Coerce|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which coerce the type of a value
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|TupleGet|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which get a value from a tuple
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|NewTuple|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches tuple expressions
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|UnionCaseTest|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which test if an expression corresponds to a particular union case
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|UnionCaseTag|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which gets the tag for a union case
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|UnionCaseSet|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which set a field from a union case (only used in FSharp.Core itself)
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|UnionCaseGet|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which get a field from a union case
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|NewUnionCase|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which create an object corresponding to a union case
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|FSharpFieldSet|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which set a field in a record or class
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|FSharpFieldGet|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which get a field from a record or class
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|AnonRecordGet|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions getting a field from an anonymous record. The integer represents the
 index into the sorted fields of the anonymous record.
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|NewAnonRecord|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches anonymous record expressions
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|NewRecord|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches record expressions
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|LetRec|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which are let-rec definitions
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|Quote|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which are quotation literals
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|BaseValue|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which are uses of the &apos;base&apos; value
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|ThisValue|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which are uses of the &apos;this&apos; value
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|NewObject|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which are calls to object constructors
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|CallWithWitnesses|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Like Call but also indicates witness arguments
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|Call|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which are calls to members or module-defined functions. When calling curried functions and members the
 arguments are collapsed to a single collection of arguments, as done in the compiled version of these.
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|Let|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which are let definitions
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|IfThenElse|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which are conditionals
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|Lambda|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which are lambda abstractions
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|DecisionTreeSuccess|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Special expressions at the end of a conditional decision structure in the decision expression node of a DecisionTree .
 The given expressions are passed as values to the decision tree target.
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|DecisionTree|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions with a decision expression, each branch of which ends in DecisionTreeSuccess passing control and values to one of the targets.
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|TypeLambda|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which are type abstractions
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|Application|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which are the application of function values
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpExprPatterns.|Value|_|(FSharp.Compiler.Symbols.FSharpExpr)">
<summary>
 Matches expressions which are uses of values
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpExprPatterns">
<summary>
 A collection of active patterns to analyze expressions
</summary>
</member>
<member name="M:FSharp.Compiler.Symbols.FSharpSymbolPatterns.|FSharpEntity|_|(FSharp.Compiler.Symbols.FSharpSymbol)">
<summary>
 Returns (originalEntity, abbreviatedEntity, abbreviatedType)
</summary>
</member>
<member name="T:FSharp.Compiler.Symbols.FSharpSymbolPatterns">
<summary>
 Patterns over FSharpSymbol and derivatives.
</summary>
</member>
<member name="M:FSharp.Compiler.Diagnostics.CompilationDiagnosticLogger.GetDiagnostics">
<summary>
 Get the captured diagnostics
</summary>
</member>
<member name="M:FSharp.Compiler.Diagnostics.CompilationDiagnosticLogger.#ctor(System.String,FSharp.Compiler.Diagnostics.FSharpDiagnosticOptions,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.DiagnosticsLogger.PhasedDiagnostic,FSharp.Compiler.DiagnosticsLogger.PhasedDiagnostic}})">
<summary>
 Create the diagnostics logger
</summary>
</member>
<member name="T:FSharp.Compiler.Diagnostics.CompilationDiagnosticLogger">
<summary>
 An error logger that capture errors, filtering them according to warning levels etc.
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.FSharpDiagnostic.Subcategory">
<summary>
 Gets the sub-category for the diagnostic
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.FSharpDiagnostic.StartLine">
<summary>
 Gets the start line for the diagnostic
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.FSharpDiagnostic.StartColumn">
<summary>
 Gets the start column for the diagnostic
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.FSharpDiagnostic.Start">
<summary>
 Gets the start position for the diagnostic
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.FSharpDiagnostic.Severity">
<summary>
 Gets the severity for the diagnostic
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.FSharpDiagnostic.Range">
<summary>
 Gets the range for the diagnostic
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.FSharpDiagnostic.Message">
<summary>
 Gets the message for the diagnostic
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.FSharpDiagnostic.FileName">
<summary>
 Gets the file name for the diagnostic
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.FSharpDiagnostic.ExtendedData">
<summary>
 Gets the contextually-relevant data to each particular diagnostic for things like code fixes
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.FSharpDiagnostic.ErrorNumberText">
<summary>
 Gets the full error number text e.g &quot;FS0031&quot;
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.FSharpDiagnostic.ErrorNumberPrefix">
<summary>
 Gets the number prefix for the diagnostic, usually &quot;FS&quot; but may differ for analyzers
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.FSharpDiagnostic.ErrorNumber">
<summary>
 Gets the number for the diagnostic
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.FSharpDiagnostic.EndLine">
<summary>
 Gets the end line for the diagnostic
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.FSharpDiagnostic.EndColumn">
<summary>
 Gets the end column for the diagnostic
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.FSharpDiagnostic.End">
<summary>
 Gets the end position for the diagnostic
</summary>
</member>
<member name="M:FSharp.Compiler.Diagnostics.FSharpDiagnostic.NormalizeErrorString(System.String)">
<summary>
 Newlines are recognized and replaced with (ASCII 29, the &apos;group separator&apos;),
 which is decoded by the IDE with &apos;NewlineifyErrorString&apos; back into newlines, so that multi-line errors can be displayed in QuickInfo
</summary>
</member>
<member name="M:FSharp.Compiler.Diagnostics.FSharpDiagnostic.NewlineifyErrorString(System.String)">
<summary>
 Newlines are recognized and replaced with (ASCII 29, the &apos;group separator&apos;),
 which is decoded by the IDE with &apos;NewlineifyErrorString&apos; back into newlines, so that multi-line errors can be displayed in QuickInfo
</summary>
</member>
<member name="M:FSharp.Compiler.Diagnostics.FSharpDiagnostic.Create(FSharp.Compiler.Diagnostics.FSharpDiagnosticSeverity,System.String,System.Int32,FSharp.Compiler.Text.Range,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Creates a diagnostic, e.g. for reporting from an analyzer
</summary>
</member>
<member name="T:FSharp.Compiler.Diagnostics.FSharpDiagnostic">
<summary>
 Represents a diagnostic produced by the F# compiler
</summary>
</member>
<member name="T:FSharp.Compiler.Diagnostics.FSharpDiagnosticKind">
<summary>
 Supported kinds of diagnostics by this service.
</summary>
</member>
<member name="T:FSharp.Compiler.Diagnostics.Activity">
<summary>
 For activities following the dotnet distributed tracing concept
 https://learn.microsoft.com/dotnet/core/diagnostics/distributed-tracing-concepts?source=recommendations
</summary>
</member>
<member name="T:FSharp.Compiler.Diagnostics.ActivityNames">
<summary>
 For activities following the dotnet distributed tracing concept
 https://learn.microsoft.com/dotnet/core/diagnostics/distributed-tracing-concepts?source=recommendations
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.ExtendedData.DefinitionsInSigAndImplNotCompatibleAbbreviationsDifferExtendedData.SignatureRange">
<summary>
 Range of the signature type identifier.
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.ExtendedData.DefinitionsInSigAndImplNotCompatibleAbbreviationsDifferExtendedData.ImplementationRange">
<summary>
 Range of the implementation type identifier.
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.ExtendedData.ArgumentsInSigAndImplMismatchExtendedData.SignatureRange">
<summary>
 Argument identifier range within signature file
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.ExtendedData.ArgumentsInSigAndImplMismatchExtendedData.SignatureName">
<summary>
 Argument name in signature file
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.ExtendedData.ArgumentsInSigAndImplMismatchExtendedData.ImplementationRange">
<summary>
 Argument identifier range within implementation file
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.ExtendedData.ArgumentsInSigAndImplMismatchExtendedData.ImplementationName">
<summary>
 Argument name in implementation file
</summary>
</member>
<member name="T:FSharp.Compiler.Diagnostics.ExtendedData.ArgumentsInSigAndImplMismatchExtendedData">
<summary>
 Additional data for &apos;argument names in the signature and implementation do not match&apos; diagnostic
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.ExtendedData.ValueNotContainedDiagnosticExtendedData.SignatureValue">
<summary>
 Represents F# value in signature file
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.ExtendedData.ValueNotContainedDiagnosticExtendedData.ImplementationValue">
<summary>
 Represents F# value in implementation file
</summary>
</member>
<member name="T:FSharp.Compiler.Diagnostics.ExtendedData.ValueNotContainedDiagnosticExtendedData">
<summary>
 Additional data for diagnostics about a value whose declarations differ in signature and implementation
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.ExtendedData.FieldNotContainedDiagnosticExtendedData.SignatureField">
<summary>
 Represents F# field in signature file
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.ExtendedData.FieldNotContainedDiagnosticExtendedData.ImplementationField">
<summary>
 Represents F# field in implementation file
</summary>
</member>
<member name="T:FSharp.Compiler.Diagnostics.ExtendedData.FieldNotContainedDiagnosticExtendedData">
<summary>
 Additional data for diagnostics about a field whose declarations differ in signature and implementation
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.ExtendedData.ExpressionIsAFunctionExtendedData.ActualType">
<summary>
 Represents F# type of the expression
</summary>
</member>
<member name="T:FSharp.Compiler.Diagnostics.ExtendedData.ExpressionIsAFunctionExtendedData">
<summary>
 Additional data for &apos;This expression is a function value, i.e. is missing arguments&apos; diagnostic
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.ExtendedData.TypeMismatchDiagnosticExtendedData.ExpectedType">
<summary>
 Represents F# type expected in the current context
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.ExtendedData.TypeMismatchDiagnosticExtendedData.DisplayContext">
<summary>
 Represents the information needed to format types
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.ExtendedData.TypeMismatchDiagnosticExtendedData.ContextInfo">
<summary>
 The context in which the type mismatch was found
</summary>
</member>
<member name="P:FSharp.Compiler.Diagnostics.ExtendedData.TypeMismatchDiagnosticExtendedData.ActualType">
<summary>
 Represents F# type type actual in the current context
</summary>
</member>
<member name="T:FSharp.Compiler.Diagnostics.ExtendedData.TypeMismatchDiagnosticExtendedData">
<summary>
 Additional data for type-mismatch-like (usually with ErrorNumber = 1) diagnostics
</summary>
</member>
<member name="T:FSharp.Compiler.Diagnostics.ExtendedData.IFSharpDiagnosticExtendedData">
<summary>
 Contextually-relevant data to each particular diagnostic
</summary>
</member>
<member name="T:FSharp.Compiler.Diagnostics.ExtendedData.DiagnosticContextInfo.SequenceExpression">
<summary>
 The type equation comes from a sequence expression
</summary>
</member>
<member name="T:FSharp.Compiler.Diagnostics.ExtendedData.DiagnosticContextInfo.PatternMatchGuard">
<summary>
 The type equation comes from a pattern match guard
</summary>
</member>
<member name="T:FSharp.Compiler.Diagnostics.ExtendedData.DiagnosticContextInfo.FollowingPatternMatchClause">
<summary>
 The type equation comes from a return type of a pattern match clause (not the first clause)
</summary>
</member>
<member name="T:FSharp.Compiler.Diagnostics.ExtendedData.DiagnosticContextInfo.DowncastUsedInsteadOfUpcast">
<summary>
 The type equation comes from an downcast where a upcast could be used
</summary>
</member>
<member name="T:FSharp.Compiler.Diagnostics.ExtendedData.DiagnosticContextInfo.RuntimeTypeTest">
<summary>
 The type equation comes from a runtime type test
</summary>
</member>
<member name="T:FSharp.Compiler.Diagnostics.ExtendedData.DiagnosticContextInfo.YieldInComputationExpression">
<summary>
 The type equation comes from a yield in a computation expression
</summary>
</member>
<member name="T:FSharp.Compiler.Diagnostics.ExtendedData.DiagnosticContextInfo.ReturnInComputationExpression">
<summary>
 The type equation comes from a return in a computation expression
</summary>
</member>
<member name="T:FSharp.Compiler.Diagnostics.ExtendedData.DiagnosticContextInfo.CollectionElement">
<summary>
 The type equation comes from a list or array constructor
</summary>
</member>
<member name="T:FSharp.Compiler.Diagnostics.ExtendedData.DiagnosticContextInfo.TupleInRecordFields">
<summary>
 The type equation comes from the verification of a tuple in record fields
</summary>
</member>
<member name="T:FSharp.Compiler.Diagnostics.ExtendedData.DiagnosticContextInfo.RecordFields">
<summary>
 The type equation comes from the verification of record fields
</summary>
</member>
<member name="T:FSharp.Compiler.Diagnostics.ExtendedData.DiagnosticContextInfo.ElseBranchResult">
<summary>
 The type equation comes from a type check of the result of an else branch
</summary>
</member>
<member name="T:FSharp.Compiler.Diagnostics.ExtendedData.DiagnosticContextInfo.OmittedElseBranch">
<summary>
 The type equation comes from an omitted else branch
</summary>
</member>
<member name="T:FSharp.Compiler.Diagnostics.ExtendedData.DiagnosticContextInfo.IfExpression">
<summary>
 The type equation comes from an IF expression
</summary>
</member>
<member name="T:FSharp.Compiler.Diagnostics.ExtendedData.DiagnosticContextInfo.NoContext">
<summary>
 No context was given
</summary>
</member>
<member name="T:FSharp.Compiler.Diagnostics.ExtendedData.DiagnosticContextInfo">
<summary>
 Information about the context of a type equation in type-mismatch-like diagnostic
</summary>
</member>
<member name="M:FSharp.Compiler.Diagnostics.CompilerDiagnostics.GetSuggestedNames(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.Unit},System.String)">
<summary>
 Given a set of names, uses and a string representing an unresolved identifier,
 returns a list of suggested names if there are any feasible candidates.
</summary>
</member>
<member name="M:FSharp.Compiler.Diagnostics.CompilerDiagnostics.GetErrorMessage(FSharp.Compiler.Diagnostics.FSharpDiagnosticKind)">
<summary>
 Given a DiagnosticKind, returns the string representing the error message for that diagnostic.
</summary>
</member>
<member name="T:FSharp.Compiler.Diagnostics.CompilerDiagnostics">
<summary>
 Exposes compiler diagnostic error messages.
</summary>
</member>
<member name="M:FSharp.Compiler.Tokenization.FSharpSourceTokenizer.CreateLineTokenizer(System.String)">
<summary>
 Create a tokenizer for a line of this source file
</summary>
</member>
<member name="M:FSharp.Compiler.Tokenization.FSharpSourceTokenizer.CreateBufferTokenizer(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.Char[],System.Int32,System.Int32},System.Int32})">
<summary>
 Create a tokenizer for a line of this source file using a buffer filler
</summary>
</member>
<member name="M:FSharp.Compiler.Tokenization.FSharpSourceTokenizer.#ctor(Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Create a tokenizer for a source file.
</summary>
</member>
<member name="T:FSharp.Compiler.Tokenization.FSharpSourceTokenizer">
<summary>
 Tokenizer for a source file. Holds some expensive-to-compute resources at the scope of the file.
</summary>
</member>
<member name="M:FSharp.Compiler.Tokenization.FSharpLineTokenizer.ScanToken(FSharp.Compiler.Tokenization.FSharpTokenizerLexState)">
<summary>
 Scan one token from the line
</summary>
</member>
<member name="M:FSharp.Compiler.Tokenization.FSharpLineTokenizer.LexStateOfColorState(FSharp.Compiler.Tokenization.FSharpTokenizerColorState)">
<summary>
 Get a default lexer state for a color state.

 NOTE: This may result in an inaccurate lexer state
 not taking into account things such as the #if/#endif and string interpolation context
 within the file
</summary>
</member>
<member name="M:FSharp.Compiler.Tokenization.FSharpLineTokenizer.ColorStateOfLexState(FSharp.Compiler.Tokenization.FSharpTokenizerLexState)">
<summary>
 Get the color state from the lexer state
</summary>
</member>
<member name="T:FSharp.Compiler.Tokenization.FSharpLineTokenizer">
<summary>
 Object to tokenize a line of F# source code, starting with the given lexState.  The lexState should be FSharpTokenizerLexState.Initial for
 the first line of text. Returns an array of ranges of the text and two enumerations categorizing the
 tokens and characters covered by that range, i.e. FSharpTokenColorKind and FSharpTokenCharKind.  The enumerations
 are somewhat adhoc but useful enough to give good colorization options to the user in an IDE.

 A new lexState is also returned.  An IDE-plugin should in general cache the lexState
 values for each line of the edited code.
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenInfo.FullMatchedLength">
<summary>
 The full length consumed by this match, including delayed tokens (which can be ignored in naive lexers)
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenInfo.TokenName">
<summary>
 Provides additional information about the token
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenInfo.Tag">
<summary>
 The tag is an integer identifier for the token
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenInfo.FSharpTokenTriggerClass">
<summary>
 Actions taken when the token is typed
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenInfo.CharClass">
<summary>
 Gives an indication of the class to assign to the token an IDE
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenInfo.RightColumn">
<summary>
 Right column of the token.
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenInfo.LeftColumn">
<summary>
 Left column of the token.
</summary>
</member>
<member name="T:FSharp.Compiler.Tokenization.FSharpTokenInfo">
<summary>
 Information about a particular token from the tokenizer
</summary>
</member>
<member name="T:FSharp.Compiler.Tokenization.FSharpTokenCharKind">
<summary>
 Gives an indication of the class to assign to the characters of the token an IDE
</summary>
</member>
<member name="T:FSharp.Compiler.Tokenization.FSharpTokenTriggerClass">
<summary>
 Gives an indication of what should happen when the token is typed in an IDE
</summary>
</member>
<member name="T:FSharp.Compiler.Tokenization.FSharpTokenColorKind">
<summary>
 Gives an indication of the color class to assign to the token an IDE
</summary>
</member>
<member name="T:FSharp.Compiler.Tokenization.FSharpTokenizerColorState">
<summary>
 Represents stable information for the state of the lexing engine at the end of a line
</summary>
</member>
<member name="T:FSharp.Compiler.Tokenization.FSharpTokenizerLexState">
<summary>
 Represents encoded information for the end-of-line continuation of lexing
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpKeywords.KeywordNames">
<summary>
 All the keywords in the F# language
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpKeywords.KeywordsDescriptionLookup">
<summary>
 A lookup from keywords to their descriptions
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpKeywords.KeywordsWithDescription">
<summary>
 Keywords paired with their descriptions. Used in completion and quick info.
</summary>
</member>
<member name="M:FSharp.Compiler.Tokenization.FSharpKeywords.NormalizeIdentifierBackticks(System.String)">
<summary>
 Add backticks if the identifier is a keyword.
 Remove backticks if present and not needed.
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.NEW">
<summary>
 Indicates the token is keyword `new`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.OWITH">
<summary>
 Indicates the token is keyword `with` in #light
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.WITH">
<summary>
 Indicates the token is keyword `with`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.TRY">
<summary>
 Indicates the token is keyword `try`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.CLASS">
<summary>
 Indicates the token is keyword `class`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.STRUCT">
<summary>
 Indicates the token is keyword `struct`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.ELSE">
<summary>
 Indicates the token is keyword `else`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.THEN">
<summary>
 Indicates the token is keyword `then`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.FUNCTION">
<summary>
 Indicates the token is keyword `function`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.DO">
<summary>
 Indicates the token is keyword `do`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.BEGIN">
<summary>
 Indicates the token is keyword `begin`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.LINE_COMMENT">
<summary>
 Indicates the token is a line comment
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.COMMENT">
<summary>
 Indicates the token is a comment
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.WHITESPACE">
<summary>
 Indicates the token is a whitespace
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.QUOTE">
<summary>
 Indicates the token is a `&quot;`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.LARROW">
<summary>
 Indicates the token is a `&lt;-`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.RARROW">
<summary>
 Indicates the token is a `-&gt;`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.BAR_BAR">
<summary>
 Indicates the token is a `||`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.COLON_EQUALS">
<summary>
 Indicates the token is a `:=`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.PREFIX_OP">
<summary>
 Indicates the token is a `~`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.AMP_AMP">
<summary>
 Indicates the token is a `@@`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.COLON_COLON">
<summary>
 Indicates the token is a `::`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.INFIX_COMPARE_OP">
<summary>
 Indicates the token is a `|`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.INFIX_BAR_OP">
<summary>
 Indicates the token is a `|`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.COLON_QMARK">
<summary>
 Indicates the token is a `:?`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.COLON_QMARK_GREATER">
<summary>
 Indicates the token is a `:?&gt;`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.COLON_GREATER">
<summary>
 Indicates the token is a `:&gt;`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.BAR">
<summary>
 Indicates the token is a `_`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.UNDERSCORE">
<summary>
 Indicates the token is a `..`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.INT32_DOT_DOT">
<summary>
 Indicates the token is a `..^`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.DOT_DOT_HAT">
<summary>
 Indicates the token is a `..`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.DOT_DOT">
<summary>
 Indicates the token is a `..`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.DOT">
<summary>
 Indicates the token is a `.`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.COMMA">
<summary>
 Indicates the token is a `,`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.SEMICOLON">
<summary>
 Indicates the token is a `;`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.EQUALS">
<summary>
 Indicates the token is a `=`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.COLON">
<summary>
 Indicates the token is a `:`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.QMARK">
<summary>
 Indicates the token is a `?`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.INFIX_AT_HAT_OP">
<summary>
 Indicates the token is a `^`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.PERCENT_OP">
<summary>
 Indicates the token is a `%`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.INFIX_STAR_DIV_MOD_OP">
<summary>
 Indicates the token is a `%`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.STAR">
<summary>
 Indicates the token is a `*`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.MINUS">
<summary>
 Indicates the token is a `-`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.PLUS_MINUS_OP">
<summary>
 Indicates the token is a `+` or `-`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.BAR_RBRACK">
<summary>
 Indicates the token is a `|]`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.LBRACK_BAR">
<summary>
 Indicates the token is a `[|`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.GREATER">
<summary>
 Indicates the token is a `&gt;`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.LESS">
<summary>
 Indicates the token is a `&lt;`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.GREATER_RBRACK">
<summary>
 Indicates the token is a `&gt;]`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.LBRACK_LESS">
<summary>
 Indicates the token is a `[&lt;`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.RBRACE">
<summary>
 Indicates the token is a `}`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.LBRACE">
<summary>
 Indicates the token is a `{`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.RBRACK">
<summary>
 Indicates the token is a `]`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.LBRACK">
<summary>
 Indicates the token is a `[`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.RPAREN">
<summary>
 Indicates the token is a `)`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.LPAREN">
<summary>
 Indicates the token is a `(`
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.INTERP_STRING_END">
<summary>
 Indicates the token is a part of an interpolated string
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.INTERP_STRING_PART">
<summary>
 Indicates the token is a part of an interpolated string
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.INTERP_STRING_BEGIN_PART">
<summary>
 Indicates the token is a part of an interpolated string
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.INTERP_STRING_BEGIN_END">
<summary>
 Indicates the token is a part of an interpolated string
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.STRING">
<summary>
 Indicates the token is a string (synonym for FSharpTokenTag.String)
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.IDENT">
<summary>
 Indicates the token is an identifier (synonym for FSharpTokenTag.Identifier)
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.String">
<summary>
 Indicates the token is a string
</summary>
</member>
<member name="P:FSharp.Compiler.Tokenization.FSharpTokenTag.Identifier">
<summary>
 Indicates the token is an identifier
</summary>
</member>
<member name="T:FSharp.Compiler.Tokenization.FSharpTokenTag">
<summary>
 Some of the values in the field FSharpTokenInfo.Tag
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.ParsedInput.SigFile">
<summary>
 A parsed signature file
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.ParsedInput.ImplFile">
<summary>
 A parsed implementation file
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.ParsedInput.ScopedPragmas">
<summary>
 Gets the #nowarn and other scoped pragmas
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.ParsedInput.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.ParsedInput.QualifiedName">
<summary>
 Gets the qualified name used to help match signature and implementation files
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.ParsedInput.Identifiers">
<summary>
 Gets a set of all identifiers used in this parsed input. Only populated if captureIdentifiersWhenParsing option was used.
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.ParsedInput.FileName">
<summary>
 Gets the file name for the parsed input
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.ParsedInput">
<summary>
 Represents the syntax tree for a parsed implementation or signature file
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.ParsedSigFileInput">
<summary>
 Represents the full syntax tree, file name and other parsing information for a signature file
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.ParsedImplFileInput">
<summary>
 Represents the full syntax tree, file name and other parsing information for an implementation file
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.QualifiedNameOfFile.Text">
<summary>
 The name of the file
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.QualifiedNameOfFile.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.QualifiedNameOfFile.Id">
<summary>
 The identifier for the name of the file
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.QualifiedNameOfFile">
<summary>
 Represents a qualifying name for anonymous module specifications and implementations,
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.ScopedPragma.WarningOff">
<summary>
 A pragma to turn a warning off
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.ScopedPragma">
<summary>
 Represents a scoped pragma
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.ParsedSigFile">
<summary>
 Represents a parsed signature file made up of fragments
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.ParsedImplFile">
<summary>
 Represents a parsed implementation file made up of fragments
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.ParsedScriptInteraction">
<summary>
 Represents a parsed syntax tree for an F# Interactive interaction
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.ParsedSigFileFragment.NamespaceFragment">
<summary>
 A signature file namespace fragment
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.ParsedSigFileFragment.NamedModule">
<summary>
 A signature file which is a module, &apos;module N&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.ParsedSigFileFragment.AnonModule">
<summary>
 A signature file which is an anonymous module, e.g. the signature file for the final file in an application
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.ParsedSigFileFragment">
<summary>
 Represents the syntax tree for the contents of a parsed signature file
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.ParsedImplFileFragment.NamespaceFragment">
<summary>
 An implementation file fragment which declares a namespace fragment
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.ParsedImplFileFragment.NamedModule">
<summary>
 An implementation file is a named module definition, &apos;module N&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.ParsedImplFileFragment.AnonModule">
<summary>
 An implementation file which is an anonymous module definition, e.g. a script
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.ParsedImplFileFragment">
<summary>
 Represents the syntax tree for the contents of a parsed implementation file
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.ParsedHashDirective">
<summary>
 Represents a parsed hash directive
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.ParsedHashDirectiveArgument.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.ParsedHashDirectiveArgument">
<summary>
 Represents a parsed hash directive argument
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynModuleOrNamespaceSig.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynModuleOrNamespaceSig">
<summary>
 Represents the definition of a module or namespace in a signature file
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynModuleOrNamespace.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynModuleOrNamespace">
<summary>
 Represents the definition of a module or namespace
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynModuleOrNamespaceKind.GlobalNamespace">
<summary>
 A namespace is declared &apos;global&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynModuleOrNamespaceKind.DeclaredNamespace">
<summary>
 A namespace is explicitly declared
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynModuleOrNamespaceKind.AnonModule">
<summary>
 A module is anonymously named, e.g. a script
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynModuleOrNamespaceKind.NamedModule">
<summary>
 A module is explicitly named &apos;module N&apos;
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynModuleOrNamespaceKind.IsModule">
<summary>
 Indicates if this is a module definition
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynModuleOrNamespaceKind">
<summary>
 Represents the kind of a module or namespace definition
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynModuleSigDecl.NamespaceFragment">
<summary>
 A namespace fragment within a namespace in a signature file
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynModuleSigDecl.HashDirective">
<summary>
 A hash directive within a module or namespace in a signature file
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynModuleSigDecl.Open">
<summary>
 An &apos;open&apos; definition within a module or namespace in a signature file
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynModuleSigDecl.Exception">
<summary>
 An exception definition within a module or namespace in a signature file
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynModuleSigDecl.Types">
<summary>
 A set of one or more type definitions within a module or namespace in a signature file
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynModuleSigDecl.Val">
<summary>
 A &apos;val&apos; definition within a module or namespace in a signature file, corresponding
 to a &apos;let&apos; definition in the implementation
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynModuleSigDecl.NestedModule">
<summary>
 A nested module definition within a module or namespace in a signature file
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynModuleSigDecl.ModuleAbbrev">
<summary>
 A module abbreviation definition within a module or namespace in a signature file
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynModuleSigDecl.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynModuleSigDecl">
<summary>
 Represents a definition within a module or namespace in a signature file
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExceptionSig">
<summary>
 Represents the right hand side of an exception definition in a signature file
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynOpenDeclTarget.Type">
<summary>
 A &apos;open type&apos; declaration
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynOpenDeclTarget.ModuleOrNamespace">
<summary>
 A &apos;open&apos; declaration
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynOpenDeclTarget.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynOpenDeclTarget">
<summary>
 Represents the target of the open declaration
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynModuleDecl.NamespaceFragment">
<summary>
 A namespace fragment within a module
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynModuleDecl.HashDirective">
<summary>
 A hash directive within a module
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynModuleDecl.Attributes">
<summary>
 An attribute definition within a module, for assembly and .NET module attributes
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynModuleDecl.Open">
<summary>
 An &apos;open&apos; definition within a module
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynModuleDecl.Exception">
<summary>
 An &apos;exception&apos; definition within a module
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynModuleDecl.Types">
<summary>
 One or more &apos;type&apos; definitions within a module
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynModuleDecl.Expr">
<summary>
 An &apos;expr&apos; within a module.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynModuleDecl.Let">
<summary>
 A &apos;let&apos; definition within a module
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynModuleDecl.NestedModule">
<summary>
 A nested module definition &apos;module X = ...&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynModuleDecl.ModuleAbbrev">
<summary>
 A module abbreviation definition &apos;module X = A.B.C&apos;
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynModuleDecl.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynModuleDecl">
<summary>
 Represents a definition within a module
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMemberDefn.AutoProperty">
<summary>
 An auto-property definition, F# syntax: &apos;member val X = expr&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMemberDefn.NestedType">
<summary>
 A nested type definition, a feature that is not implemented
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMemberDefn.ValField">
<summary>
 A &apos;val&apos; definition within a class
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMemberDefn.Inherit">
<summary>
 An &apos;inherit&apos; definition within a class
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMemberDefn.Interface">
<summary>
 An interface implementation definition within a class
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMemberDefn.AbstractSlot">
<summary>
 An abstract slot definition within a class or interface
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMemberDefn.LetBindings">
<summary>
 A &apos;let&apos; definition within a class
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMemberDefn.ImplicitInherit">
<summary>
 An implicit inherit definition, &apos;inherit &lt;typ&gt;(args...) as base&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMemberDefn.ImplicitCtor">
<summary>
 An implicit constructor definition
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMemberDefn.GetSetMember">
<summary>
 A &apos;member&apos; definition with get/set accessors within a type
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMemberDefn.Member">
<summary>
 A &apos;member&apos; definition within a type
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMemberDefn.Open">
<summary>
 An &apos;open&apos; definition within a type
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynMemberDefn.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMemberDefn">
<summary>
 Represents a definition element within a type definition, e.g. &apos;member ... &apos;
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynTypeDefn.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeDefn">
<summary>
 Represents a type or exception declaration &apos;type C = ... &apos; plus
 any additional member definitions for the type
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeDefnRepr.Exception">
<summary>
 An exception definition
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeDefnRepr.Simple">
<summary>
 A simple type definition (record, union, abbreviation)
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeDefnRepr.ObjectModel">
<summary>
 An object model type definition (class or interface)
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynTypeDefnRepr.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeDefnRepr">
<summary>
 Represents the right hand side of a type or exception declaration &apos;type C = ... &apos; plus
 any additional member definitions for the type
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynExceptionDefn.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExceptionDefn">
<summary>
 Represents the right hand side of an exception declaration &apos;exception E = ... &apos; plus
 any member definitions for the exception
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynExceptionDefnRepr.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExceptionDefnRepr">
<summary>
 Represents the right hand side of an exception declaration &apos;exception E = ... &apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynReturnInfo">
<summary>
 Represents the syntactic elements associated with the &quot;return&quot; of a function or method.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynValTyparDecls">
<summary>
 Represents the names and other metadata for the type parameters for a member or function
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynArgInfo">
<summary>
 Represents the argument names and other metadata for a parameter for a member or function
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynValInfo.SynValInfo">
<summary>
 SynValInfo(curriedArgInfos, returnInfo)
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynValInfo">
<summary>
 The argument names and other metadata for a member or function
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynValSig">
<summary>
 Represents the syntax tree for a &apos;val&apos; definition in an abstract slot or a signature file
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynValSigAccess">
<summary>
 Represents one or two access modifier(s) in a property signature
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynComponentInfo.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynComponentInfo">
<summary>
 Represents the syntax tree associated with the name of a type definition or module
 in signature or implementation.

 This includes the name, attributes, type parameters, constraints, documentation and accessibility
 for a type definition or module. For modules, entries such as the type parameters are
 always empty.
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynField.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynField">
<summary>
 Represents the syntax tree for a field declaration in a record or class
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeDefnSig.SynTypeDefnSig">
<summary>
 The information for a type definition in a signature
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynTypeDefnSig.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeDefnSig">
<summary>
 Represents the syntax tree for a type definition in a signature
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeDefnSigRepr.Simple">
<summary>
 Indicates the right right-hand-side is a record, union or other simple type.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeDefnSigRepr.ObjectModel">
<summary>
 Indicates the right right-hand-side is a class, struct, interface or other object-model type
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynTypeDefnSigRepr.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeDefnSigRepr">
<summary>
 Represents the syntax tree for the right-hand-side of a type definition in a signature.
 Note: in practice, using a discriminated union to make a distinction between
 &quot;simple&quot; types and &quot;object oriented&quot; types is not particularly useful.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynUnionCaseKind.FullType">
<summary>
 Full type spec given by &apos;UnionCase: ty1 * tyN -&gt; rty&apos;. Only used in FSharp.Core, otherwise a warning.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynUnionCaseKind.Fields">
<summary>
 Normal style declaration
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynUnionCaseKind">
<summary>
 Represents the syntax tree for the right-hand-side of union definition, excluding members,
 in either a signature or implementation.
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynUnionCase.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynUnionCase">
<summary>
 Represents the syntax tree for one case in a union definition.
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynEnumCase.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynEnumCase">
<summary>
 Represents the syntax tree for one case in an enum definition.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeDefnSimpleRepr.Exception">
<summary>
 An exception definition, &quot;exception E = ...&quot;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeDefnSimpleRepr.None">
<summary>
 An abstract definition, &quot;type X&quot;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeDefnSimpleRepr.TypeAbbrev">
<summary>
 A type abbreviation, &quot;type X = A.B.C&quot;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeDefnSimpleRepr.LibraryOnlyILAssembly">
<summary>
 A type defined by using an IL assembly representation. Only used in FSharp.Core.

 F# syntax: &quot;type X = (# &quot;...&quot;#)
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeDefnSimpleRepr.General">
<summary>
 An object oriented type definition. This is not a parse-tree form, but represents the core
 type representation which the type checker splits out from the &quot;ObjectModel&quot; cases of type definitions.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeDefnSimpleRepr.Record">
<summary>
 A record type definition, type X = { A: int; B: int }
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeDefnSimpleRepr.Enum">
<summary>
 An enum type definition, type X = A = 1 | B = 2
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeDefnSimpleRepr.Union">
<summary>
 A union type definition, type X = A | B
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynTypeDefnSimpleRepr.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeDefnSimpleRepr">
<summary>
 Represents the syntax tree for the core of a simple type definition, in either signature
 or implementation.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeDefnKind">
<summary>
 Represents the kind of a type definition whether explicit or inferred
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMemberSig.NestedType">
<summary>
 A nested type definition in a signature file (an unimplemented feature)
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMemberSig.ValField">
<summary>
 A &apos;val&apos; definition in a type in a signature file
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMemberSig.Inherit">
<summary>
 An &apos;inherit&apos; definition in a type in a signature file
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMemberSig.Interface">
<summary>
 An interface definition in a type in a signature file
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMemberSig.Member">
<summary>
 A member definition in a type in a signature file
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynMemberSig.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMemberSig">
<summary>
 Represents the syntax tree for a member signature (used in signature files, abstract member declarations
 and member constraints)
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMemberKind.PropertyGetSet">
<summary>
 An artificial member kind used prior to the point where a
 get/set property is split into two distinct members.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMemberKind.PropertySet">
<summary>
 The member kind is property setter
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMemberKind.PropertyGet">
<summary>
 The member kind is property getter
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMemberKind.Member">
<summary>
 The member kind is not yet determined
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMemberKind.Constructor">
<summary>
 The member is a object model constructor
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMemberKind.ClassConstructor">
<summary>
 The member is a class initializer
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMemberKind">
<summary>
 Note the member kind is actually computed partially by a syntax tree transformation in tc.fs
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynMemberFlags.MemberKind">
<summary>
 The kind of the member
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynMemberFlags.GetterOrSetterIsCompilerGenerated">
<summary>
 The member was generated by the compiler
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynMemberFlags.IsFinal">
<summary>
 The member is &apos;final&apos;
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynMemberFlags.IsOverrideOrExplicitImpl">
<summary>
 The member is an &apos;override&apos; or explicit interface implementation
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynMemberFlags.IsDispatchSlot">
<summary>
 The member is a dispatch slot
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynMemberFlags.IsInstance">
<summary>
 The member is an instance member (non-static)
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMemberFlags">
<summary>
 Represents the flags for a &apos;member&apos; declaration
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynBindingReturnInfo">
<summary>
 Represents the return information in a binding for a &apos;let&apos; or &apos;member&apos; declaration
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynBinding">
<summary>
 Represents a binding for a &apos;let&apos; or &apos;member&apos; declaration
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynValData">
<summary>
 Represents extra information about the declaration of a value
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynAttributeList.Range">
<summary>
 The syntax range of the list of attributes
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynAttributeList.Attributes">
<summary>
 The list of attributes
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynAttributeList">
<summary>
 List of attributes enclosed in [&lt; ... &gt;].
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynAttribute.Range">
<summary>
 The syntax range of the attribute
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynAttribute.AppliesToGetterAndSetter">
<summary>
 Is this attribute being applied to a property getter or setter?
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynAttribute.Target">
<summary>
 Target specifier, e.g. &quot;assembly&quot;, &quot;module&quot;, etc.
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynAttribute.ArgExpr">
<summary>
 The argument of the attribute, perhaps a tuple
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynAttribute.TypeName">
<summary>
 The name of the type for the attribute
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynAttribute">
<summary>
 Represents an attribute
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynMatchClause.RangeOfGuardAndRhs">
<summary>
 Gets the syntax range of part of this construct
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynMatchClause.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynMatchClause.IsTrueMatchClause">
<summary>
 Is a pattern used in a true match clause e.g. | pat -&gt; expr
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMatchClause">
<summary>
 Represents a clause in a &apos;match&apos; expression
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynInterfaceImpl">
<summary>
 Represents a set of bindings that implement an interface
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynPat.FromParseError">
<summary>
 A pattern arising from a parse error
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynPat.InstanceMember">
<summary>
 Used internally in the type checker
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynPat.QuoteExpr">
<summary>
 &amp;lt;@ expr @&amp;gt;, used for active pattern arguments
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynPat.IsInst">
<summary>
 A type test pattern &apos;:? type &apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynPat.OptionalVal">
<summary>
 &apos;?id&apos; -- for optional argument names
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynPat.Null">
<summary>
 The &apos;null&apos; pattern
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynPat.Record">
<summary>
 A record pattern
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynPat.ArrayOrList">
<summary>
 An array or a list as a pattern
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynPat.Paren">
<summary>
 A parenthesized pattern
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynPat.Tuple">
<summary>
 A tuple pattern
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynPat.LongIdent">
<summary>
 A long identifier pattern possibly with argument patterns
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynPat.As">
<summary>
 A conjunctive pattern &apos;pat1 as pat2&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynPat.Ands">
<summary>
 A conjunctive pattern &apos;pat1 &amp; pat2&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynPat.ListCons">
<summary>
 A conjunctive pattern &apos;pat1 :: pat2&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynPat.Or">
<summary>
 A disjunctive pattern &apos;pat1 | pat2&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynPat.Attrib">
<summary>
 An attributed pattern, used in argument or declaration position
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynPat.Typed">
<summary>
 A typed pattern &apos;pat : type&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynPat.Named">
<summary>
 A name pattern &apos;ident&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynPat.Wild">
<summary>
 A wildcard &apos;_&apos; in a pattern
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynPat.Const">
<summary>
 A constant in a pattern
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynPat.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynPat">
<summary>
 Represents a syntax tree for an F# pattern
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynArgPats">
<summary>
 Represents a syntax tree for arguments patterns
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynSimplePats">
<summary>
 Represents a simple set of variable bindings a, (a, b) or (a: Type, b: Type) at a lambda,
 function definition or other binding point, after the elimination of pattern matching
 from the construct, e.g. after changing a &quot;function pat1 -&gt; rule1 | ...&quot; to a
 &quot;fun v -&gt; match v with ...&quot;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynStaticOptimizationConstraint.WhenTyparIsStruct">
<summary>
 A static optimization conditional that activates for a struct
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynStaticOptimizationConstraint.WhenTyparTyconEqualsTycon">
<summary>
 A static optimization conditional that activates for a particular type instantiation
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynStaticOptimizationConstraint">
<summary>
 Represents a syntax tree for a static optimization constraint in the F# core library
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynSimplePatAlternativeIdInfo.Decided">
<summary>
 We have decided to use an alternative name in the pattern and related expression
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynSimplePatAlternativeIdInfo.Undecided">
<summary>
 We have not decided to use an alternative name in the pattern and related expression
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynSimplePatAlternativeIdInfo">
<summary>
 Represents the alternative identifier for a simple pattern
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynSimplePat.Attrib">
<summary>
 An attributed simple pattern
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynSimplePat.Typed">
<summary>
 A type annotated simple pattern
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynSimplePat.Id">
<summary>
 Indicates a simple pattern variable.

 altNameRefCell:
   Normally &apos;None&apos; except for some compiler-generated variables in desugaring pattern matching.
   Pattern processing sets this reference for hidden variable introduced
   by desugaring pattern matching in arguments. The info indicates an
   alternative (compiler generated) identifier to be used because the
   name of the identifier is already bound.

 isCompilerGenerated: true if a compiler generated name
 isThisVal: true if &apos;this&apos; variable in member
 isOptional: true if a &apos;?&apos; is in front of the name
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynSimplePat">
<summary>
 Represents a syntax tree for simple F# patterns
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynExprAndBang.Trivia">
<summary>
 Gets the trivia associated with this construct
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynExprAndBang.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.Dynamic">
<summary>
 F# syntax: f?x
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.DebugPoint">
<summary>
 Debug points arising from computation expressions
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.InterpolatedString">
<summary>
 F# syntax: interpolated string, e.g. &quot;abc{x}&quot; or &quot;abc{x,3}&quot; or &quot;abc{x:N4}&quot;
 Note the string ranges include the quotes, verbatim markers, dollar sign and braces
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.Fixed">
<summary>
 &apos;use x = fixed expr&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.DiscardAfterMissingQualificationAfterDot">
<summary>
 Inserted for error recovery when there is &quot;expr.&quot; and missing tokens or error recovery after the dot
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.FromParseError">
<summary>
 Inserted for error recovery
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.ArbitraryAfterError">
<summary>
 Inserted for error recovery
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.LibraryOnlyUnionCaseFieldSet">
<summary>
 Only used in FSharp.Core
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.LibraryOnlyUnionCaseFieldGet">
<summary>
 Only used in FSharp.Core
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.LibraryOnlyStaticOptimization">
<summary>
 Only used in FSharp.Core
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.LibraryOnlyILAssembly">
<summary>
 Only used in FSharp.Core
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.WhileBang">
<summary>
 F# syntax: &apos;while! ... do ...&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.DoBang">
<summary>
 F# syntax: do! expr
 Computation expressions only
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.MatchBang">
<summary>
 F# syntax: match! expr with pat1 -&gt; expr | ... | patN -&gt; exprN
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.LetOrUseBang">
<summary>
 F# syntax: let! pat = expr in expr
 F# syntax: use! pat = expr in expr
 F# syntax: let! pat = expr and! ... and! ... and! pat = expr in expr
 Computation expressions only
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.YieldOrReturnFrom">
<summary>
 F# syntax: yield! expr
 F# syntax: return! expr
 Computation expressions only
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.YieldOrReturn">
<summary>
 F# syntax: yield expr
 F# syntax: return expr
 Computation expressions only
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.SequentialOrImplicitYield">
<summary>
 Used internally during type checking for translating computation expressions.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.ImplicitZero">
<summary>
 Used in parser error recovery and internally during type checking for translating computation expressions.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.JoinIn">
<summary>
 F# syntax: ... in ...
 Computation expressions only, based on JOIN_IN token from lex filter
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.TraitCall">
<summary>
 F# syntax: ((type1 or ... or typeN): (member-dig) expr)
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.AddressOf">
<summary>
 F# syntax: &amp;expr, &amp;&amp;expr
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.Null">
<summary>
 F# syntax: null
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.InferredDowncast">
<summary>
 F# syntax: downcast expr
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.InferredUpcast">
<summary>
 F# syntax: upcast expr
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.Downcast">
<summary>
 F# syntax: expr :?&gt; type
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.Upcast">
<summary>
 F# syntax: expr :&gt; type
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.TypeTest">
<summary>
 F# syntax: expr :? type
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.DotNamedIndexedPropertySet">
<summary>
 F# syntax: expr.Items (e1) &lt;- e2, rarely used named-property-setter notation, e.g. (stringExpr).Chars(3) &lt;- &apos;a&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.NamedIndexedPropertySet">
<summary>
 F# syntax: Type.Items(e1) &lt;- e2, rarely used named-property-setter notation, e.g. Foo.Bar.Chars(3) &lt;- &apos;a&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.DotIndexedSet">
<summary>
 F# syntax: expr.[expr, ..., expr] &lt;- expr
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.DotIndexedGet">
<summary>
 F# syntax: expr.[expr, ..., expr]
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.Set">
<summary>
 F# syntax: expr &lt;- expr
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.DotSet">
<summary>
 F# syntax: expr.ident...ident &lt;- expr
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.DotLambda">
<summary>
 F# syntax: _.ident.ident
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.DotGet">
<summary>
 F# syntax: expr.ident.ident
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.LongIdentSet">
<summary>
 F# syntax: ident.ident...ident &lt;- expr
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.LongIdent">
<summary>
 F# syntax: ident.ident...ident

 isOptional: true if preceded by a &apos;?&apos; for an optional named parameter
 altNameRefCell: Normally &apos;None&apos; except for some compiler-generated
 variables in desugaring pattern matching. See SynSimplePat.Id
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.Ident">
<summary>
 F# syntax: ident
 Optimized representation for SynExpr.LongIdent (false, [id], id.idRange)
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.Typar">
<summary>
 F# syntax: &apos;T (for &apos;T.ident).
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.IfThenElse">
<summary>
 F# syntax: if expr then expr
 F# syntax: if expr then expr else expr
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.Sequential">
<summary>
 F# syntax: expr; expr

  isTrueSeq: false indicates &quot;let v = a in b; v&quot;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.Lazy">
<summary>
 F# syntax: lazy expr
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.TryFinally">
<summary>
 F# syntax: try expr finally expr
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.TryWith">
<summary>
 F# syntax: try expr with pat -&gt; expr
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.LetOrUse">
<summary>
 F# syntax: let pat = expr in expr
 F# syntax: let f pat1 .. patN = expr in expr
 F# syntax: let rec f pat1 .. patN = expr in expr
 F# syntax: use pat = expr in expr
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.TypeApp">
<summary>
 F# syntax: expr&lt;type1, ..., typeN&gt;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.App">
<summary>
 F# syntax: f x

 flag: indicates if the application is syntactically atomic, e.g. f.[1] is atomic, but &apos;f x&apos; is not
 isInfix is true for the first app of an infix operator, e.g. 1+2
 becomes App(App(+, 1), 2), where the inner node is marked isInfix
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.Assert">
<summary>
 F# syntax: assert expr
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.Do">
<summary>
 F# syntax: do expr
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.Match">
<summary>
 F# syntax: match expr with pat1 -&gt; expr | ... | patN -&gt; exprN
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.MatchLambda">
<summary>
 F# syntax: function pat1 -&gt; expr | ... | patN -&gt; exprN
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.Lambda">
<summary>
 First bool indicates if lambda originates from a method. Patterns here are always &quot;simple&quot;
 Second bool indicates if this is a &quot;later&quot; part of an iterated sequence of lambdas
 parsedData keeps original parsed patterns and expression,
 prior to transforming to &quot;simple&quot; patterns and iterated lambdas

 F# syntax: fun pat -&gt; expr
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.ComputationExpr">
<summary>
 F# syntax: { expr }
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.IndexFromEnd">
<summary>
 F# syntax: ^expr, used for from-end-of-collection indexing and ^T.Operation
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.IndexRange">
<summary>
 F# syntax: expr..
 F# syntax: ..expr
 F# syntax: expr..expr
 F# syntax: *
 A two-element range indexer argument a..b, a.., ..b. Also used to represent
 a range in a list, array or sequence expression.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.ArrayOrListComputed">
<summary>
 F# syntax: [ expr ], [| expr |]
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.ForEach">
<summary>
 F# syntax: &apos;for ... in ... do ...&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.For">
<summary>
 F# syntax: &apos;for i = ... to ... do ...&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.While">
<summary>
 F# syntax: &apos;while ... do ...&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.ObjExpr">
<summary>
 F# syntax: { new ... with ... }
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.New">
<summary>
 F# syntax: new C(...)
 The flag is true if known to be &apos;family&apos; (&apos;protected&apos;) scope
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.Record">
<summary>
 F# syntax: { f1=e1; ...; fn=en }
 inherit includes location of separator (for tooling)
 copyOpt contains range of the following WITH part (for tooling)
 every field includes range of separator after the field (for tooling)
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.ArrayOrList">
<summary>
 F# syntax: [ e1; ...; en ], [| e1; ...; en |]
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.AnonRecd">
<summary>
 F# syntax: {| id1=e1; ...; idN=eN |}
 F# syntax: struct {| id1=e1; ...; idN=eN |}
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.Tuple">
<summary>
 F# syntax: e1, ..., eN
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.Typed">
<summary>
 F# syntax: expr: type
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.Const">
<summary>
 F# syntax: 1, 1.3, () etc.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.Quote">
<summary>
 F# syntax: &lt;@ expr @&gt;, &lt;@@ expr @@&gt;

 Quote(operator, isRaw, quotedSynExpr, isFromQueryExpression, m)
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr.Paren">
<summary>
 F# syntax: (expr)

 Parenthesized expressions. Kept in AST to distinguish A.M((x, y))
 from A.M(x, y), among other things.
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynExpr.RangeOfFirstPortion">
<summary>
 Attempt to get the range of the first token or initial portion only - this
 is ad-hoc, just a cheap way to improve a certain &apos;query custom operation&apos; error range
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynExpr.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynExpr.IsArbExprAndThusAlreadyReportedError">
<summary>
 Indicates if this expression arises from error recovery
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynExpr">
<summary>
 Represents a syntax tree for F# expressions
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynType.Intersection">
<summary>
 F# syntax: x: #I1 &amp; #I2
 F# syntax: x: &apos;t &amp; #I1 &amp; #I2
 Shorthand for x: &apos;t when &apos;t :&gt; I1 and &apos;t :&gt; I2
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynType.FromParseError">
<summary>
 A type arising from a parse error
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynType.Or">
<summary>
 F# syntax: ^a or ^b, used in trait calls
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynType.SignatureParameter">
<summary>
 F# syntax: a: b, used in signatures and type annotations
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynType.StaticConstantNamed">
<summary>
 F# syntax: ident=1 etc., used in static parameters to type providers
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynType.StaticConstantExpr">
<summary>
 F# syntax: const expr, used in static parameters to type providers
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynType.StaticConstantNull">
<summary>
 F# syntax: null, used in parameters to type providers
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynType.StaticConstant">
<summary>
 F# syntax: 1, &quot;abc&quot; etc, used in parameters to type providers
 For the dimensionless units i.e. 1, and static parameters to provided types
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynType.MeasurePower">
<summary>
 F# syntax: for units of measure e.g. m^3, kg^1/2
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynType.HashConstraint">
<summary>
 F# syntax: #type
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynType.WithGlobalConstraints">
<summary>
 F# syntax: typ with constraints
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynType.Anon">
<summary>
 F# syntax: _
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynType.Var">
<summary>
 F# syntax: &apos;Var
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynType.Fun">
<summary>
 F# syntax: type -&gt; type
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynType.Array">
<summary>
 F# syntax: type[]
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynType.AnonRecd">
<summary>
 F# syntax: {| id: type; ...; id: type |}
 F# syntax: struct {| id: type; ...; id: type |}
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynType.Tuple">
<summary>
 F# syntax: type * ... * type
 F# syntax: struct (type * ... * type)
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynType.LongIdentApp">
<summary>
 F# syntax: type.A.B.C&lt;type, ..., type&gt;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynType.App">
<summary>
 F# syntax: type&lt;type, ..., type&gt; or type type or (type, ..., type) type
   isPostfix: indicates a postfix type application e.g. &quot;int list&quot; or &quot;(int, string) dict&quot;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynType.LongIdent">
<summary>
 F# syntax: A.B.C
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynType.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynType">
<summary>
 Represents a syntax tree for F# types
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTyparDecls">
<summary>
 List of type parameter declarations with optional type constraints,
 enclosed in `&lt; ... &gt;` (postfix) or `( ... )` (prefix), or a single prefix parameter.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeConstraint.WhereSelfConstrained">
<summary>
 F# syntax is SomeThing&lt;&apos;T&gt;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeConstraint.WhereTyparIsDelegate">
<summary>
 F# syntax is &apos;typar: delegate&lt;&apos;Args, unit&gt;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeConstraint.WhereTyparIsEnum">
<summary>
 F# syntax is &apos;typar: enum&lt;&apos;UnderlyingType&gt;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeConstraint.WhereTyparSupportsMember">
<summary>
 F# syntax is ^T: (static member MemberName: ^T * int -&gt; ^T)
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeConstraint.WhereTyparSubtypeOfType">
<summary>
 F# syntax is &apos;typar :&gt; type
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeConstraint.WhereTyparDefaultsToType">
<summary>
 F# syntax is default ^T: type
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeConstraint.WhereTyparIsEquatable">
<summary>
 F# syntax is &apos;typar: equality
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeConstraint.WhereTyparIsComparable">
<summary>
 F# syntax is &apos;typar: comparison
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeConstraint.WhereTyparNotSupportsNull">
<summary>
 F# syntax is &apos;typar : null
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeConstraint.WhereTyparSupportsNull">
<summary>
 F# syntax is &apos;typar: null
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeConstraint.WhereTyparIsUnmanaged">
<summary>
 F# syntax is &apos;typar: unmanaged
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeConstraint.WhereTyparIsReferenceType">
<summary>
 F# syntax: is &apos;typar: not struct
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeConstraint.WhereTyparIsValueType">
<summary>
 F# syntax: is &apos;typar: struct
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypeConstraint">
<summary>
 The unchecked abstract syntax tree of F# type constraints
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTyparDecl">
<summary>
 Represents the explicit declaration of a type parameter
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynBindingKind.Do">
<summary>
 A &apos;do&apos; binding in a module. Must have type &apos;unit&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynBindingKind.Normal">
<summary>
 A normal &apos;let&apos; binding in a module
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynBindingKind.StandaloneExpression">
<summary>
 A standalone expression in a module
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynBindingKind">
<summary>
 The kind associated with a binding - &quot;let&quot;, &quot;do&quot; or a standalone expression
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.ExprAtomicFlag">
<summary>
 Indicates if an expression is an atomic expression.

 An atomic expression has no whitespace unless enclosed in parentheses, e.g.
 1, &quot;3&quot;, ident, ident.[expr] and (expr). If an atomic expression has type T,
 then the largest expression ending at the same range as the atomic expression
 also has type T.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.RecordFieldName">
<summary>
 Represents a record field name plus a flag indicating if given record field name is syntactically
 correct and can be used in name resolution.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.BlockSeparator">
<summary>
 Represents the location of the separator block + optional position
 of the semicolon (used for tooling support)
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SeqExprOnly.SeqExprOnly">
<summary>
 Indicates if a for loop is &apos;for x in e1 -&gt; e2&apos;, only valid in sequence expressions
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SeqExprOnly">
<summary>
 Indicates if a for loop is &apos;for x in e1 -&gt; e2&apos;, only valid in sequence expressions
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.DebugPointAtBinding">
<summary>
 Represents whether a debug point should be present for a &apos;let&apos; binding,
 that is whether the construct corresponds to a debug point in the original source.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.DebugPointAtWhile">
<summary>
 Represents whether a debug point should be present for the &apos;while&apos; in a &apos;while...&apos; loop,
 that is whether the construct corresponds to a debug point in the original source.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.DebugPointAtInOrTo">
<summary>
 Represents whether a debug point should be present for the &apos;in&apos; or &apos;to&apos; of a &apos;for...&apos; loop,
 that is whether the construct corresponds to a debug point in the original source.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.DebugPointAtFor">
<summary>
 Represents whether a debug point should be present for the &apos;for&apos; in a &apos;for...&apos; loop,
 that is whether the construct corresponds to a debug point in the original source.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.DebugPointAtFinally">
<summary>
 Represents whether a debug point should be present for the &apos;finally&apos; in a &apos;try .. finally&apos;,
 that is whether the construct corresponds to a debug point in the original source.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.DebugPointAtWith">
<summary>
 Represents whether a debug point should be present for the &apos;with&apos; in a &apos;try .. with&apos;,
 that is whether the construct corresponds to a debug point in the original source.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.DebugPointAtTry">
<summary>
 Represents whether a debug point should be present for a &apos;try&apos;, that is whether
 the construct corresponds to a debug point in the original source.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.DebugPointAtSequential">
<summary>
 Represents whether a debug point should be suppressed for either the
 first or second part of a sequential execution, that is whether the
 construct corresponds to a debug point in the original source.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.DebugPointAtLeafExpr">
<summary>
 Represents a debug point at a leaf expression (e.g. an application or constant).
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.DebugPointAtTarget">
<summary>
 Represents whether a debug point should be present for the target
 of a decision tree, that is whether the construct corresponds to a debug
 point in the original source.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynAccess.Private">
<summary>
 A construct marked or assumed &apos;private&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynAccess.Internal">
<summary>
 A construct marked or assumed &apos;internal&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynAccess.Public">
<summary>
 A construct marked or assumed &apos;public&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynAccess">
<summary>
 Represents an accessibility modifier in F# syntax
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynRationalConst">
<summary>
 Represents an unchecked syntax tree of F# unit of measure exponents.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMeasure.Paren">
<summary>
 A parenthesized measure
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMeasure.Var">
<summary>
 A variable unit of measure
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMeasure.Anon">
<summary>
 An anonymous (inferred) unit of measure
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMeasure.One">
<summary>
 The &apos;1&apos; unit of measure
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMeasure.Power">
<summary>
 A power of a unit of measure, e.g. &apos;kg ^ 2&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMeasure.Divide">
<summary>
 A division of two units of measure, e.g. &apos;kg / m&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMeasure.Seq">
<summary>
 A sequence of several units of measure, e.g. &apos;kg m m&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMeasure.Product">
<summary>
 A product of two units of measure, e.g. &apos;kg * m&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMeasure.Named">
<summary>
 A named unit of measure
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynMeasure">
<summary>
 Represents an unchecked syntax tree of F# unit of measure annotations.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynConst.SourceIdentifier">
<summary>
 Source Line, File, and Path Identifiers
 Containing both the original value as the evaluated value.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynConst.Measure">
<summary>
 Old comment: &quot;we never iterate, so the const here is not another SynConst.Measure&quot;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynConst.UInt16s">
<summary>
 Used internally in the typechecker once an array of unit16 constants
 is detected, to allow more efficient processing of large arrays of uint16 constants.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynConst.Bytes">
<summary>
 F# syntax: verbatim or regular byte string, e.g. &quot;abc&quot;B.

 Also used internally in the typechecker once an array of unit16 constants
 is detected, to allow more efficient processing of large arrays of uint16 constants.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynConst.String">
<summary>
 F# syntax: verbatim or regular string, e.g. &quot;abc&quot;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynConst.UserNum">
<summary>
 UserNum(value, suffix)

 F# syntax: 1Q, 1Z, 1R, 1N, 1G
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynConst.Decimal">
<summary>
 F# syntax: 23.4M
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynConst.Char">
<summary>
 F# syntax: &apos;a&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynConst.Double">
<summary>
 F# syntax: 1.30, 1.40e10 etc.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynConst.Single">
<summary>
 F# syntax: 1.30f, 1.40e10f etc.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynConst.UIntPtr">
<summary>
 F# syntax: 13un
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynConst.IntPtr">
<summary>
 F# syntax: 13n
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynConst.UInt64">
<summary>
 F# syntax: 13UL
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynConst.Int64">
<summary>
 F# syntax: 13L
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynConst.UInt32">
<summary>
 F# syntax: 13u, 0x4000u, 0o0777u
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynConst.Int32">
<summary>
 F# syntax: 13, 0x4000, 0o0777
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynConst.UInt16">
<summary>
 F# syntax: 13us, 0x4000us, 0o0777us, 0b0111101us
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynConst.Int16">
<summary>
 F# syntax: 13s, 0x4000s, 0o0777s, 0b0111101s
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynConst.Byte">
<summary>
 F# syntax: 13uy, 0x40uy, 0oFFuy, 0b0111101uy
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynConst.SByte">
<summary>
 F# syntax: 13y, 0xFFy, 0o077y, 0b0111101y
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynConst.Bool">
<summary>
 F# syntax: true, false
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynConst.Unit">
<summary>
 F# syntax: ()
</summary>
</member>
<member name="M:FSharp.Compiler.Syntax.SynConst.Range(FSharp.Compiler.Text.Range)">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynConst">
<summary>
 The unchecked abstract syntax tree of constants in F# types and expressions.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynByteStringKind">
<summary>
 Indicate if the byte string had a special format
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynStringKind">
<summary>
 Indicate if the string had a special format
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynTypar.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynTypar">
<summary>
 Represents a syntactic type parameter
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.TyparStaticReq.HeadType">
<summary>
 The construct is a statically inferred type inference variable &apos;^T&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.TyparStaticReq.None">
<summary>
 The construct is a normal type inference variable
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.TyparStaticReq">
<summary>
 Represents whether a type parameter has a static requirement or not (^T or &apos;T)
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.ParserDetail.ErrorRecovery">
<summary>
 The construct arises from error recovery
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.ParserDetail.Ok">
<summary>
 The construct arises normally
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.ParserDetail">
<summary>
 Indicates if the construct arises from error recovery
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynLongIdent.Trivia">
<summary>
 Get the trivia of the idents
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynLongIdent.ThereIsAnExtraDotAtTheEnd">
<summary>
 Indicates if the construct ends in &apos;.&apos; due to error recovery
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynLongIdent.RangeWithoutAnyExtraDot">
<summary>
 Gets the syntax range for part of this construct
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynLongIdent.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynLongIdent.LongIdent">
<summary>
 Get the long ident for this construct
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynLongIdent.IdentsWithTrivia">
<summary>
 Get the idents with potential trivia attached
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SynLongIdent.Dots">
<summary>
 Get the dot ranges
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynLongIdent">
<summary>
 Represents a long identifier with possible &apos;.&apos; at end.

 Typically dotRanges.Length = lid.Length-1, but they may be same if (incomplete) code ends in a dot, e.g. &quot;Foo.Bar.&quot;
 The dots mostly matter for parsing, and are typically ignored by the typechecker, but
 if dotRanges.Length = lid.Length, then the parser must have reported an error, so the typechecker is allowed
 more freedom about typechecking these expressions.
 LongIdent can be empty list - it is used to denote that name of some AST element is absent (i.e. empty type name in inherit)
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.LongIdent">
<summary>
 Represents a long identifier e.g. &apos;A.B.C&apos;
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SynIdent">
<summary>
 Represents an identifier with potentially additional trivia information.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.Ident">
<summary>
 Represents an identifier in F# code
</summary>
</member>
<member name="M:FSharp.Compiler.Syntax.SyntaxVisitorBase`1.VisitExpr(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SyntaxNode},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Syntax.SynExpr,Microsoft.FSharp.Core.FSharpOption{`0}},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Syntax.SynExpr,Microsoft.FSharp.Core.FSharpOption{`0}},FSharp.Compiler.Syntax.SynExpr)">
<summary>
 Controls the behavior when a SynExpr is reached; it can just do
          defaultTraverse(expr)      if you have no special logic for this node, and want the default processing to pick which sub-node to dive deeper into
 or can inject non-default behavior, which might incorporate:
          traverseSynExpr(subExpr)   to recurse deeper on some particular sub-expression based on your own logic
 path helps to track AST nodes that were passed during traversal
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SyntaxVisitorPath">
<summary>
 Represents the set of ancestor nodes traversed before reaching
 the current node in a traversal of the untyped abstract syntax tree.
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.SyntaxNode.Range">
<summary>
 The range of the syntax node, inclusive of its contents.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SyntaxNode">
<summary>
 Represents a major syntax node in the untyped abstract syntax tree.
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.PrettyNaming.keywordsWithDescription">
<summary>
 Keywords paired with their descriptions. Used in completion and quick info.
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.PrettyNaming.suffixForTupleElementAssignmentTarget">
<summary>
 Indicates a ValRef generated to facilitate tuple eliminations
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.PrettyNaming.suffixForVariablesThatMayNotBeEliminated">
<summary>
 Mark some variables (the ones we introduce via abstractBigTargets) as don&apos;t-eliminate
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.PrettyNaming.FsiDynamicModulePrefix">
<summary>
 The prefix of the names used for the fake namespace path added to all dynamic code entries in FSI.EXE
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.PrettyNaming.mkExceptionFieldName">
<summary>
 Reuses generated exception field name objects for common field numbers
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.PrettyNaming.mkUnionCaseFieldName">
<summary>
 Reuses generated union case field name objects for common field numbers
</summary>
</member>
<member name="M:FSharp.Compiler.Syntax.PrettyNaming.ComputeMangledNameWithoutDefaultArgValues``1(System.String,``0[],System.Tuple{System.String,Microsoft.FSharp.Core.FSharpOption{System.String}}[])">
<summary>
 Mangle the static parameters for a provided type or method
</summary>
</member>
<member name="M:FSharp.Compiler.Syntax.PrettyNaming.MangleProvidedTypeName(System.String,System.Tuple{System.String,System.String}[])">
<summary>
 Mangle the static parameters for a provided type or method
</summary>
</member>
<member name="M:FSharp.Compiler.Syntax.PrettyNaming.ChopPropertyName(System.String)">
<summary>
 Try to chop &quot;get_&quot; or &quot;set_&quot; from a string.
 If the string does not start with &quot;get_&quot; or &quot;set_&quot;, this function raises an exception.
</summary>
</member>
<member name="M:FSharp.Compiler.Syntax.PrettyNaming.TryChopPropertyName(System.String)">
<summary>
 Try to chop &quot;get_&quot; or &quot;set_&quot; from a string
</summary>
</member>
<member name="M:FSharp.Compiler.Syntax.PrettyNaming.IsLongIdentifierPartCharacter(System.Char)">
<summary>
 Is this character a part of a long identifier?
</summary>
</member>
<member name="M:FSharp.Compiler.Syntax.PrettyNaming.IsIdentifierPartCharacter(System.Char)">
<summary>
 The characters that are allowed to be in an identifier.
</summary>
</member>
<member name="M:FSharp.Compiler.Syntax.PrettyNaming.IsIdentifierFirstCharacter(System.Char)">
<summary>
 The characters that are allowed to be the first character of an identifier.
</summary>
</member>
<member name="M:FSharp.Compiler.Syntax.PrettyNaming.ConvertValLogicalNameToDisplayLayout(System.Boolean,Microsoft.FSharp.Core.FSharpFunc{System.String,FSharp.Compiler.Text.Layout},System.String)">
<summary>
 Like ConvertValLogicalNameToDisplayName but produces a tagged layout
</summary>
</member>
<member name="M:FSharp.Compiler.Syntax.PrettyNaming.ConvertLogicalNameToDisplayLayout(Microsoft.FSharp.Core.FSharpFunc{System.String,FSharp.Compiler.Text.Layout},System.String)">
<summary>
 Like ConvertLogicalNameToDisplayName but produces a tagged layout
</summary>
</member>
<member name="M:FSharp.Compiler.Syntax.PrettyNaming.ConvertValLogicalNameToDisplayName(System.Boolean,System.String)">
<summary>
 Take a core display name for a value (e.g. op_Addition or PropertyName) and convert it to display text
     Foo                   --&gt; Foo
     +                     --&gt; ``+``
     op_Addition           --&gt; (+)
     op_Multiply           --&gt; ( * )
     op_DereferencePercent --&gt; (!%)
     A-B                   --&gt; ``A-B``
     |A|_|                 --&gt; (|A|_|)
     let                   --&gt; ``let``
     type                  --&gt; ``type``
     params                --&gt; ``params``
     base                  --&gt; base
     or                    --&gt; or
     mod                   --&gt; mod
</summary>
</member>
<member name="M:FSharp.Compiler.Syntax.PrettyNaming.ConvertValLogicalNameToDisplayNameCore(System.String)">
<summary>
 Converts the logical name for and operator back into the core of a display name. For example:
     Foo                   --&gt; Foo
     +                     --&gt; +
     op_Addition           --&gt; +
     op_DereferencePercent --&gt; !%
     A-B                   --&gt; A-B
     |A|_|                 --&gt; |A|_|
     base                  --&gt; base        regardless of IsBaseVal
 Used on names of all kinds

 TODO: We should assess uses of this function.

 In any cases it is used it probably indicates that text is being
 generated which:
    1. does not contain double-backticks for non-identifiers
    2. does not put parentheses around operators or active pattern names

 If the text is immediately in quotes, this is generally ok, e.g.

         error FS0038: &apos;+&apos; is bound twice in this pattern
         error FS0038: &apos;|A|_|&apos; is bound twice in this pattern
         error FS0038: &apos;a a&apos; is bound twice in this pattern

 If not, the it is likely this should be replaced by ConvertValLogicalNameToDisplayName.
</summary>
</member>
<member name="M:FSharp.Compiler.Syntax.PrettyNaming.ConvertLogicalNameToDisplayName(System.String)">
<summary>
 Take a core display name (e.g. &quot;List&quot; or &quot;Strange module name&quot;) and convert it to display text
 by adding backticks if necessary.
     Foo                   --&gt; Foo
     +                     --&gt; ``+``
     A-B                   --&gt; ``A-B``
</summary>
</member>
<member name="M:FSharp.Compiler.Syntax.PrettyNaming.CompileOpName(System.String)">
<summary>
 Converts the core of an operator name into a logical name. For example,
    +  --&gt; op_Addition
    !%  --&gt; op_DereferencePercent
 Only used on actual operator names
</summary>
</member>
<member name="M:FSharp.Compiler.Syntax.PrettyNaming.IsLogicalOpName(System.String)">
<summary>
 Is the name a logical operator name, including unary, binary and ternary operators
    op_UnaryPlus         - yes
    op_Addition          - yes
    op_Range             - yes (?)
    op_RangeStep         - yes (?)
    op_DynamicAssignment - yes
    op_Quack             - no
    +                    - no
    ABC                  - no
    ABC DEF              - no
    base                 - no
    |A|_|                - no
</summary>
</member>
<member name="M:FSharp.Compiler.Syntax.PrettyNaming.NormalizeIdentifierBackticks(System.String)">
<summary>
 Adds double backticks if necessary to make a valid identifier, e.g.
     op_Addition  --&gt;  op_Addition
     +            --&gt;  ``+``    (this is not op_Addition)
     |&gt;&gt;          --&gt;  ``|&gt;&gt;``  (this is not an op_)
     A-B          --&gt;  ``A-B``
     AB           --&gt;  AB
     |A|_|        --&gt;  |A|_|    this is an active pattern name, needs parens not backticks
 Removes double backticks if not necessary to make a valid identifier, e.g.
     ``A``        --&gt; A
     ``A-B``      --&gt; ``A-B``
</summary>
</member>
<member name="M:FSharp.Compiler.Syntax.PrettyNaming.IsActivePatternName(System.String)">
<summary>
 Determines if the specified name is a valid name for an active pattern.
     |A|_|        --&gt; true
     |A|B|        --&gt; true
     |A|          --&gt; true
     |            --&gt; false
     ||           --&gt; false
     op_Addition  --&gt; false

 TBD: needs unit testing
</summary>
</member>
<member name="M:FSharp.Compiler.Syntax.PrettyNaming.IsIdentifierName(System.String)">
<summary>
 Is the name a valid F# identifier, primarily used internally in PrettyNaming.fs for determining if an
 identifier needs backticks.

 In general do not use this routine. It is only used in one quick fix, for determining if it is valid
 to add &quot;_&quot; in front of an identifier.

     A            --&gt; true
     A&apos;           --&gt; true
     _A           --&gt; true
     A0           --&gt; true
     |A|B|        --&gt; false
     op_Addition  --&gt; true
     +            --&gt; false
     let          --&gt; false
     base         --&gt; false

 TBD: needs unit testing
</summary>
</member>
<member name="M:FSharp.Compiler.Syntax.PrettyNaming.IsOperatorDisplayName(System.String)">
<summary>
 Returns `true` if given string is an operator display name, e.g.
    ( |&gt;&gt; )
    |&gt;&gt;
    ..
</summary>
</member>
<member name="P:FSharp.Compiler.Syntax.PrettyNaming.opNamePrefix">
<summary>
 Prefix for compiled (mangled) operator names.
</summary>
</member>
<member name="T:FSharp.Compiler.Syntax.PrettyNaming">
<summary>
 Some general F# utilities for mangling / unmangling / manipulating names.
 Anything to do with special names of identifiers and other lexical rules
</summary>
</member>
<member name="M:FSharp.Compiler.Syntax.ParsedInputModule.tryPickLast``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SyntaxNode},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Syntax.SyntaxNode,Microsoft.FSharp.Core.FSharpOption{``0}}},FSharp.Compiler.Text.Position,FSharp.Compiler.Syntax.ParsedInput)">
 <summary>
 Applies the given function to each node of the AST and its context (path)
 down to a given position, returning <c>Some x</c> for the last (deepest) node
 for which the function returns <c>Some x</c> for some value <c>x</c>, otherwise <c>None</c>.
 Traversal is short-circuited if no matching node is found through the given position.
 </summary>
 <param name="chooser">The function to apply to each node and its context to derive an optional value.</param>
 <param name="position">The position in the input file down to which to apply the function.</param>
 <param name="parsedInput">The AST to search.</param>
 <returns>The last (deepest) value for which the function returns <c>Some</c>, or <c>None</c> if no matching node is found.</returns>
 <example>
 <code lang="fsharp">
 let range =
     (pos, parsedInput)
     ||> ParsedInput.tryPickLast (fun path node ->
         match node, path with
         | FuncIdent range -> Some range
         | _ -> None)
 </code>
 </example>
</member>
<member name="M:FSharp.Compiler.Syntax.ParsedInputModule.tryPick``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SyntaxNode},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Syntax.SyntaxNode,Microsoft.FSharp.Core.FSharpOption{``0}}},FSharp.Compiler.Text.Position,FSharp.Compiler.Syntax.ParsedInput)">
 <summary>
 Applies the given function to each node of the AST and its context (path)
 down to a given position, returning <c>Some x</c> for the first node
 for which the function returns <c>Some x</c> for some value <c>x</c>, otherwise <c>None</c>.
 Traversal is short-circuited if no matching node is found through the given position.
 </summary>
 <param name="chooser">The function to apply to each node and its context to derive an optional value.</param>
 <param name="position">The position in the input file down to which to apply the function.</param>
 <param name="parsedInput">The AST to search.</param>
 <returns>The first value for which the function returns <c>Some</c>, or <c>None</c> if no matching node is found.</returns>
 <example>
 <code lang="fsharp">
 let range =
     (pos, parsedInput) ||> ParsedInput.tryPick (fun _path node ->
       match node with
       | SyntaxNode.SynExpr (SynExpr.InterpolatedString (range = range)) when
           rangeContainsPos range pos
           -> Some range
       | _ -> None)
 </code>
 </example>
</member>
<member name="M:FSharp.Compiler.Syntax.ParsedInputModule.tryNode(FSharp.Compiler.Text.Position,FSharp.Compiler.Syntax.ParsedInput)">
 <summary>
 Dives to the deepest node that contains the given position,
 returning the node and its path if found, or <c>None</c> if no
 node contains the position.
 </summary>
 <param name="position">The position in the input file down to which to dive.</param>
 <param name="parsedInput">The AST to search.</param>
 <returns>The deepest node containing the given position, along with the path taken through the node's ancestors to find it.</returns>
</member>
<member name="M:FSharp.Compiler.Syntax.ParsedInputModule.foldWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SyntaxNode},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Syntax.SyntaxNode,Microsoft.FSharp.Core.FSharpOption{``0}}}},``0,FSharp.Compiler.Syntax.ParsedInput)">
 <summary>
 Applies a function to each node of the AST and its context (path)
 until the folder returns <c>None</c>, threading an accumulator through the computation.
 </summary>
 <param name="folder">The function to use to update the state given each node and its context, or to stop traversal by returning <c>None</c>.</param>
 <param name="state">The initial state.</param>
 <param name="parsedInput">The AST to fold over.</param>
 <returns>The final state.</returns>
</member>
<member name="M:FSharp.Compiler.Syntax.ParsedInputModule.fold``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SyntaxNode},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Syntax.SyntaxNode,``0}}},``0,FSharp.Compiler.Syntax.ParsedInput)">
 <summary>
 Applies a function to each node of the AST and its context (path),
 threading an accumulator through the computation.
 </summary>
 <param name="folder">The function to use to update the state given each node and its context.</param>
 <param name="state">The initial state.</param>
 <param name="parsedInput">The AST to fold over.</param>
 <returns>The final state.</returns>
 <example>
 <code lang="fsharp">
 let unnecessaryParentheses =
    (HashSet Range.comparer, parsedInput) ||> ParsedInput.fold (fun acc path node ->
        match node with
        | SyntaxNode.SynExpr (SynExpr.Paren (expr = inner; rightParenRange = Some _; range = range)) when
            not (SynExpr.shouldBeParenthesizedInContext getLineString path inner)
            ->
            ignore (acc.Add range)
            acc

        | SyntaxNode.SynPat (SynPat.Paren (inner, range)) when
            not (SynPat.shouldBeParenthesizedInContext path inner)
            ->
            ignore (acc.Add range)
            acc

        | _ -> acc)
 </code>
 </example>
</member>
<member name="M:FSharp.Compiler.Syntax.ParsedInputModule.exists(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SyntaxNode},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Syntax.SyntaxNode,System.Boolean}},FSharp.Compiler.Text.Position,FSharp.Compiler.Syntax.ParsedInput)">
 <summary>
 Applies the given predicate to each node of the AST and its context (path)
 down to a given position, returning true if a matching node is found, otherwise false.
 Traversal is short-circuited if no matching node is found through the given position.
 </summary>
 <param name="predicate">The predicate to match each node against.</param>
 <param name="position">The position in the input file down to which to apply the function.</param>
 <param name="parsedInput">The AST to search.</param>
 <returns>True if a matching node is found, or false if no matching node is found.</returns>
 <example>
 <code lang="fsharp">
 let isInTypeDefn =
     (pos, parsedInput)
     ||> ParsedInput.exists (fun _path node ->
         match node with
         | SyntaxNode.SynTypeDefn _ -> true
         | _ -> false)
 </code>
 </example>
</member>
<member name="T:FSharp.Compiler.Syntax.ParsedInputModule">
 <summary>
 Holds operations for working with the
 untyped abstract syntax tree (<see cref="T:FSharp.Compiler.Syntax.ParsedInput"/>).
 </summary>
</member>
<member name="M:FSharp.Compiler.Syntax.SyntaxNodesModule.tryPickLast``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SyntaxNode},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Syntax.SyntaxNode,Microsoft.FSharp.Core.FSharpOption{``0}}},FSharp.Compiler.Text.Position,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SyntaxNode})">
 <summary>
 Applies the given function to each node of the AST and its context (path)
 down to a given position, returning <c>Some x</c> for the last (deepest) node
 for which the function returns <c>Some x</c> for some value <c>x</c>, otherwise <c>None</c>.
 Traversal is short-circuited if no matching node is found through the given position.
 </summary>
 <param name="chooser">The function to apply to each node and its context to derive an optional value.</param>
 <param name="position">The position in the input file down to which to apply the function.</param>
 <param name="ast">The AST to search.</param>
 <returns>The last (deepest) value for which the function returns <c>Some</c>, or <c>None</c> if no matching node is found.</returns>
 <example>
 <code lang="fsharp">
 let range =
     (pos, ast)
     ||> SyntaxNodes.tryPickLast (fun path node ->
         match node, path with
         | FuncIdent range -> Some range
         | _ -> None)
 </code>
 </example>
</member>
<member name="M:FSharp.Compiler.Syntax.SyntaxNodesModule.tryPick``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SyntaxNode},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Syntax.SyntaxNode,Microsoft.FSharp.Core.FSharpOption{``0}}},FSharp.Compiler.Text.Position,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SyntaxNode})">
 <summary>
 Applies the given function to each node of the AST and its context (path)
 down to a given position, returning <c>Some x</c> for the first node
 for which the function returns <c>Some x</c> for some value <c>x</c>, otherwise <c>None</c>.
 Traversal is short-circuited if no matching node is found through the given position.
 </summary>
 <param name="chooser">The function to apply to each node and its context to derive an optional value.</param>
 <param name="position">The position in the input file down to which to apply the function.</param>
 <param name="ast">The AST to search.</param>
 <returns>The first value for which the function returns <c>Some</c>, or <c>None</c> if no matching node is found.</returns>
 <example>
 <code lang="fsharp">
 let range =
     (pos, ast) ||> SyntaxNodes.tryPick (fun _path node ->
       match node with
       | SyntaxNode.SynExpr (SynExpr.InterpolatedString (range = range)) when
           rangeContainsPos range pos
           -> Some range
       | _ -> None)
 </code>
 </example>
</member>
<member name="M:FSharp.Compiler.Syntax.SyntaxNodesModule.tryNode(FSharp.Compiler.Text.Position,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SyntaxNode})">
 <summary>
 Dives to the deepest node that contains the given position,
 returning the node and its path if found, or <c>None</c> if no
 node contains the position.
 </summary>
 <param name="position">The position in the input file down to which to dive.</param>
 <param name="ast">The AST to search.</param>
 <returns>The deepest node containing the given position, along with the path taken through the node's ancestors to find it.</returns>
</member>
<member name="M:FSharp.Compiler.Syntax.SyntaxNodesModule.foldWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SyntaxNode},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Syntax.SyntaxNode,Microsoft.FSharp.Core.FSharpOption{``0}}}},``0,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SyntaxNode})">
 <summary>
 Applies a function to each node of the AST and its context (path)
 until the folder returns <c>None</c>, threading an accumulator through the computation.
 </summary>
 <param name="folder">The function to use to update the state given each node and its context, or to stop traversal by returning <c>None</c>.</param>
 <param name="state">The initial state.</param>
 <param name="ast">The AST to fold over.</param>
 <returns>The final state.</returns>
</member>
<member name="M:FSharp.Compiler.Syntax.SyntaxNodesModule.fold``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SyntaxNode},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Syntax.SyntaxNode,``0}}},``0,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SyntaxNode})">
 <summary>
 Applies a function to each node of the AST and its context (path),
 threading an accumulator through the computation.
 </summary>
 <param name="folder">The function to use to update the state given each node and its context.</param>
 <param name="state">The initial state.</param>
 <param name="ast">The AST to fold over.</param>
 <returns>The final state.</returns>
 <example>
 <code lang="fsharp">
 let unnecessaryParentheses =
    (HashSet Range.comparer, ast) ||> SyntaxNodes.fold (fun acc path node ->
        match node with
        | SyntaxNode.SynExpr (SynExpr.Paren (expr = inner; rightParenRange = Some _; range = range)) when
            not (SynExpr.shouldBeParenthesizedInContext getLineString path inner)
            ->
            ignore (acc.Add range)
            acc

        | SyntaxNode.SynPat (SynPat.Paren (inner, range)) when
            not (SynPat.shouldBeParenthesizedInContext path inner)
            ->
            ignore (acc.Add range)
            acc

        | _ -> acc)
 </code>
 </example>
</member>
<member name="M:FSharp.Compiler.Syntax.SyntaxNodesModule.exists(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SyntaxNode},Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Syntax.SyntaxNode,System.Boolean}},FSharp.Compiler.Text.Position,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SyntaxNode})">
 <summary>
 Applies the given predicate to each node of the AST and its context (path)
 down to a given position, returning true if a matching node is found, otherwise false.
 Traversal is short-circuited if no matching node is found through the given position.
 </summary>
 <param name="predicate">The predicate to match each node against.</param>
 <param name="position">The position in the input file down to which to apply the function.</param>
 <param name="ast">The AST to search.</param>
 <returns>True if a matching node is found, or false if no matching node is found.</returns>
 <example>
 <code lang="fsharp">
 let isInTypeDefn =
     (pos, ast)
     ||> SyntaxNodes.exists (fun _path node ->
         match node with
         | SyntaxNode.SynTypeDefn _ -> true
         | _ -> false)
 </code>
 </example>
</member>
<member name="T:FSharp.Compiler.Syntax.SyntaxNodesModule">
 <summary>
 Holds operations for working with the untyped abstract syntax tree.
 </summary>
</member>
<member name="M:FSharp.Compiler.Syntax.SyntaxNodeModule.|Attributes|(FSharp.Compiler.Syntax.SyntaxNode)">
 <summary>
 Extracts the <see cref="T:FSharp.Compiler.Syntax.SynAttributes"/>, if any,
 from the given <see cref="T:FSharp.Compiler.Syntax.SyntaxNode"/>.
 </summary>
</member>
<member name="T:FSharp.Compiler.Syntax.SyntaxNodeModule">
 <summary>
 Holds operations for working with <see cref="T:FSharp.Compiler.Syntax.SyntaxNode"/>s
 in the untyped abstract syntax tree (AST).
 </summary>
</member>
<member name="M:FSharp.Compiler.Syntax.SynExprModule.shouldBeParenthesizedInContext(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.String},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SyntaxNode},FSharp.Compiler.Syntax.SynExpr)">
 <summary>
 Returns true if the given expression should be parenthesized in the given context, otherwise false.
 </summary>
 <param name="getSourceLineStr">A function for getting the text of a given source line.</param>
 <param name="path">The expression's ancestor nodes.</param>
 <param name="expr">The expression to check.</param>
 <returns>True if the given expression should be parenthesized in the given context, otherwise false.</returns>
</member>
<member name="M:FSharp.Compiler.Syntax.SynPatModule.shouldBeParenthesizedInContext(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Syntax.SyntaxNode},FSharp.Compiler.Syntax.SynPat)">
 <summary>
 Returns true if the given pattern should be parenthesized in the given context, otherwise false.
 </summary>
 <param name="path">The pattern's ancestor nodes.</param>
 <param name="pat">The pattern to check.</param>
 <returns>True if the given pattern should be parenthesized in the given context, otherwise false.</returns>
</member>
<member name="T:FSharp.Compiler.EditorServices.SemanticClassificationType">
<summary>
 A kind that determines what range in a source&apos;s text is semantically classified as after type-checking.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.SemanticClassificationKeyStoreBuilder">
<summary>
 A builder that will build an semantic classification key store based on the written Item and its associated range.
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.SemanticClassificationKeyStore.GetView">
<summary>
 Get a read only view on the semantic classification key store
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.SemanticClassificationKeyStore">
<summary>
 Stores a list of semantic classification key strings and their ranges in a memory mapped file.
 Provides a view to iterate over the contents of the file.
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.SemanticClassificationView.ForEach(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.EditorServices.SemanticClassificationItem,Microsoft.FSharp.Core.Unit})">
<summary>
 Iterate through the stored SemanticClassificationItem entries from the store and apply the passed function on each entry.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.SemanticClassificationView">
<summary>
 Provides a read only view to iterate over the semantic classification contents.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.MethodGroup.Methods">
<summary>
 The methods (or other items) in the group
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.MethodGroup.MethodName">
<summary>
 The shared name of the methods (or other items) in the group
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.MethodGroup">
<summary>
 Represents a group of methods (or other items) returned by GetMethods.  
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.MethodGroupItem.XmlDoc">
<summary>
 The documentation for the item
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.MethodGroupItem.StaticParameters">
<summary>
 Does the type name or method support a static arguments list, like TP&lt;42,&quot;foo&quot;&gt; or conn.CreateCommand&lt;42, &quot;foo&quot;&gt;(arg1, arg2)?
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.MethodGroupItem.ReturnTypeText">
<summary>
 The tagged text for the return type for the method (or other item)
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.MethodGroupItem.Parameters">
<summary>
 The parameters of the method in the overload set
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.MethodGroupItem.HasParameters">
<summary>
 Does the method support an arguments list?  This is always true except for static type instantiations like TP&lt;42,&quot;foo&quot;&gt;.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.MethodGroupItem.HasParamArrayArg">
<summary>
 Does the method support a params list arg?
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.MethodGroupItem.Description">
<summary>
 The description representation for the method (or other item)
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.MethodGroupItem">
<summary>
 Represents one method (or other item) in a method group. The item may represent either a method or 
 a single, non-overloaded item such as union case or a named function value.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.MethodGroupItemParameter.ParameterName">
<summary>
 The name of the parameter.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.MethodGroupItemParameter.IsOptional">
<summary>
 Is the parameter optional
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.MethodGroupItemParameter.Display">
<summary>
 The representation for the parameter including its name, its type and visual indicators of other
 information such as whether it is optional.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.MethodGroupItemParameter.CanonicalTypeTextForSorting">
<summary>
 A key that can be used for sorting the parameters, used to help sort overloads.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.MethodGroupItemParameter">
<summary>
 Represents one parameter for one method (or other item) in a group. 
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.DeclarationListInfo">
<summary>
 Represents a set of declarations in F# source code, with information attached ready for display by an editor.
 Returned by GetDeclarations.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.DeclarationListItem.NameInList">
<summary>
 Get the text to display in the declaration list for the declaration.

 This is a display name without backticks.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.DeclarationListItem.NameInCode">
<summary>
 Get the text for the declaration as it&apos;s to be inserted into source code.

 This is a display name with backticks if necessary.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.DeclarationListItem.Name">
<summary>
 Get the text to display in the declaration list for the declaration.

 This is a display name without backticks.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.DeclarationListItem.Kind">
<summary>
 Get the completion kind of the item
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.DeclarationListItem.Glyph">
<summary>
 Get the glyph to use
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.DeclarationListItem.Description">
<summary>
 Get the description
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.DeclarationListItem.Accessibility">
<summary>
 Get the accessibility of the item
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.DeclarationListItem">
<summary>
 Represents a declaration in F# source code, with information attached ready for display by an editor.
 Returned by GetDeclarations.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.ToolTipText.ToolTipText">
<summary>
 A list of data tip elements to display.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.ToolTipText">
<summary>
 Information for building a tool tip box.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.ToolTipElement.CompositionError">
<summary>
 An error occurred formatting this element
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.ToolTipElement.Group">
<summary>
 A single type, method, etc with comment. May represent a method overload group.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.ToolTipElement">
<summary>
 A single tool tip display element
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.ToolTipElementData.ParamName">
<summary>
 Parameter name
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.ToolTipElementData.Remarks">
<summary>
 Extra text, goes at the end
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.ToolTipElementData.TypeMapping">
<summary>
 typar instantiation text, to go after xml
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.ToolTipElementData">
<summary>
 A single data tip display element
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.NavigableContainer.Type">
<summary>
 The kind of container.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.NavigableContainer.Name">
<summary>
 The name of the container or file
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.NavigableContainer.FullName">
<summary>
 The fully qualified name of the container.
 For files it returns empty string.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.NavigationItems">
<summary>
 Represents result of &apos;GetNavigationItems&apos; operation - this contains
 all the members and currently selected indices. First level correspond to
 types &amp; modules and second level are methods etc.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.NavigationTopLevelDeclaration">
<summary>
 Represents top-level declarations (that should be in the type drop-down)
 with nested declarations (that can be shown in the member drop-down)
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.NavigationItem">
<summary>
 Represents an item to be displayed in the navigation bar
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.NavigationItemKind">
<summary>
 Indicates a kind of item to show in an F# navigation bar
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.ParameterLocations.TupleEndLocations">
<summary>
 The locations of commas and close parenthesis (or, last char of last arg, if no final close parenthesis)
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.ParameterLocations.OpenParenLocation">
<summary>
 The location of the open-parentheses
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.ParameterLocations.NamedParamNames">
<summary>
 Either empty or a name if an actual named parameter; f(0,a=4,?b=None) would be [|None; Some &quot;a&quot;; Some &quot;b&quot;|]
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.ParameterLocations.LongIdStartLocation">
<summary>
 The start location of long identifier prior to the open-parentheses
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.ParameterLocations.LongIdEndLocation">
<summary>
 The end location of long identifier prior to the open-parentheses
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.ParameterLocations.LongId">
<summary>
 The text of the long identifier prior to the open-parentheses
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.ParameterLocations.IsThereACloseParen">
<summary>
 Is false if either this is a call without parens &quot;f x&quot; or the parser recovered as in &quot;f(x,y&quot;
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.ParameterLocations.ArgumentLocations">
<summary>
 Array of locations for each argument, and a flag if that argument is named
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.ParameterLocations.Find(FSharp.Compiler.Text.Position,FSharp.Compiler.Syntax.ParsedInput)">
<summary>
 Find the information about parameter info locations at a particular source location
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.ParameterLocations">
<summary>
 Represents the locations relevant to activating parameter info in an IDE
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.TupledArgumentLocation">
<summary>
 Represents the location of a tupled argument, which can optionally be a named argument.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.InsertionContextEntity.LastIdent">
<summary>
 Last part of the entity&apos;s full name.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.InsertionContextEntity.FullDisplayName">
<summary>
 Full display name (i.e. last ident plus modules with `RequireQualifiedAccess` attribute prefixed).
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.InsertionContextEntity.Namespace">
<summary>
 Namespace that is needed to open to make the entity resolvable in the current scope.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.InsertionContextEntity.Qualifier">
<summary>
 Ident parts needed to append to the current ident to make it resolvable in current scope.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.InsertionContextEntity.FullRelativeName">
<summary>
 Full name, relative to the current scope.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.InsertionContextEntity">
<summary>
 Helper data structure representing a symbol, suitable for implementing unresolved identifiers resolution code fixes.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.MaybeUnresolvedIdent">
<summary>
 `ShortIdent` with a flag indicating if it&apos;s resolved in some scope.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.ShortIdents">
<summary>
 An array of `ShortIdent`.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.ShortIdent">
<summary>
 Short identifier, i.e. an identifier that contains no dots.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.OpenStatementInsertionPoint">
<summary>
 Where open statements should be added.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.InsertionContext.Pos">
<summary>
 Current position (F# compiler line number).
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.InsertionContext.ScopeKind">
<summary>
 Current scope kind.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.InsertionContext">
<summary>
 Insert open namespace context.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.ScopeKind">
<summary>
 Kind of lexical scope.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.CompletionContext.MethodOverride">
<summary>
 Completing a method override (e.g. override this.ToStr|)
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.CompletionContext.Pattern">
<summary>
 Completing a pattern in a match clause, member/let binding or lambda
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.CompletionContext.TypeAbbreviationOrSingleCaseUnion">
<summary>
 Completing a type abbreviation (e.g. type Long = int6|)
 or a single case union without a bar (type SomeUnion = Abc|)
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.CompletionContext.UnionCaseFieldsDeclaration">
<summary>
 Completing union case fields declaration (e.g. &apos;A of stri|&apos; but not &apos;B of tex|: string&apos;)
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.CompletionContext.Type">
<summary>
 Completing a type annotation (e.g. foo (x: |))
 Completing a type application (e.g. typeof&lt;str| &gt;)
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.CompletionContext.AttributeApplication">
<summary>
 Completing an attribute name, outside of the constructor
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.CompletionContext.ParameterList">
<summary>
 Completing named parameters\setters in parameter list of attributes\constructor\method calls
 end of name ast node * list of properties\parameters that were already set
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.CompletionContext.RecordField">
<summary>
 Completing records field
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.CompletionContext.Inherit">
<summary>
 Completing something after the inherit keyword
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.CompletionContext.Invalid">
<summary>
 Completion context cannot be determined due to errors
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.PatternContext.Other">
<summary>
 Any other position in a pattern that does not need special handling
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.PatternContext.RecordFieldIdentifier">
<summary>
 Completing a record field identifier in a pattern (e.g. fun { Field1 = a; Fie| } -&gt; )
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.PatternContext.UnionCaseFieldIdentifier">
<summary>
 Completing union case field identifier in a pattern (e.g. fun (Case (field1 = a; fie| )) -&gt; )
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.PatternContext.NamedUnionCaseField">
<summary>
 Completing union case field pattern (e.g. fun (Some (Value = v| )) -&gt; )
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.PatternContext.PositionalUnionCaseField">
 <summary>Completing union case field pattern (e.g. fun (Some v| ) -> ) or fun (Some (v| )) -> ). In theory, this could also be parameterized active pattern usage.</summary>
 <param name="fieldIndex">Position in the tuple. <see cref="None">None</see> if there is no tuple, with only one field outside of parentheses - `Some v|`</param>
 <param name="isTheOnlyField">True when completing the first field in the tuple and no other field is bound - `Case (a|)` but not `Case (a|, b)`</param>
 <param name="caseIdRange">Range of the case identifier</param>
</member>
<member name="M:FSharp.Compiler.EditorServices.EntityCache.Locking``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.EditorServices.IAssemblyContentCache,``0})">
<summary>
 Performs an operation on the cache in thread safe manner.
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.EntityCache.Clear">
<summary>
 Clears the cache.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.EntityCache">
<summary>
 Thread safe wrapper over `IAssemblyContentCache`.
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.IAssemblyContentCache.TryGet(System.String)">
<summary>
 Try get an assembly cached content.
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.IAssemblyContentCache.Set(System.String,FSharp.Compiler.EditorServices.AssemblyContentCacheEntry)">
<summary>
 Store an assembly content.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.IAssemblyContentCache">
<summary>
 Assembly content cache.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.AssemblyContentCacheEntry.Symbols">
<summary>
 Assembly content.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.AssemblyContentCacheEntry.ContentType">
<summary>
 Content type used to get assembly content.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.AssemblyContentCacheEntry.FileWriteTime">
<summary>
 Assembly file last write time.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.AssemblyContentCacheEntry">
<summary>
 `RawEntity` list retrieved from an assembly.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.AssemblySymbol.UnresolvedSymbol">
<summary>
 Cache display name and namespace, used for completion.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.AssemblySymbol.Kind">
<summary>
 Function that returns `EntityKind` based of given `LookupKind`.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.AssemblySymbol.AutoOpenParent">
<summary>
 Parent module that has `AutoOpen` attribute.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.AssemblySymbol.TopRequireQualifiedAccessParent">
<summary>
 Parent module that has the largest scope and has `RequireQualifiedAccess` attribute.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.AssemblySymbol.NearestRequireQualifiedAccessParent">
<summary>
 The most narrative parent module that has `RequireQualifiedAccess` attribute.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.AssemblySymbol.Namespace">
<summary>
 `FSharpEntity.Namespace`.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.AssemblySymbol.CleanedIdents">
<summary>
 Entity name parts with removed module suffixes (Ns.M1Module.M2Module.M3.entity -&gt; Ns.M1.M2.M3.entity)
 and replaced compiled names with display names (FSharpEntity.DisplayName, FSharpValueOrFunction.DisplayName).
 Note: *all* parts are cleaned, not the last one.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.AssemblySymbol.FullName">
<summary>
 Full entity name as it&apos;s seen in compiled code (raw FSharpEntity.FullName, FSharpValueOrFunction.FullName).
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.AssemblySymbol">
<summary>
 Represents type, module, member, function or value in a compiled assembly.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.AssemblyPath">
<summary>
 Assembly path.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.LookupType">
<summary>
 Entity lookup type.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.AssemblyContentType.Full">
<summary>
 All assembly content.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.AssemblyContentType.Public">
<summary>
 Public assembly content only.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.AssemblyContentType">
<summary>
 Assembly content type.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.XmlDocable">
<summary>
 Represent an Xml documentation block in source code
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.FindDeclResult.ExternalDecl">
<summary>
 Indicates an external declaration was found
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.FindDeclResult.DeclFound">
<summary>
 Indicates a declaration location was found
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.FindDeclResult.DeclNotFound">
<summary>
 Indicates a declaration location was not found, with an additional reason
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.FindDeclResult">
<summary>
 Represents the result of the GetDeclarationLocation operation.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.FindDeclFailureReason.ProvidedMember">
<summary>
 Trying to find declaration of ProvidedMember without TypeProviderDefinitionLocationAttribute
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.FindDeclFailureReason.ProvidedType">
<summary>
 Trying to find declaration of ProvidedType without TypeProviderDefinitionLocationAttribute
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.FindDeclFailureReason.NoSourceCode">
<summary>
 Source code file is not available
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.FindDeclFailureReason.Unknown">
<summary>
 Generic reason: no particular information about error apart from a message
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.FindDeclFailureReason">
<summary>
 Represents the reason why the GetDeclarationLocation operation failed.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.FindDeclExternalSymbol">
<summary>
 Represents a symbol in an external (non F#) assembly
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.FindDeclExternalParam">
<summary>
 Represents the type of a single method parameter
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.FindDeclExternalType.TypeVar">
<summary>
 Type variable defined in non-F# assembly.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.FindDeclExternalType.Pointer">
<summary>
 Pointer defined in non-F# assembly.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.FindDeclExternalType.Array">
<summary>
 Array of type that is defined in non-F# assembly.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.FindDeclExternalType.Type">
<summary>
 Type defined in non-F# assembly.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.FindDeclExternalType">
<summary>
 Represents a type in an external (non F#) assembly.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.PartialLongName.LastDotPos">
<summary>
 Position of the last dot.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.PartialLongName.EndColumn">
<summary>
 The column number at the end of full partial name.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.PartialLongName.PartialIdent">
<summary>
 Last part of long ident.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.PartialLongName.QualifyingIdents">
<summary>
 Qualifying idents, prior to the last dot, not including the last part.
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.PartialLongName.Empty(System.Int32)">
<summary>
 Empty partial long name.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.PartialLongName">
<summary>
 Qualified long name.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.InterfaceData">
<summary>
 Capture information about an interface in ASTs
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.TcResolutionsExtensions">
<summary>
 Extension methods for the TcResolutions type.
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.ParsedInput.AdjustInsertionPoint(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.String},FSharp.Compiler.EditorServices.InsertionContext)">
<summary>
 Corrects insertion line number based on kind of scope and text surrounding the insertion point.
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.ParsedInput.GetLongIdentAt(FSharp.Compiler.Syntax.ParsedInput,FSharp.Compiler.Text.Position)">
<summary>
 Returns long identifier at position.
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.ParsedInput.FindNearestPointToInsertOpenDeclaration(System.Int32,FSharp.Compiler.Syntax.ParsedInput,System.String[],FSharp.Compiler.EditorServices.OpenStatementInsertionPoint)">
<summary>
 Returns `InsertContext` based on current position and symbol idents.
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.ParsedInput.TryFindInsertionContext(System.Int32,FSharp.Compiler.Syntax.ParsedInput,FSharp.Compiler.EditorServices.MaybeUnresolvedIdent[],FSharp.Compiler.EditorServices.OpenStatementInsertionPoint)">
<summary>
 Returns `InsertContext` based on current position and symbol idents.
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.ParsedInput.|Sequentials|_|(FSharp.Compiler.Syntax.SynExpr)">
<summary>
 A pattern that collects all sequential expressions to avoid StackOverflowException
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.ParsedInput">
<summary>
 Operations querying the entire syntax tree
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.AssemblyContent.GetAssemblyContent(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.EditorServices.IAssemblyContentCache,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.EditorServices.AssemblySymbol}},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.EditorServices.AssemblySymbol}},FSharp.Compiler.EditorServices.AssemblyContentType,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Symbols.FSharpAssembly})">
<summary>
 Returns (possibly cached) assembly content.
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.AssemblyContent.GetAssemblySignatureContent(FSharp.Compiler.EditorServices.AssemblyContentType,FSharp.Compiler.Symbols.FSharpAssemblySignature)">
<summary>
 Given a `FSharpAssemblySignature`, returns assembly content.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.AssemblyContent">
<summary>
 Provides assembly content.
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.XmlDocParser.GetXmlDocables(FSharp.Compiler.Text.ISourceText,FSharp.Compiler.Syntax.ParsedInput)">
<summary>
 Get the list of Xml documentation from current source code
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.XmlDocComment.IsBlank(System.String)">
<summary>
 if it&apos;s a blank XML comment with trailing &quot;&lt;&quot;, returns Some (index of the &quot;&lt;&quot;), otherwise returns None
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.QuickParse.TestMemberOrOverrideDeclaration(FSharp.Compiler.Tokenization.FSharpTokenInfo[])">
<summary>
 Tests whether the user is typing something like &quot;member x.&quot; or &quot;override (*comment*) x.&quot;
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.QuickParse.GetPartialLongNameEx(System.String,System.Int32)">
<summary>
 Get the partial long name of the identifier to the left of index.
 For example, for `System.DateTime.Now` it returns PartialLongName ([|&quot;System&quot;; &quot;DateTime&quot;|], &quot;Now&quot;, Some 32), where &quot;32&quot; pos of the last dot.
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.QuickParse.GetPartialLongName(System.String,System.Int32)">
<summary>
 Get the partial long name of the identifier to the left of index.
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.QuickParse.GetCompleteIdentifierIsland(System.Boolean,System.String,System.Int32)">
<summary>
 Given a string and a position in that string, find an identifier as
 expected by `GotoDefinition`. This will work when the cursor is
 immediately before the identifier, within the identifier, or immediately
 after the identifier.

 &apos;tolerateJustAfter&apos; indicates that we tolerate being one character after the identifier, used
 for goto-definition

 In general, only identifiers composed from upper/lower letters and &apos;.&apos; are supported, but there
 are a couple of explicitly handled exceptions to allow some common scenarios:
 - When the name contains only letters and &apos;|&apos; symbol, it may be an active pattern, so we
   treat it as a valid identifier - e.g. let ( |Identity| ) a = a
   (but other identifiers that include &apos;|&apos; are not allowed - e.g. &apos;||&apos; operator)
 - It searches for double tick (``) to see if the identifier could be something like ``a b``

 REVIEW: Also support, e.g., operators, performing the necessary mangling.
 (i.e., I would like that the name returned here can be passed as-is
 (post `.`-chopping) to `GetDeclarationLocation.)

 In addition, return the position where a `.` would go if we were making
 a call to `DeclItemsForNamesAtPosition` for intellisense. This will
 allow us to use find the correct qualified items rather than resorting
 to the more expensive and less accurate environment lookup.
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.QuickParse.MagicalAdjustmentConstant">
<summary>
 Puts us after the last character.
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.QuickParse">
<summary>
 Methods for cheaply and inaccurately parsing F#.

 These methods are very old and are mostly to do with extracting &quot;long identifier islands&quot;
     A.B.C
 from F# source code, an approach taken from pre-F# VS samples for implementing intellisense.

 This code should really no longer be needed since the language service has access to
 parsed F# source code ASTs.  However, the long identifiers are still passed back to GetDeclarations and friends in the
 F# Compiler Service and it&apos;s annoyingly hard to remove their use completely.

 In general it is unlikely much progress will be made by fixing this code - it will be better to
 extract more information from the F# ASTs.

 It&apos;s also surprising how hard even the job of getting long identifier islands can be. For example the code
 below is inaccurate for long identifier chains involving ``...`` identifiers.  And there are special cases
 for active pattern names and so on.
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.InterfaceStubGenerator.TryFindInterfaceDeclaration(FSharp.Compiler.Text.Position,FSharp.Compiler.Syntax.ParsedInput)">
<summary>
 Find corresponding interface declaration at a given position
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.InterfaceStubGenerator.FormatInterface(System.Int32,System.Int32,System.String[],System.String,System.String,FSharp.Compiler.Symbols.FSharpDisplayContext,Microsoft.FSharp.Collections.FSharpSet{System.String},FSharp.Compiler.Symbols.FSharpEntity,System.Boolean)">
<summary>
 Generate stub implementation of an interface at a start column
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.InterfaceStubGenerator.IsInterface(FSharp.Compiler.Symbols.FSharpEntity)">
<summary>
 Check whether an entity is an interface or type abbreviation of an interface
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.InterfaceStubGenerator.GetImplementedMemberSignatures(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.String,FSharp.Compiler.Text.Range},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.CodeAnalysis.FSharpSymbolUse}},FSharp.Compiler.Symbols.FSharpDisplayContext,FSharp.Compiler.EditorServices.InterfaceData)">
<summary>
 Get interface member signatures
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.InterfaceStubGenerator.GetMemberNameAndRanges(FSharp.Compiler.EditorServices.InterfaceData)">
<summary>
 Get associated member names and ranges.
 In case of properties, intrinsic ranges might not be correct for the purpose of getting
 positions of &apos;member&apos;, which indicate the indentation for generating new members
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.InterfaceStubGenerator.HasNoInterfaceMember(FSharp.Compiler.Symbols.FSharpEntity)">
<summary>
 Check whether an interface is empty
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.InterfaceStubGenerator.GetInterfaceMembers(FSharp.Compiler.Symbols.FSharpEntity)">
<summary>
 Get members in the decreasing order of inheritance chain
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.Structure.ScopeRange.CollapseRange">
<summary>
 TextSpan in BlockSpan
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.Structure.ScopeRange.Range">
<summary>
 HintSpan in BlockSpan
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.Structure.ScopeRange">
<summary>
 Stores the range for a construct, the sub-range that should be collapsed for outlining,
 a tag for the construct type, and a tag for the collapse style
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.Structure.Scope">
<summary>
 Tag to identify the construct that can be stored alongside its associated ranges
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.Structure.Collapse">
<summary>
 Collapse indicates the way a range/snapshot should be collapsed. `Same` is for a scope inside
 some kind of scope delimiter, e.g. `[| ... |]`, `[ ... ]`, `{ ... }`, etc.  `Below` is for expressions
 following a binding or the right hand side of a pattern, e.g. `let x = ...`
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.Structure.getOutliningRanges(System.String[],FSharp.Compiler.Syntax.ParsedInput)">
<summary>
 Returns outlining ranges for given parsed input.
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.UnusedDeclarations.getUnusedDeclarations(FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults,System.Boolean)">
<summary>
 Get all unused declarations in a file
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.SimplifyNames.SimplifiableRange.RelativeName">
<summary>
 The relative name that can be applied to a simplifiable name
</summary>
</member>
<member name="P:FSharp.Compiler.EditorServices.SimplifyNames.SimplifiableRange.Range">
<summary>
 The range of a name that can be simplified
</summary>
</member>
<member name="T:FSharp.Compiler.EditorServices.SimplifyNames.SimplifiableRange">
<summary>
 Data for use in finding unnecessarily-qualified names and generating diagnostics to simplify them
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.SimplifyNames.getSimplifiableNames(FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults,Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.String})">
<summary>
 Get all ranges that can be simplified in a file
</summary>
</member>
<member name="M:FSharp.Compiler.EditorServices.UnusedOpens.getUnusedOpens(FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults,Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.String})">
<summary>
 Get all unused open declarations in a file
</summary>
</member>
<member name="T:FSharp.Compiler.Interactive.Shell.CompilerOutputStream">
<summary>
 Defines a write-only stream used to capture output of the hosted F# Interactive dynamic compiler.
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.CompilerInputStream.Add(System.String)">
<summary>
 Feeds content into the stream.
</summary>
</member>
<member name="T:FSharp.Compiler.Interactive.Shell.CompilerInputStream">
<summary>
 Defines a read-only input stream used to feed content to the hosted F# Interactive dynamic compiler.
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.ValueBound">
<summary>
 Event fires when a root-level value is bound to an identifier, e.g., via `let x = ...`.
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.PartialAssemblySignatureUpdated">
<summary>
 Raised when an interaction is successfully typechecked and executed, resulting in an update to the
 type checking state.

 This event is triggered after parsing and checking, either via input from &apos;stdin&apos;, or via a call to EvalInteraction.
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.LCID">
<summary>
 A host calls this to get the active language ID if provided by fsi-server-lcid
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.IsGui">
<summary>
 A host calls this to determine if the --gui parameter is active
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.InteractiveChecker">
<summary>
 The single, global interactive checker to use in conjunction with other operations
 on the FsiEvaluationSession.

 If you are using an FsiEvaluationSession in this process, you should only use this InteractiveChecker
 for additional checking operations.
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.DynamicAssemblies">
<summary>
 Get all the dynamically generated assemblies
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.CurrentPartialAssemblySignature">
<summary>
 Get a handle to the resolved view of the current signature of the incrementally generated assembly.
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.TryFindBoundValue(System.String)">
<summary>
 Tries to find a root-level value that is bound to the given identifier
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.Run">
<summary>
 Load the dummy interaction, load the initial files, and,
 if interacting, start the background thread to read the standard input.

 Performs these steps:
    - Load the dummy interaction, if any
    - Set up exception handling, if any
    - Load the initial files, if any
    - Start the background thread to read the standard input, if any
    - Sit in the GUI event loop indefinitely, if needed
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.ReportUnhandledException(System.Exception)">
<summary>
 A host calls this to report an unhandled exception in a standard way, e.g. an exception on the GUI thread gets printed to stderr
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.ParseAndCheckInteraction(System.String)">
<summary>
 Typecheck the given script fragment in the type checking context implied by the current state
 of F# Interactive. The results can be used to access intellisense, perform resolutions,
 check brace matching and other information.

 Operations may be run concurrently with other requests to the InteractiveChecker.
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.Interrupt">
<summary>
 A host calls this to request an interrupt on the evaluation thread.
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.GetDefaultConfiguration">
<summary>
 Get a configuration that uses a private inbuilt implementation of the &apos;fsi&apos; object and does not
 implicitly reference FSharp.Compiler.Interactive.Settings.dll.
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.GetDefaultConfiguration(System.Object)">
<summary>
 Get a configuration that uses the &apos;fsi&apos; object (normally from FSharp.Compiler.Interactive.Settings.dll,
 an object from another DLL with identical characteristics) to provide an implementation of the configuration.
 FSharp.Compiler.Interactive.Settings.dll  is referenced by default.
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.GetDefaultConfiguration(System.Object,System.Boolean)">
<summary>
 Get a configuration that uses the &apos;fsi&apos; object (normally from FSharp.Compiler.Interactive.Settings.dll,
 an object from another DLL with identical characteristics) to provide an implementation of the configuration.
 The flag indicates if FSharp.Compiler.Interactive.Settings.dll  is referenced by default.
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.GetCompletions(System.String)">
<summary>
 A host calls this to get the completions for a long identifier, e.g. in the console

 Due to a current limitation, it is not fully thread-safe to run this operation concurrently with evaluation triggered
 by input from &apos;stdin&apos;.
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.GetBoundValues">
<summary>
 Gets the root-level values that are bound to an identifier
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.FormatValue(System.Object,System.Type)">
<summary>
 Format a value to a string using the current PrintDepth, PrintLength etc settings provided by the active fsi configuration object
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.EvalScriptNonThrowing(System.String)">
<summary>
 Execute the given script. Stop on first error, discarding the rest
 of the script. Errors and warnings are collected apart from any exception arising from execution
 which is returned via a Choice. Execution is performed on the &apos;Run()&apos; thread.

 Due to a current limitation, it is not fully thread-safe to run this operation concurrently with evaluation triggered
 by input from &apos;stdin&apos;.
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.EvalScript(System.String)">
<summary>
 Execute the given script. Stop on first error, discarding the rest
 of the script. Errors are sent to the output writer, a &apos;true&apos; return value indicates there
 were no errors overall. Execution is performed on the &apos;Run()&apos; thread.

 Due to a current limitation, it is not fully thread-safe to run this operation concurrently with evaluation triggered
 by input from &apos;stdin&apos;.
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.EvalInteractionNonThrowing(System.String,System.String,Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
<summary>
 Execute the code as if it had been entered as one or more interactions, with an
 implicit termination at the end of the input. Stop on first error, discarding the rest
 of the input. Errors and warnings are collected apart from any exception arising from execution
 which is returned via a Choice. Execution is performed on the &apos;Run()&apos; thread.

 Due to a current limitation, it is not fully thread-safe to run this operation concurrently with evaluation triggered
 by input from &apos;stdin&apos;.
 The scriptFileName parameter is used to report errors including this file name.
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.EvalInteractionNonThrowing(System.String,Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
<summary>
 Execute the code as if it had been entered as one or more interactions, with an
 implicit termination at the end of the input. Stop on first error, discarding the rest
 of the input. Errors and warnings are collected apart from any exception arising from execution
 which is returned via a Choice. Execution is performed on the &apos;Run()&apos; thread.

 Due to a current limitation, it is not fully thread-safe to run this operation concurrently with evaluation triggered
 by input from &apos;stdin&apos;.
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.EvalInteraction(System.String,System.String,Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
<summary>
 Execute the code as if it had been entered as one or more interactions, with an
 implicit termination at the end of the input. Stop on first error, discarding the rest
 of the input. Errors are sent to the output writer, a &apos;true&apos; return value indicates there
 were no errors overall. Execution is performed on the &apos;Run()&apos; thread.

 Due to a current limitation, it is not fully thread-safe to run this operation concurrently with evaluation triggered
 by input from &apos;stdin&apos;.
 The scriptFileName parameter is used to report errors including this file name.
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.EvalInteraction(System.String,Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
<summary>
 Execute the code as if it had been entered as one or more interactions, with an
 implicit termination at the end of the input. Stop on first error, discarding the rest
 of the input. Errors are sent to the output writer, a &apos;true&apos; return value indicates there
 were no errors overall. Execution is performed on the &apos;Run()&apos; thread.

 Due to a current limitation, it is not fully thread-safe to run this operation concurrently with evaluation triggered
 by input from &apos;stdin&apos;.
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.EvalExpressionNonThrowing(System.String,System.String)">
<summary>
 Execute the code as if it had been entered as one or more interactions, with an
 implicit termination at the end of the input. Stop on first error, discarding the rest
 of the input. Errors and warnings are collected apart from any exception arising from execution
 which is returned via a Choice. Parsing is performed on the current thread, and execution is performed
 synchronously on the &apos;main&apos; thread.

 Due to a current limitation, it is not fully thread-safe to run this operation concurrently with evaluation triggered
 by input from &apos;stdin&apos;.
 The scriptFileName parameter is used to report errors including this file name.
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.EvalExpressionNonThrowing(System.String)">
<summary>
 Execute the code as if it had been entered as one or more interactions, with an
 implicit termination at the end of the input. Stop on first error, discarding the rest
 of the input. Errors and warnings are collected apart from any exception arising from execution
 which is returned via a Choice. Parsing is performed on the current thread, and execution is performed
 synchronously on the &apos;main&apos; thread.

 Due to a current limitation, it is not fully thread-safe to run this operation concurrently with evaluation triggered
 by input from &apos;stdin&apos;.
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.EvalExpression(System.String,System.String)">
<summary>
 Execute the code as if it had been entered as one or more interactions, with an
 implicit termination at the end of the input. Stop on first error, discarding the rest
 of the input. Errors are sent to the output writer. Parsing is performed on the current thread, and execution is performed
 synchronously on the &apos;main&apos; thread.

 Due to a current limitation, it is not fully thread-safe to run this operation concurrently with evaluation triggered
 by input from &apos;stdin&apos;.
 The scriptFileName parameter is used to report errors including this file name.
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.EvalExpression(System.String)">
<summary>
 Execute the code as if it had been entered as one or more interactions, with an
 implicit termination at the end of the input. Stop on first error, discarding the rest
 of the input. Errors are sent to the output writer. Parsing is performed on the current thread, and execution is performed
 synchronously on the &apos;main&apos; thread.

 Due to a current limitation, it is not fully thread-safe to run this operation concurrently with evaluation triggered
 by input from &apos;stdin&apos;.
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.Create(FSharp.Compiler.Interactive.Shell.FsiEvaluationSessionHostConfig,System.String[],System.IO.TextReader,System.IO.TextWriter,System.IO.TextWriter,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.CodeAnalysis.LegacyReferenceResolver})">
 <summary>Create an FsiEvaluationSession, reading from the given text input, writing to the given text output and error writers</summary>

 <param name="fsiConfig">The dynamic configuration of the evaluation session</param>
 <param name="argv">The command line arguments for the evaluation session</param>
 <param name="inReader">Read input from the given reader</param>
 <param name="errorWriter">Write errors to the given writer</param>
 <param name="outWriter">Write output to the given writer</param>
 <param name="collectible">Optionally make the dynamic assembly for the session collectible</param>
 <param name="legacyReferenceResolver">An optional resolver for legacy MSBuild references</param>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession.AddBoundValue(System.String,System.Object)">
<summary>
 Creates a root-level value with the given name and .NET object.
 If the .NET object contains types from assemblies that are not referenced in the interactive session, it will try to implicitly resolve them by default configuration.
 Name must be a valid identifier.
</summary>
</member>
<member name="T:FSharp.Compiler.Interactive.Shell.FsiEvaluationSession">
<summary>
 Represents an F# Interactive evaluation session.
</summary>
</member>
<member name="T:FSharp.Compiler.Interactive.Shell.FsiCompilationException">
<summary>
 Thrown when there was an error compiling the given code in FSI.
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.FsiEvaluationSessionHostConfig.UseFsiAuxLib">
<summary>
 Implicitly reference FSharp.Compiler.Interactive.Settings.dll
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.FsiEvaluationSessionHostConfig.ShowProperties">
<summary>
 Called by the evaluation session to ask the host for parameters to format text for output
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.FsiEvaluationSessionHostConfig.ShowIEnumerable">
<summary>
 Called by the evaluation session to ask the host for parameters to format text for output
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.FsiEvaluationSessionHostConfig.ShowDeclarationValues">
<summary>
 Called by the evaluation session to ask the host for parameters to format text for output
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.FsiEvaluationSessionHostConfig.PrintWidth">
<summary>
 Called by the evaluation session to ask the host for parameters to format text for output
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.FsiEvaluationSessionHostConfig.PrintSize">
<summary>
 Called by the evaluation session to ask the host for parameters to format text for output
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.FsiEvaluationSessionHostConfig.PrintLength">
<summary>
 Called by the evaluation session to ask the host for parameters to format text for output
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.FsiEvaluationSessionHostConfig.PrintDepth">
<summary>
 Called by the evaluation session to ask the host for parameters to format text for output
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.FsiEvaluationSessionHostConfig.OnEvaluation">
<summary>
 Hook for listening for evaluation bindings
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.FsiEvaluationSessionHostConfig.FormatProvider">
<summary>
 Called by the evaluation session to ask the host for parameters to format text for output
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.FsiEvaluationSessionHostConfig.FloatingPointFormat">
<summary>
 Called by the evaluation session to ask the host for parameters to format text for output
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.FsiEvaluationSessionHostConfig.AddedPrinters">
<summary>
 Called by the evaluation session to ask the host for parameters to format text for output
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSessionHostConfig.StartServer(System.String)">
<summary>
 The evaluation session calls this at an appropriate point in the startup phase if the --fsi-server parameter was given
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSessionHostConfig.ReportUserCommandLineArgs(System.String[])">
<summary>
 The evaluation session calls this to report the preferred view of the command line arguments after
 stripping things like &quot;/use:file.fsx&quot;, &quot;-r:Foo.dll&quot; etc.
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSessionHostConfig.GetOptionalConsoleReadLine(System.Boolean)">
<summary>
 <para>Indicate a special console "readline" reader for the evaluation session, if any.</para><para></para>

 <para>A "console" gets used if --readline is specified (the default on Windows + .NET); and --fsi-server is  not
 given (always combine with --readline-), and OptionalConsoleReadLine is given.
 When a console is used, special rules apply to "peekahead", which allows early typing on the console.
 Peekahead happens if --peekahead- is not specified (the default).
 In this case, a prompt is printed early, a background thread is created and
 the OptionalConsoleReadLine is used to read the first line.
 If a console is not used, then inReader.Peek() is called early instead.
 </para><para></para>

 <para>Further lines are read using OptionalConsoleReadLine().
 If not provided, lines are read using inReader.ReadLine().</para>
 <para></para>
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSessionHostConfig.EventLoopScheduleRestart">
<summary>
 Schedule a restart for the event loop.
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSessionHostConfig.EventLoopRun">
<summary>
 Called by the evaluation session to ask the host to enter a dispatch loop like Application.Run().
 Only called if --gui option is used (which is the default).
 Gets called towards the end of startup and every time a ThreadAbort escaped to the backup driver loop.
 Return true if a &apos;restart&apos; is required, which is a bit meaningless.
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.FsiEvaluationSessionHostConfig.EventLoopInvoke``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Request that the given operation be run synchronously on the event loop.
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.EvaluationEventArgs.SymbolUse">
<summary>
 The FSharpSymbolUse for the symbol defined
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.EvaluationEventArgs.Symbol">
<summary>
 The symbol defined
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.EvaluationEventArgs.Name">
<summary>
 The display name of the symbol defined
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.EvaluationEventArgs.ImplementationDeclaration">
<summary>
 The details of the expression defined
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.EvaluationEventArgs.FsiValue">
<summary>
 The value of the symbol defined, if any
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.FsiBoundValue.Value">
<summary>
 The evaluated F# value
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.FsiBoundValue.Name">
<summary>
 The identifier of the value
</summary>
</member>
<member name="T:FSharp.Compiler.Interactive.Shell.FsiBoundValue">
<summary>
 Represents an evaluated F# value that is bound to an identifier
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.FsiValue.ReflectionValue">
<summary>
 The value, as an object
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.FsiValue.ReflectionType">
<summary>
 The type of the value, from the point of view of the .NET type system
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.FsiValue.FSharpType">
<summary>
 The type of the value, from the point of view of the F# type system
</summary>
</member>
<member name="T:FSharp.Compiler.Interactive.Shell.FsiValue">
<summary>
 Represents an evaluated F# value
</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.Settings.InteractiveSettings.ShowProperties(System.Boolean)">
 <summary>When set to 'false', disables the display of properties of evaluated objects in the output of the interactive session.</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.Settings.InteractiveSettings.ShowIEnumerable(System.Boolean)">
 <summary>When set to 'false', disables the display of sequences in the output of the interactive session.</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.Settings.InteractiveSettings.ShowDeclarationValues(System.Boolean)">
 <summary>When set to 'false', disables the display of declaration values in the output of the interactive session.</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.Settings.InteractiveSettings.PrintWidth(System.Int32)">
 <summary>Get or set the print width of the interactive session.</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.Settings.InteractiveSettings.PrintSize(System.Int32)">
 <summary>Get or set the total print size of the interactive session.</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.Settings.InteractiveSettings.PrintLength(System.Int32)">
 <summary>Get or set the total print length of the interactive session.</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.Settings.InteractiveSettings.PrintDepth(System.Int32)">
 <summary>Get or set the print depth of the interactive session.</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.Settings.InteractiveSettings.FormatProvider(System.IFormatProvider)">
 <summary>Get or set the format provider used in the output of the interactive session.</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.Settings.InteractiveSettings.FloatingPointFormat(System.String)">
 <summary>Get or set the floating point format used in the output of the interactive session.</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.Settings.InteractiveSettings.EventLoop(FSharp.Compiler.Interactive.Shell.Settings.IEventLoop)">
 <summary>Gets or sets the current event loop being used to process interactions.</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.Settings.InteractiveSettings.CommandLineArgs(System.String[])">
 <summary>The command line arguments after ignoring the arguments relevant to the interactive
 environment and replacing the first argument with the name of the last script file,
 if any. Thus 'fsi.exe test1.fs test2.fs -- hello goodbye' will give arguments
 'test2.fs', 'hello', 'goodbye'.  This value will normally be different to those
 returned by System.Environment.GetCommandLineArgs.</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.Settings.InteractiveSettings.ShowProperties">
 <summary>When set to 'false', disables the display of properties of evaluated objects in the output of the interactive session.</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.Settings.InteractiveSettings.ShowIEnumerable">
 <summary>When set to 'false', disables the display of sequences in the output of the interactive session.</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.Settings.InteractiveSettings.ShowDeclarationValues">
 <summary>When set to 'false', disables the display of declaration values in the output of the interactive session.</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.Settings.InteractiveSettings.PrintWidth">
 <summary>Get or set the print width of the interactive session.</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.Settings.InteractiveSettings.PrintSize">
 <summary>Get or set the total print size of the interactive session.</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.Settings.InteractiveSettings.PrintLength">
 <summary>Get or set the total print length of the interactive session.</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.Settings.InteractiveSettings.PrintDepth">
 <summary>Get or set the print depth of the interactive session.</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.Settings.InteractiveSettings.FormatProvider">
 <summary>Get or set the format provider used in the output of the interactive session.</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.Settings.InteractiveSettings.FloatingPointFormat">
 <summary>Get or set the floating point format used in the output of the interactive session.</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.Settings.InteractiveSettings.EventLoop">
 <summary>Gets or sets the current event loop being used to process interactions.</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.Settings.InteractiveSettings.CommandLineArgs">
 <summary>The command line arguments after ignoring the arguments relevant to the interactive
 environment and replacing the first argument with the name of the last script file,
 if any. Thus 'fsi.exe test1.fs test2.fs -- hello goodbye' will give arguments
 'test2.fs', 'hello', 'goodbye'.  This value will normally be different to those
 returned by System.Environment.GetCommandLineArgs.</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.Settings.InteractiveSettings.AddPrinter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.String})">
 <summary>Register a printer that controls the output of the interactive session.</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.Settings.InteractiveSettings.AddPrintTransformer``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Object})">
 <summary>Register a print transformer that controls the output of the interactive session.</summary>
</member>
<member name="T:FSharp.Compiler.Interactive.Shell.Settings.InteractiveSettings">
<summary>
 Operations supported by the currently executing F# Interactive session.
</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.Settings.IEventLoop.ScheduleRestart">
 <summary>Schedule a restart for the event loop.</summary>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.Settings.IEventLoop.Run">
 <summary>Run the event loop.</summary>
 <returns>True if the event loop was restarted; false otherwise.</returns>
</member>
<member name="M:FSharp.Compiler.Interactive.Shell.Settings.IEventLoop.Invoke``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
 <summary>Request that the given operation be run synchronously on the event loop.</summary>
 <returns>The result of the operation.</returns>
</member>
<member name="T:FSharp.Compiler.Interactive.Shell.Settings.IEventLoop">
 <summary>An event loop used by the currently executing F# Interactive session to execute code
 in the context of a GUI or another event-based system.</summary>
</member>
<member name="P:FSharp.Compiler.Interactive.Shell.Settings.fsi">
<summary>
 A default implementation of the &apos;fsi&apos; object, used by GetDefaultConfiguration().  Note this
 is a different object to FSharp.Compiler.Interactive.Settings.fsi in FSharp.Compiler.Interactive.Settings.dll,
 which can be used as an alternative implementation of the interactive settings if passed as a parameter
 to GetDefaultConfiguration(fsiObj).
</summary>
</member>
<member name="T:FSharp.Compiler.Interactive.Shell.Settings">
<summary>
 A default implementation of the &apos;fsi&apos; object, used by GetDefaultConfiguration()
</summary>
</member>
<member name="M:FSharp.Compiler.SourceCodeServices.InteractiveChecker.ParseAndCheckProject(System.String,System.String[],Microsoft.FSharp.Core.FSharpFunc{System.String,System.Tuple{System.Int32,System.Lazy{System.String}}},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{FSharp.Compiler.Symbols.FSharpImplementationFileContents,Microsoft.FSharp.Core.Unit}})">
<summary>
 Parses and checks the whole project, good for compilers (Fable etc.)
 Does not retain name resolutions and symbol uses which are quite memory hungry (so no intellisense etc.).
 Already parsed files will be cached so subsequent compilations will be faster.
</summary>
</member>
<member name="M:FSharp.Compiler.SourceCodeServices.InteractiveChecker.ParseAndCheckFileInProject(System.String,System.String[],Microsoft.FSharp.Core.FSharpFunc{System.String,System.Tuple{System.Int32,System.Lazy{System.String}}},System.String)">
<summary>
 Parses and checks file in project, will compile and cache all the files up to this one
 (if not already done before), or fetch them from cache. Returns partial project results,
 up to and including the file requested. Returns parse and typecheck results containing
 name resolutions and symbol uses for the file requested only, so intellisense etc. works.
</summary>
</member>
<member name="M:FSharp.Compiler.SourceCodeServices.InteractiveChecker.GetDependentFiles(System.String,System.String[],Microsoft.FSharp.Core.FSharpFunc{System.String,System.Tuple{System.Int32,System.Lazy{System.String}}})">
<summary>
 Find the transitive dependent files of the current file based on the untyped syntax tree.
</summary>
</member>
<member name="M:FSharp.Compiler.SourceCodeServices.InteractiveChecker.Compile(System.String[],Microsoft.FSharp.Core.FSharpFunc{System.String,System.Tuple{System.Int32,System.Lazy{System.String}}},System.String)">
<summary>
 Compile project to file. If project has already been type checked,
 check results will be taken from the cache.
</summary>
</member>
<member name="M:FSharp.Compiler.SourceCodeServices.InteractiveChecker.ClearCache">
<summary>
 Clears parse and typecheck caches.
</summary>
</member>
<member name="M:FSharp.Compiler.SourceCodeServices.ParseAndCheck.ErrorsByFile(System.String[],Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.Diagnostics.FSharpDiagnostic[]})">
<summary>
 Errors grouped by file, sorted by line, column
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.ILegacyReferenceResolver.DotNetFrameworkReferenceAssembliesRootDirectory">
<summary>
 Get the Reference Assemblies directory for the .NET Framework (on Windows)
 This is added to the default resolution path for
 design-time compilations.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.ILegacyReferenceResolver.Resolve(FSharp.Compiler.CodeAnalysis.LegacyResolutionEnvironment,System.Tuple{System.String,System.String}[],System.String,Microsoft.FSharp.Collections.FSharpList{System.String},System.String,System.String,Microsoft.FSharp.Collections.FSharpList{System.String},System.String,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{System.Boolean,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}})">
<summary>
 Perform assembly resolution on the given references under the given conditions
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.ILegacyReferenceResolver.HighestInstalledNetFrameworkVersion">
<summary>
 Get the &quot;v4.5.1&quot;-style moniker for the highest installed .NET Framework version.
 This is the value passed back to Resolve if no explicit &quot;mscorlib&quot; has been given.

 Note: If an explicit &quot;mscorlib&quot; is given, then --noframework is being used, and the whole ReferenceResolver logic is essentially
 unused.  However in the future an option may be added to allow an explicit specification of
 a .NET Framework version to use for scripts.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.LegacyResolvedFile.baggage">
<summary>
 Round-tripped baggage
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.LegacyResolvedFile.prepareToolTip">
<summary>
 Prepare textual information about where the assembly was resolved from, used for tooltip output
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.LegacyResolvedFile.itemSpec">
<summary>
 Item specification.
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.LegacyResolutionEnvironment.CompilationAndEvaluation">
<summary>
 Indicates a script or source being dynamically compiled and executed. Uses implementation assemblies.
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.LegacyResolutionEnvironment.EditingOrCompilation">
<summary>
 Indicates a script or source being edited or compiled. Uses reference assemblies (not implementation assemblies).
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.ItemKeyStoreBuilder">
<summary>
 A builder that will build an item key store based on the written Item and its associated range.
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.ItemKeyStore">
<summary>
 Stores a list of item key strings and their ranges in a memory mapped file.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpSource.TimeStamp">
<summary>
 The timestamp of the source.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpSource.FilePath">
<summary>
 The file path of the source.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpSource.GetTextContainer">
<summary>
 Gets the internal text container. Text may be on-disk, in a stream, or a source text.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpSource.CreateFromFile(System.String)">
<summary>
 Creates a FSharpSource from disk. Only used internally.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpSource.CreateCopyFromFile(System.String)">
<summary>
 Creates a FSharpSource from the specified file path by shadow-copying the file.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpSource.Create(System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.DateTime},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.Text.ISourceText}}})">
<summary>
 Creates a FSharpSource.
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.FSharpSource">
<summary>
 The storage container for a F# source item that could either be on-disk or in-memory.
 TODO: Make this public.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.IncrementalBuilder.TcConfig">
<summary>
 The TcConfig passed in to the builder creation.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.IncrementalBuilder.SourceFiles">
<summary>
 The full set of source files including those from options
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.IncrementalBuilder.ProjectChecked">
<summary>
 Raised just after the whole project has finished type checking. At this point, accessing the
 overall analysis results for the project will be quick.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.IncrementalBuilder.IsReferencesInvalidated">
<summary>
 Check if one of the build&apos;s references is invalidated.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.IncrementalBuilder.ImportsInvalidatedByTypeProvider">
<summary>
 Raised when the build is invalidated.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.IncrementalBuilder.FileParsed">
<summary>
 Raised just after a file is parsed
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.IncrementalBuilder.FileChecked">
<summary>
 Raised just after a file is checked
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.IncrementalBuilder.BeforeFileChecked">
<summary>
 Raised just before a file is type-checked, to invalidate the state of the file in VS and force VS to request a new direct typecheck of the file.
 The incremental builder also typechecks the file (error and intellisense results from the background builder are not
 used by VS).
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.IncrementalBuilder.AllDependenciesDeprecated">
<summary>
 The list of files the build depends on
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.IncrementalBuilder.TryGetCheckResultsBeforeFileInProject(System.String)">
<summary>
 Get the preceding typecheck state of a slot, WITH checking if it is up-to-date w.r.t. the timestamps of files and referenced DLLs prior to this one.
 However, files will not be parsed or checked.
 Return None if the result is not available or if it is not up-to-date.

 This is safe for use from non-compiler threads but the objects returned must in many cases be accessed only from the compiler thread.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.IncrementalBuilder.TryCreateIncrementalBuilderForProjectOptions(FSharp.Compiler.CodeAnalysis.LegacyReferenceResolver,System.String,FSharp.Compiler.CodeAnalysis.FrameworkImportsCache,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.ScriptClosure.LoadClosure},Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.CompilerConfig.IProjectReference},System.String,System.Boolean,System.Boolean,System.Boolean,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.String,System.DateTime},Microsoft.FSharp.Core.FSharpOption{System.Tuple{System.Object,System.IntPtr,System.Int32}}},System.Boolean,System.Boolean,System.Boolean,System.Boolean,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.DependencyManager.DependencyProvider},FSharp.Compiler.CompilerConfig.ParallelReferenceResolution,System.Boolean,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.Text.ISourceText}}}},System.Boolean)">
<summary>
 Create the incremental builder
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.IncrementalBuilder.PopulatePartialCheckingResults">
<summary>
 The project build. Return true if the background work is finished.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.IncrementalBuilder.GetParseResultsForFile(System.String)">
<summary>
 Await the untyped parse results for a particular slot in the vector of parse results.

 This may be a marginally long-running operation (parses are relatively quick, only one file needs to be parsed)
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.IncrementalBuilder.GetLogicalTimeStampForProject(FSharp.Compiler.CompilerConfig.TimeStampCache)">
<summary>
 Get the logical time stamp that is associated with the output of the project if it were fully built immediately
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.IncrementalBuilder.GetFullCheckResultsBeforeFileInProject(System.String)">
<summary>
 Get the preceding typecheck state of a slot. Compute the entire type check of the project up
 to the necessary point if the result is not available. This may be a long-running operation.
 This will get full type-check info for the file, meaning no partial type-checking.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.IncrementalBuilder.GetFullCheckResultsAndImplementationsForProject">
<summary>
 Get the final typecheck result. If &apos;generateTypedImplFiles&apos; was set on Create then the CheckedAssemblyAfterOptimization will contain implementations.
 This may be a long-running operation.
 This will get full type-check info for the project, meaning no partial type-checking.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.IncrementalBuilder.GetFullCheckResultsAfterFileInProject(System.String)">
<summary>
 Get the typecheck state after checking a file. Compute the entire type check of the project up
 to the necessary point if the result is not available. This may be a long-running operation.
 This will get full type-check info for the file, meaning no partial type-checking.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.IncrementalBuilder.GetCheckResultsForFileInProjectEvenIfStale(System.String)">
<summary>
 Get the typecheck state of a slot, without checking if it is up-to-date w.r.t.
 the timestamps on files and referenced DLLs prior to this one. Return None if the result is not available.
 This is a very quick operation.

 This is safe for use from non-compiler threads but the objects returned must in many cases be accessed only from the compiler thread.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.IncrementalBuilder.GetCheckResultsBeforeFileInProjectEvenIfStale(System.String)">
<summary>
 Get the preceding typecheck state of a slot, without checking if it is up-to-date w.r.t.
 the timestamps on files and referenced DLLs prior to this one. Return None if the result is not available.
 This is a very quick operation.

 This is safe for use from non-compiler threads but the objects returned must in many cases be accessed only from the compiler thread.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.IncrementalBuilder.GetCheckResultsBeforeFileInProject(System.String)">
<summary>
 Get the preceding typecheck state of a slot. Compute the entire type check of the project up
 to the necessary point if the result is not available. This may be a long-running operation.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.IncrementalBuilder.GetCheckResultsAndImplementationsForProject">
<summary>
 Get the final typecheck result. If &apos;generateTypedImplFiles&apos; was set on Create then the CheckedAssemblyAfterOptimization will contain implementations.
 This may be a long-running operation.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.IncrementalBuilder.GetCheckResultsAfterLastFileInProject">
<summary>
 Get the typecheck result after the end of the last file. The typecheck of the project is not &apos;completed&apos;.
 This may be a long-running operation.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.IncrementalBuilder.GetCheckResultsAfterFileInProject(System.String)">
<summary>
 Get the typecheck state after checking a file. Compute the entire type check of the project up
 to the necessary point if the result is not available. This may be a long-running operation.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.IncrementalBuilder.ContainsFile(System.String)">
<summary>
 Does the given file exist in the builder&apos;s pipeline?
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.IncrementalBuilder.AreCheckResultsBeforeFileInProjectReady(System.String)">
<summary>
 Get the preceding typecheck state of a slot, but only if it is up-to-date w.r.t.
 the timestamps on files and referenced DLLs prior to this one. Return None if the result is not available.
 This is a relatively quick operation.

 This is safe for use from non-compiler threads
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.IncrementalBuilder">
<summary>
 Manages an incremental build graph for the build of an F# project
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.PartialCheckResults.GetOrComputeTcInfoWithExtras">
<summary>
 Compute both the &quot;TcInfo&quot; and &quot;TcInfoExtras&quot; parts of the results.
 Can cause a second type-check if `enablePartialTypeChecking` is true in the checker.
 Only use when it&apos;s absolutely necessary to get rich information on a file.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.PartialCheckResults.GetOrComputeTcInfo">
<summary>
 Compute the &quot;TcInfo&quot; part of the results.  If `enablePartialTypeChecking` is false then
 extras will also be available.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.PartialCheckResults.GetOrComputeSemanticClassificationIfEnabled">
<summary>
 Can cause a second type-check if `enablePartialTypeChecking` is true in the checker.
 Only use when it&apos;s absolutely necessary to get rich information on a file.

 Will return &apos;None&apos; for enableBackgroundItemKeyStoreAndSemanticClassification=false.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.PartialCheckResults.GetOrComputeItemKeyStoreIfEnabled">
<summary>
 Compute the &quot;ItemKeyStore&quot; parts of the results.
 Can cause a second type-check if `enablePartialTypeChecking` is true in the checker.
 Only use when it&apos;s absolutely necessary to get rich information on a file.

 Will return &apos;None&apos; for enableBackgroundItemKeyStoreAndSemanticClassification=false.
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.PartialCheckResults">
<summary>
 Represents the state in the incremental graph associated with checking a file
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.TcInfoExtras.semanticClassificationKeyStore">
<summary>
 If enabled, holds semantic classification information for Item(symbol)s in a file.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.TcInfoExtras.itemKeyStore">
<summary>
 If enabled, stores a linear list of ranges and strings that identify an Item(symbol) in a file. Used for background find all references.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.TcInfoExtras.latestImplFile">
<summary>
 Result of checking most recent file, if any
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.TcInfoExtras">
<summary>
 Accumulated results of type checking. Optional data that isn&apos;t needed to type-check a file, but needed for more information for in tooling.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.TcInfo.tcDiagnosticsRev">
<summary>
 Accumulated errors, last file first
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.TcInfo.moduleNamesDict">
<summary>
 Disambiguation table for module names
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.TcInfo.TcDiagnostics">
<summary>
 Accumulated diagnostics
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.TcInfo">
<summary>
 Accumulated results of type checking. The minimum amount of state in order to continue type-checking following files.
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.FrameworkImportsCache">
<summary>
 Lookup the global static cache for building the FrameworkTcImports
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpParseFileResults.ParseTree">
<summary>
 The syntax tree resulting from the parse
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpParseFileResults.ParseHadErrors">
<summary>
 Indicates if any errors occurred during the parse
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpParseFileResults.FileName">
<summary>
 Name of the file for which this information were created
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpParseFileResults.Diagnostics">
<summary>
 Get the errors and warnings for the parse
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpParseFileResults.DependencyFiles">
<summary>
 When these files change then the build is invalid
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpParseFileResults.ValidateBreakpointLocation(FSharp.Compiler.Text.Position)">
<summary>
 Return the inner-most range associated with a possible breakpoint location
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpParseFileResults.TryRangeOfStringInterpolationContainingPos(FSharp.Compiler.Text.Position)">
<summary>
 Attempts to find the range of the string interpolation that contains a given position.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpParseFileResults.TryRangeOfReturnTypeHint(FSharp.Compiler.Text.Position,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Gets the range of where a return type hint could be placed for a function binding. This will be right in front of the equals sign.
 Returns None if type annotation is present.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpParseFileResults.TryRangeOfRefCellDereferenceContainingPos(FSharp.Compiler.Text.Position)">
 <summary>
 Given the position of an expression, attempts to find the range of the
 '!' in a dereference operation of that expression, like:
 '!expr', '!(expr)', etc.
 </summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpParseFileResults.TryRangeOfRecordExpressionContainingPos(FSharp.Compiler.Text.Position)">
<summary>
 Attempts to find the range of a record expression containing the given position.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpParseFileResults.TryRangeOfParenEnclosingOpEqualsGreaterUsage(FSharp.Compiler.Text.Position)">
<summary>
 Attempts to find the range of an attempted lambda expression or pattern, the argument range, and the expr range when writing a C#-style &quot;lambda&quot; (which is actually an operator application)
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpParseFileResults.TryRangeOfNameOfNearestOuterBindingContainingPos(FSharp.Compiler.Text.Position)">
<summary>
 Attempts to find the range of the name of the nearest outer binding that contains a given position.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpParseFileResults.TryRangeOfFunctionOrMethodBeingApplied(FSharp.Compiler.Text.Position)">
<summary>
 Attempts to find the range of a function or method that is being applied. Also accounts for functions in pipelines.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpParseFileResults.TryRangeOfExpressionBeingDereferencedContainingPos(FSharp.Compiler.Text.Position)">
<summary>
 Gets the range of an expression being dereferenced. For `!expr`, gives the range of `expr`
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpParseFileResults.TryRangeOfExprInYieldOrReturn(FSharp.Compiler.Text.Position)">
<summary>
 Attempts to find the range of an expression `expr` contained in a `yield expr`  or `return expr` expression (and bang-variants).
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpParseFileResults.TryIdentOfPipelineContainingPosAndNumArgsApplied(FSharp.Compiler.Text.Position)">
<summary>
 Attempts to find an Ident of a pipeline containing the given position, and the number of args already applied in that pipeline.
 For example, &apos;[1..10] |&gt; List.map &apos; would give back the ident of &apos;|&gt;&apos; and 1, because it applied 1 arg (the list) to &apos;List.map&apos;.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpParseFileResults.IsTypeName(FSharp.Compiler.Text.Range)">
<summary>
 Determines if the range points to a type name in the type definition.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpParseFileResults.IsTypeAnnotationGivenAtPosition(FSharp.Compiler.Text.Position)">
<summary>
 Determines if the expression or pattern at the given position has a type annotation
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpParseFileResults.IsPositionWithinTypeDefinition(FSharp.Compiler.Text.Position)">
<summary>
 Determines if the given position is bound to a type definition
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpParseFileResults.IsPositionWithinRecordDefinition(FSharp.Compiler.Text.Position)">
<summary>
 Determines if the given position is bound to a record definition
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpParseFileResults.IsPositionContainedInACurriedParameter(FSharp.Compiler.Text.Position)">
<summary>
 Determines if the given position is contained within a curried parameter in a binding.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpParseFileResults.IsPosContainedInApplication(FSharp.Compiler.Text.Position)">
<summary>
 Determines if the given position is inside a function or method application.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpParseFileResults.IsBindingALambdaAtPosition(FSharp.Compiler.Text.Position)">
<summary>
 Determines if the binding at the given position is bound to a lambda expression
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpParseFileResults.GetNavigationItems">
<summary>
 Get declared items and the selected item at the specified location
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpParseFileResults.GetAllArgumentsForFunctionApplicationAtPosition(FSharp.Compiler.Text.Position)">
<summary>
 Gets the ranges of all arguments, if they can be found, for a function application at the given position.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpParseFileResults.FindParameterLocations(FSharp.Compiler.Text.Position)">
<summary>
 Notable parse info for ParameterInfo at a given location
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.FSharpParseFileResults">
<summary>
 Represents the results of parsing an F# file and a set of analysis operations based on the parse tree alone.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpCheckProjectResults.ProjectContext">
<summary>
 Get the resolution of the ProjectOptions
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpCheckProjectResults.HasCriticalErrors">
<summary>
 Indicates if critical errors existed in the project options
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpCheckProjectResults.Diagnostics">
<summary>
 The errors returned by processing the project
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpCheckProjectResults.DependencyFiles">
<summary>
 Indicates the set of files which must be watched to accurately track changes that affect these results,
 Clients interested in reacting to updates to these files should watch these files and take actions as described
 in the documentation for compiler service.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpCheckProjectResults.AssemblySignature">
<summary>
 Get a view of the overall signature of the assembly. Only valid to use if HasCriticalErrors is false.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpCheckProjectResults.AssemblyContents">
<summary>
 Get a view of the overall contents of the assembly. Only valid to use if HasCriticalErrors is false.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpCheckProjectResults.GetUsesOfSymbol(FSharp.Compiler.Symbols.FSharpSymbol,Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
<summary>
 Get the textual usages that resolved to the given symbol throughout the project
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpCheckProjectResults.GetOptimizedAssemblyContents">
<summary>
 Get an optimized view of the overall contents of the assembly. Only valid to use if HasCriticalErrors is false.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpCheckProjectResults.GetAllUsesOfAllSymbols(Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
<summary>
 Get all textual usages of all symbols throughout the project
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.FSharpCheckProjectResults">
<summary>
 A handle to the results of CheckFileInProject.
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.FSharpCheckFileAnswer.Succeeded">
<summary>
 Success
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.FSharpCheckFileAnswer.Aborted">
<summary>
 Aborted because cancellation caused an abandonment of the operation
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.FSharpCheckFileAnswer">
<summary>
 The result of calling TypeCheckResult including the possibility of abort and background compiler not caught up.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.ProjectContext">
<summary>
 Get the resolution of the ProjectOptions
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.PartialAssemblySignature">
<summary>
 Get a view of the contents of the assembly up to and including the file just checked
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.OpenDeclarations">
<summary>
 Open declarations in the file, including auto open modules.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.ImplementationFile">
<summary>
 Represents complete typechecked implementation file, including its typechecked signatures if any.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.HasFullTypeCheckInfo">
<summary>
 Indicates whether type checking successfully occurred with some results returned. If false, indicates that
 an unrecoverable error in earlier checking/parsing/resolution steps.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.Diagnostics">
<summary>
 The errors returned by parsing a source file.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.DependencyFiles">
<summary>
 Indicates the set of files which must be watched to accurately track changes that affect these results,
 Clients interested in reacting to updates to these files should watch these files and take actions as described
 in the documentation for compiler service.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.TryGetCurrentTcImports">
<summary>
 Tries to get the current successful TcImports. This is only used in testing. Do not use it for other stuff.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.MakeEmpty(System.String,FSharp.Compiler.Diagnostics.FSharpDiagnostic[],System.Boolean)">
<summary>
 Internal constructor
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.Make(System.String,System.String,FSharp.Compiler.CompilerConfig.TcConfig,FSharp.Compiler.TcGlobals.TcGlobals,System.Boolean,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.CodeAnalysis.IncrementalBuilder},FSharp.Compiler.CodeAnalysis.FSharpProjectOptions,System.String[],FSharp.Compiler.Diagnostics.FSharpDiagnostic[],FSharp.Compiler.Diagnostics.FSharpDiagnostic[],FSharp.Compiler.Diagnostics.FSharpDiagnostic[],System.Boolean,FSharp.Compiler.TypedTree.ModuleOrNamespaceType,FSharp.Compiler.TypedTree.CcuThunk,FSharp.Compiler.CompilerImports.TcImports,FSharp.Compiler.AccessibilityLogic.AccessorDomain,FSharp.Compiler.NameResolution.TcResolutions,FSharp.Compiler.NameResolution.TcSymbolUses,FSharp.Compiler.NameResolution.NameResolutionEnv,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.ScriptClosure.LoadClosure},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.TypedTree.CheckedImplFile},FSharp.Compiler.TypedTree.OpenDeclaration[])">
<summary>
 Internal constructor
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.IsRelativeNameResolvableFromSymbol(FSharp.Compiler.Text.Position,Microsoft.FSharp.Collections.FSharpList{System.String},FSharp.Compiler.Symbols.FSharpSymbol)">
<summary>
 Determines if a long ident is resolvable at a specific point.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.IsRelativeNameResolvable(FSharp.Compiler.Text.Position,Microsoft.FSharp.Collections.FSharpList{System.String},FSharp.Compiler.NameResolution.Item)">
<summary>
 Determines if a long ident is resolvable at a specific point.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.GetUsesOfSymbolInFile(FSharp.Compiler.Symbols.FSharpSymbol,Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
<summary>
 Get the textual usages that resolved to the given symbol throughout the file
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.GetToolTip(System.Int32,System.Int32,System.String,Microsoft.FSharp.Collections.FSharpList{System.String},System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Compute a formatted tooltip for the given location</summary>

 <param name="line">The line number where the information is being requested.</param>
 <param name="colAtEndOfNames">The column number at the end of the identifiers where the information is being requested.</param>
 <param name="lineText">The text of the line where the information is being requested.</param>
 <param name="names">The identifiers at the location where the information is being requested.</param>
 <param name="tokenTag">Used to discriminate between 'identifiers', 'strings' and others. For strings, an attempt is made to give a tooltip for a #r "..." location. Use a value from FSharpTokenInfo.Tag, or FSharpTokenTag.Identifier, unless you have other information available.</param>
 <param name="width">The optional width that the layout gets squashed to.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.GetSymbolUsesAtLocation(System.Int32,System.Int32,System.String,Microsoft.FSharp.Collections.FSharpList{System.String})">
 <summary>Similar to GetSymbolUseAtLocation, but returns all found symbols if there are multiple.</summary>

 <param name="line">The line number where the information is being requested.</param>
 <param name="colAtEndOfNames">The column number at the end of the identifiers where the information is being requested.</param>
 <param name="lineText">The text of the line where the information is being requested.</param>
 <param name="names">The identifiers at the location where the information is being requested.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.GetSymbolUseAtLocation(System.Int32,System.Int32,System.String,Microsoft.FSharp.Collections.FSharpList{System.String})">
 <summary>Resolve the names at the given location to a use of symbol.</summary>

 <param name="line">The line number where the information is being requested.</param>
 <param name="colAtEndOfNames">The column number at the end of the identifiers where the information is being requested.</param>
 <param name="lineText">The text of the line where the information is being requested.</param>
 <param name="names">The identifiers at the location where the information is being requested.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.GetSemanticClassification(Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.Text.Range})">
 <summary>Get any extra colorization info that is available after the typecheck</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.GetMethodsAsSymbols(System.Int32,System.Int32,System.String,Microsoft.FSharp.Collections.FSharpList{System.String})">
 <summary>Compute a set of method overloads to show in a dialog relevant to the given code location.  The resulting method overloads are returned as symbols.</summary>
 <param name="line">The line number where the information is being requested.</param>
 <param name="colAtEndOfNames">The column number at the end of the identifiers where the information is being requested.</param>
 <param name="lineText">The text of the line where the information is being requested.</param>
 <param name="names">The identifiers at the location where the information is being requested.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.GetMethods(System.Int32,System.Int32,System.String,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.String}})">
 <summary>Compute a set of method overloads to show in a dialog relevant to the given code location.</summary>

 <param name="line">The line number where the information is being requested.</param>
 <param name="colAtEndOfNames">The column number at the end of the identifiers where the information is being requested.</param>
 <param name="lineText">The text of the line where the information is being requested.</param>
 <param name="names">The identifiers at the location where the information is being requested.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.GetKeywordTooltip(Microsoft.FSharp.Collections.FSharpList{System.String})">
 <summary>Compute a formatted tooltip for the given keywords</summary>

 <param name="names">The keywords at the location where the information is being requested.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.GetFormatSpecifierLocationsAndArity">
 <summary>Get the locations of and number of arguments associated with format specifiers</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.GetFormatSpecifierLocations">
 <summary>Get the locations of format specifiers</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.GetF1Keyword(System.Int32,System.Int32,System.String,Microsoft.FSharp.Collections.FSharpList{System.String})">
 <summary>Compute the Visual Studio F1-help key identifier for the given location, based on name resolution results</summary>

 <param name="line">The line number where the information is being requested.</param>
 <param name="colAtEndOfNames">The column number at the end of the identifiers where the information is being requested.</param>
 <param name="lineText">The text of the line where the information is being requested.</param>
 <param name="names">The identifiers at the location where the information is being requested.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.GetDisplayContextForPos(FSharp.Compiler.Text.Position)">
<summary>
 Find the most precise display environment for the given line and column.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.GetDescription(FSharp.Compiler.Symbols.FSharpSymbol,Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Compiler.Symbols.FSharpGenericParameter,FSharp.Compiler.Symbols.FSharpType}},System.Boolean,FSharp.Compiler.Text.Range)">
 <summary>Compute a formatted tooltip for the given symbol at position</summary>

 <param name="symbol">The symbol.</param>
 <param name="inst">Generic arguments.</param>
 <param name="displayFullName">Display the symbol full name.</param>
 <param name="range">The position.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.GetDeclarationLocation(System.Int32,System.Int32,System.String,Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Resolve the names at the given location to the declaration location of the corresponding construct.</summary>

 <param name="line">The line number where the information is being requested.</param>
 <param name="colAtEndOfNames">The column number at the end of the identifiers where the information is being requested.</param>
 <param name="lineText">The text of the line where the information is being requested.</param>
 <param name="names">The identifiers at the location where the information is being requested.</param>
 <param name="preferFlag">If not given, then get the location of the symbol. If false, then prefer the location of the corresponding symbol in the implementation of the file (rather than the signature if present). If true, prefer the location of the corresponding symbol in the signature of the file (rather than the implementation).</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.GetDeclarationListSymbols(Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.CodeAnalysis.FSharpParseFileResults},System.Int32,System.String,FSharp.Compiler.EditorServices.PartialLongName,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.EditorServices.AssemblySymbol}}})">
 <summary>Get the items for a declaration list in FSharpSymbol format</summary>

 <param name="parsedFileResults">
    If this is present, it is used to filter declarations based on location in the
    parse tree, specifically at 'open' declarations, 'inherit' of class or interface
    'record field' locations and r.h.s. of 'range' operator a..b
 </param>
 <param name="line">The line number where the completion is happening</param>
 <param name="partialName">
    Partial long name. QuickParse.GetPartialLongNameEx can be used to get it.
 </param>
 <param name="lineText">
    The text of the line where the completion is happening. This is only used to make a couple
    of adhoc corrections to completion accuracy (e.g. checking for "..")
 </param>
 <param name="getAllEntities">
    Function that returns all entities from current and referenced assemblies.
 </param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.GetDeclarationListInfo(Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.CodeAnalysis.FSharpParseFileResults},System.Int32,System.String,FSharp.Compiler.EditorServices.PartialLongName,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.EditorServices.AssemblySymbol}}},Microsoft.FSharp.Core.FSharpOption{System.Tuple{FSharp.Compiler.Text.Position,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.EditorServices.CompletionContext}}})">
 <summary>Get the items for a declaration list</summary>

 <param name="parsedFileResults">
    If this is present, it is used to filter declarations based on location in the
    parse tree, specifically at 'open' declarations, 'inherit' of class or interface
    'record field' locations and r.h.s. of 'range' operator a..b
 </param>
 <param name="line">The line number where the completion is happening</param>
 <param name="partialName">
    Partial long name. QuickParse.GetPartialLongNameEx can be used to get it.
 </param>
 <param name="lineText">
    The text of the line where the completion is happening. This is only used to make a couple
    of adhoc corrections to completion accuracy (e.g. checking for "..")
 </param>
 <param name="getAllEntities">
    Function that returns all entities from current and referenced assemblies.
 </param>
 <param name="completionContextAtPos">
    Completion context for a particular position computed in advance.
 </param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.GetAllUsesOfAllSymbolsInFile(Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
<summary>
 Get all textual usages of all symbols throughout the file
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.GenerateSignature(Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Lays out and returns the formatted signature for the typechecked file as source text.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults.CheckOneFile(FSharp.Compiler.CodeAnalysis.FSharpParseFileResults,FSharp.Compiler.Text.ISourceText,System.String,System.String,FSharp.Compiler.CompilerConfig.TcConfig,FSharp.Compiler.TcGlobals.TcGlobals,FSharp.Compiler.CompilerImports.TcImports,FSharp.Compiler.ParseAndCheckInputs.TcState,Microsoft.FSharp.Collections.FSharpMap{System.String,Microsoft.FSharp.Collections.FSharpMap{System.String,FSharp.Compiler.Syntax.QualifiedNameOfFile}},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.ScriptClosure.LoadClosure},System.Tuple{FSharp.Compiler.DiagnosticsLogger.PhasedDiagnostic,FSharp.Compiler.Diagnostics.FSharpDiagnosticSeverity}[],System.Boolean,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.CodeAnalysis.IncrementalBuilder},System.String[],FSharp.Compiler.Diagnostics.FSharpDiagnostic[],FSharp.Compiler.Diagnostics.FSharpDiagnostic[],System.Boolean,System.Boolean)">
<summary>
 Internal constructor - check a file and collect errors
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults">
<summary>
 A handle to the results of CheckFileInProject.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpParsingOptions.ApplyLineDirectives">
<summary>
 Indicates if the ranges returned by parsing should have &apos;#line&apos; directives applied to them.
 When compiling code, this should usually be &apos;true&apos;.  For editing tools, this is usually &apos;false.
 The default for FSharpParsingOptions.ApplyLineDirectives is &apos;false&apos;.  The default for
 FSharpParsingOptions arising from FSharpProjectOptions will be &apos;true&apos; unless &apos;--ignorelinedirectives&apos; is used in the
 parameters from which these are derived.
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.FSharpParsingOptions">
<summary>
 Options used to determine active --define conditionals and other options relevant to parsing files in a project
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpProjectContext.ProjectOptions">
<summary>
 Get the project options
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpProjectContext.AccessibilityRights">
<summary>
 Get the accessibility rights for this project context w.r.t. InternalsVisibleTo attributes granting access to other assemblies
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpProjectContext.GetReferencedAssemblies">
<summary>
 Get the resolution and full contents of the assemblies referenced by the project options
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.FSharpProjectContext">
<summary>
 Represents the checking context implied by the ProjectOptions
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpSymbolUse.Symbol">
<summary>
 The symbol referenced
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpSymbolUse.Range">
<summary>
 The range of text representing the reference to the symbol
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpSymbolUse.IsPrivateToFileAndSignatureFile">
<summary>
 Indicates if the FSharpSymbolUse is private to the implementation &amp; signature file.
 This is true for function and method parameters.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpSymbolUse.IsPrivateToFile">
<summary>
 Indicates if the FSharpSymbolUse is declared as private
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpSymbolUse.IsFromUse">
<summary>
 Indicates if the reference is used for example at a call site
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpSymbolUse.IsFromType">
<summary>
 Indicates if the reference is in a syntactic type
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpSymbolUse.IsFromPattern">
<summary>
 Indicates if the reference is in a pattern
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpSymbolUse.IsFromOpenStatement">
<summary>
 Indicates if the reference is in open statement
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpSymbolUse.IsFromDispatchSlotImplementation">
<summary>
 Indicates if the reference is via the member being implemented in a class or object expression
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpSymbolUse.IsFromDefinition">
<summary>
 Indicates if the reference is a definition for the symbol, either in a signature or implementation
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpSymbolUse.IsFromComputationExpression">
<summary>
 Indicates if the reference is either a builder or a custom operation in a computation expression
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpSymbolUse.IsFromAttribute">
<summary>
 Indicates if the reference is in an attribute
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpSymbolUse.FileName">
<summary>
 The file name the reference occurs in
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpSymbolUse.DisplayContext">
<summary>
 The display context active at the point where the symbol is used. Can be passed to FSharpType.Format
 and other methods to format items in a way that is suitable for a specific source code location.
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.FSharpSymbolUse">
<summary>
 Represents the use of an F# symbol from F# source code
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.FSharpReferencedProject.ILModuleReference">
 <summary>
 A reference from an ILModuleReader.
 </summary>
 <param name="projectOutputFile">The fully qualified path to the output of the referenced project. This should be the same value as the <c>-r</c> reference in the project options for this referenced project.</param>
 <param name="getStamp">A function that calculates a last-modified timestamp for this reference. This will be used to determine if the reference is up-to-date.</param>
 <param name="getReader">A function that creates an ILModuleReader for reading module data.</param>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.FSharpReferencedProject.PEReference">
 <summary>
 A reference for any portable executable, including F#. The stream is owned by this reference.
 The stream will be automatically disposed when there are no references to FSharpReferencedProject and is GC collected.
 Once the stream is evaluated, the function that constructs the stream will no longer be referenced by anything.
 If the stream evaluation throws an exception, it will be automatically handled.
 </summary>
 <param name="getStamp">A function that calculates a last-modified timestamp for this reference. This will be used to determine if the reference is up-to-date.</param>
 <param name="delayedReader">A function that opens a Portable Executable data stream for reading.</param>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.FSharpReferencedProject.FSharpReference">
 <summary>
 A reference for an F# project. The physical data for it is stored/cached inside of the compiler service.
 </summary>
 <param name="projectOutputFile">The fully qualified path to the output of the referenced project. This should be the same value as the <c>-r</c> reference in the project options for this referenced project.</param>
 <param name="options">The Project Options for this F# project</param>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpReferencedProject.OutputFile">
 <summary>
 The fully qualified path to the output of the referenced project. This should be the same value as the <c>-r</c>
 reference in the project options for this referenced project.
 </summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpProjectOptions.Stamp">
<summary>
 An optional stamp to uniquely identify this set of options
 If two sets of options both have stamps, then they are considered equal
 if and only if the stamps are equal
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpProjectOptions.OriginalLoadReferences">
<summary>
 Unused in this API and should be &apos;[]&apos; when used as user-specified input
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpProjectOptions.UnresolvedReferences">
<summary>
 Unused in this API and should be &apos;None&apos; when used as user-specified input
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpProjectOptions.LoadTime">
<summary>
 Timestamp of project/script load, used to differentiate between different instances of a project load.
 This ensures that a complete reload of the project or script type checking
 context occurs on project or script unload/reload.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpProjectOptions.UseScriptResolutionRules">
<summary>
 When true, use the reference resolution rules for scripts rather than the rules for compiler.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpProjectOptions.IsIncompleteTypeCheckEnvironment">
<summary>
 When true, the typechecking environment is known a priori to be incomplete, for
 example when a .fs file is opened outside of a project. In this case, the number of error
 messages reported is reduced.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpProjectOptions.ReferencedProjects">
<summary>
 The command line arguments for the other projects referenced by this project, indexed by the
 exact text used in the &quot;-r:&quot; reference in FSharpProjectOptions.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpProjectOptions.OtherOptions">
<summary>
 Additional command line argument options for the project. These can include additional files and references.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpProjectOptions.SourceFiles">
<summary>
 The files in the project
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpProjectOptions.ProjectId">
<summary>
 This is the unique identifier for the project, it is case-sensitive. If it&apos;s None, will key off of ProjectFileName in our caching.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpProjectOptions.ProjectDirectory">
<summary>
 Compute the project directory.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpProjectOptions.UseSameProject(FSharp.Compiler.CodeAnalysis.FSharpProjectOptions,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions)">
<summary>
 Whether the two parse options refer to the same project.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpProjectOptions.AreSameForChecking(FSharp.Compiler.CodeAnalysis.FSharpProjectOptions,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions)">
<summary>
 Compare two options sets with respect to the parts of the options that are important to building.
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.FSharpProjectOptions">
 <summary>A set of information describing a project or script build configuration.</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.FSharpUnresolvedReferencesSet">
 <summary>Unused in this API</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.DelayedILModuleReader.TryGetILModuleReader">
<summary>
 Will lazily create the ILModuleReader.
 Is only evaluated once and can be called by multiple threads.
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.DelayedILModuleReader">
<summary>
 Delays the creation of an ILModuleReader
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.IBackgroundCompiler.TryGetRecentCheckResultsForFile(System.String,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.Text.ISourceText},System.String)">
<summary>
 Try to get recent approximate type check results for a file.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.IBackgroundCompiler.ParseAndCheckProject(FSharp.Compiler.CodeAnalysis.FSharpProjectOptions,System.String)">
<summary>
 Parse and typecheck the whole project.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.IBackgroundCompiler.ParseAndCheckFileInProject(System.String,System.Int32,FSharp.Compiler.Text.ISourceText,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions,System.String)">
<summary>
 Parses and checks the source file and returns untyped AST and check results.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.IBackgroundCompiler.GetBackgroundParseResultsForFileInProject(System.String,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions,System.String)">
<summary>
 Fetch the parse information from the background compiler (which checks w.r.t. the FileSystem API)
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.IBackgroundCompiler.GetBackgroundCheckResultsForFileInProject(System.String,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions,System.String)">
<summary>
 Fetch the check information from the background compiler (which checks w.r.t. the FileSystem API)
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.IBackgroundCompiler.CheckFileInProjectAllowingStaleCachedResults(FSharp.Compiler.CodeAnalysis.FSharpParseFileResults,System.String,System.Int32,FSharp.Compiler.Text.ISourceText,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions,System.String)">
<summary>
 Type-check the result obtained by parsing, but only if the antecedent type checking context is available.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.IBackgroundCompiler.CheckFileInProject(FSharp.Compiler.CodeAnalysis.FSharpParseFileResults,System.String,System.Int32,FSharp.Compiler.Text.ISourceText,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions,System.String)">
<summary>
 Type-check the result obtained by parsing. Force the evaluation of the antecedent type checking context if needed.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpChecker.ProjectChecked">
<summary>
 Notify the host that a project has been fully checked in the background (using file contents provided by the file system API)

 The event may be raised on a background thread.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpChecker.FileParsed">
<summary>
 Raised after a parse of a file in the background analysis.

 The event will be raised on a background thread.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpChecker.FileChecked">
<summary>
 Raised after a check of a file in the background analysis.

 The event will be raised on a background thread.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpChecker.BeforeBackgroundFileCheck">
 <summary>
 Notify the host that the logical type checking context for a file has now been updated internally
 and that the file has become eligible to be re-typechecked for errors.
 The event will be raised on a background thread.
 </summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpChecker.ActualParseFileCount">
<summary>
 Report a statistic for testability
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.FSharpChecker.ActualCheckFileCount">
<summary>
 Report a statistic for testability
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.TryGetRecentCheckResultsForFile(System.String,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.Text.ISourceText},Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>
 Try to get type check results for a file. This looks up the results of recent type checks of the
 same file, regardless of contents. The version tag specified in the original check of the file is returned.
 If the source of the file has changed the results returned by this function may be out of date, though may
 still be usable for generating intellisense menus and information.
 </summary>

 <param name="fileName">The file name for the file.</param>
 <param name="options">The options for the project or script, used to determine active --define conditionals and other options relevant to parsing.</param>
 <param name="sourceText">Optionally, specify source that must match the previous parse precisely.</param>
 <param name="userOpName">An optional string used for tracing compiler operations associated with this request.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.TokenizeLine(System.String,FSharp.Compiler.Tokenization.FSharpTokenizerLexState)">
<summary>
 Tokenize a single line, returning token information and a tokenization state represented by an integer
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.TokenizeFile(System.String)">
<summary>
 Tokenize an entire file, line by line
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.ParseFileInProject(System.String,System.String,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>
 Parses a source code for a file. Returns an AST that can be traversed for various features.
 </summary>

 <param name="fileName">The path for the file. The file name is also as a module name for implicit top level modules (e.g. in scripts).</param>
 <param name="source">The source to be parsed.</param>
 <param name="options">Parsing options for the project or script.</param>
 <param name="cache">Store the parse in a size-limited cache associated with the FSharpChecker. Default: true</param>
 <param name="userOpName">An optional string used for tracing compiler operations associated with this request.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.ParseFile(System.String,FSharp.Compiler.Text.ISourceText,FSharp.Compiler.CodeAnalysis.FSharpParsingOptions,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>
 Parses a source code for a file and caches the results. Returns an AST that can be traversed for various features.
 </summary>

 <param name="fileName">The path for the file. The file name is used as a module name for implicit top level modules (e.g. in scripts).</param>
 <param name="sourceText">The source to be parsed.</param>
 <param name="options">Parsing options for the project or script.</param>
 <param name="cache">Store the parse in a size-limited cache associated with the FSharpChecker. Default: true</param>
 <param name="userOpName">An optional string used for tracing compiler operations associated with this request.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.ParseAndCheckProject(FSharp.Compiler.CodeAnalysis.FSharpProjectOptions,Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>
 <para>Parse and typecheck all files in a project.</para>
 <para>All files are read from the FileSystem API</para>
 <para>Can cause a second type-check on the entire project when `enablePartialTypeChecking` is true on the FSharpChecker.</para>
 </summary>

 <param name="options">The options for the project or script.</param>
 <param name="userOpName">An optional string used for tracing compiler operations associated with this request.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.ParseAndCheckFileInProject(System.String,System.Int32,FSharp.Compiler.Text.ISourceText,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions,Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>
 <para>
   Parse and check a source code file, returning a handle to the results
 </para>
 <para>
    Note: all files except the one being checked are read from the FileSystem API
 </para>
 <para>
   Return FSharpCheckFileAnswer.Aborted if a parse tree was not available.
 </para>
 </summary>

 <param name="fileName">The name of the file in the project whose source is being checked.</param>
 <param name="fileVersion">An integer that can be used to indicate the version of the file. This will be returned by TryGetRecentCheckResultsForFile when looking up the file.</param>
 <param name="sourceText">The source for the file.</param>
 <param name="options">The options for the project or script.</param>
 <param name="userOpName">An optional string used for tracing compiler operations associated with this request.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.NotifyProjectCleaned(FSharp.Compiler.CodeAnalysis.FSharpProjectOptions,Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>
 This function is called when a project has been cleaned/rebuilt, and thus any live type providers should be refreshed.
 </summary>

 <param name="options">The options describing the project that has been cleaned.</param>
 <param name="userOpName">An optional string used for tracing compiler operations associated with this request.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.NotifyFileChanged(System.String,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions,Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Notify the checker that given file has changed. This needs to be used when checker is created with documentSource = Custom.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.MatchBraces(System.String,System.String,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions,Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>
   Parse a source code file, returning information about brace matching in the file.
   Return an enumeration of the matching parenthetical tokens in the file.
 </summary>

 <param name="fileName">The fileName for the file, used to help caching of results.</param>
 <param name="source">The full source for the file.</param>
 <param name="options">Parsing options for the project or script.</param>
 <param name="userOpName">An optional string used for tracing compiler operations associated with this request.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.MatchBraces(System.String,FSharp.Compiler.Text.ISourceText,FSharp.Compiler.CodeAnalysis.FSharpParsingOptions,Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>
   Parse a source code file, returning information about brace matching in the file.
   Return an enumeration of the matching parenthetical tokens in the file.
 </summary>

 <param name="fileName">The fileName for the file, used to help caching of results.</param>
 <param name="sourceText">The full source for the file.</param>
 <param name="options">Parsing options for the project or script.</param>
 <param name="userOpName">An optional string used for tracing compiler operations associated with this request.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.InvalidateConfiguration(FSharp.Compiler.CodeAnalysis.ProjectSnapshot.FSharpProjectSnapshot,Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>
  This function is called when the configuration is known to have changed for reasons not encoded in the projectSnapshot.
  For example, dependent references may have been deleted or created.
 </summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.InvalidateConfiguration(FSharp.Compiler.CodeAnalysis.FSharpProjectOptions,Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>
  This function is called when the configuration is known to have changed for reasons not encoded in the ProjectOptions.
  For example, dependent references may have been deleted or created.
 </summary>
 <param name="options">The options for the project or script, used to determine active --define conditionals and other options relevant to parsing.</param>
 <param name="userOpName">An optional string used for tracing compiler operations associated with this request.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.InvalidateAll">
<summary>
 This function is called when the entire environment is known to have changed for reasons not encoded in the ProjectOptions of any project/compilation.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.GetProjectSnapshotFromScript(System.String,FSharp.Compiler.Text.ISourceTextNew,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.CodeAnalysis.DocumentSource},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.DateTime},Microsoft.FSharp.Core.FSharpOption{System.String[]},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Int64},Microsoft.FSharp.Core.FSharpOption{System.String})">
 <param name="fileName">Used to differentiate between scripts, to consider each script a separate project. Also used in formatted error messages.</param>
 <param name="source">The source for the file.</param>
 <param name="documentSource">DocumentSource to load any additional files.</param>
 <param name="previewEnabled">Is the preview compiler enabled.</param>
 <param name="loadedTimeStamp">Indicates when the script was loaded into the editing environment,
 so that an 'unload' and 'reload' action will cause the script to be considered as a new project,
 so that references are re-resolved.</param>
 <param name="otherFlags">Other flags for compilation.</param>
 <param name="useFsiAuxLib">Add a default reference to the FSharp.Compiler.Interactive.Settings library.</param>
 <param name="useSdkRefs">Use the implicit references from the .NET SDK.</param>
 <param name="assumeDotNetFramework">Set up compilation and analysis for .NET Framework scripts.</param>
 <param name="sdkDirOverride">Override the .NET SDK used for default references.</param>
 <param name="optionsStamp">An optional unique stamp for the options.</param>
 <param name="userOpName">An optional string used for tracing compiler operations associated with this request.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.GetProjectOptionsFromScript(System.String,FSharp.Compiler.Text.ISourceText,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.DateTime},Microsoft.FSharp.Core.FSharpOption{System.String[]},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Int64},Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>
 <para>For a given script file, get the FSharpProjectOptions implied by the #load closure.</para>
 <para>All files are read from the FileSystem API, except the file being checked.</para>
 </summary>

 <param name="fileName">Used to differentiate between scripts, to consider each script a separate project. Also used in formatted error messages.</param>
 <param name="source">The source for the file.</param>
 <param name="previewEnabled">Is the preview compiler enabled.</param>
 <param name="loadedTimeStamp">Indicates when the script was loaded into the editing environment,
 so that an 'unload' and 'reload' action will cause the script to be considered as a new project,
 so that references are re-resolved.</param>
 <param name="otherFlags">Other flags for compilation.</param>
 <param name="useFsiAuxLib">Add a default reference to the FSharp.Compiler.Interactive.Settings library.</param>
 <param name="useSdkRefs">Use the implicit references from the .NET SDK.</param>
 <param name="assumeDotNetFramework">Set up compilation and analysis for .NET Framework scripts.</param>
 <param name="sdkDirOverride">Override the .NET SDK used for default references.</param>
 <param name="optionsStamp">An optional unique stamp for the options.</param>
 <param name="userOpName">An optional string used for tracing compiler operations associated with this request.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.GetProjectOptionsFromCommandLineArgs(System.String,System.String[],Microsoft.FSharp.Core.FSharpOption{System.DateTime},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Get the FSharpProjectOptions implied by a set of command line arguments.</summary>

 <param name="projectFileName">Used to differentiate between projects and for the base directory of the project.</param>
 <param name="argv">The command line arguments for the project build.</param>
 <param name="loadedTimeStamp">Indicates when the script was loaded into the editing environment,
 <param name="isEditing">Indicates that compilation should assume the EDITING define and related settings</param>
 <param name="isInteractive">Indicates that compilation should assume the INTERACTIVE define and related settings</param>
 so that an 'unload' and 'reload' action will cause the script to be considered as a new project,
 so that references are re-resolved.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.GetParsingOptionsFromProjectOptions(FSharp.Compiler.CodeAnalysis.FSharpProjectOptions)">
 <summary>
 <para>Get the FSharpParsingOptions implied by a FSharpProjectOptions.</para>
 </summary>

 <param name="options">The overall options.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.GetParsingOptionsFromCommandLineArgs(Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
 <para>Get the FSharpParsingOptions implied by a set of command line arguments.</para>
 </summary>

 <param name="argv">The command line arguments for the project build.</param>
 <param name="isInteractive">Indicates that parsing should assume the INTERACTIVE define and related settings</param>
 <param name="isEditing">Indicates that compilation should assume the EDITING define and related settings</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.GetParsingOptionsFromCommandLineArgs(Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
 <para>Get the FSharpParsingOptions implied by a set of command line arguments and list of source files.</para>
 </summary>

 <param name="sourceFiles">Initial source files list. Additional files may be added during argv evaluation.</param>
 <param name="argv">The command line arguments for the project build.</param>
 <param name="isInteractive">Indicates that parsing should assume the INTERACTIVE define and related settings</param>
 <param name="isEditing">Indicates that compilation should assume the EDITING define and related settings</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.GetBackgroundSemanticClassificationForFile(System.String,FSharp.Compiler.CodeAnalysis.ProjectSnapshot.FSharpProjectSnapshot,Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>
 <para>Get semantic classification for a file.</para>
 </summary>

 <param name="fileName">The file name for the file.</param>
 <param name="snapshot">The project snapshot for which we want to get the semantic classification.</param>
 <param name="userOpName">An optional string used for tracing compiler operations associated with this request.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.GetBackgroundSemanticClassificationForFile(System.String,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions,Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>
 <para>Get semantic classification for a file.</para>
 <para>All files are read from the FileSystem API, including the file being checked.</para>
 <para>Can cause a second type-check when `enablePartialTypeChecking` is true on the FSharpChecker.</para>
 </summary>

 <param name="fileName">The file name for the file.</param>
 <param name="options">The options for the project or script, used to determine active --define conditionals and other options relevant to parsing.</param>
 <param name="userOpName">An optional string used for tracing compiler operations associated with this request.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.GetBackgroundParseResultsForFileInProject(System.String,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions,Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>
 <para>Like ParseFile, but uses results from the background builder.</para>
 <para>All files are read from the FileSystem API, including the file being checked.</para>
 </summary>

 <param name="fileName">The name for the file.</param>
 <param name="options">The options for the project or script, used to determine active --define conditionals and other options relevant to parsing.</param>
 <param name="userOpName">An optional string used for tracing compiler operations associated with this request.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.GetBackgroundCheckResultsForFileInProject(System.String,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions,Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>
 <para>Like CheckFileInProject, but uses the existing results from the background builder.</para>
 <para>All files are read from the FileSystem API, including the file being checked.</para>
 <para>Can cause a second type-check when `enablePartialTypeChecking` is true on the FSharpChecker.</para>
 </summary>

 <param name="fileName">The file name for the file.</param>
 <param name="options">The options for the project or script, used to determine active --define conditionals and other options relevant to parsing.</param>
 <param name="userOpName">An optional string used for tracing compiler operations associated with this request.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.FindBackgroundReferencesInFile(System.String,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions,FSharp.Compiler.Symbols.FSharpSymbol,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>
 <para>Optimized find references for a given symbol in a file of project.</para>
 <para>All files are read from the FileSystem API, including the file being checked.</para>
 <para>Can cause a second type-check when `enablePartialTypeChecking` is true on the FSharpChecker.</para>
 </summary>

 <param name="fileName">The file name for the file.</param>
 <param name="options">The options for the project or script, used to determine active --define conditionals and other options relevant to parsing.</param>
 <param name="symbol">The symbol to find all uses in the file.</param>
 <param name="canInvalidateProject">Default: true. If true, this call can invalidate the current state of project if the options have changed. If false, the current state of the project will be used.</param>
 <param name="fastCheck">Default: false. Experimental feature that makes the operation faster. Requires FSharpChecker to be created with captureIdentifiersWhenParsing = true.</param>
 <param name="userOpName">An optional string used for tracing compiler operations associated with this request.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.Create(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.CodeAnalysis.LegacyReferenceResolver},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.String,System.DateTime},Microsoft.FSharp.Core.FSharpOption{System.Tuple{System.Object,System.IntPtr,System.Int32}}}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.CodeAnalysis.DocumentSource},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.CodeAnalysis.TransparentCompiler.CacheSizes})">
 <summary>
 Create an instance of an FSharpChecker.
 </summary>

 <param name="projectCacheSize">The optional size of the project checking cache.</param>
 <param name="keepAssemblyContents">Keep the checked contents of projects.</param>
 <param name="keepAllBackgroundResolutions">If false, do not keep full intermediate checking results from background checking suitable for returning from GetBackgroundCheckResultsForFileInProject. This reduces memory usage.</param>
 <param name="legacyReferenceResolver">An optional resolver for legacy MSBuild references</param>
 <param name="tryGetMetadataSnapshot">An optional resolver to access the contents of .NET binaries in a memory-efficient way</param>
 <param name="suggestNamesForErrors">Indicate whether name suggestion should be enabled</param>
 <param name="keepAllBackgroundSymbolUses">Indicate whether all symbol uses should be kept in background checking</param>
 <param name="enableBackgroundItemKeyStoreAndSemanticClassification">Indicates whether a table of symbol keys should be kept for background compilation</param>
 <param name="enablePartialTypeChecking">Indicates whether to perform partial type checking. Cannot be set to true if keepAssemblyContents is true. If set to true, can cause duplicate type-checks when richer information on a file is needed, but can skip background type-checking entirely on implementation files with signature files.</param>
 <param name="parallelReferenceResolution">Indicates whether to resolve references in parallel.</param>
 <param name="captureIdentifiersWhenParsing">When set to true we create a set of all identifiers for each parsed file which can be used to speed up finding references.</param>
 <param name="documentSource">Default: FileSystem. You can use Custom source to provide a function that will return the source for a given file path instead of reading it from the file system. Note that with this option the FSharpChecker will also not monitor the file system for file changes. It will expect to be notified of changes via the NotifyFileChanged method.</param>
 <param name="useTransparentCompiler">Default: false. Indicates whether we use a new experimental background compiler. This does not yet support all features</param>
 <param name="transparentCompilerCacheSizes">Default: None. The cache sizes for the transparent compiler</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.Compile(System.String[],Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>
 Compile using the given flags.  Source files names are resolved via the FileSystem API.
 The output file must be given by a -o flag.
 The first argument is ignored and can just be "fsc.exe".
 The method returns the collected diagnostics, and (possibly) a terminating exception.
 </summary>

 <param name="argv">The command line arguments for the project build.</param>
 <param name="userOpName">An optional string used for tracing compiler operations associated with this request.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.ClearLanguageServiceRootCachesAndCollectAndFinalizeAllTransients">
<summary>
 Flush all caches and garbage collect
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.ClearCache(System.Collections.Generic.IEnumerable{FSharp.Compiler.CodeAnalysis.FSharpProjectOptions},Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>Clear the internal cache of the given projects.</summary>
 <param name="options">The given project options.</param>
 <param name="userOpName">An optional string used for tracing compiler operations associated with this request.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.CheckFileInProjectAllowingStaleCachedResults(FSharp.Compiler.CodeAnalysis.FSharpParseFileResults,System.String,System.Int32,System.String,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions,Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>
 <para>Check a source code file, returning a handle to the results of the parse including
 the reconstructed types in the file.</para>

 <para>All files except the one being checked are read from the FileSystem API</para>
 <para>Note: returns NoAntecedent if the background builder is not yet done preparing the type check context for the
 file (e.g. loading references and parsing/checking files in the project that this file depends upon).
 In this case, the caller can either retry, or wait for FileTypeCheckStateIsDirty to be raised for this file.
 </para>
 </summary>

 <param name="parseResults">The results of ParseFile for this file.</param>
 <param name="fileName">The name of the file in the project whose source is being checked.</param>
 <param name="fileVersion">An integer that can be used to indicate the version of the file. This will be returned by TryGetRecentCheckResultsForFile when looking up the file.</param>
 <param name="source">The full source for the file.</param>
 <param name="options">The options for the project or script.</param>
 <param name="userOpName">An optional string used for tracing compiler operations associated with this request.</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.FSharpChecker.CheckFileInProject(FSharp.Compiler.CodeAnalysis.FSharpParseFileResults,System.String,System.Int32,FSharp.Compiler.Text.ISourceText,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions,Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>
 <para>
   Check a source code file, returning a handle to the results
 </para>
 <para>
    Note: all files except the one being checked are read from the FileSystem API
 </para>
 <para>
   Return FSharpCheckFileAnswer.Aborted if a parse tree was not available.
 </para>
 </summary>

 <param name="parseResults">The results of ParseFile for this file.</param>
 <param name="fileName">The name of the file in the project whose source is being checked.</param>
 <param name="fileVersion">An integer that can be used to indicate the version of the file. This will be returned by TryGetRecentCheckResultsForFile when looking up the file.</param>
 <param name="sourceText">The full source for the file.</param>
 <param name="options">The options for the project or script.</param>
 <param name="userOpName">An optional string used for tracing compiler operations associated with this request.</param>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.FSharpChecker">
<summary>
 Used to parse and check F# source code.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.IncrementalBuild.LocallyInjectCancellationFault">
<summary>
 Used for unit testing. Causes all steps of underlying incremental graph evaluation to cancel
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.IncrementalBuild">
<summary>
 Generalized Incremental Builder. This is exposed only for unit testing purposes.
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.IncrementalBuilderEventTesting">
<summary>
 Used for unit testing
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.ParseAndCheckFile.DiagnosticsHandler">
<summary>
 Diagnostics handler for parsing &amp; type checking while processing a single file
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.FSharpProjectSnapshot.Replace(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.CodeAnalysis.ProjectSnapshot.FSharpFileSnapshot})">
<summary>
 Create a new snapshot with given source files replacing files in this snapshot with the same name. Other files remain unchanged.
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.FSharpProjectSnapshot">
<summary>
 A snapshot of an F# project. This type contains all the necessary information for type checking a project.
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.FSharpProjectIdentifier">
<summary>
 An identifier of an F# project. This serves to identify the same project as it changes over time and enables us to clear obsolete data from caches.
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.FSharpReferencedProjectSnapshot.ILModuleReference">
 <summary>
 A reference to an ILModuleReader.
 </summary>
 <param name="projectOutputFile">The fully qualified path to the output of the referenced project. This should be the same value as the <c>-r</c> reference in the project options for this referenced project.</param>
 <param name="getStamp">A function that calculates a last-modified timestamp for this reference. This will be used to determine if the reference is up-to-date.</param>
 <param name="getReader">A function that creates an ILModuleReader for reading module data.</param>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.FSharpReferencedProjectSnapshot.PEReference">
 <summary>
 A reference to any portable executable, including F#. The stream is owned by this reference.
 The stream will be automatically disposed when there are no references to FSharpReferencedProject and is GC collected.
 Once the stream is evaluated, the function that constructs the stream will no longer be referenced by anything.
 If the stream evaluation throws an exception, it will be automatically handled.
 </summary>
 <param name="getStamp">A function that calculates a last-modified timestamp for this reference. This will be used to determine if the reference is up-to-date.</param>
 <param name="delayedReader">A function that opens a Portable Executable data stream for reading.</param>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.FSharpReferencedProjectSnapshot.FSharpReference">
 <summary>
 A reference to an F# project. The physical data for it is stored/cached inside of the compiler service.
 </summary>
 <param name="projectOutputFile">The fully qualified path to the output of the referenced project. This should be the same value as the <c>-r</c> reference in the project options for this referenced project.</param>
 <param name="snapshot">Snapshot of the referenced F# project</param>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.FSharpReferencedProjectSnapshot.OutputFile">
 <summary>
 The fully qualified path to the output of the referenced project. This should be the same value as the <c>-r</c>
 reference in the project options for this referenced project.
 </summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.FSharpReferencedProjectSnapshot.CreateFSharp(System.String,FSharp.Compiler.CodeAnalysis.ProjectSnapshot.FSharpProjectSnapshot)">
 <summary>
 Creates a reference for an F# project. The physical data for it is stored/cached inside of the compiler service.
 </summary>
 <param name="projectOutputFile">The fully qualified path to the output of the referenced project. This should be the same value as the <c>-r</c> reference in the project options for this referenced project.</param>
 <param name="snapshot">The project snapshot for this F# project</param>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.ProjectConfig.With(Microsoft.FSharp.Collections.FSharpList{FSharp.Compiler.CodeAnalysis.ProjectSnapshot.ReferenceOnDisk})">
<summary>
 Creates a copy of this project config with a new set of references
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.ProjectConfig">
<summary>
 All required information for compiling a project except the source files and referenced projects. It&apos;s kept separate so it can be reused
 for different stages of a project snapshot and also between changes to the source files.
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.ProjectSnapshotWithSources">
<summary>
 Project snapshot with file sources loaded
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.ProjectSnapshot">
<summary>
 Project snapshot with filenames and versions given as initial input
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.ProjectSnapshotBase`1.SignatureKey">
<summary>
 A key including the public surface or signature for this snapshot
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.ProjectSnapshotBase`1.ParsingVersion">
<summary>
 Version for parsing - doesn&apos;t include any references because they don&apos;t affect parsing (...right?)
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.ProjectSnapshotBase`1.NoFileVersionsKey">
<summary>
 A key for this snapshot but without file versions. So it will be the same across any in-file changes.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.ProjectSnapshotBase`1.LastFileKey">
<summary>
 A key including the public surface or signature for this snapshot and the last file (even if it&apos;s not a signature file)
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.ProjectSnapshotBase`1.FullKey">
<summary>
 A full key for this snapshot, any change will cause this to change.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.ProjectSnapshotBase`1.UpTo(System.String)">
<summary>
 Create a new snapshot with source files only up to the given file name (inclusive)
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.ProjectSnapshotBase`1.UpTo(System.Int32)">
<summary>
 Create a new snapshot with source files only up to the given index (inclusive)
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.ProjectSnapshotBase`1.Replace(Microsoft.FSharp.Collections.FSharpList{`0})">
<summary>
 Create a new snapshot with given source files replacing files in this snapshot with the same name. Other files remain unchanged.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.ProjectSnapshotBase`1.OnlyWith(Microsoft.FSharp.Collections.FSharpSet{System.Int32})">
<summary>
 Create a new snapshot with only source files at the given indexes
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.ProjectSnapshotBase`1.GetLastModifiedTimeOnDisk">
<summary>
 The newest last modified time of any file in this snapshot including the project file
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.ProjectSnapshotBase`1.BaseCacheKeyWith``2(``0,``1)">
<summary>
 Cache key for the project without source files
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.ProjectSnapshotBase`1">
<summary>
 A snapshot of an F# project. The source file type can differ based on which stage of compilation the snapshot is used for.
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.ReferenceOnDisk">
<summary>
 An on-disk reference needed for project compilation.
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.FSharpParsedFile">
<summary>
 A source file snapshot with parsed syntax tree
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.FSharpFileSnapshotWithSource">
<summary>
 A source file snapshot with loaded source text.
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.FSharpFileSnapshot">
<summary>
 A snapshot of an F# source file.
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.ProjectSnapshot.IFileSnapshot">
<summary>
 A common interface for an F# source file snapshot that can be used across all stages (lazy, source loaded, parsed)
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.Helpers.NamesContainAttribute(FSharp.Compiler.Symbols.FSharpSymbol,Microsoft.FSharp.Collections.FSharpSet{System.String})">
<summary>
 If a symbol is an attribute check if given set of names contains its name without the Attribute suffix
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.Helpers.AreSubsumable3``2(System.Tuple{System.String,``0,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions},System.Tuple{System.String,``1,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions})">
<summary>
 Determine whether two (fileName,sourceText,options) keys should be identical w.r.t. resource usage
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.Helpers.AreSameForChecking3(System.Tuple{System.String,System.Int64,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions},System.Tuple{System.String,System.Int64,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions})">
<summary>
 Determine whether two (fileName,sourceText,options) keys should be identical w.r.t. checking
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.Helpers.AreSameForParsing``1(System.Tuple{System.String,System.Int64,``0},System.Tuple{System.String,System.Int64,``0})">
<summary>
 Determine whether two (fileName,sourceText,options) keys should be identical w.r.t. parsing
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.Helpers.AreSubsumable2(System.Tuple{System.String,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions},System.Tuple{System.String,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions})">
<summary>
 Determine whether two (fileName,options) keys should be identical w.r.t. resource usage
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.Helpers.AreSameForChecking2(System.Tuple{System.String,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions},System.Tuple{System.String,FSharp.Compiler.CodeAnalysis.FSharpProjectOptions})">
<summary>
 Determine whether two (fileName,options) keys are identical w.r.t. affect on checking
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.TransparentCompiler.DependencyGraphType.Project">
<summary>
 A dependency graph for a project - it will contain all files in the project
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.TransparentCompiler.DependencyGraphType.File">
<summary>
 A dependency graph for a single file - it will be missing files which this file does not depend on
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.TransparentCompiler.BootstrapInfo">
<summary>
 Things we need to start parsing and checking files for a given project snapshot
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.TransparentCompiler.TcIntermediate.tcDiagnosticsRev">
<summary>
 Accumulated diagnostics, last file first
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.TransparentCompiler.TcIntermediate.moduleNamesDict">
<summary>
 Disambiguation table for module names
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.TransparentCompiler.TcInfo.tcDiagnosticsRev">
<summary>
 Accumulated diagnostics, last file first
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.TransparentCompiler.TcInfo.moduleNamesDict">
<summary>
 Disambiguation table for module names
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.TransparentCompiler.TcInfo">
<summary>
 Accumulated results of type checking. The minimum amount of state in order to continue type-checking following files.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.Workspace.FSharpWorkspace.Query">
<summary>
 Use this to query the workspace for information
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.Workspace.FSharpWorkspace.Projects">
<summary>
 Project management for this workspace
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.Workspace.FSharpWorkspace.Files">
<summary>
 File management for this workspace
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.Workspace.FSharpWorkspace.Checker">
<summary>
 The `FSharpChecker` instance used by this workspace.
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.Workspace.FSharpWorkspace">
<summary>
 This type holds the current state of an F# workspace. It&apos;s mutable but thread-safe.
 It accepts updates to the state and can be queried for information about the workspace.

 The state can be built up incrementally by adding projects with one of the `Projects.AddOrUpdate` overloads.
 Updates to any project properties are done the same way. Each project is identified by its project file
 path and output path or by `FSharpProjectIdentifier`. When the same project is added again, it will be
 updated with the new information.

 Project references are discovered automatically as projects are added or updated.

 Updates to file contents are signaled through the `Files.Open`, `Files.Edit`, and `Files.Close` methods.
</summary>
</member>
<member name="F:FSharp.Compiler.CodeAnalysis.Workspace.FSharpWorkspaceState.FSharpWorkspaceProjects.outputPathMap">
<summary>
 A map from project output path to project identifier.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.Workspace.FSharpWorkspaceState.FSharpWorkspaceProjects.AddOrUpdate(FSharp.Compiler.CodeAnalysis.ProjectSnapshot.ProjectConfig,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Adds or updates an F# project in the workspace. Project is identified by the project file and output path or FSharpProjectIdentifier.
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.Workspace.FSharpWorkspaceState.FSharpWorkspaceProjects">
<summary>
 Interface for managing with projects in an F# workspace.
</summary>
</member>
<member name="F:FSharp.Compiler.CodeAnalysis.Workspace.FSharpWorkspaceState.FSharpWorkspaceFiles.openFiles">
<summary>
 Open files in the editor.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.Workspace.FSharpWorkspaceState.FSharpWorkspaceFiles.Open">
<summary>
 Indicates that a file has been opened and has the given content. Any updates to the file should be done through `Files.Edit`.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.Workspace.FSharpWorkspaceState.FSharpWorkspaceFiles.Edit(System.Uri,System.String)">
<summary>
 Indicates that a file has been changed and now has the given content. If it wasn&apos;t previously open it is considered open now.
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.Workspace.FSharpWorkspaceState.FSharpWorkspaceFiles.Close(System.Uri)">
<summary>
 Indicates that a file has been closed. Any changes that were not saved to disk are undone and any further reading
 of the file&apos;s contents will be from the filesystem.
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.Workspace.FSharpWorkspaceState.FSharpWorkspaceFiles">
<summary>
 Interface for managing files in an F# workspace.
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.Workspace.FSharpWorkspaceState.WorkspaceDependencyGraphExtensions.WorkspaceDependencyGraphTypeExtensions">
<summary>
 This type adds extension methods to the dependency graph to constraint the types and type relations
 that can be added to the graph.

 All unsafe operations that can throw at runtime, i.e. unpacking, are done here.
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.Workspace.FSharpWorkspaceState.WorkspaceGraphTypes.WorkspaceNodeValue.ProjectSnapshot">
<summary>
 Complete project information
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.Workspace.FSharpWorkspaceState.WorkspaceGraphTypes.WorkspaceNodeValue.ProjectWithoutFiles">
<summary>
 All project information except source files
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.Workspace.FSharpWorkspaceState.WorkspaceGraphTypes.WorkspaceNodeValue.ProjectConfig">
<summary>
 All project information except source files and (in-memory) project references
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.Workspace.FSharpWorkspaceState.WorkspaceGraphTypes.WorkspaceNodeKey.ProjectSnapshot">
<summary>
 Complete project information
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.Workspace.FSharpWorkspaceState.WorkspaceGraphTypes.WorkspaceNodeKey.ProjectWithoutFiles">
<summary>
 All project information except source files
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.Workspace.FSharpWorkspaceState.WorkspaceGraphTypes.WorkspaceNodeKey.ProjectConfig">
<summary>
 All project information except source files and (in-memory) project references
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.Workspace.FSharpWorkspaceState.WorkspaceGraphTypes.ProjectWithoutFiles">
<summary>
 All project information except source files
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.Workspace.FSharpWorkspaceState.WorkspaceGraphTypes">
<summary>
 Types for the workspace graph. These should not be accessed directly, rather through the
 extension methods in `WorkspaceDependencyGraphExtensions`.
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.Workspace.FSharpWorkspaceState">
<summary>
 Code to handle state management in an F# workspace.
</summary>
</member>
<member name="P:FSharp.Compiler.CodeAnalysis.Workspace.FSharpWorkspaceQuery.FSharpDiagnosticReport.ResultId">
<summary>
 The result ID of the diagnostics. This needs to be unique for each version of the document in order to be able to clear old diagnostics.
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.Workspace.FSharpWorkspaceQuery">
<summary>
 Code to handle quries to F# workspace
</summary>
</member>
<member name="F:FSharp.Compiler.CodeAnalysis.Hosted.FscCompiler.fscExeArg">
<summary>
 test if an arg is a path to fsc.exe
</summary>
</member>
<member name="F:FSharp.Compiler.CodeAnalysis.Hosted.FscCompiler.vsErrorsArg">
<summary>
 test if --vserrors flag is set
</summary>
</member>
<member name="F:FSharp.Compiler.CodeAnalysis.Hosted.FscCompiler.errorRangesArg">
<summary>
 test if --test:ErrorRanges flag is set
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.Hosted.FscCompiler.Compile(System.String[])">
<summary>
 do compilation as if args was argv to fsc.exe
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.Hosted.FscCompiler">
<summary>
 in-proc version of fsc.exe
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.Hosted.FailureDetails">
<summary>
 combined warning and error details
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.Hosted.CompilationIssue">
<summary>
 build issue details
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.Hosted.Location">
<summary>
 build issue location
</summary>
</member>
<member name="T:FSharp.Compiler.CodeAnalysis.Hosted.InProcDiagnosticsLoggerProvider">
<summary>
 Part of LegacyHostedCompilerForTesting

 Yet another DiagnosticsLogger implementation, capturing the messages but only up to the maxerrors maximum
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.Hosted.CompilerHelpers.fscCompile(FSharp.Compiler.CodeAnalysis.LegacyReferenceResolver,System.String,System.String[])">
<summary>
 runs in-proc fsc compilation, returns array consisting of exit code, then compiler output
</summary>
</member>
<member name="M:FSharp.Compiler.CodeAnalysis.Hosted.CompilerHelpers.parseCommandLine(System.String)">
<summary>
 splits a provided command line string into argv array
 currently handles quotes, but not escaped quotes
</summary>
</member>
</members>
</doc>
